
# Information about all exercises in the file main_vib.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_vib.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_undamped_verify_mms'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:verify:linquad',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Derive the equation for the\nfirst time step ($u^1$).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'For verification purposes,\nwe use the method of manufactured solutions (MMS) with the\nchoice of ${u_{\\small\\mbox{e}}}(x,t)= ct+d$.\nFind restrictions on $c$ and $d$ from\nthe initial conditions. Compute the corresponding source term $f$ by term.\nShow that $[D_tD_t t]^n=0$ and use the fact\nthat the $D_tD_t$ operator is linear,\n$[D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0$, to show that\n${u_{\\small\\mbox{e}}}$ is also a perfect solution of the discrete equations.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Use `sympy` to do the symbolic calculations above. Here is a\nsketch of the program `vib_undamped_verify_mms.py`:\n\n!bc pycod\nimport sympy as sym\nV, t, I, w, dt = sym.symbols(\'V t I w dt\')  # global symbols\nf = None  # global variable for the source term in the ODE\n\ndef ode_source_term(u):\n    """Return the terms in the ODE that the source term\n    must balance, here u\'\' + w**2*u.\n    u is symbolic Python function of t."""\n    return sym.diff(u(t), t, t) + w**2*u(t)\n\ndef residual_discrete_eq(u):\n    """Return the residual of the discrete eq. with u inserted."""\n    R = ...\n    return sym.simplify(R)\n\ndef residual_discrete_eq_step1(u):\n    """Return the residual of the discrete eq. at the first\n    step with u inserted."""\n    R = ...\n    return sym.simplify(R)\n\ndef DtDt(u, dt):\n    """Return 2nd-order finite difference for u_tt.\n    u is a symbolic Python function of t.\n    """\n    return ...\n\ndef main(u):\n    """\n    Given some chosen solution u (as a function of t, implemented\n    as a Python function), use the method of manufactured solutions\n    to compute the source term f, and check if u also solves\n    the discrete equations.\n    """\n    print \'=== Testing exact solution: %s ===\' % u\n    print "Initial conditions u(0)=%s, u\'(0)=%s:" % \\ \n          (u(t).subs(t, 0), sym.diff(u(t), t).subs(t, 0))\n\n    # Method of manufactured solution requires fitting f\n    global f  # source term in the ODE\n    f = sym.simplify(ode_lhs(u))\n\n    # Residual in discrete equations (should be 0)\n    print \'residual step1:\', residual_discrete_eq_step1(u)\n    print \'residual:\', residual_discrete_eq(u)\n\ndef linear():\n    main(lambda t: V*t + I)\n\nif __name__ == \'__main__\':\n    linear()\n\n!ec\nFill in the various functions such that the calls in the `main`\nfunction works.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The purpose now is to choose a quadratic function\n${u_{\\small\\mbox{e}}} = bt^2 + ct + d$ as exact solution. Extend the `sympy`\ncode above with a function `quadratic` for fitting `f` and checking\nif the discrete equations are fulfilled. (The function is very similar\nto `linear`.)\n\n#Check with hand calculations that the `sympy` implementation\n#is correct.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Will a polynomial of degree three fulfill the discrete equations?'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement a `solver` function for computing the numerical\nsolution of this problem.'},
            {'aftertext': '\n',
             'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a nose test for checking that the quadratic solution\nis computed to correctly (too machine precision, but the\nround-off errors accumulate and increase with $T$) by the `solver`\nfunction.'}],
  'text': 'Consider the ODE problem\n\n!bt\n\\[ u^{\\prime\\prime} + \\omega^2u=f(t), \\quad u(0)=I,\\ u^{\\prime}(0)=V,\\ t\\in(0,T]{\\thinspace .}\\]\n\n!et\nDiscretize this equation according to\n$[D_tD_t u + \\omega^2 u = f]^n$.',
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_phase_error_growth'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:phase:err:growth',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider an exact solution $I\\cos (\\omega t)$ and an\napproximation $I\\cos(\\tilde\\omega t)$.\nDefine the phase error as time lag between the peak $I$\nin the exact solution and the corresponding peak in the approximation\nafter $m$ periods of oscillations. Show that this phase error\nis linear in $m$.',
  'title': 'Show linear growth of the phase with time',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_adjust_w'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:w:adjust',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'According to (ref{vib:ode1:tildeomega:series}), the numerical\nfrequency deviates from the exact frequency by a (dominating) amount\n$\\omega^3\\Delta t^2/24 >0$. Replace the `w` parameter in the algorithm\nin the `solver` function in `vib_undamped.py` by `w*(1 -\n(1./24)*w**2*dt**2` and test how this adjustment in the numerical\nalgorithm improves the accuracy (use $\\Delta t =0.1$ and simulate\nfor 80 periods, with and without adjustment of $\\omega$).',
  'title': 'Improve the accuracy by adjusting the frequency',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_undamped_adaptive'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:adaptive',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Adaptive methods for solving ODEs aim at adjusting $\\Delta t$ such\nthat the error is within a user-prescribed tolerance. Implement the\nequation $u^{\\prime\\prime}+u=0$ in the "Odespy": "https://github.com/hplgit/odespy"\nsoftware. Use the example ref[from Section\nref{decay:fd2:adaptiveRK}][ in cite{Langtangen_decay}]["on adaptive\nschemes": "http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#example-adaptive-runge-kutta-methods"\nin cite{Langtangen_decay}].  Run the scheme with a very low\ntolerance (say $10^{-14}$) and for a long time, check the number of\ntime points in the solver\'s mesh (`len(solver.t_all)`), and compare\nthe phase error with that produced by the simple finite difference\nmethod from Section ref{vib:ode1:fdm} with the same number of (equally\nspaced) mesh points. The question is whether it pays off to use an\nadaptive solver or if equally many points with a simple method gives\nabout the same accuracy.',
  'title': 'See if adaptive methods improve the phase error',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_first_step'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:step4b:alt',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an alternative to the derivation of (ref{vib:ode1:step4b}) for\ncomputing $u^1$, one can use a Taylor polynomial with three terms\nfor $u^1$:\n\n!bt\n\\[ u(t_1) \\approx u(0) + u^{\\prime}(0)\\Delta t + {\\frac{1}{2}}u^{\\prime\\prime}(0)\\Delta t^2\\]\n\n!et\nWith $u^{\\prime\\prime}=-\\omega^2 u$ and $u^{\\prime}(0)=0$, show that this method also leads to\n(ref{vib:ode1:step4b}). Generalize the condition on $u^{\\prime}(0)$ to\nbe $u^{\\prime}(0)=V$ and compute $u^1$ in this case with both methods.',
  'title': 'Use a Taylor polynomial to compute $u^1$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_largest_wdt'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:wdt:limit',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Find the largest relevant value of $\\omega\\Delta t$\n\n\nSketch the function on a given mesh which has the highest possible\nfrequency. That is, this oscillatory "cos-like" function has its\nmaxima and minima at every two grid points.  Find an expression for\nthe frequency of this function, and use the result to find the largest\nrelevant value of $\\omega\\Delta t$ when $\\omega$ is the frequency\nof an oscillating function and $\\Delta t$ is the mesh spacing.',
  'title': 'Find the minimal resolution of an oscillatory function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_plot_fd_exp_error'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:fd:exp:plot',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# Short: Visualize the accuracy of finite differences\n\n\nWe introduce the error fraction\n!bt\n\\[ E = \\frac{[D_tD_t u]^n}{u^{\\prime\\prime}(t_n)} \\]\n\n!et\nto measure the error in the finite difference approximation $D_tD_tu$ to\n$u^{\\prime\\prime}$.\nCompute $E$\nfor the specific choice of a cosine/sine function of the\nform $u=\\exp{(i\\omega t)}$ and show that\n!bt\n\\[ E = \\left(\\frac{2}{\\omega\\Delta t}\\right)^2\n\\sin^2(\\frac{\\omega\\Delta t}{2})\n{\\thinspace .}\n\\]\n\n!et\nPlot $E$ as a function of $p=\\omega\\Delta t$. The relevant\nvalues of $p$ are $[0,\\pi]$ (see Exercise ref{vib:exer:wdt:limit}\nfor why $p>\\pi$ does not make sense).\nThe deviation of the curve from unity visualizes the error in the\napproximation. Also expand $E$ as a Taylor polynomial in $p$ up to\nfourth degree (use, e.g., `sympy`).',
  'title': 'Visualize the accuracy of finite differences for a cosine function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['test_error_conv'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:energy:convrate',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the ODE problem $u^{\\prime\\prime} + \\omega^2u=0$, $u(0)=I$, $u^{\\prime}(0)=V$,\nfor $t\\in (0,T]$. The total energy of the solution\n$E(t)=\\frac{1}{2}(u^{\\prime})^2 + \\frac{1}{2}\\omega^2 u^2$ should stay\nconstant.\nThe error in energy can be computed as explained in\nSection ref{vib:model1:energy}.\n\nMake a nose test in a file `test_error_conv.py`, where code from\n`vib_undamped.py` is imported, but the `convergence_rates` and\n`test_convergence_rates` functions are copied and modified to also\nincorporate computations of the error in energy and the convergence\nrate of this error. The expected rate is 2.',
  'title': 'Verify convergence rates of the error in energy',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_verify_mms'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:verify:gen:linear',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This exercise is a generalization of Problem\nref{vib:exer:undamped:verify:linquad} to the extended model problem\n(ref{vib:ode2}) where the damping term is either linear or quadratic.\nSolve the various subproblems and see how the results and problem\nsettings change with the generalized ODE in case of linear or\nquadratic damping. By modifying the code from Problem\nref{vib:exer:undamped:verify:linquad}, `sympy` will do most\nof the work required to analyze the generalized problem.',
  'title': 'Use linear/quadratic functions for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['test_vib_undamped_exact_discrete_sol'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:discrete:omega',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Write a nose test function in a separate file\nthat employs the exact discrete solution\n(ref{vib:ode1:un:exact}) to verify the implementation of the\n`solver` function in the file `vib_undamped.py`.',
  'title': 'Use an exact discrete solution for verification',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_conv_rate'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:conv:rate',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to perform convergence tests of the\nproblem (ref{vib:ode2}) when $s(u)=\\omega^2u$ and $F(t)=A\\sin\\phi t$.\nFind the complete analytical solution to the problem in this case\n(most textbooks on mechanics or ordinary differential equations list\nthe various elements you need to write down the exact solution).\nModify the `convergence_rate` function from the `vib_undamped.py`\nprogram to perform experiments with the extended model.  Verify that\nthe error is of order $\\Delta t^2$.',
  'title': 'Use analytical solution for convergence rate tests',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_amplitude_errors'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:undamped:odespy',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the program `vib_undamped_odespy.py` from Section\nref{vib:model2x2:compare} and the amplitude estimation from the\n`amplitudes` function in the `vib_undamped.py` file (see Section\nref{vib:ode1:empirical}) to investigate how well famous methods for\n1st-order ODEs can preserve the amplitude of $u$ in undamped\noscillations.  Test, for example, the 3rd- and 4th-order Runge-Kutta\nmethods (`RK3`, `RK4`), the Crank-Nicolson method (`CrankNicolson`),\nthe 2nd- and 3rd-order Adams-Bashforth methods (`AdamsBashforth2`,\n`AdamsBashforth3`), and a 2nd-order Backwards scheme\n(`Backward2Step`).  The relevant governing equations are listed in\nthe beginning of Section ref{vib:model2x2}.',
  'title': 'Investigate the amplitude errors of many solvers',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_memsave'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:memsave',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The program "`vib.py`": "http://tinyurl.com/nm5587k/vib/vib.py"\nstore the complete solution $u^0,u^1,\\ldots,u^{N_t}$ in memory, which is\nconvenient for later plotting.\nMake a memory minimizing version of this program where only the last three\n$u^{n+1}$, $u^n$, and $u^{n-1}$ values are stored in memory.\nWrite each computed $(t_{n+1}, u^{n+1})$ pair to file.\nVisualize the data in the file (a cool solution is to\nread one line at a time and\nplot the $u$ value using the line-by-line plotter in the\n`visualize_front_ascii` function - this technique makes it trivial\nto visualize very long time simulations).',
  'title': 'Minimize memory usage of a vibration solver',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_class'],
  'heading': '=====',
  'hints': ['Use the ideas and examples\nref[from Section ref{decay:prog:se:class} and ref{decay:prog:se:class2}][in cite{Langtangen_decay}][for an "ODE model": "http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book009.html#classes-for-problem-and-solution-method" in cite{Langtangen_decay}].\nMore specifically, make a superclass `Problem` for holding the scalar\nphysical parameters of a problem and let subclasses implement the\n$s(u)$ and $F(t)$ functions as methods.\nTry to call up as much existing functionality in `vib.py` as possible.'],
  'keywords': None,
  'label': 'vib:exer:gen:class',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Reimplement the `vib.py`\nprogram\nusing a class `Problem` to hold all the physical parameters of the problem,\na class `Solver` to hold the numerical parameters and compute the\nsolution, and a class `Visualizer` to display the solution.',
  'title': 'Implement the solver via classes',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_DtDt_fw_bw'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:DtDt:asDtpDtm',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Show that the difference $[D_t D_tu]^n$ is equal to $[D_t^+D_t^-u]^n$\nand $D_t^-D_t^+u]^n$. That is, instead of applying a centered difference\ntwice one can alternatively apply a mixture forward and backward\ndifferences.',
  'title': 'Interpret $[D_tD_t u]^n$ as a forward-backward difference',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['vib_gen_bwdamping'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:quad:damping:bw',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'As an alternative to discretizing the damping terms $\\beta u^{\\prime}$ and\n$\\beta |u^{\\prime}|u^{\\prime}$ by centered differences, we may apply\nbackward differences:\n\n!bt\n\\begin{align*}\n[u^{\\prime}]^n &\\approx [D_t^-u]^n,\\\\ \n& [|u^{\\prime}|u^{\\prime}]^n &\\approx [|D_t^-u|D_t^-u]^n\n= |[D_t^-u]^n|[D_t^-u]^n{\\thinspace .}\n\\end{align*}\n\n!et\nThe advantage of the backward difference is that the damping term is\nevaluated using known values $u^n$ and $u^{n-1}$ only.\nExtend the "`vib.py`": "http://tinyurl.com/nm5587k/vib/vib.py" code with a scheme based\non using backward differences in the damping terms. Add statements\nto compare the original approach with centered difference and the\nnew idea launched in this exercise. Perform numerical experiments\nto investigate how much accuracy that is lost by using the backward\ndifferences.',
  'title': 'Use a backward difference for the damping term',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': ["Use an ``ansatz'' $u^n=I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ and\n$v^n=qu^n$, where $\\tilde\\omega$ and $q$ are unknown parameters. The\nfollowing formula is handy:\n\n138 <<<!!MATH_BLOCK"],
  'keywords': None,
  'label': 'vib:exer:EulerCromer:analysis',
  'no': 17,
  'solution': 'We follow the ideas in Section ref{vib:ode1:analysis}. Inserting\n$u^n=I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ and\n$v^=qu^n$ in\n(ref{vib:model2x2:EulerCromer:ueq1b})-(ref{vib:model2x2:EulerCromer:veq1b})\nand dividing by $I\\exp{(i\\tilde\\omega\\Delta t\\,n)}$ gives\n\n!bt\n\\begin{equation}\nq\\exp{(i\\tilde\\omega\\Delta t)} = q - \\omega^2 \\Delta t,\nlabel{vib:exer:EulerCromer:analysis:equ} \n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\exp{(i\\tilde\\omega\\Delta t)} = 1 + \\Delta t\\, q\\exp{(i\\tilde\\omega\\Delta t)}\nlabel{vib:exer:EulerCromer:analysis:eqv}{\\thinspace .}\n\\end{equation}\n\n!et\nSolving (ref{vib:exer:EulerCromer:analysis:eqv}) with respect to $q$ gives\n\n!bt\n\\[ q = \\frac{1}{\\Delta t}\\left( 1 - \\exp{(i\\tilde\\omega\\Delta t)} \\right){\\thinspace .}\\]\n\n!et\nInserting this expression for $q$ in (ref{vib:exer:EulerCromer:analysis:equ})\nresults in\n\n!bt\n\\[ \\exp{(i\\tilde\\omega\\Delta t)} + \\exp{(-i\\tilde\\omega\\Delta t)} -2\n= - \\omega^2\\Delta t^2{\\thinspace .}\\]\n\n!et\nUsing the relation\n$\\exp{(i\\tilde\\omega(\\Delta t))} + \\exp{(i\\tilde\\omega(-\\Delta t))} - 2\n= -4\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2})$ gives\n\n!bt\n\\[ -4\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2}) = - \\omega^2\\Delta t^2,\\]\n\n!et\nor after dividing by 4,\n\n!bt\n\\[\n\\sin^2(\\frac{\\tilde\\omega\\Delta t}{2}) = \\left(\\frac{1}{2}\\omega\\Delta t\\right)^2,\\]\n\n!et\nwhich is the same equation for $\\tilde\\omega$ as found in\nSection ref{vib:ode1:analysis}, such that $\\tilde\\omega$ is the\nsame. The accuracy, stability, and formula for the exact discrete solution\nare then all the same as derived in Section ref{vib:ode1:analysis}.\n#This proves that the solution of the Euler-Cromer scheme\n#coincides',
  'solution_file': None,
  'subex': [],
  'text': 'The Euler-Cromer scheme for the model problem\n$u^{\\prime\\prime} + \\omega^2 u =0$, $u(0)=I$, $u^{\\prime}(0)=0$, is given in\n(ref{vib:model2x2:EulerCromer:ueq1b})-(ref{vib:model2x2:EulerCromer:veq1b}).\nFind the exact discrete solutions of this scheme and show that the solution\nfor $u^n$ coincides with that found in Section ref{vib:ode1:analysis}.',
  'title': 'Analysis of the Euler-Cromer scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['resonance'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:resonance',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': "Comparing the scaled ODE (ref{vib:app:mass_gen:scaled})\nwith the ODE (ref{vib:app:mass_gen:equ}) with dimensions, we\nrealize that the parameters in the latter must be set as\n\n * $m=1$\n * $f(\\dot u) = 2\\beta |\\dot u|\\dot u$\n * $s(u)=ku$\n * $F(t)=\\sin(\\gamma t)$\n * $I=Ik/A$\n * $V=\\sqrt{mk}V/A$\n\nThe expected period is $2\\pi$, so simulating for $N$ periods means\n$T=2\\pi N$. Having $m$ time steps per period means $\\Delta t = 2\\pi/m$.\n\nSuppose we just choose $I=1$ and $V=0$. Simulating for 20 periods with\n60 time steps per period, implies the following\n`solver` call to run the scaled model:\n\n!bc pycod\nu, t = solver(I=1, V=0, m=1, b=2*beta, s=lambda u: u,\n              F=lambda t: sin(gamma*t), dt=2*pi/60,\n              T=2*pi*20, damping='quadratic')\n\n!ec",
             'text': 'Figure out how the `solver` function in `vib.py` can be called\nfor the scaled ODE (ref{vib:app:mass_gen:scaled}).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "An appropriate program is\n\n!bc pycod\nfrom vib import solver, visualize, plt\nfrom math import pi, sin\nimport numpy as np\n\nbeta_values = [0.005, 0.05, 0.2]\nbeta_values = [0.00005]\ngamma_values = [5, 1.5, 1.1, 1]\nfor i, beta in enumerate(beta_values):\n    for gamma in gamma_values:\n        u, t = solver(I=1, V=0, m=1, b=2*beta, s=lambda u: u,\n                      F=lambda t: sin(gamma*t), dt=2*pi/60,\n                      T=2*pi*20, damping='quadratic')\n        visualize(u, t, title='gamma=%g' %\n                  gamma, filename='tmp_%s' % gamma)\n        print gamma, 'max u amplitude:', np.abs(u).max()\n    for ext in 'png', 'pdf':\n        cmd = 'doconce combine_images '\n        cmd += ' '.join(['tmp_%s.' % gamma + ext for gamma in gamma_values])\n        cmd += ' resonance%d.' % (i+1) + ext\n        os.system(cmd)\nraw_input()\n\n!ec\n\nFor $\\beta = 0.2$ we see that the amplitude is not far from unity:\n\nFIGURE: [fig-vib/resonance3, width=800 frac=1]\n\nFor $\\beta =0.05$ we see that as $\\gamma\\rightarrow 1$, the amplitude grows:\n\nFIGURE: [fig-vib/resonance2, width=800 frac=1]\n\nFinally, a small damping ($\\beta = 0.005$) amplifies the amplitude significantly (by a factor of 10) for $\\gamma=1$:\n\nFIGURE: [fig-vib/resonance2, width=800 frac=1]\n\nFor a very small $\\beta=0.00005$, the amplitude grows linearly up to\nabout 60 for $\\bar t\\in [0,120]$.",
             'text': 'Run $\\gamma =5, 1.5, 1.1, 1$ for $\\beta=0.005, 0.05, 0.2$.\nFor each $\\beta$ value, present an image with plots of $u(t)$ for\nthe four $\\gamma$ values.'}],
  'text': 'idx{resonance}\n\nWe consider the scaled ODE model\n(ref{vib:app:mass_gen:scaled}) from Section ref{vib:app:mass_gen}.\nAfter scaling, the amplitude of $u$ will have a size about unity\nas time grows and the effect of the initial conditions die out due\nto damping. However, as $\\gamma\\rightarrow 1$, the amplitude of $u$\nincreases, especially if $\\beta$ is small. This effect is called\n*resonance*. The purpose of this exercise is to explore resonance.',
  'title': 'Simulate resonance',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['sliding_box'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:sliding_box',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': "Here is a function that does the plotting:\n\n!bc pycod\nimport scitools.std as plt\nimport numpy as np\n\ndef plot_spring():\n    alpha_values = [1, 2, 3, 10]\n    s = lambda u: 1.0/alpha*np.tanh(alpha*u)\n    u = np.linspace(-1, 1, 1001)\n    for alpha in alpha_values:\n        print alpha, s(u)\n        plt.plot(u, s(u))\n        plt.hold('on')\n    plt.legend([r'$\\alpha=%g$' % alpha for alpha in alpha_values])\n    plt.xlabel('u');  plt.ylabel('Spring response $s(u)$')\n    plt.savefig('tmp_s.png'); plt.savefig('tmp_s.pdf')\n\n!ec\n\nFIGURE: [fig-vib/tanh_spring, width=600 frac=0.8]",
             'text': 'Plot $g(u)=\\alpha^{-1}\\tanh(\\alpha u)$ for various values of $\\alpha$.\nAssume $u\\in [-1,1]$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Inserting the dimensionless dependent and independent variables,\n\n!bt\n\\[ \\bar u = \\frac{u}{I},\\quad \\bar t = \\frac{tk}{m},\\]\n\n!et\nin the problem\n\n!bt\n\\[\nm\\ddot u + \\mu mg\\hbox{sign}(\\dot u) + s(u) = 0,\\quad u(0)=I,\\ \\dot u(0)=V,\\]\n\n!et\ngives\n\n!bt\n\\[ \\frac{d^2\\bar u}{d\\bar t^2} + \\frac{\\mu mg}{kI}\\hbox{sign}\\left(\n\\frac{d\\bar u}{d\\bar t}\\right) + \\frac{1}{\\alpha I}\\tanh(\\alpha I\\bar u)\n= 0,\\quad \\bar u(0)=1,\\ \\frac{d\\bar u}{d\\bar t}(0)=\\frac{V\\sqrt{mk}}{kI}{\\thinspace .}\n\\]\n\n!et\nWe identify three dimensionless parameters,\n\n!bt\n\\[ \\beta = \\frac{\\mu mg}{kI},\\quad\n\\gamma = \\alpha I,\\quad \\delta = \\frac{V\\sqrt{mk}}{kI}{\\thinspace .}\\]\n\n!et\nThe scaled problem can the be written\n\n!bt\n\\[ \\frac{d^2\\bar u}{d\\bar t^2} + \\beta\\hbox{sign}\\left(\n\\frac{d\\bar u}{d\\bar t}\\right) + \\gamma^{-1}\\tanh(\\gamma \\bar u)\n= 0,\\quad \\bar u(0)=1,\\ \\frac{d\\bar u}{d\\bar t}(0)=\\delta{\\thinspace .}\n\\]\n\n!et\nThe initial set of 7 parameters $(\\mu, m, g, k, \\alpha, I, V)$ are\nreduced to 3 dimensionless combinations.',
             'text': 'Scale the equations using $I$ as scale for $u$ and $m/k$ as\ntime scale.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'The code can be like this:\n\n!bc pycod\ndef simulate(beta, gamma, delta=0,\n             num_periods=8, time_steps_per_period=60):\n    # Use oscillations without friction to set dt and T\n    P = 2*np.pi\n    dt = P/time_steps_per_period\n    T = num_periods*P\n    t = np.linspace(0, T, time_steps_per_period*num_periods+1)\n    import odespy\n    def f(u, t, beta, gamma):\n        v, u = u\n        return [-beta*np.sign(v) - 1.0/gamma*np.tanh(gamma*u), v]\n        #return [-beta*np.sign(v) - u, v]\n\n    solver = odespy.RK4(f, f_args=(beta, gamma))\n    solver.set_initial_condition([delta, 1])\n    uv, t = solver.solve(t)\n    u = uv[:,0]\n    v = uv[:,1]\n    return u, t\n\n!ec\n\nWe simulate for an almost linear spring in the regime of $\\bar u$ (recall\nthat $\\bar u\\in [0,1]$ since $u$ is scaled with $I$), which corresponds\nto $\\alpha = 1$ in a) and therefore $\\gamma =1$. Then we can try a\nspring whose force quickly flattens out like $\\alpha=10$ in a), which\ncorresponds to $\\gamma = 10$ in the scaled model. After some\nexperimentation we realize that $\\beta=0,0.05, 0.1$ are relevant values.\n\nFIGURE: [fig-vib/sliding_box_gamma1, width=600 frac=0.8]\n\nFIGURE: [fig-vib/sliding_box_gamma10, width=600 frac=0.8]',
             'text': 'Implement the scaled model in b). Run it for some values of\nthe dimensionless parameters.'}],
  'text': 'Consider a sliding box on a flat surface as modeled in Section\nref{vib:app:mass_sliding}. As spring force we choose the nonlinear\nformula\n\n!bt\n\\[ s(u) = \\frac{k}{\\alpha}\\tanh(\\alpha u) = ku + \\frac{1}{3}\\alpha^2 ku^3 + \\frac{2}{15}\\alpha^4 k u^5 + {\\mathcal{O}(u^6)}{\\thinspace .}\\]\n\n!et',
  'title': 'Simulate oscillations of a sliding box',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['bouncing_ball'],
  'heading': '=====',
  'hints': ['A naive implementation may get stuck in repeated impacts for large time\nstep sizes. To avoid this situation, one can introduce a state\nvariable that holds the mode of the motion: free fall, impact, or rest.\nTwo consecutive impacts imply that the motion has stopped.'],
  'keywords': None,
  'label': 'vib:exer:bouncing:ball',
  'no': 20,
  'solution': 'A tailored `solver` function and some plotting statements go like\n\n!bc pypro\nimport numpy as np\n\ndef solver(H, C_R, dt, T, eps_v=0.01, eps_h=0.01):\n    """\n    Simulate bouncing ball until it comes to rest. Time step dt.\n    h(0)=H (initial height). T: maximum simulation time.\n    Method: Euler-Cromer.\n    """\n    dt = float(dt)\n    Nt = int(round(T/dt))\n    h = np.zeros(Nt+1)\n    v = np.zeros(Nt+1)\n    t = np.linspace(0, Nt*dt, Nt+1)\n    g = 0.81\n\n    v[0] = 0\n    h[0] = H\n    mode = \'free fall\'\n    for n in range(Nt):\n        v[n+1] = v[n] - dt*g\n        h[n+1] = h[n] + dt*v[n+1]\n\n        if h[n+1] < eps_h:\n            #if abs(v[n+1]) > eps_v:  # handles large dt, but is wrong\n            if v[n+1] < -eps_v:\n                # Impact\n                v[n+1] = -C_R*v[n+1]\n                h[n+1] = 0\n                if mode == \'impact\':\n                    # impact twice\n                    return h[:n+2], v[:n+2], t[:n+2]\n                mode = \'impact\'\n            elif abs(v[n+1]) < eps_v:\n                mode = \'rest\'\n                v[n+1] = 0\n                h[n+1] = 0\n                return h[:n+2], v[:n+2], t[:n+2]\n            else:\n                mode = \'free fall\'\n        else:\n            mode = \'free fall\'\n        print \'%4d v=%8.5f h=%8.5f %s\' % (n, v[n+1], h[n+1], mode)\n    raise ValueError(\'T=%g is too short simulation time\' % T)\n\nimport matplotlib.pyplot as plt\nh, v, t = solver(H=1, C_R=0.8, T=100, dt=0.0001, eps_v=0.01, eps_h=0.01)\nplt.plot(t, h)\nplt.legend(\'h\')\nplt.savefig(\'tmp_h.png\'); plt.savefig(\'tmp_h.pdf\')\nplt.figure()\nplt.plot(t, v)\nplt.legend(\'v\')\nplt.savefig(\'tmp_v.png\'); plt.savefig(\'tmp_v.pdf\')\nplt.show()\n\n!ec\n\nFIGURE: [fig-vib/bouncing_ball, width=800 frac=1]',
  'solution_file': None,
  'subex': [],
  'text': 'Section ref{vib:app:bouncing_ball} presents a model for a bouncing\nball.\nChoose one of the two ODE formulation, (ref{vib:app:bouncing:ball:h2eq}) or\n(ref{vib:app:bouncing:ball:veq})-(ref{vib:app:bouncing:ball:heq}),\nand simulate the motion of a bouncing ball. Plot $h(t)$. Think about how to\nplot $v(t)$.',
  'title': 'Simulate a bouncing ball',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': ['elastic_pendulum'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:pendulum_elastic',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ["Equal aspect ratio is set by `plt.gca().set_aspect('equal')` in\nMatplotlib (`import matplotlib.pyplot as plt`)\nand by `plot(..., daspect=[1,1,1], daspectmode='equal')`\nin SciTools (`import scitools.std as plt`).",
                       'If you want to use Odespy to solve the equations, order the ODEs\nlike $\\dot \\bar x, \\bar x, \\dot\\bar y,\\bar y$ such that the Euler-Cromer\nscheme can (also) be used (`odespy.EulerCromer`).'],
             'solution': "Here is a suggested `simulate` function:\n\n!bc pycod\nimport odespy\nimport numpy as np\nimport scitools.std as plt\n\ndef simulate(\n    beta=0.9,                 # dimensionless parameter\n    Theta=30,                 # initial angle in degrees\n    epsilon=0,                # initial stretch of wire\n    num_periods=6,            # simulate for num_periods\n    time_steps_per_period=60, # time step resolution\n    plot=True,                # make plots or not\n    ):\n    from math import sin, cos, pi\n    Theta = Theta*np.pi/180  # convert to radians\n    # Initial position and velocity\n    # (we order the equations such that Euler-Cromer in odespy\n    # can be used, i.e., vx, x, vy, y)\n    ic = [0,                              # x'=vx\n          (1 + epsilon)*sin(Theta),       # x\n          0,                              # y'=vy\n          1 - (1 + epsilon)*cos(Theta),   # y\n          ]\n\n    def f(u, t, beta):\n        vx, x, vy, y = u\n        L = np.sqrt(x**2 + (y-1)**2)\n        h = beta/(1-beta)*(1 - beta/L)  # help factor\n        return [-h*x, vx, -h*(y-1) - beta, vy]\n\n    # Non-elastic pendulum (scaled similarly in the limit beta=1)\n    # solution Theta*cos(t)\n    P = 2*pi\n    dt = P/time_steps_per_period\n    T = num_periods*P\n    omega = 2*pi/P\n\n    time_points = np.linspace(\n        0, T, num_periods*time_steps_per_period+1)\n\n    solver = odespy.EulerCromer(f, f_args=(beta,))\n    solver.set_initial_condition(ic)\n    u, t = solver.solve(time_points)\n    x = u[:,1]\n    y = u[:,3]\n    theta = np.arctan(x/(1-y))\n\n    if plot:\n        plt.figure()\n        plt.plot(x, y, 'b-', title='Pendulum motion',\n                 daspect=[1,1,1], daspectmode='equal',\n                 axis=[x.min(), x.max(), 1.3*y.min(), 1])\n        plt.savefig('tmp_xy.png')\n        plt.savefig('tmp_xy.pdf')\n        # Plot theta in degrees\n        plt.figure()\n        plt.plot(t, theta*180/np.pi, 'b-',\n                 title='Angular displacement in degrees')\n        plt.savefig('tmp_theta.png')\n        plt.savefig('tmp_theta.pdf')\n        if abs(Theta) < 10*pi/180:\n            # Compare theta and theta_e for small angles (<10 degrees)\n            theta_e = Theta*np.cos(omega*t)  # non-elastic scaled sol.\n            plt.figure()\n            plt.plot(t, theta, t, theta_e,\n                     legend=['theta elastic', 'theta non-elastic'],\n                     title='Elastic vs non-elastic pendulum, '\\ \n                            'beta=%g' % beta)\n            plt.savefig('tmp_compare.png')\n            plt.savefig('tmp_compare.pdf')\n        # Plot y vs x (the real physical motion)\n    return x, y, theta, t\n\n!ec",
             'text': 'Write a function `simulate`\nthat can simulate an elastic pendulum using the scaled model.\nThe function should have the following arguments:\n\n!bc pycod\ndef simulate(\n    beta=0.9,                 # dimensionless parameter\n    Theta=30,                 # initial angle in degrees\n    epsilon=0,                # initial stretch of wire\n    num_periods=6,            # simulate for num_periods\n    time_steps_per_period=60, # time step resolution\n    plot=True,                # make plots or not\n    ):\n\n!ec\nTo set the total simulation time and the time step, we\nuse our knowledge of the scaled, classical, non-elastic pendulum:\n$u^{\\prime\\prime} + u = 0$, with solution\n$u = \\Theta\\cos \\bar t$.\nThe period of these oscillations is $P=2\\pi$\nand the frequency is unity. The time\nfor simulation is taken as `num_periods` times $P$. The time step\nis set as $P$ divided by `time_steps_per_period`.\n\nThe `simulate` function should return the arrays of\n$x$, $y$, $\\theta$, and $t$, where $\\theta = \\tan^{-1}(x/(1-y))$ is\nthe angular displacement of the elastic pendulum corresponding to the\nposition $(x,y)$.\n\nIf `plot` is `True`, make a plot of $\\bar y(\\bar t)$\nversus $\\bar x(\\bar t)$, i.e., the physical motion\nof the mass at $(\\bar x,\\bar y)$. Use the equal aspect ratio on the axis\nsuch that we get a physically correct picture of the motion. Also\nmake a plot of $\\theta(\\bar t)$, where $\\theta$ is measured in degrees.\nIf $\\Theta < 10$ degrees, add a plot that compares the solutions of\nthe scaled, classical, non-elastic pendulum and the elastic pendulum\n($\\theta(t)$).\n\nAlthough the mathematics here employs a bar over scaled quantities, the\ncode should feature plain names `x` for $\\bar x$, `y` for $\\bar y$, and\n`t` for $\\bar t$ (rather than `x_bar`, etc.). These variable names make\nthe code easier to read and compare with the mathematics.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Here is the code:\n\n!bc pycod\ndef test_equilibrium():\n    """Test that starting from rest makes x=y=theta=0."""\n    x, y, theta, t = simulate(\n        beta=0.9, Theta=0, epsilon=0,\n        num_periods=6, time_steps_per_period=10, plot=False)\n    tol = 1E-14\n    assert np.abs(x.max()) < tol\n    assert np.abs(y.max()) < tol\n    assert np.abs(theta.max()) < tol\n\n!ec',
             'text': 'Write a test function for testing that $\\Theta=0$ and $\\epsilon=0$\ngives $x=y=0$ for all times.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "For purely vertical motion, the ODEs reduce to $\\ddot x = 0$ and\n\n!bt\n\\[ \\ddot\\bar y = -\\frac{\\beta}{1-\\beta}(1-\\beta\\frac{1}{\\sqrt{(\\bar y - 1)^2}})(\\bar y-1) - \\beta = -\\frac{\\beta}{1-\\beta}(\\bar y-1 + \\beta) - \\beta{\\thinspace .}\\]\n\n!et\nWe have here used that $(\\bar y -1)/\\sqrt{(\\bar y -1)^2}=-1$ since\n$\\bar y$ cannot exceed 1 (the pendulum's wire is fixed at the scaled\npoint $(0,1)$). In fact, $\\bar y$ will be around zero.\n(As a consistency check, we realize that in equilibrium, $\\ddot\\bar y =0$,\nand multiplying by $(1-\\beta)/\\beta$ leads to the expected $\\bar y=0$.)\nFurther calculations easily lead to\n\n!bt\n\\[ \\ddot\\bar y = -\\frac{\\beta}{1-\\beta}\\bar y = -\\omega^2\\bar y,\\]\n\n!et\nwhere we have introduced the frequency\n$\\omega = \\sqrt{\\beta/(1-\\beta)}$.\nSolving this standard ODE, with an initial stretching $\\bar y(0)=\\epsilon$\nand no velocity, results in\n\n!bt\n\\[ \\bar y(\\bar t) = \\epsilon\\cos(\\omega\\bar t){\\thinspace .}\\]\n\n!et\n\nNote that the oscillations we describe here are very different from\nthe oscillations used to set the period and time step in function\n`simulate`. The latter type of oscillations are due to gravity when\na classical, non-elastic pendulum oscillates back and forth, while\n$\\bar y(\\bar t)$ above refers to vertical *elastic* oscillations in the wire\naround the equilibrium point in the gravity field. The angular frequency\nof the vertical oscillations are given by $\\omega$ and the corresponding\nperiod is $\\hat P = 2\\pi/\\omega$. Suppose we want to simulate for\n$T=N\\hat P = N2\\pi/\\omega$ and use $n$ time steps per period,\n$\\Delta\\bar t = \\hat P/n$. The `simulate` function operates with\na simulation time of `num_periods` times $2\\pi$. This means that we must set\n`num_periods=N/omega` if we want to simulate to time $T=N\\hat P$.\nThe parameter `time_steps_per_period` must be set to $\\omega n$\nsince `simulate` has $\\Delta t$ as $2\\pi$ divided by `time_steps_per_period`\nand we want $\\Delta t = 2\\pi\\omega^{-1}n^{-1}$.\n\nThe corresponding test function can be written as follows.\n\n!bc pycod\ndef test_vertical_motion():\n    beta = 0.9\n    omega = np.sqrt(beta/(1-beta))\n    # Find num_periods. Recall that P=2*pi for scaled pendulum\n    # oscillations, while here we don't have gravity driven\n    # oscillations, but elastic oscillations with frequency omega.\n    period = 2*np.pi/omega\n    # We want T = N*period\n    N = 5\n    # simulate function has T = 2*pi*num_periods\n    num_periods = 5/omega\n    n = 600\n    time_steps_per_period = omega*n\n\n    y_exact = lambda t: -0.1*np.cos(omega*t)\n    x, y, theta, t = simulate(\n        beta=beta, Theta=0, epsilon=0.1,\n        num_periods=num_periods,\n        time_steps_per_period=time_steps_per_period,\n        plot=False)\n\n    tol = 0.00055 # ok tolerance for the above resolution\n    # No motion in x direction is epxected\n    assert np.abs(x.max()) < tol\n    # Check motion in y direction\n    y_e = y_exact(t)\n    diff = np.abs(y_e - y).max()\n    if diff > tol: # plot\n        plt.plot(t, y, t, y_e, legend=['y', 'exact'])\n        raw_input('Error in test_vertical_motion; type CR:')\n    assert diff < tol, 'diff=%g' % diff\n\n!ec",
             'text': 'Write another test function for checking that the pure vertical\nmotion of the elastic pendulum is correct.\nStart with simplifying the ODEs for pure vertical motion and show that\n$\\bar y(\\bar t)$ fulfills a vibration equation with\nfrequency $\\sqrt{\\beta/(1-\\beta)}$. Set up the exact solution.\n\nWrite a test function that\nuses this special case to verify the `simulate` function. There will\nbe numerical approximation errors present in the results from\n`simulate` so you have to believe in correct results and set a\n(low) tolerance that corresponds to the computed maximum error.\nUse a small $\\Delta t$ to obtain a small numerical approximation error.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'The `demo` function is just\n\n!bc pycod\ndef demo(beta=0.999, Theta=40, num_periods=3):\n    x, y, theta, t = simulate(\n        beta=beta, Theta=Theta, epsilon=0,\n        num_periods=num_periods, time_steps_per_period=600,\n        plot=True)\n\n!ec\n\nBelow are plots corresponding to $\\beta = 0.999$ (3 periods) and\n$\\beta = 0.93$ (one period):\n\nFIGURE: [fig-vib/elastic_pendulum_xy, width=600 frac=0.8]\n\nFIGURE: [fig-vib/elastic_pendulum_theta, width=600 frac=0.8]\n\nFIGURE: [fig-vib/elastic_pendulum_xy2, width=600 frac=0.8]\n\nFIGURE: [fig-vib/elastic_pendulum_theta2, width=600 frac=0.8]',
             'text': 'Make a function `demo(beta, Theta)` for simulating an elastic pendulum with a\ngiven $\\beta$ parameter and initial angle $\\Theta$. Use 600 time steps\nper period to get every accurate results, and simulate for 3 periods.'}],
  'text': 'Section ref{vib:app:pendulum_elastic} describes a model for an elastic\npendulum, resulting in a system of two ODEs. The purpose of this\nexercise is to implement the scaled model, test the software, and\ngeneralize the model.',
  'title': 'Simulate an elastic pendulum',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': 'Test functions are challenging to construct for the problem with\nair resistance. You can reuse the tests from\nExercise ref{vib:exer:pendulum_elastic_drag} for `simulate_drag`,\nbut these tests does not verify the new terms arising from air\nresistance.',
  'file': ['elastic_pendulum_drag'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'vib:exer:pendulum_elastic_drag',
  'no': 22,
  'solution': "We start with the model\n(ref{vib:app:pendulum_elastic:x})-(ref{vib:app:pendulum_elastic:vy0}).\nSince $\\bm{v} = \\dot x\\bm{i} + \\dot y\\bm{j}$, the air resistance term\ncan be written\n\n!bt\n\\[ -q(\\dot x\\bm{i} + \\dot y\\bm{j}),\\quad q=\\frac{1}{2}\\varrho C_D A\\sqrt{\\dot x^2 + \\dot y^2}{\\thinspace .}\\]\n\n!et\nNote that for positive velocities, the pendulum is moving to the right\nand the air resistance works against the motion, i.e., in direction of $-\\bm{v}$.\n\nWe can easily include the terms in the ODEs:\n\n!bt\n\\begin{equation}\n\\ddot x = -\\frac{q}{m}\\dot x -\\frac{k}{m}\\left(1 -\\frac{L_0}{L}\\right)(x-x_0),\nlabel{vib:app:pendulum_elastic_drag:x}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\ddot y = \\frac{q}{m}\\dot y -\\frac{k}{m}\\left(1 -\\frac{L_0}{L}\\right)(y-y_0) - g,\nlabel{vib:app:pendulum_elastic_drag:y}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nL = \\sqrt{(x-x_0)^2 + (y-y_0)^2},\nlabel{vib:app:pendulum_elastic_drag:L}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \nlabel{_auto29}\n\\end{equation}\n\n!et\nThe initial conditions are not affected.\n\nThe next step is to scale the model. We use the same scales as in\nExercise ref{vib:exer:pendulum_elastic_drag}. The new scaled term\n(after dividing by the length scale) in the $x$ component is\n\n!bt\n\\[ t_c^{-2} \\frac{1}{2m}\\varrho C_D A\\sqrt{\\frac{(L_0+mg/k)^2}{t_c^2}(\n\\left(\\frac{d\\bar x}{d\\bar t}\\right)^2 +\n\\left(\\frac{d\\bar y}{d\\bar t}\\right)^2)} t_c^{-1}\\dot\\bar\\dot x\n= \\frac{1}{2}\\varrho C_D A (L_0+mg/k)\\sqrt{\\bar\\dot x^2 + \\bar y^2}\\bar\\dot x\n{\\thinspace .}\\]\n\n!et\nWe can introduce the $\\beta$ parameter and use $A=\\pi R^2$ to simplify a bit:\n\n!bt\n\\[ \\frac{L_0}{2m}\\varrho C_D R^2\\beta^{-1}\n\\sqrt{\\left(\\frac{d\\bar x}{d\\bar t}\\right)^2 +\n\\left(\\frac{d\\bar y}{d\\bar t}\\right)^2}\n= \\gamma \\beta^{-1}\n\\sqrt{\\left(\\frac{d\\bar x}{d\\bar t}\\right)^2 +\n\\left(\\frac{d\\bar y}{d\\bar t}\\right)^2},\\]\n\n!et\nwhere $\\gamma$ is a second dimensionless parameter:\n\n!bt\n\\[ \\gamma = \\frac{L_0}{2m}\\varrho C_D R^2{\\thinspace .}\\]\n\n!et\n\nThe final set of scaled equations are then\n\n!bt\n\\begin{equation}\n\\frac{d^2\\bar x}{d\\bar t^2} = -\\gamma\\beta^{-1}\n\\sqrt{\\left(\\frac{d\\bar x}{d\\bar t}\\right)^2 +\n\\left(\\frac{d\\bar y}{d\\bar t}\\right)^2}\\frac{d\\bar x}{d\\bar t}\n-\\frac{\\beta}{1-\\beta}\\left(1- \\frac{\\beta}{\\bar L}\\right)\\bar x,\nlabel{vib:app:pendulum_elastic_drag:x:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d^2\\bar y}{d\\bar t^2} =\n-\\gamma\\beta^{-1}\n\\sqrt{\\left(\\frac{d\\bar x}{d\\bar t}\\right)^2 +\n\\left(\\frac{d\\bar y}{d\\bar t}\\right)^2}\\frac{d\\bar y}{d\\bar t}\n-\\frac{\\beta}{1-\\beta}\\left(1- \\frac{\\beta}{\\bar L}\\right)(\\bar y-1)\n-\\beta,\nlabel{vib:app:pendulum_elastic_drag:y:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar L = \\sqrt{\\bar x^2 + (\\bar y-1)^2},\nlabel{vib:app:pendulum_elastic_drag:L:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar x(0) = (1+\\epsilon)\\sin\\Theta,\nlabel{vib:app:pendulum_elastic_drag:x0:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar x}{d\\bar t}(0) = 0,\nlabel{vib:app:pendulum_elastic_drag:vx0:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\bar y(0) = 1 - (1+\\epsilon)\\cos\\Theta,\nlabel{vib:app:pendulum_elastic_drag:y0:s}\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{d\\bar y}{d\\bar t}(0) = 0,\nlabel{vib:app:pendulum_elastic_drag:vy0:s}\n\\end{equation}\n\n!et\n\nThe new `simulate_drag` function becomes\n\n!bc pycod\ndef simulate_drag(\n    beta=0.9,                 # dimensionless elasticity parameter\n    gamma=0,                  # dimensionless drag parameter\n    Theta=30,                 # initial angle in degrees\n    epsilon=0,                # initial stretch of wire\n    num_periods=6,            # simulate for num_periods\n    time_steps_per_period=60, # time step resolution\n    plot=True,                # make plots or not\n    ):\n    from math import sin, cos, pi\n    Theta = Theta*np.pi/180  # convert to radians\n    # Initial position and velocity\n    # (we order the equations such that Euler-Cromer in odespy\n    # can be used, i.e., vx, x, vy, y)\n    ic = [0,                              # x'=vx\n          (1 + epsilon)*sin(Theta),       # x\n          0,                              # y'=vy\n          1 - (1 + epsilon)*cos(Theta),   # y\n          ]\n\n    def f(u, t, beta, gamma):\n        vx, x, vy, y = u\n        L = np.sqrt(x**2 + (y-1)**2)\n        v = np.sqrt(vx**2 + vy**2)\n        h1 = beta/(1-beta)*(1 - beta/L)  # help factor\n        h2 = gamma/beta*v\n        return [-h2*vx - h1*x, vx, -h2*vy - h1*(y-1) - beta, vy]\n\n    # Non-elastic pendulum (scaled similarly in the limit beta=1)\n    # solution Theta*cos(t)\n    P = 2*pi\n    dt = P/time_steps_per_period\n    T = num_periods*P\n    omega = 2*pi/P\n\n    time_points = np.linspace(\n        0, T, num_periods*time_steps_per_period+1)\n\n    solver = odespy.EulerCromer(f, f_args=(beta, gamma))\n    solver.set_initial_condition(ic)\n    u, t = solver.solve(time_points)\n    x = u[:,1]\n    y = u[:,3]\n    theta = np.arctan(x/(1-y))\n\n    if plot:\n        plt.figure()\n        plt.plot(x, y, 'b-', title='Pendulum motion',\n                 daspect=[1,1,1], daspectmode='equal',\n                 axis=[x.min(), x.max(), 1.3*y.min(), 1])\n        plt.savefig('tmp_xy.png')\n        plt.savefig('tmp_xy.pdf')\n        # Plot theta in degrees\n        plt.figure()\n        plt.plot(t, theta*180/np.pi, 'b-',\n                 title='Angular displacement in degrees')\n        plt.savefig('tmp_theta.png')\n        plt.savefig('tmp_theta.pdf')\n        if abs(Theta) < 10*pi/180:\n            # Compare theta and theta_e for small angles (<10 degrees)\n            theta_e = Theta*np.cos(omega*t)  # non-elastic scaled sol.\n            plt.figure()\n            plt.plot(t, theta, t, theta_e,\n                     legend=['theta elastic', 'theta non-elastic'],\n                     title='Elastic vs non-elastic pendulum, '\\ \n                            'beta=%g' % beta)\n            plt.savefig('tmp_compare.png')\n            plt.savefig('tmp_compare.pdf')\n        # Plot y vs x (the real physical motion)\n    return x, y, theta, t\n\n!ec\n\nThe plot of $\\theta$ shows the damping ($\\beta = 0.999$):\n\nFIGURE: [fig-vib/elastic_pendulum_drag_theta, width=600 frac=0.8]\n\nTest functions for equilibrium and vertical motion are also included. These\nare as in Exercise ref{vib:exer:pendulum_elastic_drag}, except that\nthey call `simulate_drag` instead of `simulate`.",
  'solution_file': None,
  'subex': [],
  'text': 'This is a continuation Exercise ref{vib:exer:pendulum_elastic_drag}.\nAir resistance on the body with mass $m$ can be modeled by the\nforce $-\\frac{1}{2}\\varrho C_D A|\\bm{v}|\\bm{v}$,\nwhere $C_D$ is a drag coefficient (0.2 for a sphere), $\\varrho$\nis the density of air (1.2 $\\hbox{kg }\\,{\\hbox{m}}^{-3}$), $A$ is the\ncross section area ($A=\\pi R^2$ for a sphere, where $R$ is the radius),\nand $\\bm{v}$ is the velocity of the body.\nInclude air resistance in the original model, scale the model,\nwrite a function `simulate_drag` that is a copy of the `simulate`\nfunction from Exercise ref{vib:exer:pendulum_elastic_drag}, but with the\nnew ODEs included, and show plots of how air resistance\ninfluences the motion.',
  'title': 'Simulate an elastic pendulum with air resistance',
  'type': 'Exercise',
  'type_visible': True}]