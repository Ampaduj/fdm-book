
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generalization: reflecting boundaries</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Finite difference methods for wave equations" href="index.html" />
    <link rel="next" title="Analysis of the difference equations" href="._main_wave004.html" />
    <link rel="prev" title="Implementation" href="._main_wave002.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_wave004.html" title="Analysis of the difference equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="generalization-reflecting-boundaries">
<span id="wave-pde2-neumann"></span><h1>Generalization: reflecting boundaries<a class="headerlink" href="#generalization-reflecting-boundaries" title="Permalink to this headline">¶</a></h1>
<p>The boundary condition <span class="math">\(u=0\)</span> in a wave equation
reflects the wave, but <span class="math">\(u\)</span> changes sign at the boundary,
while the condition <span class="math">\(u_x=0\)</span> reflects the wave as a mirror and preserves
the sign, see
a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/demo_BC_gaussian/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/demo_BC_gaussian/movie.flv">movie file</a>
for demonstration.</p>
<p>Our next task is to explain how to implement the boundary
condition <span class="math">\(u_x=0\)</span>, which is
more complicated to express numerically and also to implement than
a given value of <span class="math">\(u\)</span>.
We shall present two methods for implementing <span class="math">\(u_x=0\)</span>
in a finite difference scheme, one based on deriving a modified
stencil at the boundary, and another one based on extending the mesh
with ghost cells and ghost points.</p>
<div class="section" id="neumann-boundary-condition">
<span id="wave-pde2-neumann-bc"></span><h2>Neumann boundary condition<a class="headerlink" href="#neumann-boundary-condition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">When a wave hits a boundary and is to be reflected back, one applies
the condition</p>
<div class="math" id="eq-wave-pde1-neumann-0">
\[\tag{35}
\frac{\partial u}{\partial n} \equiv \boldsymbol{n}\cdot\nabla u = 0\]\[    {\thinspace .}\]</div>
<p>The derivative <span class="math">\(\partial /\partial n\)</span> is in the
outward normal direction from a general boundary.
For a 1D domain <span class="math">\([0,L]\)</span>,
we have that</p>
<div class="math">
\[\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\left.\frac{\partial}{\partial x}\right\vert_{x=L},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\left.\frac{\partial}{\partial x}\right\vert_{x=0}{\thinspace .}\]</div>
<div class="admonition-boundary-condition-terminology admonition">
<p class="first admonition-title">Boundary condition terminology</p>
<p class="last">Boundary conditions
that specify the value of <span class="math">\(\partial u/\partial n\)</span>,
or shorter <span class="math">\(u_n\)</span>, are known as
<a class="reference external" href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">Neumann</a> conditions, while <a class="reference external" href="http://en.wikipedia.org/wiki/Dirichlet_conditions">Dirichlet conditions</a>
refer to specifications of <span class="math">\(u\)</span>.
When the values are zero (<span class="math">\(\partial u/\partial n=0\)</span> or <span class="math">\(u=0\)</span>) we speak
about <em>homogeneous</em> Neumann or Dirichlet conditions.</p>
</div>
</div>
<div class="section" id="discretization-of-derivatives-at-the-boundary">
<span id="wave-pde2-neumann-discr"></span><h2>Discretization of derivatives at the boundary<a class="headerlink" href="#discretization-of-derivatives-at-the-boundary" title="Permalink to this headline">¶</a></h2>
<p id="index-6">How can we incorporate the condition <a class="reference internal" href="#eq-wave-pde1-neumann-0"><em>(35)</em></a>
in the finite difference scheme?  Since we have used central
differences in all the other approximations to derivatives in the
scheme, it is tempting to implement <a class="reference internal" href="#eq-wave-pde1-neumann-0"><em>(35)</em></a> at
<span class="math">\(x=0\)</span> and <span class="math">\(t=t_n\)</span> by the difference</p>
<div class="math" id="eq-wave-pde1-neumann-0-cd">
\[\tag{36}
[D_{2x} u]^n_0 = \frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
    {\thinspace .}\]</div>
<p>The problem is that <span class="math">\(u_{-1}^n\)</span> is not a <span class="math">\(u\)</span> value that is being
computed since the point is outside the mesh. However, if we combine
<a class="reference internal" href="#eq-wave-pde1-neumann-0-cd"><em>(36)</em></a> with the scheme</p>
<p>for <span class="math">\(i=0\)</span>,</p>
<div class="math" id="eq-wave-pde1-neumann-0-scheme">
\[\tag{37}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>we can eliminate the fictitious value <span class="math">\(u_{-1}^n\)</span>. We see that
<span class="math">\(u_{-1}^n=u_1^n\)</span> from <a class="reference internal" href="#eq-wave-pde1-neumann-0-cd"><em>(36)</em></a>, which
can be used in <a class="reference internal" href="#eq-wave-pde1-neumann-0-scheme"><em>(37)</em></a> to
arrive at a modified scheme for the boundary point <span class="math">\(u_0^{n+1}\)</span>:</p>
<div class="math" id="eq-auto11">
\[\tag{38}
u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
    \left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0 {\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-neumann-stencil"><em>Modified stencil at a boundary with a Neumann condition</em></a> visualizes this equation
for computing <span class="math">\(u^3_0\)</span> in terms of <span class="math">\(u^2_0\)</span>, <span class="math">\(u^1_0\)</span>, and
<span class="math">\(u^2_1\)</span>.</p>
<div class="figure" id="wave-pde1-fig-neumann-stencil">
<a class="reference internal image-reference" href="_images/stencil_n_left.png"><img alt="_images/stencil_n_left.png" src="_images/stencil_n_left.png" style="width: 500px;" /></a>
<p class="caption"><em>Modified stencil at a boundary with a Neumann condition</em></p>
</div>
<p>Similarly, <a class="reference internal" href="#eq-wave-pde1-neumann-0"><em>(35)</em></a> applied at <span class="math">\(x=L\)</span>
is discretized by a central difference</p>
<div class="math" id="eq-wave-pde1-neumann-0-cd2">
\[\tag{39}
\frac{u_{N_x+1}^n - u_{N_x-1}^n}{2\Delta x} = 0
    {\thinspace .}\]</div>
<p>Combined with the scheme for <span class="math">\(i=N_x\)</span> we get a modified scheme for
the boundary value <span class="math">\(u_{N_x}^{n+1}\)</span>:</p>
<div class="math" id="eq-auto12">
\[\tag{40}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + 2C^2
    \left(u^{n}_{i-1}-u^{n}_{i}\right),\quad i=N_x {\thinspace .}\]</div>
<p>The modification of the scheme at the boundary is also required for
the special formula for the first time step. How the stencil moves
through the mesh and is modified at the boundary can be illustrated
by an animation
in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="implementation-of-neumann-conditions">
<span id="wave-pde2-neumann-impl"></span><h2>Implementation of Neumann conditions<a class="headerlink" href="#implementation-of-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>We have seen in the preceding section
that the special formulas for the boundary points
arise from replacing <span class="math">\(u_{i-1}^n\)</span> by <span class="math">\(u_{i+1}^n\)</span> when computing
<span class="math">\(u_i^{n+1}\)</span> from the stencil formula for <span class="math">\(i=0\)</span>. Similarly, we
replace <span class="math">\(u_{i+1}^n\)</span> by <span class="math">\(u_{i-1}^n\)</span> in the stencil formula
for <span class="math">\(i=N_x\)</span>. This observation can conveniently
be used in the coding: we just work with the general stencil formula,
but write the code such that it is easy to replace <tt class="docutils literal"><span class="pre">u[i-1]</span></tt> by
<tt class="docutils literal"><span class="pre">u[i+1]</span></tt> and vice versa. This is achieved by
having the indices <tt class="docutils literal"><span class="pre">i+1</span></tt> and <tt class="docutils literal"><span class="pre">i-1</span></tt> as variables <tt class="docutils literal"><span class="pre">ip1</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> plus 1)
and <tt class="docutils literal"><span class="pre">im1</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> minus 1), respectively.
At the boundary we can easily define <tt class="docutils literal"><span class="pre">im1=i+1</span></tt> while we use
<tt class="docutils literal"><span class="pre">im1=i-1</span></tt> in the internal parts of the mesh. Here are the details
of the implementation (note that the updating formula for <tt class="docutils literal"><span class="pre">u[i]</span></tt>
is the general stencil formula):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>  <span class="c"># i-1 -&gt; i+1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">im1</span>  <span class="c"># i+1 -&gt; i-1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>We can in fact create one loop over both the internal and boundary
points and use only one updating formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Nx</span> <span class="k">else</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="k">else</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span>
</pre></div>
</div>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0.py">wave1D_n0.py</a>
contains a complete implementation of the 1D wave equation with
boundary conditions <span class="math">\(u_x = 0\)</span> at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.</p>
<p>It would be nice to modify the <tt class="docutils literal"><span class="pre">test_quadratic</span></tt> test case from the
<tt class="docutils literal"><span class="pre">wave1D_u0.py</span></tt> with Dirichlet conditions, described in the section <a class="reference internal" href="._main_wave002.html#wave-pde1-impl-vec-verify-quadratic"><em>Verification</em></a>. However, the Neumann
conditions require the polynomial variation in the <span class="math">\(x\)</span> direction to
be of third degree, which causes challenging problems when
designing a test where the numerical solution is known exactly.
<a class="reference internal" href="#wave-fd2-exer-verify-cubic"><em>Exercise 14: Verification by a cubic polynomial in space</em></a> outlines ideas and code
for this purpose. The only test in <tt class="docutils literal"><span class="pre">wave1D_n0.py</span></tt> is to start
with a plug wave at rest and see that the initial condition is
reached again perfectly after one period of motion, but such
a test requires <span class="math">\(C=1\)</span> (so the numerical solution coincides with
the exact solution of the PDE, see the section <a class="reference internal" href="._main_wave004.html#wave-pde1-num-dispersion"><em>Numerical dispersion relation</em></a>).</p>
</div>
<div class="section" id="index-set-notation">
<span id="wave-indexset"></span><h2>Index set notation<a class="headerlink" href="#index-set-notation" title="Permalink to this headline">¶</a></h2>
<p id="index-7">To improve our mathematical writing and our implementations,
it is wise to introduce a special notation for index sets. This means
that we write
<span class="math">\(x_i\)</span>, <span class="math">\(i\in{\mathcal{I}_x}\)</span>, instead of <span class="math">\(i=0,\ldots,N_x\)</span>.
Obviously, <span class="math">\({\mathcal{I}_x}\)</span> must be the index set <span class="math">\({\mathcal{I}_x} =\{0,\ldots,N_x\}\)</span>, but it
is often advantageous to have a symbol for this set rather than
specifying all its elements (all the time, as we have done up to
now). This new notation saves writing and makes
specifications of algorithms and their implementation of computer code
simpler.</p>
<p>The first index in the set will be denoted <span class="math">\({{\mathcal{I^0}_x}}\)</span>
and the last <span class="math">\({\mathcal{I^{-1}_x}}\)</span>. When we need to skip the first element of
the set, we use <span class="math">\({{\mathcal{I^+}_x}}\)</span> for the remaining subset
<span class="math">\({{\mathcal{I^+}_x}}=\{1,\ldots,N_x\}\)</span>. Similarly, if the last element is
to be dropped, we write <span class="math">\({{\mathcal{I^-}_x}}=\{0,\ldots,N_x-1\}\)</span> for the
remaining indices.
All the
indices corresponding to inner grid points are specified by
<span class="math">\({{\mathcal{I^i}_x}}=\{1,\ldots,N_x-1\}\)</span>.  For the time domain we find it
natural to explicitly use 0 as the first index, so we will usually
write <span class="math">\(n=0\)</span> and <span class="math">\(t_0\)</span> rather than <span class="math">\(n={\mathcal{I}_t}^0\)</span>. We also avoid notation
like <span class="math">\(x_{{\mathcal{I^{-1}_x}}}\)</span> and will instead use <span class="math">\(x_i\)</span>, <span class="math">\(i={\mathcal{I^{-1}_x}}\)</span>.</p>
<p>The Python code associated with index sets applies the following
conventions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="70%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Notation</th>
<th class="head">Python</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="math">\({\mathcal{I}_x}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix</span></tt></td>
</tr>
<tr class="row-odd"><td><span class="math">\({{\mathcal{I^0}_x}}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix[0]</span></tt></td>
</tr>
<tr class="row-even"><td><span class="math">\({\mathcal{I^{-1}_x}}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix[-1]</span></tt></td>
</tr>
<tr class="row-odd"><td><span class="math">\({{\mathcal{I^-}_x}}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix[:-1]</span></tt></td>
</tr>
<tr class="row-even"><td><span class="math">\({{\mathcal{I^+}_x}}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix[1:]</span></tt></td>
</tr>
<tr class="row-odd"><td><span class="math">\({{\mathcal{I^i}_x}}\)</span></td>
<td><tt class="docutils literal"><span class="pre">Ix[1:-1]</span></tt></td>
</tr>
</tbody>
</table>
<div class="admonition-why-index-sets-are-useful admonition">
<p class="first admonition-title">Why index sets are useful</p>
<p class="last">An important feature of the index set notation is that it
keeps our formulas and code independent of how
we count mesh points. For example, the notation <span class="math">\(i\in{\mathcal{I}_x}\)</span> or <span class="math">\(i={{\mathcal{I^0}_x}}\)</span>
remains the same whether <span class="math">\({\mathcal{I}_x}\)</span> is defined as above or as starting at 1,
i.e., <span class="math">\({\mathcal{I}_x}=\{1,\ldots,Q\}\)</span>. Similarly, we can in the code define
<tt class="docutils literal"><span class="pre">Ix=range(Nx+1)</span></tt> or <tt class="docutils literal"><span class="pre">Ix=range(1,Q)</span></tt>, and expressions
like <tt class="docutils literal"><span class="pre">Ix[0]</span></tt> and <tt class="docutils literal"><span class="pre">Ix[1:-1]</span></tt> remain correct. One application where
the index set notation is convenient is
conversion of code from a language where arrays has base index 0 (e.g.,
Python and C) to languages where the base index is 1 (e.g., MATLAB and
Fortran). Another important application is implementation of
Neumann conditions via ghost points (see next section).</p>
</div>
<p>For the current problem setting in the <span class="math">\(x,t\)</span> plane, we work with
the index sets</p>
<div class="math" id="eq-auto13">
\[\tag{41}
{\mathcal{I}_x} = \{0,\ldots,N_x\},\quad {\mathcal{I}_t} = \{0,\ldots,N_t\},\]</div>
<p>defined in Python as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A finite difference scheme can with the index set notation be specified as</p>
<div class="math">
\[\begin{split}u_i^{n+1} &amp;= u^n_i - \frac{1}{2}
C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\quad,
i\in{{\mathcal{I^i}_x}},\ n=0,\\
u^{n+1}_i &amp;= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in{{\mathcal{I^i}_x}},\ n\in{{\mathcal{I^i}_t}},\\
u_i^{n+1} &amp;= 0,
\quad i={{\mathcal{I^0}_x}},\ n\in{{\mathcal{I^-}_t}},\\
u_i^{n+1} &amp;= 0,
\quad i={\mathcal{I^{-1}_x}},\ n\in{{\mathcal{I^-}_t}}{\thinspace .}\end{split}\]</div>
<p>The corresponding implementation becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initial condition</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="c"># Time loop</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Compute internal points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
               <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="c"># Compute boundary conditions</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>
applies the index set notation and
solves the 1D wave equation <span class="math">\(u_{tt}=c^2u_{xx}+f(x,t)\)</span> with
quite general boundary and initial conditions:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(x=0\)</span>: <span class="math">\(u=U_0(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(x=L\)</span>: <span class="math">\(u=U_L(t)\)</span> or <span class="math">\(u_x=0\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u=I(x)\)</span></li>
<li><span class="math">\(t=0\)</span>: <span class="math">\(u_t=I(x)\)</span></li>
</ul>
</div></blockquote>
<p>The program combines Dirichlet and Neumann conditions, scalar and vectorized
implementation of schemes, and the index notation into one piece of code.
A lot of test examples are also included in the program:</p>
<blockquote class="last">
<div><ul class="simple">
<li>A rectangular plug-shaped initial condition. (For <span class="math">\(C=1\)</span> the solution
will be a rectangle that jumps one cell per time step, making the case
well suited for verification.)</li>
<li>A Gaussian function as initial condition.</li>
<li>A triangular profile as initial condition, which resembles the
typical initial shape of a guitar string.</li>
<li>A sinusoidal variation of <span class="math">\(u\)</span> at <span class="math">\(x=0\)</span> and either <span class="math">\(u=0\)</span> or
<span class="math">\(u_x=0\)</span> at <span class="math">\(x=L\)</span>.</li>
<li>An exact analytical solution <span class="math">\(u(x,t)=\cos(m\pi t/L)\sin({\frac{1}{2}}m\pi x/L)\)</span>, which can be used for convergence rate tests.</li>
</ul>
</div></blockquote>
</div>
<p>[<strong>hpl 2</strong>: Should include some experiments here or make exercises. Qualitative behavior of the wave equation can be exemplified.]</p>
</div>
<div class="section" id="verifying-the-implementation-of-neumann-conditions">
<span id="wave-pde1-verify"></span><h2>Verifying the implementation of Neumann conditions<a class="headerlink" href="#verifying-the-implementation-of-neumann-conditions" title="Permalink to this headline">¶</a></h2>
<p>How can we test that the Neumann conditions are correctly implemented?
The <tt class="docutils literal"><span class="pre">solver</span></tt> function in the <tt class="docutils literal"><span class="pre">wave1D_dn.py</span></tt> program described in the
box above accepts Dirichlet or Neumann conditions at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>.
It is tempting to apply a quadratic solution as described in
the sections <a class="reference internal" href="._main_wave001.html#wave-pde2-fd"><em>A slightly generalized model problem</em></a> and <a class="reference internal" href="._main_wave002.html#wave-pde1-impl-verify-quadratic"><em>Verification: exact quadratic solution</em></a>,
but it turns out that this solution is no longer an exact solution
of the discrete equations if a Neumann condition is implemented on
the boundary. A linear solution does not help since we only have
homogeneous Neumann conditions in <tt class="docutils literal"><span class="pre">wave1D_dn.py</span></tt>, and we are
consequently left with testing just a constant solution: <span class="math">\(u=\hbox{const}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_constant</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the scalar and vectorized versions for</span>
<span class="sd">    a constant u(x,t). We simulate in [0, L] and apply</span>
<span class="sd">    Neumann and Dirichlet conditions at both ends.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_const</span> <span class="o">=</span> <span class="mf">0.45</span>
    <span class="n">u_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">assert_no_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;diff=</span><span class="si">%E</span><span class="s">, t_</span><span class="si">%d</span><span class="s">=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>

    <span class="k">for</span> <span class="n">U_0</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">U_L</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_const</span><span class="p">):</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mf">2.5</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">0.75</span>
            <span class="n">Nx</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c"># Very coarse mesh for this exact test</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mi">18</span>  <span class="c"># long time integration</span>

            <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                   <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span>
                   <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
            <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                   <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">,</span>
                   <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
            <span class="k">print</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span>
</pre></div>
</div>
<p>The quadratic solution is very useful for testing though, but it requires
Dirichlet conditions at both ends.</p>
<p>Another test may utilize the fact that the approximation error vanishes
when the Courant number is unity. We can, for example, start with a
plug profile as initial condition, let this wave split into two plug waves,
one in each direction, and check that the two plug waves come back and
form the initial condition again after &#8220;one period&#8221; of the solution
process. Neumann conditions can be applied at both ends. A proper
test function reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_plug</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Check that an initial plug is correct back after one period.&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>  <span class="c"># Nx=10</span>
    <span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="n">u_s</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span>
        <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">u_v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span>
        <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-13</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_s</span> <span class="o">-</span> <span class="n">u_v</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="n">u_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">I</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_s</span> <span class="o">-</span> <span class="n">u_0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Other tests must rely on an unknown approximation error, so effectively
we are left with tests on the convergence rate.</p>
</div>
<div class="section" id="alternative-implementation-via-ghost-cells">
<span id="wave-pde1-neumann-ghost"></span><h2>Alternative implementation via ghost cells<a class="headerlink" href="#alternative-implementation-via-ghost-cells" title="Permalink to this headline">¶</a></h2>
<div class="section" id="idea">
<h3>Idea<a class="headerlink" href="#idea" title="Permalink to this headline">¶</a></h3>
<p>Instead of modifying the scheme at the boundary, we can introduce
extra points outside the domain such that the fictitious values
<span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>
are defined in the mesh.
Adding the intervals <span class="math">\([-\Delta x,0]\)</span> and <span class="math">\([L, L+\Delta x]\)</span>,
often referred to as <em>ghost cells</em>, to the mesh gives us all the
needed mesh points, corresponding to <span class="math">\(i=-1,0,\ldots,N_x,N_x+1\)</span>.
The extra points <span class="math">\(i=-1\)</span> and <span class="math">\(i=N_x+1\)</span> are known as <em>ghost points</em>,
and values at these points, <span class="math">\(u_{-1}^n\)</span> and <span class="math">\(u_{N_x+1}^n\)</span>, are
called <em>ghost values</em>.</p>
<p>The important idea is
to ensure that we always have</p>
<div class="math">
\[u_{-1}^n = u_{1}^n\hbox{ and } u_{N_x+1}^n = u_{N_x-1}^n,\]</div>
<p>because then
the application of the standard scheme at a boundary point <span class="math">\(i=0\)</span> or <span class="math">\(i=N_x\)</span>
will be correct and guarantee that the solution is compatible with the
boundary condition <span class="math">\(u_x=0\)</span>.</p>
</div>
<div class="section" id="implementation-2">
<h3>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">u</span></tt> array now needs extra elements corresponding to the ghost
points. Two new point values are needed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The arrays <tt class="docutils literal"><span class="pre">u_1</span></tt> and <tt class="docutils literal"><span class="pre">u_2</span></tt> must be defined accordingly.</p>
<p>Unfortunately, a major indexing problem arises with ghost cells.
The reason is that Python indices <em>must</em> start
at 0 and <tt class="docutils literal"><span class="pre">u[-1]</span></tt> will always mean the last element in <tt class="docutils literal"><span class="pre">u</span></tt>.
This fact gives, apparently, a mismatch between the mathematical
indices <span class="math">\(i=-1,0,\ldots,N_x+1\)</span> and the Python indices running over
<tt class="docutils literal"><span class="pre">u</span></tt>: <tt class="docutils literal"><span class="pre">0,..,Nx+2</span></tt>. One remedy is to change the mathematical indexing
of <span class="math">\(i\)</span> in the scheme and write</p>
<div class="math">
\[u^{n+1}_i = \cdots,\quad i=1,\ldots,N_x+1,\]</div>
<p>instead of <span class="math">\(i=0,\ldots,N_x\)</span> as we have previously used. The ghost
points now correspond to <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x+1\)</span>.
A better solution is to use the ideas of the section <a class="reference internal" href="#wave-indexset"><em>Index set notation</em></a>:
we hide the specific index value in an index set and operate with
inner and boundary points using the index set notation.</p>
<p>To this end, we define <tt class="docutils literal"><span class="pre">u</span></tt> with proper length and <tt class="docutils literal"><span class="pre">Ix</span></tt> to be the corresponding
indices for the real physical mesh points (<span class="math">\(1,2,\ldots,N_x+1\)</span>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, the boundary points have indices <tt class="docutils literal"><span class="pre">Ix[0]</span></tt> and <tt class="docutils literal"><span class="pre">Ix[-1]</span></tt> (as before).
We first update the solution at all physical mesh points (i.e., interior
points in the mesh):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The indexing becomes a bit more complicated when we call functions like
<tt class="docutils literal"><span class="pre">V(x)</span></tt> and <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">t)</span></tt>, as we must remember that the appropriate
<span class="math">\(x\)</span> coordinate is given as <tt class="docutils literal"><span class="pre">x[i-Ix[0]]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>It remains to update the solution at ghost points, i.e, <tt class="docutils literal"><span class="pre">u[0]</span></tt>
and <tt class="docutils literal"><span class="pre">u[-1]</span></tt> (or <tt class="docutils literal"><span class="pre">u[Nx+2]</span></tt>). For a boundary condition <span class="math">\(u_x=0\)</span>,
the ghost value must equal the value at the associated inner mesh
point. Computer code makes this statement precise:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># x=0 boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>         <span class="c"># x=L boundary</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <tt class="docutils literal"><span class="pre">u[1:-1]</span></tt>, or
equivalently <tt class="docutils literal"><span class="pre">u[Ix[0]:Ix[-1]+1]</span></tt>, so this slice is
the quantity to be returned from a solver function.
A complete implementation appears in the program
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0_ghost.py">wave1D_n0_ghost.py</a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>We have to be careful with how the spatial and temporal mesh
points are stored. Say we let <tt class="docutils literal"><span class="pre">x</span></tt> be the physical mesh points,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8220;Standard coding&#8221; of the initial condition,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>becomes wrong, since <tt class="docutils literal"><span class="pre">u_1</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> have different lengths and the index <tt class="docutils literal"><span class="pre">i</span></tt>
corresponds to two different mesh points. In fact, <tt class="docutils literal"><span class="pre">x[i]</span></tt> corresponds
to <tt class="docutils literal"><span class="pre">u[1+i]</span></tt>. A correct implementation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>Similarly, a source term usually coded as <tt class="docutils literal"><span class="pre">f(x[i],</span> <span class="pre">t[n])</span></tt> is incorrect
if <tt class="docutils literal"><span class="pre">x</span></tt> is defined to be the physical points, so <tt class="docutils literal"><span class="pre">x[i]</span></tt> must be
replaced by <tt class="docutils literal"><span class="pre">x[i-Ix[0]]</span></tt>.</p>
<p class="last">An alternative remedy is to let <tt class="docutils literal"><span class="pre">x</span></tt> also cover the ghost points such that
<tt class="docutils literal"><span class="pre">u[i]</span></tt> is the value at <tt class="docutils literal"><span class="pre">x[i]</span></tt>.</p>
</div>
<p>The ghost cell is only added to the boundary where we have a Neumann
condition. Suppose we have a Dirichlet condition at <span class="math">\(x=L\)</span> and
a homogeneous Neumann condition at <span class="math">\(x=0\)</span>. One ghost cell <span class="math">\([-\Delta x,0]\)</span>
is added to the mesh, so the index set for the physical points
becomes <span class="math">\(\{1,\ldots,N_x+1\}\)</span>. A relevant implementation
is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0</span>       <span class="c"># set Dirichlet value</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># update ghost value</span>
</pre></div>
</div>
<p>The physical solution to be plotted is now in <tt class="docutils literal"><span class="pre">u[1:]</span></tt>
or (as always) <tt class="docutils literal"><span class="pre">u[Ix[0]:Ix[-1]+1]</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="generalization-variable-wave-velocity">
<span id="wave-pde2-var-c"></span><h1>Generalization: variable wave velocity<a class="headerlink" href="#generalization-variable-wave-velocity" title="Permalink to this headline">¶</a></h1>
<p>Our next generalization of the 1D wave equation <a class="reference internal" href="._main_wave001.html#eq-wave-pde1"><em>(1)</em></a> or
<a class="reference internal" href="._main_wave001.html#eq-wave-pde2"><em>(17)</em></a> is to allow for a variable wave velocity <span class="math">\(c\)</span>:
<span class="math">\(c=c(x)\)</span>, usually motivated by wave motion in a domain composed of
different physical media. When the media differ in physical properties
like density or porosity, the wave velocity <span class="math">\(c\)</span> is affected and
will depend on the position in space.
Figure <a class="reference internal" href="#wave-pde1-fig-pulse1-two-media"><em>Left: wave entering another medium; right: transmitted and reflected wave</em></a> shows a wave
propagating in one medium <span class="math">\([0, 0.7]\cup [0.9,1]\)</span> with wave
velocity <span class="math">\(c_1\)</span> (left) before it enters a second medium <span class="math">\((0.7,0.9)\)</span>
with wave velocity <span class="math">\(c_2\)</span> (right). When the wave passes the boundary
where <span class="math">\(c\)</span> jumps from <span class="math">\(c_1\)</span> to <span class="math">\(c_2\)</span>, a part of the wave is reflected back
into the first medium (the <em>reflected</em> wave), while one part is
transmitted through the second medium (the <em>transmitted</em> wave).</p>
<div class="figure" id="wave-pde1-fig-pulse1-two-media">
<a class="reference internal image-reference" href="_images/pulse1_in_two_media.png"><img alt="_images/pulse1_in_two_media.png" src="_images/pulse1_in_two_media.png" style="width: 800px;" /></a>
<p class="caption"><em>Left: wave entering another medium; right: transmitted and reflected wave</em></p>
</div>
<div class="section" id="the-model-pde-with-a-variable-coefficient">
<h2>The model PDE with a variable coefficient<a class="headerlink" href="#the-model-pde-with-a-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Instead of working with the squared quantity <span class="math">\(c^2(x)\)</span>, we
shall for notational convenience introduce <span class="math">\(q(x) = c^2(x)\)</span>.
A 1D wave equation with variable wave velocity often takes the form</p>
<div class="math" id="eq-wave-pde2-var-c-pde">
\[\tag{42}
\frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right) + f(x,t)\]\[    {\thinspace .}\]</div>
<p>This is the most frequent form of a wave
equation with variable wave velocity,
but other forms also appear, see the section <a class="reference internal" href="._main_wave007.html#wave-app-string"><em>Waves on a string</em></a>
and equation <a class="reference internal" href="._main_wave007.html#eq-wave-app-string-model2"><em>(125)</em></a>.</p>
<p>As usual, we sample <a class="reference internal" href="#eq-wave-pde2-var-c-pde"><em>(42)</em></a> at a mesh point,</p>
<div class="math">
\[\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),\]</div>
<p>where the only new term to discretize is</p>
<div class="math">
\[\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) = \left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
{\thinspace .}\]</div>
</div>
<div class="section" id="discretizing-the-variable-coefficient">
<span id="wave-pde2-var-c-ideas"></span><h2>Discretizing the variable coefficient<a class="headerlink" href="#discretizing-the-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>The principal idea is to first discretize the outer derivative.
Define</p>
<div class="math">
\[\phi = q(x)
\frac{\partial u}{\partial x},\]</div>
<p>and use a centered derivative around <span class="math">\(x=x_i\)</span> for the derivative of <span class="math">\(\phi\)</span>:</p>
<div class="math">
\[\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\frac{1}{2}} - \phi_{i-\frac{1}{2}}}{\Delta x}
= [D_x\phi]^n_i
{\thinspace .}\]</div>
<p>Then discretize</p>
<div class="math">
\[\phi_{i+\frac{1}{2}}  = q_{i+\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\frac{1}{2}}
\approx q_{i+\frac{1}{2}} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\frac{1}{2}}^n
{\thinspace .}\]</div>
<p>Similarly,</p>
<div class="math">
\[\phi_{i-\frac{1}{2}}  = q_{i-\frac{1}{2}}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\frac{1}{2}}
\approx q_{i-\frac{1}{2}} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\frac{1}{2}}^n
{\thinspace .}\]</div>
<p>These intermediate results are now combined to</p>
<div class="math" id="eq-wave-pde2-var-c-formula">
\[\tag{43}
\left[
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right)\right]^n_i
    \approx \frac{1}{\Delta x^2}
    \left( q_{i+\frac{1}{2}} \left({u^n_{i+1} - u^n_{i}}\right)
    - q_{i-\frac{1}{2}} \left({u^n_{i} - u^n_{i-1}}\right)\right)\]\[    {\thinspace .}\]</div>
<p>With operator notation we can write the discretization as</p>
<div class="math" id="eq-wave-pde2-var-c-formula-op">
\[\tag{44}
\left[
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right)\right]^n_i
    \approx [D_xq D_x u]^n_i\]\[    {\thinspace .}\]</div>
<div class="admonition-do-not-use-the-chain-rule-on-the-spatial-derivative-term admonition">
<p class="first admonition-title">Do not use the chain rule on the spatial derivative term</p>
<p>Many are tempted to use the chain rule on the
term <span class="math">\(\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\)</span>, but this is not a good idea
when discretizing such a term.</p>
<p>The term with a variable coefficient expresses the net flux
<span class="math">\(qu_x\)</span> into a small volume (i.e., interval in 1D):</p>
<div class="math">
\[\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) \approx
\frac{1}{\Delta x}(q(x+\Delta x)u_x(x+\Delta x) - q(x)u_x(x)){\thinspace .}\]</div>
<p>Our discretization reflects this
principle directly: <span class="math">\(qu_x\)</span> at the right end of the cell minus <span class="math">\(qu_x\)</span>
at the left end, because this follows from the formula
<a class="reference internal" href="#eq-wave-pde2-var-c-formula"><em>(43)</em></a> or <span class="math">\([D_x(q D_x u)]^n_i\)</span>.</p>
<p class="last">When using the chain rule, we get two
terms <span class="math">\(qu_{xx} + q_xu_x\)</span>. The typical discretization is</p>
</div>
<div class="math" id="eq-wave-pde2-var-c-chainrule-scheme">
\[ \tag{45}
 D_x q D_x u + D_{2x}q D_{2x} u]_i^n,\]\[\begin{split}Writing this out shows that it is different from
 \( [D_x(q D_x u)]^n_i \)  and lacks the physical interpretation of
net flux into a cell. With a smooth and slowly varying  \( q(x) \)  the
differences between the two discretizations are not substantial.
However, when  \( q \)  exhibits (potentially large) jumps,
 \( [D_x(q D_x u)]^n_i \)  with harmonic averaging of  \( q \)  yields
a better solution than arithmetic averaging or
:ref:`(45) &lt;Eq:wave:pde2:var:c:chainrule_scheme&gt;`.
In the literature, the discretization  \( [D_x(q D_x u)]^n_i \)  totally
dominates and very few mention the possibility of
:ref:`(45) &lt;Eq:wave:pde2:var:c:chainrule_scheme&gt;`.\end{split}\]</div>
</div>
<div class="section" id="computing-the-coefficient-between-mesh-points">
<span id="wave-pde2-var-c-means"></span><h2>Computing the coefficient between mesh points<a class="headerlink" href="#computing-the-coefficient-between-mesh-points" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(q\)</span> is a known function of <span class="math">\(x\)</span>, we can easily evaluate
<span class="math">\(q_{i+\frac{1}{2}}\)</span> simply as <span class="math">\(q(x_{i+\frac{1}{2}})\)</span> with
<span class="math">\(x_{i+\frac{1}{2}} = x_i + \frac{1}{2}\Delta x\)</span>.
However, in many cases <span class="math">\(c\)</span>, and hence <span class="math">\(q\)</span>,
is only known as a discrete function, often at the mesh points <span class="math">\(x_i\)</span>.
Evaluating <span class="math">\(q\)</span> between two mesh points <span class="math">\(x_i\)</span> and <span class="math">\(x_{i+1}\)</span> can then
be done by averaging in three ways:</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><div class="math" id="eq-wave-pde2-var-c-mean-arithmetic">
<span id="index-13"></span>\[\tag{46}
q_{i+\frac{1}{2}} \approx
    \frac{1}{2}\left( q_{i} + q_{i+1}\right) =
    [\overline{q}^{x}]_i
    \quad \hbox{(arithmetic mean)}\]</div>
<div class="math" id="eq-wave-pde2-var-c-mean-harmonic">
\[\tag{47}
q_{i+\frac{1}{2}} \approx
    2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1}
    \quad \hbox{(harmonic mean)}\]</div>
<div class="math" id="eq-wave-pde2-var-c-mean-geometric">
\[\tag{48}
q_{i+\frac{1}{2}} \approx
    \left(q_{i}q_{i+1}\right)^{1/2}
    \quad \hbox{(geometric mean)}\]</div>
<p>The arithmetic mean in <a class="reference internal" href="#eq-wave-pde2-var-c-mean-arithmetic"><em>(46)</em></a> is by
far the most commonly used averaging technique and is well suited
for smooth <span class="math">\(q(x)\)</span> functions.
The harmonic mean is often preferred when <span class="math">\(q(x)\)</span> exhibits large
jumps (which is typical for geological media).
The geometric mean is less used, but popular in
discretizations to linearize quadratic
nonlinearities.</p>
<p>With the operator notation from <a class="reference internal" href="#eq-wave-pde2-var-c-mean-arithmetic"><em>(46)</em></a>
we can specify the discretization of the complete variable-coefficient
wave equation in a compact way:</p>
<div class="math" id="eq-wave-pde2-var-c-scheme-op">
\[\tag{49}
\lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
    {\thinspace .}\]</div>
<p>From this notation we immediately see what kind of differences that
each term is approximated with. The notation <span class="math">\(\overline{q}^{x}\)</span>
also specifies that the variable coefficient is approximated by
an arithmetic mean, the definition being
<span class="math">\([\overline{q}^{x}]_{i+\frac{1}{2}}=(q_i+q_{i+1})/2\)</span>.
With the notation <span class="math">\([D_xq D_x u]^n_i\)</span>,
we specify that <span class="math">\(q\)</span> is evaluated directly, as a function,
between the mesh points:
<span class="math">\(q(x_{i-\frac{1}{2}})\)</span> and <span class="math">\(q(x_{i+\frac{1}{2}})\)</span>.</p>
<p>Before any implementation, it remains to solve
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-op"><em>(49)</em></a> with respect to <span class="math">\(u_i^{n+1}\)</span>:</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
\frac{1}{2}(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\frac{1}{2}(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl">
\[\tag{50}
\quad \Delta t^2 f^n_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="how-a-variable-coefficient-affects-the-stability">
<span id="wave-pde2-var-c-stability"></span><h2>How a variable coefficient affects the stability<a class="headerlink" href="#how-a-variable-coefficient-affects-the-stability" title="Permalink to this headline">¶</a></h2>
<p>The stability criterion derived in the section <a class="reference internal" href="._main_wave004.html#wave-pde1-stability"><em>Stability</em></a>
reads <span class="math">\(\Delta t\leq \Delta x/c\)</span>. If <span class="math">\(c=c(x)\)</span>, the criterion will depend
on the spatial location. We must therefore choose a <span class="math">\(\Delta t\)</span> that
is small enough such that no mesh cell has <span class="math">\(\Delta x/c(x) &gt;\Delta t\)</span>.
That is, we must use the largest <span class="math">\(c\)</span> value in the criterion:</p>
<div class="math" id="eq-auto14">
\[\tag{51}
\Delta t \leq \beta \frac{\Delta x}{\max_{x\in [0,L]}c(x)}
    {\thinspace .}\]</div>
<p>The parameter <span class="math">\(\beta\)</span> is included as a safety factor: in some problems with a
significantly varying <span class="math">\(c\)</span> it turns out that one must choose <span class="math">\(\beta &lt;1\)</span> to
have stable solutions (<span class="math">\(\beta =0.9\)</span> may act as an all-round value).</p>
<p>A different strategy to handle the stability criterion with variable
wave velocity is to use a spatially varying <span class="math">\(\Delta t\)</span>. While the idea
is mathematically attractive at first sight, the implementation quickly
becomes very complicated, so we stick to using a constant <span class="math">\(\Delta t\)</span>
and a worst case value of <span class="math">\(c(x)\)</span> (with a safety factor <span class="math">\(\beta\)</span>).</p>
</div>
<div class="section" id="neumann-condition-and-a-variable-coefficient">
<span id="wave-pde2-var-c-neumann"></span><h2>Neumann condition and a variable coefficient<a class="headerlink" href="#neumann-condition-and-a-variable-coefficient" title="Permalink to this headline">¶</a></h2>
<p>Consider a Neumann condition <span class="math">\(\partial u/\partial x=0\)</span> at <span class="math">\(x=L=N_x\Delta x\)</span>,
discretized as</p>
<div class="math">
\[[D_{2x} u]^n_i =
\frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad\Rightarrow\quad
u_{i+1}^n = u_{i-1}^n,\]</div>
<p>for <span class="math">\(i=N_x\)</span>. Using the scheme <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl"><em>(50)</em></a>
at the end point <span class="math">\(i=N_x\)</span> with <span class="math">\(u_{i+1}^n=u_{i-1}^n\)</span> results in</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math" id="eq-auto15">
\[\tag{52}
\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
    q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
    q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
    + \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann0">
\[\tag{53}
= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    (q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}})(u_{i-1}^n - u_{i}^n) +
    \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann">
\[\tag{54}
\approx - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
    {\thinspace .}\]</div>
<p>Here we used the approximation</p>
<div class="math">
\[q_{i+\frac{1}{2}} + q_{i-\frac{1}{2}} =
q_i + \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots
+\nonumber\]</div>
<div class="math">
\[\quad q_i - \left(\frac{dq}{dx}\right)_i \Delta x
+ \left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + \cdots\nonumber\]</div>
<div class="math">
\[= 2q_i + 2\left(\frac{d^2q}{dx^2}\right)_i \Delta x^2 + {\cal O}(\Delta x^4)
\nonumber\]</div>
<div class="math" id="eq-auto16">
\[\tag{55}
\approx 2q_i
    {\thinspace .}\]</div>
<p>An alternative derivation may apply the arithmetic mean of <span class="math">\(q\)</span> in
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann0"><em>(53)</em></a>, leading to the term</p>
<div class="math">
\[(q_i + \frac{1}{2}(q_{i+1}+q_{i-1}))(u_{i-1}^n-u_i^n){\thinspace .}\]</div>
<p>Since <span class="math">\(\frac{1}{2}(q_{i+1}+q_{i-1}) = q_i + {\cal O}(\Delta x^2)\)</span>,
we can approximate with <span class="math">\(2q_i(u_{i-1}^n-u_i^n)\)</span> for <span class="math">\(i=N_x\)</span> and
get the same term as we did above.</p>
<p>A common technique when implementing <span class="math">\(\partial u/\partial x=0\)</span>
boundary conditions, is to assume <span class="math">\(dq/dx=0\)</span> as well. This implies
<span class="math">\(q_{i+1}=q_{i-1}\)</span> and <span class="math">\(q_{i+1/2}=q_{i-1/2}\)</span> for <span class="math">\(i=N_x\)</span>.
The implications for the scheme are</p>
<div class="math">
\[u^{n+1}_i = - u_i^{n-1}  + 2u_i^n + \nonumber\]</div>
<div class="math">
\[\quad \left(\frac{\Delta t}{\Delta x}\right)^2 \left(
q_{i+\frac{1}{2}}(u_{i-1}^n - u_{i}^n) -
q_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\]</div>
<div class="math" id="eq-auto17">
\[\tag{56}
\quad \Delta t^2 f^n_i\]</div>
<div class="math" id="eq-wave-pde2-var-c-scheme-impl-neumann2">
\[\tag{57}
= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
    2q_{i-\frac{1}{2}}(u_{i-1}^n - u_{i}^n) +
    \Delta t^2 f^n_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="implementation-of-variable-coefficients">
<span id="wave-pde2-var-c-impl"></span><h2>Implementation of variable coefficients<a class="headerlink" href="#implementation-of-variable-coefficients" title="Permalink to this headline">¶</a></h2>
<p>The implementation of the scheme with a variable wave velocity <span class="math">\(q(x)=c^2(x)\)</span>
may assume that <span class="math">\(q\)</span> is available as an array <tt class="docutils literal"><span class="pre">q[i]</span></tt> at
the spatial mesh points. The following loop is a straightforward
implementation of the scheme <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl"><em>(50)</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
           <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
               <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
           <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>The coefficient <tt class="docutils literal"><span class="pre">C2</span></tt> is now defined as <tt class="docutils literal"><span class="pre">(dt/dx)**2</span></tt>, i.e., <em>not</em> as the
squared Courant number, since the wave velocity is variable and appears
inside the parenthesis.</p>
<p>With Neumann conditions <span class="math">\(u_x=0\)</span> at the
boundary, we need to combine this scheme with the discrete
version of the boundary condition, as shown in the section <a class="reference internal" href="#wave-pde2-var-c-neumann"><em>Neumann condition and a variable coefficient</em></a>.
Nevertheless, it would be convenient to reuse the formula for the
interior points and just modify the indices <tt class="docutils literal"><span class="pre">ip1=i+1</span></tt> and <tt class="docutils literal"><span class="pre">im1=i-1</span></tt>
as we did in the section <a class="reference internal" href="#wave-pde2-neumann-impl"><em>Implementation of Neumann conditions</em></a>. Assuming
<span class="math">\(dq/dx=0\)</span> at the boundaries, we can implement the scheme at
the boundary with the following code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">ip1</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
       <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">ip1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">im1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">]))</span> <span class="o">+</span> \
       <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>With ghost cells we can just reuse the formula for the interior
points also at the boundary, provided that the ghost values of both
<span class="math">\(u\)</span> and <span class="math">\(q\)</span> are correctly updated to ensure <span class="math">\(u_x=0\)</span> and <span class="math">\(q_x=0\)</span>.</p>
<p>A vectorized version of the scheme with a variable coefficient
at internal mesh points becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">C2</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
              <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span> \
          <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="a-more-general-pde-model-with-variable-coefficients">
<h2>A more general PDE model with variable coefficients<a class="headerlink" href="#a-more-general-pde-model-with-variable-coefficients" title="Permalink to this headline">¶</a></h2>
<p>Sometimes a wave PDE has a variable coefficient in front of
the time-derivative term:</p>
<div class="math" id="eq-wave-pde2-var-c-pde2">
\[\tag{58}
\varrho(x)\frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x)
    \frac{\partial u}{\partial x}\right) + f(x,t)\]\[    {\thinspace .}\]</div>
<p>One example appears when modeling elastic waves in a rod
with varying density, cf.&nbsp;(<a class="reference internal" href="._main_wave007.html#wave-app-string"><em>Waves on a string</em></a>) with <span class="math">\(\varrho (x)\)</span>.</p>
<p>A natural scheme for <a class="reference internal" href="#eq-wave-pde2-var-c-pde2"><em>(58)</em></a> is</p>
<div class="math" id="eq-auto18">
\[\tag{59}
[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
    {\thinspace .}\]</div>
<p>We realize that the <span class="math">\(\varrho\)</span> coefficient poses no particular
difficulty, since <span class="math">\(\varrho\)</span> enters the formula just as a simple factor
in front of a derivative. There is hence no need for any averaging
of <span class="math">\(\varrho\)</span>. Often, <span class="math">\(\varrho\)</span> will be moved to the right-hand side,
also without any difficulty:</p>
<div class="math" id="eq-auto19">
\[\tag{60}
[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="generalization-damping">
<h2>Generalization: damping<a class="headerlink" href="#generalization-damping" title="Permalink to this headline">¶</a></h2>
<p>Waves die out by two mechanisms. In 2D and 3D the energy of the wave
spreads out in space, and energy conservation then requires
the amplitude to decrease. This effect is not present in 1D.
Damping is another cause of amplitude reduction. For example,
the vibrations of a string die out because of damping due to
air resistance and non-elastic effects in the string.</p>
<p>The simplest way of including damping is to add a first-order derivative
to the equation (in the same way as friction forces enter a vibrating
mechanical system):</p>
<div class="math" id="eq-wave-pde3">
\[\tag{61}
\frac{\partial^2 u}{\partial t^2} + b\frac{\partial u}{\partial t} =
    c^2\frac{\partial^2 u}{\partial x^2}
     + f(x,t),\]</div>
<p>where <span class="math">\(b \geq 0\)</span> is a prescribed damping coefficient.</p>
<p>A typical discretization of <a class="reference internal" href="#eq-wave-pde3"><em>(61)</em></a> in terms of centered
differences reads</p>
<div class="math" id="eq-wave-pde3-fd">
\[\tag{62}
[D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
    {\thinspace .}\]</div>
<p>Writing out the equation and solving for the unknown <span class="math">\(u^{n+1}_i\)</span>
gives the scheme</p>
<div class="math" id="eq-wave-pde3-fd2">
\[\tag{63}
u^{n+1}_i = (1 + {\frac{1}{2}}b\Delta t)^{-1}(({\frac{1}{2}}b\Delta t -1)
    u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \Delta t^2 f^n_i),\]</div>
<p>for <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span> and <span class="math">\(n\geq 1\)</span>.
New equations must be derived for <span class="math">\(u^1_i\)</span>, and for boundary points in case
of Neumann conditions.</p>
<p>The damping is very small in many wave phenomena and thus only evident
for very long time simulations. This makes the standard wave equation
without damping relevant for a lot of applications.</p>
</div>
</div>
<div class="section" id="building-a-general-1d-wave-equation-solver">
<span id="wave-pde2-software"></span><h1>Building a general 1D wave equation solver<a class="headerlink" href="#building-a-general-1d-wave-equation-solver" title="Permalink to this headline">¶</a></h1>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
is a fairly general code for 1D wave propagation problems that
targets the following initial-boundary value problem</p>
<div class="math" id="eq-wave-pde2-software-ueq">
\[\tag{64}
u_{tt} = (c^2(x)u_x)_x + f(x,t),\quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-auto20">
\[\tag{65}
u(x,0) = I(x),\quad x\in [0,L]\]</div>
<div class="math" id="eq-auto21">
\[\tag{66}
u_t(x,0) = V(t),\quad x\in [0,L]\]</div>
<div class="math" id="eq-auto22">
\[\tag{67}
u(0,t) = U_0(t)\hbox{ or } u_x(0,t)=0,\quad t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-software-bcl">
\[\tag{68}
u(L,t) = U_L(t)\hbox{ or } u_x(L,t)=0,\quad t\in (0,T]\]</div>
<p>The only new feature here is the time-dependent Dirichlet conditions.
These are trivial to implement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># x=0</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># x=L</span>
<span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_L</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function is a natural extension of the simplest
<tt class="docutils literal"><span class="pre">solver</span></tt> function in the initial <tt class="docutils literal"><span class="pre">wave1D_u0.py</span></tt> program,
extended with Neumann boundary conditions (<span class="math">\(u_x=0\)</span>),
time-varying Dirichlet conditions, as well as
a variable wave velocity. The different code segments needed
to make these extensions have been shown and commented upon in the
preceding text. We refer to the <tt class="docutils literal"><span class="pre">solver</span></tt> function in the
<tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> file for all the details. Note in that</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">solver</span></tt> function, however, that the technique of &#8220;hashing&#8221; is</div></blockquote>
<p>used to check whether a certain simulation has been run before, or not.</p>
<p>The vectorization is only applied inside the time loop, not for the
initial condition or the first time steps, since this initial work
is negligible for long time simulations in 1D problems.</p>
<p>The following sections explain various more advanced programming
techniques applied in the general 1D wave equation solver.</p>
<div class="section" id="user-action-function-as-a-class">
<h2>User action function as a class<a class="headerlink" href="#user-action-function-as-a-class" title="Permalink to this headline">¶</a></h2>
<p>A useful feature in the <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> program is the specification
of the <tt class="docutils literal"><span class="pre">user_action</span></tt> function as a class. This part of the program may
need some motivation and explanation. Although the <tt class="docutils literal"><span class="pre">plot_u_st</span></tt>
function (and the <tt class="docutils literal"><span class="pre">PlotMatplotlib</span></tt> class) in the <tt class="docutils literal"><span class="pre">wave1D_u0.viz</span></tt>
function remembers the local variables in the <tt class="docutils literal"><span class="pre">viz</span></tt> function, it is a
cleaner solution to store the needed variables together with the
function, which is exactly what a class offers.</p>
<div class="section" id="the-code">
<h3>The code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h3>
<p>A class for flexible plotting, cleaning up files, making movie
files, like the function <tt class="docutils literal"><span class="pre">wave1D_u0.viz</span></tt> did, can be coded as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">PlotAndStoreSolution</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for the user_action function in solver.</span>
<span class="sd">    Visualizes the solution only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">casename</span><span class="o">=</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span>    <span class="c"># Prefix in filenames</span>
        <span class="n">umin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>   <span class="c"># Fixed range of y axis</span>
        <span class="n">pause_between_frames</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="c"># Movie speed</span>
        <span class="n">backend</span><span class="o">=</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span>       <span class="c"># or &#39;gnuplot&#39; or None</span>
        <span class="n">screen_movie</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c"># Show movie on screen?</span>
        <span class="n">title</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span>          <span class="c"># Extra message in title</span>
        <span class="n">skip_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>      <span class="c"># Skip every skip_frame frame</span>
        <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>    <span class="c"># Name of file with solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casename</span> <span class="o">=</span> <span class="n">casename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="o">=</span> <span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="o">=</span> <span class="n">pause_between_frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Use native matplotlib</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;matplotlib&#39;</span><span class="p">,</span> <span class="s">&#39;gnuplot&#39;</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="s">&#39;scitools.easyviz.&#39;</span> <span class="o">+</span> <span class="n">backend</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&#39;import </span><span class="si">%s</span><span class="s"> as plt&#39;</span> <span class="o">%</span> <span class="n">module</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span> <span class="o">=</span> <span class="n">plt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span> <span class="o">=</span> <span class="n">screen_movie</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_frame</span> <span class="o">=</span> <span class="n">skip_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Store time points when u is written to file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filenames</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;*.dat.npz&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c"># Clean up old movie frames</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;frame_*.png&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback function user_action, call by solver:</span>
<span class="sd">        Store solution, plot on screen and save to file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Save solution u to a file using numpy.savez</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;u</span><span class="si">%04d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span>  <span class="c"># array name</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">u</span><span class="p">}</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#39;.dat&#39;</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>  <span class="c"># store corresponding time value</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>           <span class="c"># save x once</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;_x.dat&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># Animate</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_frame</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span> <span class="n">title</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># native matplotlib animation</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Update new solution</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;t=</span><span class="si">%.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># scitools.easyviz animation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span>
                          <span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
                          <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                          <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                          <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_movie</span><span class="p">)</span>
        <span class="c"># pause</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># let initial condition stay 2 s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pause</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pause</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">pause</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;frame_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="dissection">
<h3>Dissection<a class="headerlink" href="#dissection" title="Permalink to this headline">¶</a></h3>
<p>Understanding this class requires quite some familiarity with Python
in general and class programming in particular.
The class supports plotting with Matplotlib (<tt class="docutils literal"><span class="pre">backend=None</span></tt>) or
SciTools (<tt class="docutils literal"><span class="pre">backend=matplotlib</span></tt> or <tt class="docutils literal"><span class="pre">backend=gnuplot</span></tt>) for maximum
flexibility.</p>
<p>The constructor shows how we can flexibly import the plotting engine
as (typically) <tt class="docutils literal"><span class="pre">scitools.easyviz.gnuplot_</span></tt> or
<tt class="docutils literal"><span class="pre">scitools.easyviz.matplotlib_</span></tt> (note the trailing underscore - it is required).
With the <tt class="docutils literal"><span class="pre">screen_movie</span></tt> parameter
we can suppress displaying each movie frame on the screen.
Alternatively, for slow movies associated with
fine meshes, one can set
<tt class="docutils literal"><span class="pre">skip_frame=10</span></tt>, causing every 10 frames to be shown.</p>
<p>The <tt class="docutils literal"><span class="pre">__call__</span></tt> method makes <tt class="docutils literal"><span class="pre">PlotAndStoreSolution</span></tt> instances behave like
functions, so we can just pass an instance, say <tt class="docutils literal"><span class="pre">p</span></tt>, as the
<tt class="docutils literal"><span class="pre">user_action</span></tt> argument in the <tt class="docutils literal"><span class="pre">solver</span></tt> function, and any call to
<tt class="docutils literal"><span class="pre">user_action</span></tt> will be a call to <tt class="docutils literal"><span class="pre">p.__call__</span></tt>. The <tt class="docutils literal"><span class="pre">__call__</span></tt>
method plots the solution on the screen,
saves the plot to file, and stores the solution in a file for
later retrieval.</p>
<p>More details on storing the solution in files appear in
in
the document
<a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/softeng2">Scientific software engineering; wave equation case</a>
<a class="reference internal" href="._main_wave010.html#ref3" id="id1">[Ref3]</a>.</p>
</div>
</div>
<div class="section" id="pulse-propagation-in-two-media">
<h2>Pulse propagation in two media<a class="headerlink" href="#pulse-propagation-in-two-media" title="Permalink to this headline">¶</a></h2>
<p>The function <tt class="docutils literal"><span class="pre">pulse</span></tt> in <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> demonstrates wave motion in
heterogeneous media where <span class="math">\(c\)</span> varies. One can specify an interval
where the wave velocity is decreased by a factor <tt class="docutils literal"><span class="pre">slowness_factor</span></tt>
(or increased by making this factor less than one).
Figure <a class="reference internal" href="#wave-pde1-fig-pulse1-two-media"><em>Left: wave entering another medium; right: transmitted and reflected wave</em></a> shows a typical simulation
scenario.</p>
<p>Four types of initial conditions are available:</p>
<ol class="arabic simple">
<li>a rectangular pulse (<tt class="docutils literal"><span class="pre">plug</span></tt>),</li>
<li>a Gaussian function (<tt class="docutils literal"><span class="pre">gaussian</span></tt>),</li>
<li>a &#8220;cosine hat&#8221; consisting of one period of the cosine function
(<tt class="docutils literal"><span class="pre">cosinehat</span></tt>),</li>
<li>half a period of a &#8220;cosine hat&#8221; (<tt class="docutils literal"><span class="pre">half-cosinehat</span></tt>)</li>
</ol>
<p>These peak-shaped initial
conditions can be placed in the middle (<tt class="docutils literal"><span class="pre">loc='center'</span></tt>) or at
the left end (<tt class="docutils literal"><span class="pre">loc='left'</span></tt>) of the domain.
With the pulse in the middle, it splits in two parts, each with half the
initial amplitude, traveling in opposite directions. With the pulse
at the left end, centered at <span class="math">\(x=0\)</span>, and using the
symmetry condition <span class="math">\(\partial u/\partial x=0\)</span>, only a right-going pulse
is generated. There is also a left-going pulse, but it travels from <span class="math">\(x=0\)</span>
in negative <span class="math">\(x\)</span> direction and is not visible in the domain <span class="math">\([0,L]\)</span>.</p>
<p>The <tt class="docutils literal"><span class="pre">pulse</span></tt>
function is a flexible tool for playing around with various wave
shapes and location of a medium with a different wave velocity.</p>
<p>The code is shown to demonstrate how easy it is to reach this
flexibility with the building blocks we have already developed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>            <span class="c"># Maximum Courant number</span>
          <span class="n">Nx</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>         <span class="c"># spatial resolution</span>
          <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
          <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span>
          <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>            <span class="c"># end time</span>
          <span class="n">loc</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span>     <span class="c"># location of initial condition</span>
          <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span>  <span class="c"># pulse/init.cond. type</span>
          <span class="n">slowness_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="c"># inverse of wave vel. in right medium</span>
          <span class="n">medium</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="c"># interval for right medium</span>
          <span class="n">skip_frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>      <span class="c"># skip frames in animations</span>
          <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span>         <span class="c"># width measure of the pulse</span>
          <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Various peaked-shaped initial conditions on [0,1].</span>
<span class="sd">    Wave velocity is decreased by the slowness_factor inside</span>
<span class="sd">    medium. The loc parameter can be &#39;center&#39; or &#39;left&#39;,</span>
<span class="sd">    depending on where the initial pulse is to be located.</span>
<span class="sd">    The sigma parameter governs the width of the pulse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Use scaled parameters: L=1 for domain length, c_0=1</span>
    <span class="c"># for wave velocity outside the domain.</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">c_0</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;center&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pulse_tp</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;gaussian&#39;</span><span class="p">,</span><span class="s">&#39;Gaussian&#39;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;plug&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sigma</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># One period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">))</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">elif</span> <span class="n">pulse_tp</span> <span class="o">==</span> <span class="s">&#39;half-cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c"># Half a period of a cosine</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">sigma</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">)</span> \
                   <span class="k">if</span> <span class="n">xc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xc</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Wrong pulse_tp=&quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="n">pulse_tp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c_0</span><span class="o">/</span><span class="n">slowness_factor</span> \
               <span class="k">if</span> <span class="n">medium</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">medium</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">c_0</span>

    <span class="n">umin</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">umax</span><span class="o">=</span><span class="mf">1.5</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
    <span class="n">casename</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_Nx</span><span class="si">%s</span><span class="s">_sf</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="n">pulse_tp</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">slowness_factor</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">PlotMediumAndSolution</span><span class="p">(</span>
        <span class="n">medium</span><span class="p">,</span> <span class="n">casename</span><span class="o">=</span><span class="n">casename</span><span class="p">,</span> <span class="n">umin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span>
        <span class="n">skip_frame</span><span class="o">=</span><span class="n">skip_frame</span><span class="p">,</span> <span class="n">screen_movie</span><span class="o">=</span><span class="n">animate</span><span class="p">,</span>
        <span class="n">backend</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmpdata&#39;</span><span class="p">)</span>

    <span class="c"># Choose the stability limit with given Nx, worst case c</span>
    <span class="c"># (lower C will then use this dt, but smaller Nx)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">)</span><span class="o">/</span><span class="n">c_0</span>
    <span class="n">cpu</span><span class="p">,</span> <span class="n">hashed_input</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                               <span class="n">U_0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                               <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">user_action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span>
                               <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span>
                               <span class="n">stability_safety_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cpu</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># did we generate new data?</span>
        <span class="n">action</span><span class="o">.</span><span class="n">close_file</span><span class="p">(</span><span class="n">hashed_input</span><span class="p">)</span>
        <span class="n">action</span><span class="o">.</span><span class="n">make_movie_file</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;cpu (-1 means no new data generated):&#39;</span><span class="p">,</span> <span class="n">cpu</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">PlotMediumAndSolution</span></tt> class used here is a subclass of
<tt class="docutils literal"><span class="pre">PlotAndStoreSolution</span></tt> where the medium with reduced <span class="math">\(c\)</span> value,
as specified by the <tt class="docutils literal"><span class="pre">medium</span></tt> interval,
is visualized in the plots.</p>
<div class="admonition-comment-on-the-choices-of-discretization-parameters admonition">
<p class="first admonition-title">Comment on the choices of discretization parameters</p>
<p class="last">The argument <span class="math">\(N_x\)</span> in the <tt class="docutils literal"><span class="pre">pulse</span></tt> function does not correspond to
the actual spatial resolution of <span class="math">\(C&lt;1\)</span>, since the <tt class="docutils literal"><span class="pre">solver</span></tt>
function takes a fixed <span class="math">\(\Delta t\)</span> and <span class="math">\(C\)</span>, and adjusts <span class="math">\(\Delta x\)</span>
accordingly. As seen in the <tt class="docutils literal"><span class="pre">pulse</span></tt> function,
the specified <span class="math">\(\Delta t\)</span> is chosen according to the
limit <span class="math">\(C=1\)</span>, so if <span class="math">\(C&lt;1\)</span>, <span class="math">\(\Delta t\)</span> remains the same, but the
<tt class="docutils literal"><span class="pre">solver</span></tt> function operates with a larger <span class="math">\(\Delta x\)</span> and smaller
<span class="math">\(N_x\)</span> than was specified in the call to <tt class="docutils literal"><span class="pre">pulse</span></tt>. The practical reason
is that we always want to keep <span class="math">\(\Delta t\)</span> fixed such that
plot frames and movies are synchronized in time regardless of the
value of <span class="math">\(C\)</span> (i.e., <span class="math">\(\Delta x\)</span> is varied when the
Courant number varies).</p>
</div>
<p>The reader is encouraged to play around with the <tt class="docutils literal"><span class="pre">pulse</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">wave1D_dn_vc</span> <span class="kn">as</span> <span class="nn">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">pulse</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">pulse_tp</span><span class="o">=</span><span class="s">&#39;cosinehat&#39;</span><span class="p">,</span> <span class="n">slowness_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>To easily kill the graphics by Ctrl-C and restart a new simulation it might be
easier to run the above two statements from the command line
with</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;import wave1D_dn_vc as w; w.pulse(...)&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="exercises-2">
<h1>Exercises<a class="headerlink" href="#exercises-2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-6-find-the-analytical-solution-to-a-damped-wave-equation">
<span id="wave-exer-standingwave-damped-uex"></span><h2>Exercise 6: Find the analytical solution to a damped wave equation<a class="headerlink" href="#exercise-6-find-the-analytical-solution-to-a-damped-wave-equation" title="Permalink to this headline">¶</a></h2>
<p>Consider the wave equation with damping <a class="reference internal" href="#eq-wave-pde3"><em>(61)</em></a>.
The goal is to find an exact solution to a wave problem with damping and zero source term.
A starting point is the standing wave solution from
<a class="reference internal" href="._main_wave002.html#wave-exer-standingwave"><em>Exercise 1: Simulate a standing wave</em></a>. It becomes necessary to
include a damping term <span class="math">\(e^{-\beta t}\)</span> and also have both a sine and cosine
component in time:</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) =  e^{-\beta t}
\sin kx \left( A\cos\omega t
+ B\sin\omega t\right)
{\thinspace .}\]</div>
<p>Find <span class="math">\(k\)</span> from the boundary conditions
<span class="math">\(u(0,t)=u(L,t)=0\)</span>. Then use the PDE to find constraints on
<span class="math">\(\beta\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(A\)</span>, and <span class="math">\(B\)</span>.
Set up a complete initial-boundary value problem
and its solution.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">damped_waves</span></tt>.</p>
</div>
<div class="section" id="problem-7-explore-symmetry-boundary-conditions">
<span id="wave-exer-symmetry-bc"></span><h2>Problem 7: Explore symmetry boundary conditions<a class="headerlink" href="#problem-7-explore-symmetry-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>Consider the simple &#8220;plug&#8221; wave where <span class="math">\(\Omega = [-L,L]\)</span> and</p>
<div class="math">
\[\begin{split}I(x) = \left\lbrace\begin{array}{ll}
1, &amp; x\in [-\delta, \delta],\\
0, &amp; \hbox{otherwise}
\end{array}\right.\end{split}\]</div>
<p>for some number <span class="math">\(0 &lt; \delta &lt; L\)</span>. The other initial condition is
<span class="math">\(u_t(x,0)=0\)</span> and there is no source term <span class="math">\(f\)</span>.
The boundary conditions can be set to <span class="math">\(u=0\)</span>.
The solution to this problem is symmetric around <span class="math">\(x=0\)</span>.
This means that we can simulate the wave process in only the half
of the domain <span class="math">\([0,L]\)</span>.</p>
<p><strong>a)</strong>
Argue why the symmetry boundary condition
is <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>.</p>
<p><strong>Hint.</strong>
Symmetry of a function about <span class="math">\(x=x_0\)</span> means that
<span class="math">\(f(x_0+h) = f(x_0-h)\)</span>.</p>
<p><strong>b)</strong>
Perform simulations of the complete wave problem
on <span class="math">\([-L,L]\)</span>. Thereafter, utilize the
symmetry of the solution and run a simulation
in half of the domain <span class="math">\([0,L]\)</span>, using a boundary condition
at <span class="math">\(x=0\)</span>. Compare plots from the two solutions and
confirm that they are the same.</p>
<p><strong>c)</strong>
Prove the symmetry property of the solution
by setting up the complete initial-boundary value problem
and showing that if <span class="math">\(u(x,t)\)</span> is a solution, then also <span class="math">\(u(-x,t)\)</span>
is a solution.</p>
<p><strong>d)</strong>
If the code works correctly, the solution <span class="math">\(u(x,t) = x(L-x)(1+\frac{t}{2})\)</span>
should be reproduced exactly. Write a test function <tt class="docutils literal"><span class="pre">test_quadratic</span></tt> that
checks whether this is the case. Simulate for <span class="math">\(x\)</span> in <span class="math">\([0, \frac{L}{2}]\)</span> with
a symmetry condition at the end <span class="math">\(x = \frac{L}{2}\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_symmetric</span></tt>.</p>
</div>
<div class="section" id="exercise-8-send-pulse-waves-through-a-layered-medium">
<span id="wave-app-exer-pulse1d"></span><h2>Exercise 8: Send pulse waves through a layered medium<a class="headerlink" href="#exercise-8-send-pulse-waves-through-a-layered-medium" title="Permalink to this headline">¶</a></h2>
<p>Use the <tt class="docutils literal"><span class="pre">pulse</span></tt> function in <tt class="docutils literal"><span class="pre">wave1D_dn_vc.py</span></tt> to investigate
sending a pulse, located with its peak at <span class="math">\(x=0\)</span>, through two
media with different wave velocities. The (scaled) velocity in
the left medium is 1 while it is <span class="math">\(\frac{1}{s_f}\)</span> in the right medium.
Report what happens with a Gaussian pulse, a &#8220;cosine hat&#8221; pulse,
half a &#8220;cosine hat&#8221; pulse, and a plug pulse for resolutions
<span class="math">\(N_x=40,80,160\)</span>, and <span class="math">\(s_f=2,4\)</span>. Simulate until <span class="math">\(T=2\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">pulse1D</span></tt>.</p>
</div>
<div class="section" id="exercise-9-explain-why-numerical-noise-occurs">
<span id="wave-app-exer-pulse1d-analysis"></span><h2>Exercise 9: Explain why numerical noise occurs<a class="headerlink" href="#exercise-9-explain-why-numerical-noise-occurs" title="Permalink to this headline">¶</a></h2>
<p>The experiments performed in <a class="reference internal" href="#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a> shows
considerable numerical noise in the form of non-physical waves,
especially for <span class="math">\(s_f=4\)</span> and the plug pulse or the half a &#8220;cosinehat&#8221;
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a &#8220;cosinehat&#8221; pulses for <span class="math">\(s_f=1\)</span>, <span class="math">\(C=0.9,
0.25\)</span>, and <span class="math">\(N_x=40,80,160\)</span>. Use the numerical dispersion relation to
explain the observations.
Filename: <tt class="docutils literal"><span class="pre">pulse1D_analysis</span></tt>.</p>
</div>
<div class="section" id="exercise-10-investigate-harmonic-averaging-in-a-1d-model">
<span id="wave-app-exer-pulse1d-harmonic"></span><h2>Exercise 10: Investigate harmonic averaging in a 1D model<a class="headerlink" href="#exercise-10-investigate-harmonic-averaging-in-a-1d-model" title="Permalink to this headline">¶</a></h2>
<p>Harmonic means are often used if the wave velocity is non-smooth or
discontinuous.  Will harmonic averaging of the wave velocity give less
numerical noise for the case <span class="math">\(s_f=4\)</span> in <a class="reference internal" href="#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a>?
Filename: <tt class="docutils literal"><span class="pre">pulse1D_harmonic</span></tt>.</p>
</div>
<div class="section" id="problem-11-implement-open-boundary-conditions">
<span id="wave-app-exer-radiationbc"></span><h2>Problem 11: Implement open boundary conditions<a class="headerlink" href="#problem-11-implement-open-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-14"></span><span class="target" id="index-15"></span><p id="index-16">To enable a wave to leave the computational domain and travel
undisturbed through
the boundary <span class="math">\(x=L\)</span>, one can in a one-dimensional problem impose the
following condition, called a <em>radiation condition</em> or
<em>open boundary condition</em>:</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq">
\[\tag{69}
\frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0{\thinspace .}\]</div>
<p>The parameter <span class="math">\(c\)</span> is the wave velocity.</p>
<p>Show that <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><em>(69)</em></a> accepts
a solution <span class="math">\(u = g_R(x-ct)\)</span> (right-going wave),
but not <span class="math">\(u = g_L(x+ct)\)</span> (left-going wave). This means
that <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><em>(69)</em></a> will allow any
right-going wave <span class="math">\(g_R(x-ct)\)</span> to pass through the boundary undisturbed.</p>
<p>A corresponding open boundary condition for a left-going wave
through <span class="math">\(x=0\)</span> is</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eql">
\[\tag{70}
\frac{\partial u}{\partial t} - c\frac{\partial u}{\partial x} = 0{\thinspace .}\]</div>
<p><strong>a)</strong>
A natural idea for discretizing
the condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><em>(69)</em></a>
at the spatial end point <span class="math">\(i=N_x\)</span> is to apply
centered differences in time and space:</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op">
\[\tag{71}
[D_{2t}u + cD_{2x}u =0]^n_{i},\quad i=N_x{\thinspace .}\]</div>
<p>Eliminate the fictitious value <span class="math">\(u_{N_x+1}^n\)</span> by using
the discrete equation at the same point.</p>
<p>The equation for the first step, <span class="math">\(u_i^1\)</span>, is in principle also affected,
but we can then use the condition <span class="math">\(u_{N_x}=0\)</span> since the wave
has not yet reached the right boundary.</p>
<p><strong>b)</strong>
A much more convenient implementation of the open boundary condition
at <span class="math">\(x=L\)</span> can be based on an explicit discretization</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op-1storder">
\[\tag{72}
[D^+_tu + cD_x^- u = 0]_i^n,\quad i=N_x{\thinspace .}\]</div>
<p>From this equation, one can solve for <span class="math">\(u^{n+1}_{N_x}\)</span> and apply the
formula as a Dirichlet condition at the boundary point.
However, the finite difference approximations involved are of
first order.</p>
<p>Implement this scheme for a wave equation
<span class="math">\(u_{tt}=c^2u_{xx}\)</span> in a domain <span class="math">\([0,L]\)</span>,
where you have <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>, the condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><em>(69)</em></a>
at <span class="math">\(x=L\)</span>, and an initial disturbance in the middle
of the domain, e.g., a plug profile like</p>
<div class="math">
\[\begin{split}u(x,0) = \left\lbrace\begin{array}{ll} 1,&amp; L/2-\ell \leq x \leq  L/2+\ell,\\
0,\hbox{otherwise}\end{array}\right.\end{split}\]</div>
<p>Observe that the initial wave is split in two, the left-going wave
is reflected at <span class="math">\(x=0\)</span>, and both waves travel out of <span class="math">\(x=L\)</span>,
leaving the solution as <span class="math">\(u=0\)</span> in <span class="math">\([0,L]\)</span>. Use a unit Courant number
such that the numerical solution is exact.
Make a movie to illustrate what happens.</p>
<p>Because this simplified
implementation of the open boundary condition works, there is no
need to pursue the more complicated discretization in a).</p>
<p><strong>Hint.</strong>
Modify the solver function in
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>.</p>
<p><strong>c)</strong>
Add the possibility to have either <span class="math">\(u_x=0\)</span> or an open boundary
condition at the left boundary. The latter condition is discretized
as</p>
<div class="math" id="eq-wave-app-exer-radiationbc-eq-op-1storder2">
\[\tag{73}
[D^+_tu - cD_x^+ u = 0]_i^n,\quad i=0,\]</div>
<p>leading to an explicit update of the boundary value <span class="math">\(u^{n+1}_0\)</span>.</p>
<p>The implementation can be tested with a Gaussian function as initial condition:</p>
<div class="math">
\[g(x;m,s) = \frac{1}{\sqrt{2\pi}s}e^{-\frac{(x-m)^2}{2s^2}}{\thinspace .}\]</div>
<p>Run two tests:</p>
<ol class="arabic simple">
<li>Disturbance in the middle of the domain, <span class="math">\(I(x)=g(x;L/2,s)\)</span>, and
open boundary condition at the left end.</li>
<li>Disturbance at the left end, <span class="math">\(I(x)=g(x;0,s)\)</span>, and <span class="math">\(u_x=0\)</span>
as symmetry boundary condition at this end.</li>
</ol>
<p>Make test functions for both cases, testing that the solution is zero
after the waves have left the domain.</p>
<p><strong>d)</strong>
In 2D and 3D it is difficult to compute the correct wave velocity
normal to the boundary, which is needed in generalizations of
the open boundary conditions in higher dimensions. Test the effect
of having a slightly wrong wave velocity in
<a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq-op-1storder"><em>(72)</em></a>.
Make movies to illustrate what happens.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_open_BC</span></tt>.</p>
<div class="section" id="remarks-2">
<h3>Remarks<a class="headerlink" href="#remarks-2" title="Permalink to this headline">¶</a></h3>
<p>The condition <a class="reference internal" href="#eq-wave-app-exer-radiationbc-eq"><em>(69)</em></a>
works perfectly in 1D when <span class="math">\(c\)</span> is known. In 2D and 3D, however, the
condition reads <span class="math">\(u_t + c_x u_x + c_y u_y=0\)</span>, where <span class="math">\(c_x\)</span> and
<span class="math">\(c_y\)</span> are the wave speeds in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions. Estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.</p>
</div>
</div>
<div class="section" id="exercise-12-implement-periodic-boundary-conditions">
<span id="wave-exer-periodic"></span><h2>Exercise 12: Implement periodic boundary conditions<a class="headerlink" href="#exercise-12-implement-periodic-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-17"></span><p id="index-18">It is frequently of interest to follow wave motion over large
distances and long times. A straightforward approach is to
work with a very large domain, but that might lead to a lot of
computations in areas of the domain where the waves cannot
be noticed. A more efficient approach is to let a right-going
wave out of the domain and at the same time let it enter
the domain on the left. This is called a <em>periodic boundary
condition</em>.</p>
<p>The boundary condition at the right end <span class="math">\(x=L\)</span> is an open boundary
condition (see <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 11: Implement open boundary conditions</em></a>) to let a
right-going wave out of the domain.  At the left end, <span class="math">\(x=0\)</span>, we apply,
in the beginning of the simulation, either a symmetry boundary
condition (see <a class="reference internal" href="#wave-exer-symmetry-bc"><em>Problem 7: Explore symmetry boundary conditions</em></a>) <span class="math">\(u_x=0\)</span>, or an
open boundary condition.</p>
<p>This initial wave will split in two and either be reflected or
transported out of the domain at <span class="math">\(x=0\)</span>. The purpose of the exercise is
to follow the right-going wave. We can do that with a <em>periodic
boundary condition</em>.  This means that when the right-going wave hits
the boundary <span class="math">\(x=L\)</span>, the open boundary condition lets the wave out of
the domain, but at the same time we use a boundary condition on the
left end <span class="math">\(x=0\)</span> that feeds the outgoing wave into the domain
again. This periodic condition is simply <span class="math">\(u(0)=u(L)\)</span>. The switch from
<span class="math">\(u_x=0\)</span> or an open boundary condition at the left end to a periodic
condition can happen when <span class="math">\(u(L,t)&gt;\epsilon\)</span>, where <span class="math">\(\epsilon =10^{-4}\)</span>
might be an appropriate value for determining when the right-going
wave hits the boundary <span class="math">\(x=L\)</span>.</p>
<p>The open boundary conditions can conveniently be discretized as
explained in <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 11: Implement open boundary conditions</em></a>.  Implement the
described type of boundary conditions and test them on two different
initial shapes: a plug <span class="math">\(u(x,0)=1\)</span> for <span class="math">\(x\leq 0.1\)</span>, <span class="math">\(u(x,0)=0\)</span> for
<span class="math">\(x&gt;0.1\)</span>, and a Gaussian function in the middle of the domain:
<span class="math">\(u(x,0)=\exp{(-\frac{1}{2}(x-0.5)^2/0.05)}\)</span>. The domain is the unit
interval <span class="math">\([0,1]\)</span>. Run these two shapes for Courant numbers 1 and
0.5. Assume constant wave velocity.  Make movies of the four cases.
Reason why the solutions are correct.
Filename: <tt class="docutils literal"><span class="pre">periodic</span></tt>.</p>
</div>
<div class="section" id="exercise-13-compare-discretizations-of-a-neumann-condition">
<h2>Exercise 13: Compare discretizations of a Neumann condition<a class="headerlink" href="#exercise-13-compare-discretizations-of-a-neumann-condition" title="Permalink to this headline">¶</a></h2>
<p>We have a 1D wave equation with variable wave velocity:
<span class="math">\(u_{tt}=(qu_x)_x\)</span>.
A Neumann condition <span class="math">\(u_x\)</span> at <span class="math">\(x=0, L\)</span> can be
discretized as shown in <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann"><em>(54)</em></a>
and <a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann2"><em>(57)</em></a>.</p>
<p>The aim of this exercise is to examine the rate of the numerical
error when using different ways of discretizing the Neumann condition.</p>
<p><strong>a)</strong>
As a test problem, <span class="math">\(q=1+(x-L/2)^4\)</span> can be used, with <span class="math">\(f(x,t)\)</span>
adapted such that the solution has a simple form, say
<span class="math">\(u(x,t)=\cos (\pi x/L)\cos (\omega t)\)</span> for, e.g., <span class="math">\(\omega = 1\)</span>.
Perform numerical experiments and find the convergence rate of the
error using the approximation
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann"><em>(54)</em></a>.</p>
<p><strong>b)</strong>
Switch to <span class="math">\(q(x)=1+\cos(\pi x/L)\)</span>, which is symmetric at <span class="math">\(x=0,L\)</span>,
and check the convergence rate
of the scheme
<a class="reference internal" href="#eq-wave-pde2-var-c-scheme-impl-neumann2"><em>(57)</em></a>. Now,
<span class="math">\(q_{i-1/2}\)</span> is a 2nd-order approximation to <span class="math">\(q_i\)</span>,
<span class="math">\(q_{i-1/2}=q_i + 0.25q_i''\Delta x^2 + \cdots\)</span>, because <span class="math">\(q_i'=0\)</span>
for <span class="math">\(i=N_x\)</span> (a similar argument can be applied to the case <span class="math">\(i=0\)</span>).</p>
<p><strong>c)</strong>
A third discretization can be based on a simple and convenient,
but less accurate, one-sided difference:
<span class="math">\(u_{i}-u_{i-1}=0\)</span> at <span class="math">\(i=N_x\)</span> and <span class="math">\(u_{i+1}-u_i=0\)</span> at <span class="math">\(i=0\)</span>.
Derive the resulting scheme in detail and implement it.
Run experiments with <span class="math">\(q\)</span> from a) or b) to establish the rate of convergence
of the scheme.</p>
<p><strong>d)</strong>
A fourth technique is to view the scheme as</p>
<div class="math">
\[[D_tD_tu]^n_i = \frac{1}{\Delta x}\left(
[qD_xu]_{i+\frac{1}{2}}^n - [qD_xu]_{i-\frac{1}{2}}^n\right)
+ [f]_i^n,\]</div>
<p>and place the boundary at <span class="math">\(x_{i+\frac{1}{2}}\)</span>, <span class="math">\(i=N_x\)</span>, instead of
exactly at the physical boundary. With this idea of approximating (moving) the
boundary,
we can just set <span class="math">\([qD_xu]_{i+\frac{1}{2}}^n=0\)</span>.
Derive the complete scheme
using this technique. The implementation of the boundary condition at
<span class="math">\(L-\Delta x/2\)</span> is <span class="math">\({\mathcal{O}(\Delta x^2)}\)</span> accurate, but the interesting question
is what impact the movement of the boundary has on the convergence
rate. Compute the errors as usual over the entire mesh and use <span class="math">\(q\)</span> from
a) or b).</p>
<p>Filename: <tt class="docutils literal"><span class="pre">Neumann_discr</span></tt>.</p>
</div>
<div class="section" id="exercise-14-verification-by-a-cubic-polynomial-in-space">
<span id="wave-fd2-exer-verify-cubic"></span><h2>Exercise 14: Verification by a cubic polynomial in space<a class="headerlink" href="#exercise-14-verification-by-a-cubic-polynomial-in-space" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to verify the implementation of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function in the program <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_n0.py">wave1D_n0.py</a> by using an exact numerical solution
for the wave equation <span class="math">\(u_{tt}=c^2u_{xx} + f\)</span> with Neumann boundary
conditions <span class="math">\(u_x(0,t)=u_x(L,t)=0\)</span>.</p>
<p>A similar verification is used in the file <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>, which solves the same PDE, but with
Dirichlet boundary conditions <span class="math">\(u(0,t)=u(L,t)=0\)</span>.  The idea of the
verification test in function <tt class="docutils literal"><span class="pre">test_quadratic</span></tt> in <tt class="docutils literal"><span class="pre">wave1D_u0.py</span></tt> is to
produce a solution that is a lower-order polynomial such that both the
PDE problem, the boundary conditions, and all the discrete equations
are exactly fulfilled. Then the <tt class="docutils literal"><span class="pre">solver</span></tt> function should reproduce
this exact solution to machine precision.  More precisely, we seek
<span class="math">\(u=X(x)T(t)\)</span>, with <span class="math">\(T(t)\)</span> as a linear function and <span class="math">\(X(x)\)</span> as a
parabola that fulfills the boundary conditions.  Inserting this <span class="math">\(u\)</span> in
the PDE determines <span class="math">\(f\)</span>.  It turns out that <span class="math">\(u\)</span> also fulfills the
discrete equations, because the truncation error of the discretized
PDE has derivatives in <span class="math">\(x\)</span> and <span class="math">\(t\)</span> of order four and higher. These
derivatives all vanish for a quadratic <span class="math">\(X(x)\)</span> and linear <span class="math">\(T(t)\)</span>.</p>
<p>It would be attractive to use a similar approach in the case of
Neumann conditions. We set <span class="math">\(u=X(x)T(t)\)</span> and seek lower-order
polynomials <span class="math">\(X\)</span> and <span class="math">\(T\)</span>.
To force <span class="math">\(u_x\)</span> to vanish at the boundary, we let <span class="math">\(X_x\)</span> be
a parabola. Then <span class="math">\(X\)</span> is a cubic polynomial. The fourth-order
derivative of a cubic polynomial vanishes, so <span class="math">\(u=X(x)T(t)\)</span>
will fulfill the discretized PDE also in this case, if <span class="math">\(f\)</span>
is adjusted such that <span class="math">\(u\)</span> fulfills the PDE.</p>
<p>However, the discrete boundary condition is not exactly fulfilled
by this choice of <span class="math">\(u\)</span>. The reason is that</p>
<div class="math" id="eq-wave-fd2-exer-verify-cubic-d2x">
\[\tag{74}
[D_{2x}u]^n_i = u_{x}(x_i,t_n) + \frac{1}{6}u_{xxx}(x_i,t_n)\Delta x^2
    + {\mathcal{O}(\Delta x^4)}{\thinspace .}\]</div>
<p>At the boundary two boundary points, we must demand that
the derivative <span class="math">\(X_x(x)=0\)</span> such that <span class="math">\(u_x=0\)</span>.
However, <span class="math">\(u_{xxx}\)</span> is a constant and not zero
when <span class="math">\(X(x)\)</span> is a cubic polynomial.
Therefore, our <span class="math">\(u=X(x)T(t)\)</span> fulfills</p>
<div class="math">
\[[D_{2x}u]^n_i = \frac{1}{6}u_{xxx}(x_i,t_n)\Delta x^2,\]</div>
<p>and not</p>
<div class="math">
\[[D_{2x}u]^n_i =0, \quad i=0,N_x,\]</div>
<p>as it should. (Note that all the higher-order terms <span class="math">\({\mathcal{O}(\Delta x^4)}\)</span>
also have higher-order derivatives that vanish for a cubic polynomial.)
So to summarize, the fundamental problem is that <span class="math">\(u\)</span> as a product of
a cubic polynomial and a linear or quadratic polynomial in time
is not an exact solution of the discrete boundary conditions.</p>
<p>To make progress,
we assume that <span class="math">\(u=X(x)T(t)\)</span>, where <span class="math">\(T\)</span> for simplicity is taken as a
prescribed linear function <span class="math">\(1+\frac{1}{2}t\)</span>, and <span class="math">\(X(x)\)</span> is taken
as an <em>unknown</em> cubic polynomial <span class="math">\(\sum_{j=0}^3 a_jx^j\)</span>.
There are two different ways of determining the coefficients
<span class="math">\(a_0,\ldots,a_3\)</span> such that both the discretized PDE and the
discretized boundary conditions are fulfilled, under the
constraint that we can specify a function <span class="math">\(f(x,t)\)</span> for the PDE to feed
to the <tt class="docutils literal"><span class="pre">solver</span></tt> function in <tt class="docutils literal"><span class="pre">wave1D_n0.py</span></tt>. Both approaches
are explained in the subexercises.</p>
<p><strong>a)</strong>
One can insert <span class="math">\(u\)</span> in the discretized PDE and find the corresponding <span class="math">\(f\)</span>.
Then one can insert <span class="math">\(u\)</span> in the discretized boundary conditions.
This yields two equations for the four coefficients <span class="math">\(a_0,\ldots,a_3\)</span>.
To find the coefficients, one can set <span class="math">\(a_0=0\)</span> and <span class="math">\(a_1=1\)</span> for
simplicity and then determine <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span>. This approach will make
<span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span> depend on <span class="math">\(\Delta x\)</span> and <span class="math">\(f\)</span> will depend on both
<span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>.</p>
<p>Use <tt class="docutils literal"><span class="pre">sympy</span></tt> to perform analytical computations.
A starting point is to define <span class="math">\(u\)</span> as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_cubic1</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x t c L dx dt&#39;</span><span class="p">)</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;i n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># Assume discrete solution is a polynomial of degree 3 in x</span>
    <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>  <span class="c"># Temporal term</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a_0 a_1 a_2 a_3&#39;</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  <span class="c"># Spatial term</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The symbolic expression for <span class="math">\(u\)</span> is reached by calling <tt class="docutils literal"><span class="pre">u(x,t)</span></tt>
with <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt> as <tt class="docutils literal"><span class="pre">sympy</span></tt> symbols.</p>
<p>Define <tt class="docutils literal"><span class="pre">DxDx(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></tt>, <tt class="docutils literal"><span class="pre">DtDt(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></tt>, and <tt class="docutils literal"><span class="pre">D2x(u,</span> <span class="pre">i,</span> <span class="pre">n)</span></tt>
as Python functions for returning the difference
approximations <span class="math">\([D_xD_x u]^n_i\)</span>, <span class="math">\([D_tD_t u]^n_i\)</span>, and
<span class="math">\([D_{2x}u]^n_i\)</span>. The next step is to set up the residuals
for the equations <span class="math">\([D_{2x}u]^n_0=0\)</span> and <span class="math">\([D_{2x}u]^n_{N_x}=0\)</span>,
where <span class="math">\(N_x=L/\Delta x\)</span>. Call the residuals <tt class="docutils literal"><span class="pre">R_0</span></tt> and <tt class="docutils literal"><span class="pre">R_L</span></tt>.
Substitute <span class="math">\(a_0\)</span> and <span class="math">\(a_1\)</span> by 0 and 1, respectively, in
<tt class="docutils literal"><span class="pre">R_0</span></tt>, <tt class="docutils literal"><span class="pre">R_L</span></tt>, and <tt class="docutils literal"><span class="pre">a</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">R_0</span> <span class="o">=</span> <span class="n">R_0</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">R_L</span> <span class="o">=</span> <span class="n">R_L</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c"># enable in-place assignment</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Determining <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span> from the discretized boundary conditions
is then about solving two equations with respect to <span class="math">\(a_2\)</span> and <span class="math">\(a_3\)</span>,
i.e., <tt class="docutils literal"><span class="pre">a[2:]</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">R_0</span><span class="p">,</span> <span class="n">R_L</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="c"># s is dictionary with the unknowns a[2] and a[3] as keys</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>Now, <tt class="docutils literal"><span class="pre">a</span></tt> contains computed values and <tt class="docutils literal"><span class="pre">u</span></tt> will automatically use
these new values since <tt class="docutils literal"><span class="pre">X</span></tt> accesses <tt class="docutils literal"><span class="pre">a</span></tt>.</p>
<p>Compute the source term <span class="math">\(f\)</span> from the discretized PDE:
<span class="math">\(f^n_i = [D_tD_t u - c^2D_xD_x u]^n_i\)</span>. Turn <span class="math">\(u\)</span>, the time
derivative <span class="math">\(u_t\)</span> (needed for the initial condition <span class="math">\(V(x)\)</span>),
and <span class="math">\(f\)</span> into Python functions. Set numerical values for
<span class="math">\(L\)</span>, <span class="math">\(N_x\)</span>, <span class="math">\(C\)</span>, and <span class="math">\(c\)</span>. Prescribe the time interval as
<span class="math">\(\Delta t = CL/(N_xc)\)</span>, which imply <span class="math">\(\Delta x = c\Delta t/C = L/N_x\)</span>.
Define new functions <tt class="docutils literal"><span class="pre">I(x)</span></tt>, <tt class="docutils literal"><span class="pre">V(x)</span></tt>, and <tt class="docutils literal"><span class="pre">f(x,t)</span></tt> as wrappers of the ones
made above, where fixed values of <span class="math">\(L\)</span>, <span class="math">\(c\)</span>, <span class="math">\(\Delta x\)</span>, and <span class="math">\(\Delta t\)</span>
are inserted, such that <tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">V</span></tt>, and <tt class="docutils literal"><span class="pre">f</span></tt> can be passed on to the
<tt class="docutils literal"><span class="pre">solver</span></tt> function. Finally, call <tt class="docutils literal"><span class="pre">solver</span></tt> with a <tt class="docutils literal"><span class="pre">user_action</span></tt>
function that compares the numerical solution to this exact
solution <span class="math">\(u\)</span> of the discrete PDE problem.</p>
<p><strong>Hint.</strong>
To turn a <tt class="docutils literal"><span class="pre">sympy</span></tt> expression <tt class="docutils literal"><span class="pre">e</span></tt>, depending on a series of
symbols, say <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">t</span></tt>, <tt class="docutils literal"><span class="pre">dx</span></tt>, <tt class="docutils literal"><span class="pre">dt</span></tt>, <tt class="docutils literal"><span class="pre">L</span></tt>, and <tt class="docutils literal"><span class="pre">c</span></tt>, into a plain
Python function <tt class="docutils literal"><span class="pre">e_exact(x,t,L,dx,dt,c)</span></tt>, one can write</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">e_exact</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">'numpy'</span></tt> argument is a good habit as the <tt class="docutils literal"><span class="pre">e_exact</span></tt> function
will then work with array arguments if it contains mathematical
functions (but here we only do plain arithmetics, which automatically
work with arrays).</p>
<p><strong>b)</strong>
An alternative way of determining <span class="math">\(a_0,\ldots,a_3\)</span> is to reason as
follows. We first construct <span class="math">\(X(x)\)</span> such that the boundary conditions
are fulfilled: <span class="math">\(X=x(L-x)\)</span>. However, to compensate for the fact
that this choice of <span class="math">\(X\)</span> does not fulfill the discrete boundary
condition, we seek <span class="math">\(u\)</span> such that</p>
<div class="math">
\[u_x = \frac{\partial}{\partial x}x(L-x)T(t) - \frac{1}{6}u_{xxx}\Delta x^2,\]</div>
<p>since this <span class="math">\(u\)</span> will fit the discrete boundary condition.
Assuming <span class="math">\(u=T(t)\sum_{j=0}^3a_jx^j\)</span>, we can use the above equation to
determine the coefficients <span class="math">\(a_1,a_2,a_3\)</span>. A value, e.g., 1 can be used for
<span class="math">\(a_0\)</span>. The following <tt class="docutils literal"><span class="pre">sympy</span></tt> code computes this <span class="math">\(u\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_cubic2</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sm</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x t c L dx&#39;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span>  <span class="c"># Temporal term</span>
    <span class="c"># Set u as a 3rd-degree polynomial in space</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a_0 a_1 a_2 a_3&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c"># Force discrete boundary condition to be zero by adding</span>
    <span class="c"># a correction term the analytical suggestion x*(L-x)*T</span>
    <span class="c"># u_x = x*(L-x)*T(t) - 1/6*u_xxx*dx**2</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>
        <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sm</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">sm</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c"># R is a polynomial: force all coefficients to vanish.</span>
    <span class="c"># Turn R to Poly to extract coefficients:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c"># a[0] is not present in R</span>
    <span class="c"># s is dictionary with a[i] as keys</span>
    <span class="c"># Fix a[0] as 1</span>
    <span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">X</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sm</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;u:&#39;</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to find the source term <tt class="docutils literal"><span class="pre">f_e</span></tt> by inserting <tt class="docutils literal"><span class="pre">u_e</span></tt>
in the PDE. Thereafter, turn <tt class="docutils literal"><span class="pre">u</span></tt>, <tt class="docutils literal"><span class="pre">f</span></tt>, and the time derivative of <tt class="docutils literal"><span class="pre">u</span></tt>
into plain Python functions as in a), and then wrap these functions
in new functions <tt class="docutils literal"><span class="pre">I</span></tt>, <tt class="docutils literal"><span class="pre">V</span></tt>, and <tt class="docutils literal"><span class="pre">f</span></tt>, with the right signature as
required by the <tt class="docutils literal"><span class="pre">solver</span></tt> function. Set parameters as in a) and
check that the solution is exact to machine precision at each
time level using an appropriate <tt class="docutils literal"><span class="pre">user_action</span></tt> function.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_n0_test_cubic</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generalization: reflecting boundaries</a><ul>
<li><a class="reference internal" href="#neumann-boundary-condition">Neumann boundary condition</a></li>
<li><a class="reference internal" href="#discretization-of-derivatives-at-the-boundary">Discretization of derivatives at the boundary</a></li>
<li><a class="reference internal" href="#implementation-of-neumann-conditions">Implementation of Neumann conditions</a></li>
<li><a class="reference internal" href="#index-set-notation">Index set notation</a></li>
<li><a class="reference internal" href="#verifying-the-implementation-of-neumann-conditions">Verifying the implementation of Neumann conditions</a></li>
<li><a class="reference internal" href="#alternative-implementation-via-ghost-cells">Alternative implementation via ghost cells</a><ul>
<li><a class="reference internal" href="#idea">Idea</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#generalization-variable-wave-velocity">Generalization: variable wave velocity</a><ul>
<li><a class="reference internal" href="#the-model-pde-with-a-variable-coefficient">The model PDE with a variable coefficient</a></li>
<li><a class="reference internal" href="#discretizing-the-variable-coefficient">Discretizing the variable coefficient</a></li>
<li><a class="reference internal" href="#computing-the-coefficient-between-mesh-points">Computing the coefficient between mesh points</a></li>
<li><a class="reference internal" href="#how-a-variable-coefficient-affects-the-stability">How a variable coefficient affects the stability</a></li>
<li><a class="reference internal" href="#neumann-condition-and-a-variable-coefficient">Neumann condition and a variable coefficient</a></li>
<li><a class="reference internal" href="#implementation-of-variable-coefficients">Implementation of variable coefficients</a></li>
<li><a class="reference internal" href="#a-more-general-pde-model-with-variable-coefficients">A more general PDE model with variable coefficients</a></li>
<li><a class="reference internal" href="#generalization-damping">Generalization: damping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-a-general-1d-wave-equation-solver">Building a general 1D wave equation solver</a><ul>
<li><a class="reference internal" href="#user-action-function-as-a-class">User action function as a class</a><ul>
<li><a class="reference internal" href="#the-code">The code</a></li>
<li><a class="reference internal" href="#dissection">Dissection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pulse-propagation-in-two-media">Pulse propagation in two media</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-2">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-6-find-the-analytical-solution-to-a-damped-wave-equation">Exercise 6: Find the analytical solution to a damped wave equation</a></li>
<li><a class="reference internal" href="#problem-7-explore-symmetry-boundary-conditions">Problem 7: Explore symmetry boundary conditions</a></li>
<li><a class="reference internal" href="#exercise-8-send-pulse-waves-through-a-layered-medium">Exercise 8: Send pulse waves through a layered medium</a></li>
<li><a class="reference internal" href="#exercise-9-explain-why-numerical-noise-occurs">Exercise 9: Explain why numerical noise occurs</a></li>
<li><a class="reference internal" href="#exercise-10-investigate-harmonic-averaging-in-a-1d-model">Exercise 10: Investigate harmonic averaging in a 1D model</a></li>
<li><a class="reference internal" href="#problem-11-implement-open-boundary-conditions">Problem 11: Implement open boundary conditions</a><ul>
<li><a class="reference internal" href="#remarks-2">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-12-implement-periodic-boundary-conditions">Exercise 12: Implement periodic boundary conditions</a></li>
<li><a class="reference internal" href="#exercise-13-compare-discretizations-of-a-neumann-condition">Exercise 13: Compare discretizations of a Neumann condition</a></li>
<li><a class="reference internal" href="#exercise-14-verification-by-a-cubic-polynomial-in-space">Exercise 14: Verification by a cubic polynomial in space</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_wave002.html"
                        title="previous chapter">Implementation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_wave004.html"
                        title="next chapter">Analysis of the difference equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_wave003.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_wave004.html" title="Analysis of the difference equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;H. P. Langtangen.
  </div>
</div>

  </body>
</html>