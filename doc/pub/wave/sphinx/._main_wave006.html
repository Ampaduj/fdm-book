
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Finite difference methods for wave equations" href="index.html" />
    <link rel="next" title="Applications of wave equations" href="._main_wave007.html" />
    <link rel="prev" title="Finite difference methods for 2D and 3D wave equations" href="._main_wave005.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_wave007.html" title="Applications of wave equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_wave005.html" title="Finite difference methods for 2D and 3D wave equations"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implementation-3">
<span id="wave-2d3d-impl"></span><h1>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h1>
<p id="index-0">We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and <span class="math">\(u=0\)</span> on the
boundary. The wave equation is to be solved
in the space-time domain <span class="math">\(\Omega\times (0,T]\)</span>,
where <span class="math">\(\Omega = (0,L_x)\times (0,L_y)\)</span> is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by</p>
<div class="math" id="eq-auto61">
\[\tag{113}
u_{tt} = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],\]</div>
<div class="math" id="eq-auto62">
\[\tag{114}
u(x,y,0) = I(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto63">
\[\tag{115}
u_t(x,y,0) = V(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto64">
\[\tag{116}
u = 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],\]</div>
<p>where <span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>, in this case
the four sides of the rectangle <span class="math">\(\Omega = [0,L_x]\times [0,L_y]\)</span>:
<span class="math">\(x=0\)</span>, <span class="math">\(x=L_x\)</span>, <span class="math">\(y=0\)</span>, and <span class="math">\(y=L_y\)</span>.</p>
<p>The PDE is discretized as</p>
<div class="math">
\[[D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},\]</div>
<p>which leads to an explicit updating formula to be implemented in a
program:</p>
<div class="math">
\[u^{n+1}_{i,j} = -u^{n-1}_{i,j} + 2u^n_{i,j} + \nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-discrete">
\[\tag{117}
\quad C_x^2(
    u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
    (u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,\]</div>
<p>for all interior mesh points <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span> and
<span class="math">\(j\in{{\mathcal{I^i}_y}}\)</span>, for <span class="math">\(n\in{{\mathcal{I^+}_t}}\)</span>.
The constants <span class="math">\(C_x\)</span> and <span class="math">\(C_y\)</span> are defined as</p>
<div class="math">
\[C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
{\thinspace .}\]</div>
<p>At the boundary, we simply set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for
<span class="math">\(i=0\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>; <span class="math">\(i=N_x\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>;
<span class="math">\(j=0\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>; and <span class="math">\(j=N_y\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>.
For the first step, <span class="math">\(n=0\)</span>, <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><em>(117)</em></a>
is combined with the discretization of the initial condition <span class="math">\(u_t=V\)</span>,
<span class="math">\([D_{2t} u = V]^0_{i,j}\)</span> to obtain a special formula for
<span class="math">\(u^1_{i,j}\)</span> at the interior mesh points:</p>
<div class="math">
\[u^{1}_{i,j} = u^0_{i,j} + \Delta t V_{i,j} + \nonumber\]</div>
<div class="math">
\[\quad {\frac{1}{2}}C_x^2(
u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + {\frac{1}{2}}C_y^2
(u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) +\nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-n0-discrete">
\[\tag{118}
\quad \frac{1}{2}\Delta t^2f_{i,j}^n,\]</div>
<p>The algorithm is very similar to the one in 1D:</p>
<ol class="arabic simple">
<li>Set initial condition <span class="math">\(u^0_{i,j}=I(x_i,y_j)\)</span></li>
<li>Compute <span class="math">\(u^1_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><em>(117)</em></a></li>
<li>Set <span class="math">\(u^1_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
<li>For <span class="math">\(n=1,2,\ldots,N_t\)</span>:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Find <span class="math">\(u^{n+1}_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><em>(117)</em></a>
for all internal mesh points, <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span>, <span class="math">\(j\in{{\mathcal{I^i}_y}}\)</span></li>
<li>Set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
</ol>
</div></blockquote>
<div class="section" id="scalar-computations">
<span id="wave2d3d-impl-scalar"></span><h2>Scalar computations<a class="headerlink" href="#scalar-computations" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">solver</span></tt> function for a 2D case with constant wave velocity and
boundary condition <span class="math">\(u=0\)</span> is analogous to the 1D case with similar parameter
values (see <tt class="docutils literal"><span class="pre">wave1D_u0.py</span></tt>), apart from a few necessary
extensions. The code is found in the program
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>.</p>
<div class="section" id="domain-and-mesh">
<h3>Domain and mesh<a class="headerlink" href="#domain-and-mesh" title="Permalink to this headline">¶</a></h3>
<p>The spatial domain is now <span class="math">\([0,L_x]\times [0,L_y]\)</span>, specified
by the arguments <tt class="docutils literal"><span class="pre">Lx</span></tt> and <tt class="docutils literal"><span class="pre">Ly</span></tt>. Similarly, the number of mesh
points in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions,
<span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span>, become the arguments <tt class="docutils literal"><span class="pre">Nx</span></tt> and <tt class="docutils literal"><span class="pre">Ny</span></tt>.
In multi-dimensional problems it makes less sense to specify a
Courant number since the wave velocity is a vector and mesh spacings
may differ in the various spatial directions.
We therefore give <span class="math">\(\Delta t\)</span> explicitly. The signature of
the <tt class="docutils literal"><span class="pre">solver</span></tt> function is then</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>Key parameters used in the calculations are created as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c"># mesh points in x dir</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c"># mesh points in y dir</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                 <span class="c"># mesh points in time</span>
<span class="n">Cx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="c"># help variables</span>
<span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-arrays">
<h3>Solution arrays<a class="headerlink" href="#solution-arrays" title="Permalink to this headline">¶</a></h3>
<p>We store <span class="math">\(u^{n+1}_{i,j}\)</span>, <span class="math">\(u^{n}_{i,j}\)</span>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> in three two-dimensional arrays,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution array</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-dt</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c"># solution at t-2*dt</span>
</pre></div>
</div>
<p>where <span class="math">\(u^{n+1}_{i,j}\)</span> corresponds to <tt class="docutils literal"><span class="pre">u[i,j]</span></tt>,
<span class="math">\(u^{n}_{i,j}\)</span> to <tt class="docutils literal"><span class="pre">u_1[i,j]</span></tt>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> to <tt class="docutils literal"><span class="pre">u_2[i,j]</span></tt></p>
</div>
<div class="section" id="index-sets">
<span id="index-1"></span><h3>Index sets<a class="headerlink" href="#index-sets" title="Permalink to this headline">¶</a></h3>
<p>It is also convenient to introduce the index sets (cf. The section <a class="reference internal" href="._main_wave003.html#wave-indexset"><em>Index set notation</em></a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-the-solution">
<h3>Computing the solution<a class="headerlink" href="#computing-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Inserting the initial
condition <tt class="docutils literal"><span class="pre">I</span></tt> in <tt class="docutils literal"><span class="pre">u_1</span></tt> and making a callback to the user in terms of
the <tt class="docutils literal"><span class="pre">user_action</span></tt> function is a straightforward generalization of
the 1D code from the section <a class="reference internal" href="._main_wave001.html#wave-string-impl"><em>Sketch of an implementation</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

<span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">user_action</span></tt> function has additional arguments compared to the
1D case. The arguments <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt> will be commented
upon in the section <a class="reference internal" href="#wave2d3d-impl-vectorized"><em>Vectorized computations</em></a>.</p>
<p>The key finite difference formula <a class="reference internal" href="._main_wave005.html#eq-wave-2d3d-models-unp1"><em>(110)</em></a>
for updating the solution at
a time level is implemented in a separate function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                   <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="c"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">step1</span></tt> variable has been introduced to allow the formula to be
reused for first step <span class="math">\(u^1_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                   <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Below, we will make many alternative implementations of the
<tt class="docutils literal"><span class="pre">advance_scalar</span></tt> function to speed up the code since most of
the CPU time in simulations is spent in this function.</p>
<p>Finally, we remark that the <tt class="docutils literal"><span class="pre">solver</span></tt> function in the <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt> code
updates arrays for the next time step by switching references as
described in the section <a class="reference internal" href="._main_wave002.html#wave-pde1-impl-ref-switch"><em>Remark on the updating of arrays</em></a>. If the solution
<tt class="docutils literal"><span class="pre">u</span></tt> is returned from <tt class="docutils literal"><span class="pre">solver</span></tt>, which it is not, it is important to
set <tt class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">u_1</span></tt> after the time loop, otherwise <tt class="docutils literal"><span class="pre">u</span></tt> actually contains <tt class="docutils literal"><span class="pre">u_2</span></tt>.</p>
</div>
</div>
<div class="section" id="vectorized-computations">
<span id="wave2d3d-impl-vectorized"></span><h2>Vectorized computations<a class="headerlink" href="#vectorized-computations" title="Permalink to this headline">¶</a></h2>
<p>The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless in 3D beyond debugging of small test cases.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of <span class="math">\(30\times 30\)</span> cells, vectorization
brings down the CPU time by a factor of 70 (!). Equally important,
vectorized code can also easily be parallelized to take (usually)
optimal advantage of parallel computer platforms.</p>
<p>In the vectorized case, we must be able to evaluate user-given
functions like <span class="math">\(I(x,y)\)</span> and <span class="math">\(f(x,y,t)\)</span> for the entire mesh in one
operation (without loops). These user-given functions are provided as
Python functions <tt class="docutils literal"><span class="pre">I(x,y)</span></tt> and <tt class="docutils literal"><span class="pre">f(x,y,t)</span></tt>, respectively.  Having the
one-dimensional coordinate arrays <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> is not sufficient when
calling <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> in a vectorized way.  We must extend <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt>
to their vectorized versions <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">newaxis</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="c"># or</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>This is a standard required technique when evaluating functions over
a 2D mesh, say <tt class="docutils literal"><span class="pre">sin(xv)*cos(xv)</span></tt>, which then gives a result with shape
<tt class="docutils literal"><span class="pre">(Nx+1,Ny+1)</span></tt>. Calling <tt class="docutils literal"><span class="pre">I(xv,</span> <span class="pre">yv)</span></tt> and <tt class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></tt> will now
return <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">f</span></tt> values for the entire set of mesh points.</p>
<p>With the <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt> arrays for vectorized computing,
setting the initial condition is just a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u_1</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
<p>One could also have written <tt class="docutils literal"><span class="pre">u_1</span> <span class="pre">=</span> <span class="pre">I(xv,</span> <span class="pre">yv)</span></tt> and let <tt class="docutils literal"><span class="pre">u_1</span></tt> point to a
new object, but vectorized operations often make use of direct
insertion in the original array through <tt class="docutils literal"><span class="pre">u_1[:,:]</span></tt>, because sometimes
not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for
<span class="math">\(u^{n+1}_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">advance_vectorized</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">f_a</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                       <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f_a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing <span class="math">\(u^{n}_{i,j} - u^{n}_{i-1,j}\)</span> for <span class="math">\(i\in{{\mathcal{I^+}_x}}\)</span>,
we just keep <tt class="docutils literal"><span class="pre">j</span></tt> constant and make a slice in the first index:
<tt class="docutils literal"><span class="pre">u_1[1:,j]</span> <span class="pre">-</span> <span class="pre">u_1[:-1,j]</span></tt>, exactly as in 1D. The <tt class="docutils literal"><span class="pre">1:</span></tt> slice
specifies all the indices <span class="math">\(i=1,2,\ldots,N_x\)</span> (up to the last
valid index),
while <tt class="docutils literal"><span class="pre">:-1</span></tt> specifies the relevant indices for the second term:
<span class="math">\(0,1,\ldots,N_x-1\)</span> (up to, but not including the last index).</p>
<p>In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a <tt class="docutils literal"><span class="pre">1:-1</span></tt> slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.</p>
<p>The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[:,</span><span class="n">Ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span> <span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>In the vectorized update of <tt class="docutils literal"><span class="pre">u</span></tt> (above), the function <tt class="docutils literal"><span class="pre">f</span></tt> is first computed
as an array over all mesh points:</p>
<div class="highlight-text"><div class="highlight"><pre>f_a = f(xv, yv, t[n])
</pre></div>
</div>
<p>We could, alternatively, have used the call <tt class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])[1:-1,1:-1]</span></tt>
in the last term of the update statement, but other implementations
in compiled languages benefit from having <tt class="docutils literal"><span class="pre">f</span></tt> available in an array
rather than calling our Python function <tt class="docutils literal"><span class="pre">f(x,y,t)</span></tt> for
every point.</p>
<p>Also in the <tt class="docutils literal"><span class="pre">advance_vectorized</span></tt> function we have introduced a
boolean <tt class="docutils literal"><span class="pre">step1</span></tt> to reuse the formula for the first time step
in the same way as we did with <tt class="docutils literal"><span class="pre">advance_scalar</span></tt>.
We refer to the <tt class="docutils literal"><span class="pre">solver</span></tt> function in <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt>
for the details on how the overall algorithm is implemented.</p>
<p>The callback function now has the arguments
<tt class="docutils literal"><span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">xv,</span> <span class="pre">y,</span> <span class="pre">yv,</span> <span class="pre">t,</span> <span class="pre">n</span></tt>. The inclusion of <tt class="docutils literal"><span class="pre">xv</span></tt> and <tt class="docutils literal"><span class="pre">yv</span></tt> makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through an expression like
<tt class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_exact(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></tt>.</p>
</div>
<div class="section" id="verification-3">
<span id="wave2d3d-impl-verify"></span><h2>Verification<a class="headerlink" href="#verification-3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-a-quadratic-solution">
<h3>Testing a quadratic solution<a class="headerlink" href="#testing-a-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>The 1D solution from the section <a class="reference internal" href="._main_wave001.html#wave-pde2-fd-verify-quadratic"><em>Constructing an exact solution of the discrete equations</em></a> can be
generalized to multi-dimensions and provides a test case where the
exact solution also fulfills the discrete equations, such that we know
(to machine precision) what numbers the solver function should
produce. In 2D we use the following generalization of
<a class="reference internal" href="._main_wave001.html#eq-wave-pde2-fd-verify-quadratic-uex"><em>(30)</em></a>:</p>
<div class="math" id="eq-wave2d3d-impl-verify-quadratic">
\[\tag{119}
{u_{\small\mbox{e}}}(x,y,t) = x(L_x-x)y(L_y-y)(1+{\frac{1}{2}}t)
    {\thinspace .}\]</div>
<p>This solution fulfills the PDE problem if <span class="math">\(I(x,y)={u_{\small\mbox{e}}}(x,y,0)\)</span>,
<span class="math">\(V=\frac{1}{2}{u_{\small\mbox{e}}}(x,y,0)\)</span>, and <span class="math">\(f=2c^2(1+{\frac{1}{2}}t)(y(L_y-y) +
x(L_x-x))\)</span>. To show that <span class="math">\({u_{\small\mbox{e}}}\)</span> also solves the discrete equations,
we start with the general results <span class="math">\([D_t D_t 1]^n=0\)</span>, <span class="math">\([D_t D_t t]^n=0\)</span>,
and <span class="math">\([D_t D_t t^2]=2\)</span>, and use these to compute</p>
<div class="math">
\[\begin{split}[D_xD_x {u_{\small\mbox{e}}}]^n_{i,j} &amp;= [y(L_y-y)(1+{\frac{1}{2}}t) D_xD_x x(L_x-x)]^n_{i,j}\\
&amp;= y_j(L_y-y_j)(1+{\frac{1}{2}}t_n)(-2){\thinspace .}\end{split}\]</div>
<p>A similar calculation must be carried out for the <span class="math">\([D_yD_y
{u_{\small\mbox{e}}}]^n_{i,j}\)</span> and <span class="math">\([D_tD_t {u_{\small\mbox{e}}}]^n_{i,j}\)</span> terms.  One must also show
that the quadratic solution fits the special formula for
<span class="math">\(u^1_{i,j}\)</span>. The details are left as <a class="reference internal" href="#wave-exer-quadratic-2d"><em>Exercise 15: Check that a solution fulfills the discrete model</em></a>.
The <tt class="docutils literal"><span class="pre">test_quadratic</span></tt> function in the
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program implements this verification as a proper test function
for the pytest and nose frameworks.</p>
</div>
</div>
</div>
<div class="section" id="exercises-3">
<h1>Exercises<a class="headerlink" href="#exercises-3" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-15-check-that-a-solution-fulfills-the-discrete-model">
<span id="wave-exer-quadratic-2d"></span><h2>Exercise 15: Check that a solution fulfills the discrete model<a class="headerlink" href="#exercise-15-check-that-a-solution-fulfills-the-discrete-model" title="Permalink to this headline">¶</a></h2>
<p>Carry out all mathematical details to show that
<a class="reference internal" href="#eq-wave2d3d-impl-verify-quadratic"><em>(119)</em></a> is indeed a solution of the
discrete model for a 2D wave equation with <span class="math">\(u=0\)</span> on the boundary.
One must check the boundary conditions, the initial conditions,
the general discrete equation at a time level and the special
version of this equation for the first time level.
Filename: <tt class="docutils literal"><span class="pre">check_quadratic_solution</span></tt>.</p>
</div>
<div class="section" id="project-16-calculus-with-2d-mesh-functions">
<span id="wave-exer-mesh3d-calculus"></span><h2>Project 16: Calculus with 2D mesh functions<a class="headerlink" href="#project-16-calculus-with-2d-mesh-functions" title="Permalink to this headline">¶</a></h2>
<p>The goal of this project is to redo
<a class="reference internal" href="._main_wave002.html#wave-exer-mesh1d-calculus"><em>Project 5: Calculus with 1D mesh functions</em></a> with 2D
mesh functions (<span class="math">\(f_{i,j}\)</span>).</p>
<p><strong>Differentiation.</strong>
The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array <tt class="docutils literal"><span class="pre">df[d,i,j]</span></tt> where <tt class="docutils literal"><span class="pre">d</span></tt> represents the direction of
the derivative, and <tt class="docutils literal"><span class="pre">i,j</span></tt> is a mesh point in 2D.
Use centered differences for
the derivative at inner points and one-sided forward or backward
differences at the boundary points. Construct unit tests and
write a corresponding test function.</p>
<p><strong>Integration.</strong>
The integral of a 2D mesh function <span class="math">\(f_{i,j}\)</span> is defined as</p>
<div class="math">
\[F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,\]</div>
<p>where <span class="math">\(f(x,y)\)</span> is a function that takes on the values of the
discrete mesh function <span class="math">\(f_{i,j}\)</span> at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate <span class="math">\(f(x,y)\)</span> at the mesh points.</p>
<p>Suppose <span class="math">\(F_{i,j}\)</span> is computed. The calculation of <span class="math">\(F_{i+1,j}\)</span>
is then</p>
<div class="math">
\[\begin{split}F_{i+1,j} &amp;= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\
&amp; \approx \Delta x \frac{1}{2}\left(
\int_{y_0}^{y_j} f(x_{i},y)dy
+ \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)\end{split}\]</div>
<p>The integrals in the <span class="math">\(y\)</span> direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute <span class="math">\(F_{i,j+1}\)</span>. Thereafter,
<span class="math">\(F_{i+1,j+1}\)</span> can be computed by adding the integral over the final
corner cell to <span class="math">\(F_{i+1,j} + F_{i,j+1} - F_{i,j}\)</span>. Carry out the
details of these computations and implement a function that can
return <span class="math">\(F_{i,j}\)</span> for all mesh indices <span class="math">\(i\)</span> and <span class="math">\(j\)</span>. Use the
fact that the Trapezoidal rule is exact for linear functions and
write a test function.
Filename: <tt class="docutils literal"><span class="pre">mesh_calculus_2D</span></tt>.</p>
</div>
<div class="section" id="exercise-17-implement-neumann-conditions-in-2d">
<span id="wave-app-exer-wave2d-neumann"></span><h2>Exercise 17: Implement Neumann conditions in 2D<a class="headerlink" href="#exercise-17-implement-neumann-conditions-in-2d" title="Permalink to this headline">¶</a></h2>
<p>Modify the <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program, which solves the 2D wave equation <span class="math">\(u_{tt}=c^2(u_{xx}+u_{yy})\)</span>
with constant wave velocity <span class="math">\(c\)</span> and <span class="math">\(u=0\)</span> on the boundary, to have
Neumann boundary conditions: <span class="math">\(\partial u/\partial n=0\)</span>.
Include both scalar code (for debugging and reference) and
vectorized code (for speed).</p>
<p>To test the code, use <span class="math">\(u=1.2\)</span> as solution (<span class="math">\(I(x,y)=1.2\)</span>, <span class="math">\(V=f=0\)</span>, and
<span class="math">\(c\)</span> arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <tt class="docutils literal"><span class="pre">pulse</span></tt> function from the section <a class="reference internal" href="._main_wave003.html#wave-pde2-software"><em>Building a general 1D wave equation solver</em></a>
and the <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
program. This pulse
is exactly propagated in 1D if <span class="math">\(c\Delta t/\Delta x=1\)</span>. Check
that also the 2D program can propagate this pulse exactly
in <span class="math">\(x\)</span> direction (<span class="math">\(c\Delta t/\Delta x=1\)</span>, <span class="math">\(\Delta y\)</span> arbitrary)
and <span class="math">\(y\)</span> direction (<span class="math">\(c\Delta t/\Delta y=1\)</span>, <span class="math">\(\Delta x\)</span> arbitrary).
Filename: <tt class="docutils literal"><span class="pre">wave2D_dn</span></tt>.</p>
</div>
<div class="section" id="exercise-18-test-the-efficiency-of-compiled-loops-in-3d">
<span id="wave-exer-3d-f77-cy-efficiency"></span><h2>Exercise 18: Test the efficiency of compiled loops in 3D<a class="headerlink" href="#exercise-18-test-the-efficiency-of-compiled-loops-in-3d" title="Permalink to this headline">¶</a></h2>
<p>Extend the <tt class="docutils literal"><span class="pre">wave2D_u0.py</span></tt> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <tt class="docutils literal"><span class="pre">wave3D_u0</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation</a><ul>
<li><a class="reference internal" href="#scalar-computations">Scalar computations</a><ul>
<li><a class="reference internal" href="#domain-and-mesh">Domain and mesh</a></li>
<li><a class="reference internal" href="#solution-arrays">Solution arrays</a></li>
<li><a class="reference internal" href="#index-sets">Index sets</a></li>
<li><a class="reference internal" href="#computing-the-solution">Computing the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorized-computations">Vectorized computations</a></li>
<li><a class="reference internal" href="#verification-3">Verification</a><ul>
<li><a class="reference internal" href="#testing-a-quadratic-solution">Testing a quadratic solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-3">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-15-check-that-a-solution-fulfills-the-discrete-model">Exercise 15: Check that a solution fulfills the discrete model</a></li>
<li><a class="reference internal" href="#project-16-calculus-with-2d-mesh-functions">Project 16: Calculus with 2D mesh functions</a></li>
<li><a class="reference internal" href="#exercise-17-implement-neumann-conditions-in-2d">Exercise 17: Implement Neumann conditions in 2D</a></li>
<li><a class="reference internal" href="#exercise-18-test-the-efficiency-of-compiled-loops-in-3d">Exercise 18: Test the efficiency of compiled loops in 3D</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_wave005.html"
                        title="previous chapter">Finite difference methods for 2D and 3D wave equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_wave007.html"
                        title="next chapter">Applications of wave equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_wave006.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_wave007.html" title="Applications of wave equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_wave005.html" title="Finite difference methods for 2D and 3D wave equations"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;H. P. Langtangen.
  </div>
</div>

  </body>
</html>