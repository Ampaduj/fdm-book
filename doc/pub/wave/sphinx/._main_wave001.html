
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Simulation of waves on a string</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Finite difference methods for wave equations" href="index.html" />
    <link rel="next" title="Implementation" href="._main_wave002.html" />
    <link rel="prev" title="Finite difference methods for wave equations" href="._main_wave000.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_wave000.html" title="Finite difference methods for wave equations"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
<span class="math">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
<div class="section" id="simulation-of-waves-on-a-string">
<span id="wave-string"></span><h1>Simulation of waves on a string<a class="headerlink" href="#simulation-of-waves-on-a-string" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin.
Let the string in the deformed state
coincide with the interval
<span class="math">\([0,L]\)</span> on the <span class="math">\(x\)</span> axis, and let <span class="math">\(u(x,t)\)</span> be the displacement at
time <span class="math">\(t\)</span> in the <span class="math">\(y\)</span> direction of a point initially at <span class="math">\(x\)</span>.
The displacement function <span class="math">\(u\)</span> is governed by the mathematical model</p>
<div class="math" id="eq-wave-pde1">
\[\tag{1}
\frac{\partial^2 u}{\partial t^2} =
    c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-ic-u">
\[\tag{2}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-ic-ut">
\[\tag{3}
\frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-bc-0">
\[\tag{4}
u(0,t)  = 0, \quad  t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-bc-l">
\[\tag{5}
u(L,t)  = 0, \quad  t\in (0,T]\]</div>
<p>The constant <span class="math">\(c\)</span> and the function <span class="math">\(I(x)\)</span> must be prescribed.</p>
<p>Equation <a class="reference internal" href="#eq-wave-pde1"><em>(1)</em></a> is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>. The condition
<a class="reference internal" href="#eq-wave-pde1-ic-u"><em>(2)</em></a> specifies
the initial shape of the string, <span class="math">\(I(x)\)</span>, and
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><em>(3)</em></a> expresses that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, given here as
<a class="reference internal" href="#eq-wave-pde1-bc-0"><em>(4)</em></a> and <a class="reference internal" href="#eq-wave-pde1-bc-l"><em>(5)</em></a>. These two
conditions specify that
the string is fixed at the ends, i.e., that the displacement <span class="math">\(u\)</span> is zero.</p>
<p>The solution <span class="math">\(u(x,t)\)</span> varies in space and time and describes waves that
move with velocity <span class="math">\(c\)</span> to the left and right.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/guitar_C0.8/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-wave/guitar_C0.8/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Example of waves on a string.</em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<div class="math" id="eq-auto1">
\[\tag{6}
u_t = \frac{\partial u}{\partial t}, \quad
    u_{tt} = \frac{\partial^2 u}{\partial t^2},\]</div>
<p>and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p id="index-3">The PDE problem <a class="reference internal" href="#eq-wave-pde1"><em>(1)</em></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><em>(5)</em></a> will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<span id="wave-string-mesh"></span><span id="index-4"></span><h2>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h2>
<p id="index-5">The temporal domain <span class="math">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<div class="math" id="eq-auto2">
\[\begin{split}\tag{7}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T {\thinspace .}\end{split}\]</div>
<p>Similarly, the spatial domain <span class="math">\([0,L]\)</span> is replaced by a set of mesh points</p>
<div class="math" id="eq-auto3">
\[\begin{split}\tag{8}
0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L {\thinspace .}\end{split}\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math">\(x,t\)</span> plane, consisting
of points <span class="math">\((x_i, t_n)\)</span>, with <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h3>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h3>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>. We have that</p>
<div class="math" id="eq-auto4">
\[\tag{9}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
    t_n = n\Delta t,\ n=0,\ldots,N_t{\thinspace .}\]</div>
<p>We also have that <span class="math">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math">\(i=1,\ldots,N_x\)</span>, and
<span class="math">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math">\(n=1,\ldots,N_t\)</span>. Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></a>
displays a mesh in the <span class="math">\(x,t\)</span> plane with <span class="math">\(N_t=5\)</span>, <span class="math">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<span id="wave-string-numerical-sol"></span><h2>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-6"></span><p id="index-7">The solution <span class="math">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math">\((x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.</p>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<span id="wave-string-samplingpde"></span><h2>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-8"></span><p id="index-9">In the finite difference method, we relax
the condition that <a class="reference internal" href="#eq-wave-pde1"><em>(1)</em></a> holds at all points in
the space-time domain <span class="math">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points only:</p>
<div class="math" id="eq-wave-pde1-step2">
\[\tag{10}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
    c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=1,\ldots,N_t-1\)</span>. For <span class="math">\(n=0\)</span> we have
the initial conditions <span class="math">\(u=I(x)\)</span> and <span class="math">\(u_t=0\)</span>,
and at the boundaries <span class="math">\(i=0,N_x\)</span> we
have the boundary condition <span class="math">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<span id="wave-string-fd"></span><h2>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math">
\[[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>A similar approximation of the second-order derivative in the <span class="math">\(x\)</span>
direction reads</p>
<div class="math">
\[\frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
{\thinspace .}\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h3>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h3>
<p>We can now replace the derivatives in <a class="reference internal" href="#eq-wave-pde1-step2"><em>(10)</em></a>
and get</p>
<div class="math" id="eq-wave-pde1-step3b">
\[\tag{11}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
    c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},\]</div>
<p>or written more compactly using the operator notation:</p>
<div class="math" id="eq-wave-pde1-step3a">
\[\tag{12}
[D_tD_t u = c^2 D_xD_x]^{n}_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="interpretation-of-the-equation-as-a-stencil">
<h3>Interpretation of the equation as a stencil<a class="headerlink" href="#interpretation-of-the-equation-as-a-stencil" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">A characteristic feature of <a class="reference internal" href="#eq-wave-pde1-step3b"><em>(11)</em></a> is that it
involves <span class="math">\(u\)</span> values from neighboring points only: <span class="math">\(u_i^{n+1}\)</span>,
<span class="math">\(u^n_{i\pm 1}\)</span>, <span class="math">\(u^n_i\)</span>, and <span class="math">\(u^{n-1}_i\)</span>.  The circles in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></a> illustrate such neighboring mesh points that
contribute to an algebraic equation. In this particular case, we have
sampled the PDE at the point <span class="math">\((2,2)\)</span> and constructed
<a class="reference internal" href="#eq-wave-pde1-step3b"><em>(11)</em></a>, which then involves a coupling of <span class="math">\(u_1^2\)</span>,
<span class="math">\(u_2^3\)</span>, <span class="math">\(u_2^2\)</span>, <span class="math">\(u_2^1\)</span>, and <span class="math">\(u_3^2\)</span>.  The term <em>stencil</em> is often
used about the algebraic equation at a mesh point, and the geometry of
a typical stencil is illustrated in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></a>. One also often refers to the algebraic
equations as <em>discrete equations</em>, <em>(finite) difference equations</em> or
a <em>finite difference scheme</em>.</p>
<div class="figure" id="wave-pde1-fig-mesh">
<a class="reference internal image-reference" href="_images/stencil_n_interior.png"><img alt="_images/stencil_n_interior.png" src="_images/stencil_n_interior.png" style="width: 500px;" /></a>
<p class="caption"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></p>
</div>
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h3>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h3>
<p>We also need to replace the derivative in the initial condition
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><em>(3)</em></a> by a finite difference approximation.
A centered difference of the type</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i,t_0)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,\]</div>
<p>seems appropriate. Writing out this equation and ordering the terms give</p>
<div class="math" id="eq-wave-pde1-step3c">
\[\tag{13}
u^{-1}_i=u^{1}_i,\quad i=0,\ldots,N_x{\thinspace .}\]</div>
<p>The other initial condition can be computed by</p>
<div class="math">
\[u_i^0 = I(x_i),\quad i=0,\ldots,N_x{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<span id="wave-string-alg"></span><h2>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h2>
<p id="index-13">We assume that <span class="math">\(u^n_i\)</span> and <span class="math">\(u^{n-1}_i\)</span> are available for
<span class="math">\(i=0,\ldots,N_x\)</span>.  The only unknown quantity in
<a class="reference internal" href="#eq-wave-pde1-step3b"><em>(11)</em></a> is therefore <span class="math">\(u^{n+1}_i\)</span>, which we now can
solve for:</p>
<div class="math" id="eq-wave-pde1-step4">
\[\tag{14}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right){\thinspace .}\]</div>
<p>We have here introduced the parameter</p>
<div class="math" id="eq-auto5">
\[\tag{15}
C = c\frac{\Delta t}{\Delta x},\]</div>
<p>known as the <em>Courant number</em>.</p>
<div class="admonition-math-c-is-the-key-parameter-in-the-discrete-wave-equation admonition">
<p class="first admonition-title"><span class="math">\(C\)</span> is the key parameter in the discrete wave equation</p>
<p class="last">We see that the discrete version of the PDE features only one
parameter, <span class="math">\(C\)</span>, which is therefore the key parameter, together with
<span class="math">\(N_x\)</span>, that governs the quality of the numerical solution (see the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><em>Analysis of the difference equations</em></a> for details). Both the primary physical
parameter <span class="math">\(c\)</span> and the numerical parameters <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>
are lumped together in <span class="math">\(C\)</span>. Note that <span class="math">\(C\)</span> is a dimensionless
parameter.</p>
</div>
<p>Given that <span class="math">\(u^{n-1}_i\)</span> and <span class="math">\(u^n_i\)</span> are known for <span class="math">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
<a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a> for <span class="math">\(i=1,\ldots,N_x-1\)</span>. Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></a> illustrates the points that are used to
compute <span class="math">\(u^3_2\)</span>. For the boundary points, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math">\(u_i^{n+1}=0\)</span>.</p>
<p>Even though sound reasoning leads up to
<a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a>, there is still a minor challenge with it that needs
to be resolved. Think of the very first computational step to be made.
The scheme <a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a> is supposed to start at <span class="math">\(n=1\)</span>, which means
that we compute <span class="math">\(u^2\)</span> from <span class="math">\(u^1\)</span> and <span class="math">\(u^0\)</span>. Unfortunately, we do not know the
value of <span class="math">\(u^1\)</span>, so how to proceed? A standard procedure in such cases is to
apply <a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a> also for <span class="math">\(n=0\)</span>. This immediately seems strange,
since it involves <span class="math">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition <a class="reference internal" href="#eq-wave-pde1-step3c"><em>(13)</em></a> in combination with
<a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a> when <span class="math">\(n=0\)</span> to eliminate <span class="math">\(u^{-1}_i\)</span> and
arrive at a special formula for <span class="math">\(u_i^1\)</span>:</p>
<div class="math" id="eq-wave-pde1-step4-1">
\[\tag{16}
u_i^1 = u^0_i - \frac{1}{2}
    C^2\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right)
    {\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-stencil-u1"><em>Modified stencil for the first time step</em></a> illustrates how <a class="reference internal" href="#eq-wave-pde1-step4-1"><em>(16)</em></a>
connects four instead of five points: <span class="math">\(u^1_2\)</span>, <span class="math">\(u_1^0\)</span>, <span class="math">\(u_2^0\)</span>, and <span class="math">\(u_3^0\)</span>.</p>
<div class="figure" id="wave-pde1-fig-stencil-u1">
<a class="reference internal image-reference" href="_images/stencil_n0_interior.png"><img alt="_images/stencil_n0_interior.png" src="_images/stencil_n0_interior.png" style="width: 500px;" /></a>
<p class="caption"><em>Modified stencil for the first time step</em></p>
</div>
<p>We can now summarize the computational algorithm:</p>
<ol class="arabic simple">
<li>Compute <span class="math">\(u^0_i=I(x_i)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>Compute <span class="math">\(u^1_i\)</span> by <a class="reference internal" href="#eq-wave-pde1-step4-1"><em>(16)</em></a> for <span class="math">\(i=1,2,\ldots,N_x-1\)</span> and set <span class="math">\(u_i^1=0\)</span>
for the boundary points given by <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>,</li>
<li>For each time level <span class="math">\(n=1,2,\ldots,N_t-1\)</span></li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>apply <a class="reference internal" href="#eq-wave-pde1-step4"><em>(14)</em></a> to find <span class="math">\(u^{n+1}_i\)</span> for <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set <span class="math">\(u^{n+1}_i=0\)</span> for the boundary points having <span class="math">\(i=0\)</span>, <span class="math">\(i=N_x\)</span>.</li>
</ol>
</div></blockquote>
<p>The algorithm essentially consists of moving a finite difference
stencil through all the mesh points, which can be seen as an animation
in a <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/pub/wave/html/mov-wave/D_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/pub/wave/html/mov-wave/D_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<span id="wave-string-impl"></span><h2>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h2>
<p>The algorithm only involves the three most recent time levels, so we
need only three arrays for <span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u_i^n\)</span>, and <span class="math">\(u_i^{n-1}\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>.  Storing all the solutions in a two-dimensional
array of size <span class="math">\((N_x+1)\times (N_t+1)\)</span> would be possible in this simple
one-dimensional PDE problem, but is normally out of the question in
three-dimensional (3D) and large two-dimensional (2D) problems. We
shall therefore, in all our PDE solving programs, have the unknown in
memory at as few time levels as possible.</p>
<p>In a Python implementation of this algorithm, we use the array
elements <tt class="docutils literal"><span class="pre">u[i]</span></tt> to store <span class="math">\(u^{n+1}_i\)</span>, <tt class="docutils literal"><span class="pre">u_n[i]</span></tt> to store <span class="math">\(u^n_i\)</span>, and
<tt class="docutils literal"><span class="pre">u_nm1[i]</span></tt> to store <span class="math">\(u^{n-1}_i\)</span>.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given mesh points as arrays x and t (x[i], t[n])</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c"># Courant number</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c"># Help variable in the scheme</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
           <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Enforce boundary conditions</span>

<span class="c"># Switch variables before next step</span>
<span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_nm1</span><span class="p">[:],</span> <span class="n">u_n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<h1>Verification<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h1>
<p id="index-14">Before implementing the algorithm, it is convenient to add a source
term to the PDE <a class="reference internal" href="#eq-wave-pde1"><em>(1)</em></a>, since that gives us more freedom in
finding test problems for verification. Physically, a source term acts
as a generator for waves in the interior of the domain.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<span id="wave-pde2-fd"></span><h2>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h2>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<div class="math" id="eq-wave-pde2">
\[\tag{17}
u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-ic-u">
\[\tag{18}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-ic-ut">
\[\tag{19}
u_t(x,0) = V(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-bc-0">
\[\begin{split}\tag{20}
u(0,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<div class="math" id="eq-wave-pde2-bc-l">
\[\begin{split}\tag{21}
u(L,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<p>Sampling the PDE at <span class="math">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<div class="math" id="eq-wave-pde2-fdop">
\[\tag{22}
[D_tD_t u = c^2 D_xD_x u + f]^{n}_i
    {\thinspace .}\]</div>
<p>Writing this out and solving for the unknown <span class="math">\(u^{n+1}_i\)</span> results in</p>
<div class="math" id="eq-wave-pde2-step3b">
\[\tag{23}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i\]\[    {\thinspace .}\]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math">\(u_t = V(x)\)</span> at <span class="math">\(t=0\)</span>
becomes</p>
<div class="math">
\[[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,\]</div>
<p>which, when inserted in <a class="reference internal" href="#eq-wave-pde2-step3b"><em>(23)</em></a> for <span class="math">\(n=0\)</span>, gives
the special formula</p>
<div class="math" id="eq-wave-pde2-step3c">
\[\tag{24}
u^{1}_i = u^0_i - \Delta t V_i + {\frac{1}{2}}
    C^2
    \left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^0_i\]\[    {\thinspace .}\]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<span id="wave-pde2-fd-standing-waves"></span><h2>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h2>
<p id="index-15">Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
<a class="reference internal" href="#eq-wave-pde1"><em>(1)</em></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><em>(5)</em></a> allows an exact solution</p>
<div class="math" id="eq-wave-pde2-test-ue">
\[\tag{25}
{u_{\small\mbox{e}}}(x,t) = A\sin\left(\frac{\pi}{L}x\right)
    \cos\left(\frac{\pi}{L}ct\right){\thinspace .}\]</div>
<p>This <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the PDE with <span class="math">\(f=0\)</span>, boundary conditions
<span class="math">\({u_{\small\mbox{e}}}(0,t)={u_{\small\mbox{e}}}(L,0)=0\)</span>, as well as initial
conditions <span class="math">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math">\(V=0\)</span>.</p>
<div class="admonition-how-to-use-exact-solutions-for-verification admonition">
<p class="first admonition-title">How to use exact solutions for verification</p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math">\(u^n_i\)</span> will only be an approximation to <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.
We have no knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between <span class="math">\(u^n_i\)</span> and <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if plots of the computed solution <span class="math">\(u^n_i\)</span> and
the exact one <a class="reference internal" href="#eq-wave-pde2-test-ue"><em>(25)</em></a> look similar, many
are tempted to claim that the implementation works. However,
even if color plots look nice and the accuracy is &#8220;deemed good&#8221;,
there can still be serious programming errors present!</p>
<p class="last">The only way to use exact physical solutions like
<a class="reference internal" href="#eq-wave-pde2-test-ue"><em>(25)</em></a> for serious and thorough verification is to
run a series of simulations on finer and finer meshes, measure the
integrated error in each mesh, and from this information estimate the
empirical convergence rate of the method.</p>
</div>
<dl class="docutils">
<dt>An introduction to the computing of convergence rates is given in Section 3.1.6</dt>
<dd>in <a class="reference internal" href="._main_wave008.html#ref1" id="id1">[Ref1]</a>.</dd>
</dl>
<p>In the present problem, one expects the method to have a convergence rate
of 2 (see the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><em>Analysis of the difference equations</em></a>), so if the computed rates
are close to 2 on a sufficiently fine mesh, we have good evidence that
the implementation is free of programming mistakes.</p>
</div>
<div class="section" id="manufactured-solution-and-estimation-of-convergence-rates">
<span id="wave-pde2-fd-mms"></span><h2>Manufactured solution and estimation of convergence rates<a class="headerlink" href="#manufactured-solution-and-estimation-of-convergence-rates" title="Permalink to this headline">¶</a></h2>
<div class="section" id="specifying-the-solution-and-computing-corresponding-data">
<h3>Specifying the solution and computing corresponding data<a class="headerlink" href="#specifying-the-solution-and-computing-corresponding-data" title="Permalink to this headline">¶</a></h3>
<p id="index-16">One problem with the exact solution <a class="reference internal" href="#eq-wave-pde2-test-ue"><em>(25)</em></a> is
that it requires a simplification (<span class="math">\(V=0, f=0\)</span>) of the implemented problem
<a class="reference internal" href="#eq-wave-pde2"><em>(17)</em></a>-<a class="reference internal" href="#eq-wave-pde2-bc-l"><em>(21)</em></a>. An advantage of using
a <em>manufactured solution</em> is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) = x(L-x)\sin t{\thinspace .}\]</div>
<p>Inserted in the PDE <span class="math">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math">
\[-x(L-x)\sin t = -c^2 2\sin t + f\quad\Rightarrow f = (2c^2 - x(L-x))\sin t{\thinspace .}\]</div>
<p>The initial conditions become</p>
<div class="math">
\[\begin{split}u(x,0) =&amp; I(x) = 0,\\
u_t(x,0) &amp;= V(x) = x(L-x){\thinspace .}\end{split}\]</div>
</div>
<div class="section" id="defining-a-single-discretization-parameter">
<h3>Defining a single discretization parameter<a class="headerlink" href="#defining-a-single-discretization-parameter" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-17"></span><p id="index-18">To verify the code, we compute the convergence rates in a series of
simulations, letting each simulation use a finer mesh than the
previous one. Such empirical estimation of convergence rates relies on
an assumption that some measure <span class="math">\(E\)</span> of the numerical error is related
to the discretization parameters through</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^p,\]</div>
<p>where <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(p\)</span> are constants. The constants <span class="math">\(r\)</span> and
<span class="math">\(p\)</span> are known as the <em>convergence rates</em> in time and space,
respectively.  From the accuracy in the finite difference
approximations, we expect <span class="math">\(r=p=2\)</span>, since the error terms are of order
<span class="math">\(\Delta t^2\)</span> and <span class="math">\(\Delta x^2\)</span>.  This is confirmed by truncation error
analysis and other types of analysis.</p>
<p>By using an exact solution of the PDE problem, we will next compute
the error measure <span class="math">\(E\)</span> on a sequence of refined meshes and see if
the rates <span class="math">\(r=p=2\)</span> are obtained. We will not be concerned with estimating
the constants <span class="math">\(C_t\)</span> and <span class="math">\(C_x\)</span>, simply because we are not interested in
their values.</p>
<p>It is advantageous to introduce a single discretization parameter
<span class="math">\(h=\Delta t=\hat c \Delta x\)</span> for some constant <span class="math">\(\hat c\)</span>.  Since
<span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span> are related through the Courant number,
<span class="math">\(\Delta t = C\Delta x/c\)</span>, we set <span class="math">\(h=\Delta t\)</span>, and then <span class="math">\(\Delta x =
hc/C\)</span>.  Now the expression for the error measure is greatly
simplified:</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^r =
C_t h^r + C_x\left(\frac{c}{C}\right)^r h^r
= Dh^r,\quad D = C_t+C_x\left(\frac{c}{C}\right)^r {\thinspace .}\]</div>
</div>
<div class="section" id="computing-errors">
<h3>Computing errors<a class="headerlink" href="#computing-errors" title="Permalink to this headline">¶</a></h3>
<p>We choose an initial discretization parameter <span class="math">\(h_0\)</span> and run
experiments with decreasing <span class="math">\(h\)</span>: <span class="math">\(h_i=2^{-i}h_0\)</span>, <span class="math">\(i=1,2,\ldots,m\)</span>.
Halving <span class="math">\(h\)</span> in each experiment is not necessary, but it is a common
choice.  For each experiment we must record <span class="math">\(E\)</span> and <span class="math">\(h\)</span>.  Standard
choices of error measure are the <span class="math">\(\ell^2\)</span> and <span class="math">\(\ell^\infty\)</span> norms of the
error mesh function <span class="math">\(e^n_i\)</span>:</p>
<div class="math" id="eq-wave-pde2-fd-mms-e-l2">
\[\tag{26}
E = ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x
    \sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-wave-pde2-fd-mms-e-linf">
\[\tag{27}
E = ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^n_i|{\thinspace .}\]</div>
<p>In Python, one can compute <span class="math">\(\sum_{i}(e^{n}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <tt class="docutils literal"><span class="pre">e2_sum</span></tt>.  At the
final time step one can do <tt class="docutils literal"><span class="pre">sqrt(dt*dx*e2_sum)</span></tt>.  For the
<span class="math">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<tt class="docutils literal"><span class="pre">e.max()</span></tt>) with the global maximum over the time domain: <tt class="docutils literal"><span class="pre">e_max</span> <span class="pre">=</span>
<span class="pre">max(e_max,</span> <span class="pre">e.max())</span></tt>.</p>
<p>An alternative error measure is to use a spatial norm at one time step
only, e.g., the end time <span class="math">\(T\)</span> (<span class="math">\(n=N_t\)</span>):</p>
<div class="math" id="eq-auto6">
\[\tag{28}
E = ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto7">
\[\tag{29}
E = ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^{n}_i|{\thinspace .}\]</div>
<p>The important point is that the error measure (<span class="math">\(E\)</span>) for the simulation is represented by a single number.</p>
</div>
<div class="section" id="computing-rates">
<h3>Computing rates<a class="headerlink" href="#computing-rates" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math">\(i\)</span>
(not to be confused with the spatial index <span class="math">\(i\)</span>) and
let <span class="math">\(h_i\)</span> be the corresponding discretization parameter (<span class="math">\(h\)</span>).
With the error model <span class="math">\(E_i = Dh_i^r\)</span>, we can
estimate <span class="math">\(r\)</span> by comparing two consecutive
experiments:</p>
<div class="math">
\[\begin{split}E_{i+1}&amp; =D h_{i+1}^{r},\\
E_{i}&amp; =D h_{i}^{r}{\thinspace .}\end{split}\]</div>
<p>Dividing the two equations eliminates the (uninteresting) constant <span class="math">\(D\)</span>.
Thereafter, solving for <span class="math">\(r\)</span> yields</p>
<div class="math">
\[r = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}}{\thinspace .}\]</div>
<p>Since <span class="math">\(r\)</span> depends on <span class="math">\(i\)</span>, i.e., which simulations we compare,
we add an index to <span class="math">\(r\)</span>: <span class="math">\(r_i\)</span>, where <span class="math">\(i=0,\ldots,m-2\)</span>, if we
have <span class="math">\(m\)</span> experiments: <span class="math">\((h_0,E_0),\ldots,(h_{m-1}, E_{m-1})\)</span>.</p>
<p>In our present discretization of the wave equation we expect <span class="math">\(r=2\)</span>, and
hence the <span class="math">\(r_i\)</span> values should converge to 2 as <span class="math">\(i\)</span> increases.</p>
</div>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<span id="wave-pde2-fd-verify-quadratic"></span><h2>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h2>
<p>With a manufactured or known analytical solution, as outlined above,
we can estimate convergence rates and see if they have the correct
asymptotic behavior. Experience shows that this is a quite good
verification technique in that many common bugs will destroy the
convergence rates. A significantly better test though,
would be to check that the
numerical solution is exactly what it should be. This will in general
require exact knowledge of the numerical error, which we do not normally have
(although we in the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><em>Analysis of the difference equations</em></a> establish such knowledge
in simple cases).
However, it is possible to look for solutions where we can show that
the numerical error vanishes, i.e., the solution of the original continuous
PDE problem is
also a solution of the discrete equations. This property often arises
if the exact solution of the PDE
is a lower-order polynomial. (Truncation error
analysis leads to error measures that involve derivatives of the
exact solution. In the present problem, the truncation error involves
4th-order derivatives of <span class="math">\(u\)</span> in space and time. Choosing <span class="math">\(u\)</span>
as a polynomial of degree three or less
will therefore lead to vanishing error.)</p>
<p>We shall now illustrate the construction of an exact solution to both the
PDE itself and the discrete equations.
Our chosen manufactured solution is quadratic in space
and linear in time. More specifically, we set</p>
<div class="math" id="eq-wave-pde2-fd-verify-quadratic-uex">
\[\tag{30}
{u_{\small\mbox{e}}} (x,t) = x(L-x)(1+{\frac{1}{2}}t),\]</div>
<p>which by insertion in the PDE leads to <span class="math">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math">\({u_{\small\mbox{e}}}\)</span>
fulfills the boundary conditions <span class="math">\(u=0\)</span> and demands <span class="math">\(I(x)=x(L-x)\)</span>
and <span class="math">\(V(x)={\frac{1}{2}}x(L-x)\)</span>.</p>
<p>To realize that the chosen <span class="math">\({u_{\small\mbox{e}}}\)</span> is also an exact
solution of the discrete equations,
we first remind ourselves that <span class="math">\(t_n=n\Delta t\)</span> so that</p>
<div class="math" id="eq-auto8">
\[\tag{31}
\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
    = (n+1)^2 -2n^2 + (n-1)^2 = 2,\]</div>
<div class="math" id="eq-auto9">
\[\tag{32}
\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
    = \frac{((n+1) -2n + (n-1))\Delta t}{\Delta t^2} = 0
    {\thinspace .}\]</div>
<p>Hence,</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}}]^n_i = x_i(L-x_i)[D_tD_t (1+{\frac{1}{2}}t)]^n =
x_i(L-x_i){\frac{1}{2}}[D_tD_t t]^n = 0{\thinspace .}\]</div>
<p>Similarly, we get that</p>
<div class="math">
\[\begin{split}\lbrack D_xD_x {u_{\small\mbox{e}}}\rbrack^n_i &amp;=
(1+{\frac{1}{2}}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i\\
&amp; =
(1+{\frac{1}{2}}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\
&amp;= -2(1+{\frac{1}{2}}t_n)
{\thinspace .}\end{split}\]</div>
<p>Now, <span class="math">\(f^n_i = 2(1+{\frac{1}{2}}t_n)c^2\)</span>, which results in</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} - c^2D_xD_x{u_{\small\mbox{e}}} - f]^n_i = 0 +
c^2 2(1 + {\frac{1}{2}}t_{n}) +
2(1+{\frac{1}{2}}t_n)c^2 = 0{\thinspace .}\]</div>
<p>Moreover, <span class="math">\({u_{\small\mbox{e}}}(x_i,0)=I(x_i)\)</span>,
<span class="math">\(\partial {u_{\small\mbox{e}}}/\partial t = V(x_i)\)</span> at <span class="math">\(t=0\)</span>, and
<span class="math">\({u_{\small\mbox{e}}}(x_0,t)={u_{\small\mbox{e}}}(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+t/2)\)</span> of the PDE
problem is also an exact solution of the discrete problem.  This means
that we know beforehand what numbers the numerical algorithm should
produce.  We can use this fact to check that the computed <span class="math">\(u^n_i\)</span>
values from an implementation equals <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>, within machine
precision.  This result is valid <em>regardless of the mesh spacings</em>
<span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!  Nevertheless, there might be stability
restrictions on <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>, so the test can only be run
for a mesh that is compatible with the stability criterion (which in
the present case is <span class="math">\(C\leq 1\)</span>, to be derived later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
PDE problem and the discrete equations, and can therefore be very useful
solutions for verifying implementations.</p>
<p class="last">However, for 1D wave
equations of the type <span class="math">\(u_{tt}=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (which consists in just setting <span class="math">\(C=1\)</span> (!), as shown in
the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><em>Analysis of the difference equations</em></a>).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Simulation of waves on a string</a><ul>
<li><a class="reference internal" href="#discretizing-the-domain">Discretizing the domain</a><ul>
<li><a class="reference internal" href="#uniform-meshes">Uniform meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-discrete-solution">The discrete solution</a></li>
<li><a class="reference internal" href="#fulfilling-the-equation-at-the-mesh-points">Fulfilling the equation at the mesh points</a></li>
<li><a class="reference internal" href="#replacing-derivatives-by-finite-differences">Replacing derivatives by finite differences</a><ul>
<li><a class="reference internal" href="#algebraic-version-of-the-pde">Algebraic version of the PDE</a></li>
<li><a class="reference internal" href="#interpretation-of-the-equation-as-a-stencil">Interpretation of the equation as a stencil</a></li>
<li><a class="reference internal" href="#algebraic-version-of-the-initial-conditions">Algebraic version of the initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#formulating-a-recursive-algorithm">Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#sketch-of-an-implementation">Sketch of an implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification</a><ul>
<li><a class="reference internal" href="#a-slightly-generalized-model-problem">A slightly generalized model problem</a></li>
<li><a class="reference internal" href="#using-an-analytical-solution-of-physical-significance">Using an analytical solution of physical significance</a></li>
<li><a class="reference internal" href="#manufactured-solution-and-estimation-of-convergence-rates">Manufactured solution and estimation of convergence rates</a><ul>
<li><a class="reference internal" href="#specifying-the-solution-and-computing-corresponding-data">Specifying the solution and computing corresponding data</a></li>
<li><a class="reference internal" href="#defining-a-single-discretization-parameter">Defining a single discretization parameter</a></li>
<li><a class="reference internal" href="#computing-errors">Computing errors</a></li>
<li><a class="reference internal" href="#computing-rates">Computing rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constructing-an-exact-solution-of-the-discrete-equations">Constructing an exact solution of the discrete equations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_wave000.html"
                        title="previous chapter">Finite difference methods for wave equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_wave002.html"
                        title="next chapter">Implementation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_wave001.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_wave000.html" title="Finite difference methods for wave equations"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2017, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>