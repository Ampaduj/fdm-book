
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference discretization</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Finite difference methods for vibration problems" href="index.html" />
    <link rel="next" title="Generalization: damping, nonlinear spring, and external excitation" href="._main_vib002.html" />
    <link rel="prev" title="Finite difference methods for vibration problems" href="._main_vib000.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_vib002.html" title="Generalization: damping, nonlinear spring, and external excitation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_vib000.html" title="Finite difference methods for vibration problems"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the forthcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.</p>
<p>[<strong>hpl 1</strong>: Need to discuss errors also for the damped and nonlinear models. At least the frequency errors must be illustrated here as well and investigated numerically, either in text or exercises.]</p>
<div class="section" id="finite-difference-discretization">
<span id="vib-model1"></span><h1>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h1>
<p>Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
<span class="math">\(u^{\prime\prime} + u =0\)</span>. This ODE is thus chosen as our starting
point for method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h2>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">The simplest model of a vibrating mechanical system has the following form:</p>
<div class="math" id="eq-vib-ode1">
\[\tag{1}
u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
    {\thinspace .}\]</div>
<p>Here, <span class="math">\(\omega\)</span> and <span class="math">\(I\)</span> are given constants.
The section <a class="reference internal" href="._main_vib002.html#vib-app-mass-spring"><em>Oscillating mass attached to a spring</em></a> derives <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a> from physical
principles and explains what the constants mean.</p>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><p id="index-5">The exact solution of <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a> is</p>
<div class="math" id="eq-vib-ode1-uex">
\[\tag{2}
u(t) = I\cos (\omega t)
    {\thinspace .}\]</div>
<p>That is, <span class="math">\(u\)</span> oscillates with constant amplitude <span class="math">\(I\)</span> and
angular frequency <span class="math">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math">\(f\)</span> and <span class="math">\(\omega\)</span> are referred to as frequency, but <span class="math">\(\omega\)</span>
is more precisely named <em>angular frequency</em>, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a>, <span class="math">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math">\(u^{\prime}(t)\)</span> then has the
interpretation of velocity, and <span class="math">\(u^{\prime\prime}(t)\)</span> is the associated
acceleration.  The model <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme">
<span id="vib-ode1-fdm"></span><h2>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h2>
<p>To formulate a finite difference method for the model
problem  <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a> we follow the <a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme">four steps</a> explained in <a class="reference internal" href="._main_vib002.html#ref1" id="id1">[Ref1]</a>.</p>
<span class="target" id="index-6"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-7"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are <span class="math">\(t_n=n\Delta t\)</span>, <span class="math">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math">\(u^n\)</span> for <span class="math">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is to be satisfied at each mesh point:</p>
<div class="math" id="eq-vib-ode1-step2">
\[\tag{3}
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
    {\thinspace .}\]</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-9"></span><h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The derivative <span class="math">\(u^{\prime\prime}(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<div class="math" id="eq-vib-ode1-step3">
\[\tag{4}
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    {\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-ode1-step3"><em>(4)</em></a> in <a class="reference internal" href="#eq-vib-ode1-step2"><em>(3)</em></a>
yields</p>
<div class="math" id="eq-vib-ode1-step3b">
\[\tag{5}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
    {\thinspace .}\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for <span class="math">\(u^{\prime\prime}\)</span>:</p>
<div class="math" id="eq-vib-ode1-step3c">
\[\tag{6}
\frac{u^1-u^{-1}}{2\Delta t} = 0\]\[    {\thinspace .}\]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span> such that <span class="math">\(u^{n+1}\)</span> is the
unknown value, which we can readily solve for:</p>
<div class="math" id="eq-vib-ode1-step4">
\[\tag{7}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
    {\thinspace .}\]</div>
<p>The computational algorithm is simply to apply <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
successively for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stormer&#8217;s
method or <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>.</p>
</div>
<div class="section" id="computing-the-first-step">
<h3>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h3>
<p>We observe that <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> cannot be used for <span class="math">\(n=0\)</span> since
the computation of <span class="math">\(u^1\)</span> then involves the undefined value <span class="math">\(u^{-1}\)</span>
at <span class="math">\(t=-\Delta t\)</span>. The discretization of the initial condition
then comes to our rescue: <a class="reference internal" href="#eq-vib-ode1-step3c"><em>(6)</em></a> implies <span class="math">\(u^{-1} = u^1\)</span>
and this relation can be combined with <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
for <span class="math">\(n=0\)</span> to yield a value for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\]</div>
<p>which reduces to</p>
<div class="math" id="eq-vib-ode1-step4b">
\[\tag{8}
u^1 = u^0 - \frac{1}{2} \Delta t^2 \omega^2 u^0
    {\thinspace .}\]</div>
<p><a class="reference internal" href="._main_vib002.html#vib-exer-step4b-alt"><em>Exercise 5: Use a Taylor polynomial to compute </em></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math">\(u^{\prime}(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h3>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The steps for solving <a class="reference internal" href="#eq-vib-ode1"><em>(1)</em></a> become</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4b"><em>(8)</em></a></li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>: compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a></li>
</ol>
</div></blockquote>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-remark-on-using-w-for-math-omega-in-computer-code admonition">
<p class="first admonition-title">Remark on using <tt class="docutils literal"><span class="pre">w</span></tt> for <span class="math">\(\omega\)</span> in computer code</p>
<p class="last">In the code, we use <tt class="docutils literal"><span class="pre">w</span></tt> as the symbol for <span class="math">\(\omega\)</span>.
The reason is that the authors prefer <tt class="docutils literal"><span class="pre">w</span></tt> for readability
and comparison with the mathematical <span class="math">\(\omega\)</span> instead of
the full word <tt class="docutils literal"><span class="pre">omega</span></tt> as variable name.</p>
</div>
</div>
<div class="section" id="operator-notation">
<h3>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h3>
<p>We may write the scheme using a compact difference notation
(see also
<a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a class="reference internal" href="._main_vib002.html#ref1" id="id2">[Ref1]</a>).
The difference <a class="reference internal" href="#eq-vib-ode1-step3"><em>(4)</em></a> has the operator
notation <span class="math">\([D_tD_t u]^n\)</span> such that we can write:</p>
<div class="math" id="eq-vib-ode1-step4-op">
\[\tag{9}
[D_tD_t u  + \omega^2 u = 0]^n
    {\thinspace .}\]</div>
<p>Note that <span class="math">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math">\(\Delta t/2\)</span> twice:</p>
<div class="math">
\[[D_t(D_t u)]^n = \frac{[D_t u]^{n+\frac{1}{2}} - [D_t u]^{n-\frac{1}{2}}}{\Delta t}\]</div>
<p>which is written out as</p>
<div class="math">
\[\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
{\thinspace .}\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<div class="math" id="eq-auto1">
\[\tag{10}
[u = I]^0,\quad [D_{2t} u = 0]^0,\]</div>
<p>where the operator <span class="math">\([D_{2t} u]^n\)</span> is defined as</p>
<div class="math" id="eq-auto2">
\[\tag{11}
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
    {\thinspace .}\]</div>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="vib-impl1"></span><h1>Implementation<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="making-a-solver-function">
<span id="vib-impl1-solver"></span><h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
<span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math">\(I\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We have imported <tt class="docutils literal"><span class="pre">numpy</span></tt> and <tt class="docutils literal"><span class="pre">matplotlib</span></tt> under the names <tt class="docutils literal"><span class="pre">np</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt>,
respectively, as this is very common in the Python scientific
computing community and a good programming habit (since we explicitly
see where the different functions come from).  An alternative is to do
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">import</span> <span class="pre">*</span></tt> and a similar &#8220;import all&#8221; for Matplotlib to
avoid the <tt class="docutils literal"><span class="pre">np</span></tt> and <tt class="docutils literal"><span class="pre">plt</span></tt> prefixes and make the code as close as
possible to MATLAB. (See the section
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:basic:modprefix">Prefixing imported functions by the module name</a> in the book
<a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._main_vib002.html#ref1" id="id3">[Ref1]</a> for a discussion of the two
types of import in Python.)</p>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding main program calling these functions to simulate
a given number of periods (<tt class="docutils literal"><span class="pre">num_periods</span></tt>) may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <tt class="docutils literal"><span class="pre">ArgumentParser</span></tt> tool in
the <tt class="docutils literal"><span class="pre">argparse</span></tt> module to define option value (<tt class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></tt>)
pairs on the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Such parsing of the command line is explained in more detail in</dt>
<dd>the</dd>
</dl>
<p>section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:basic:UI:options_cml">Option-value pairs on the command line</a> in <a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._main_vib002.html#ref1" id="id4">[Ref1]</a>.</p>
<p>A typical execution goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>
</div>
<div class="section" id="computing">
<h3>Computing <span class="math">\(u^{\prime}\)</span><a class="headerlink" href="#computing" title="Permalink to this headline">¶</a></h3>
<p>In mechanical vibration applications one is often interested in
computing the velocity <span class="math">\(v(t)=u^{\prime}(t)\)</span> after <span class="math">\(u(t)\)</span> has been computed.
This can be done by a central difference,</p>
<div class="math" id="eq-auto3">
\[\tag{12}
v(t_n)=u^{\prime}(t_n) \approx v^n = \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
    {\thinspace .}\]</div>
<p>This formula applies for all inner mesh points, <span class="math">\(n=1,\ldots,N_t-1\)</span>.
For <span class="math">\(n=0\)</span>, <span class="math">\(v(0)\)</span> is given by the initial condition on <span class="math">\(u^{\prime}(0)\)</span>,
and for <span class="math">\(n=N_t\)</span> we can use a one-sided, backward difference:</p>
<div class="math">
\[v^n=[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}{\thinspace .}\]</div>
<p>Typical (scalar) code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c"># or v = np.zeros(len(u))</span>
<span class="c"># Use central difference for internal points</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="c"># Use initial condition for u&#39;(0) when i=0</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c"># Use backward difference at the final mesh point</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>
</pre></div>
</div>
<p>Since the loop is slow for large <span class="math">\(N_t\)</span>, we
can get rid of the loop by
vectorizing the central difference. The above code segment
goes as follows in its vectorized version (see the problem
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/html/._decay-book005.html#decay:exer:dudt">Differentiate a function</a> in
<a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._main_vib002.html#ref1" id="id5">[Ref1]</a>
for explanation of details):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># central difference</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                           <span class="c"># boundary condition u&#39;(0)</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>         <span class="c"># backward difference</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<span id="vib-ode1-verify"></span><h2>Verification<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><div class="section" id="manual-calculation">
<span id="index-14"></span><h3>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h3>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <tt class="docutils literal"><span class="pre">solver</span></tt>
function. The <tt class="docutils literal"><span class="pre">test_three_steps</span></tt> function in
the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped.py">vib_undamped.py</a>
shows the details of how we use the hand calculations to test the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_three_steps</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.000000000000000</span><span class="p">,</span>
                          <span class="mf">0.802607911978213</span><span class="p">,</span>
                          <span class="mf">0.288358920740053</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u_by_hand</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>This function is a proper <em>test function</em>,
compliant with the pytest and nose testing
framework for Python code, because</p>
<blockquote>
<div><ul class="simple">
<li>the function name begins with <tt class="docutils literal"><span class="pre">test_</span></tt></li>
<li>the function takes no arguments</li>
<li>the test is formulated as a boolean condition and executed by <tt class="docutils literal"><span class="pre">assert</span></tt></li>
</ul>
</div></blockquote>
<p>See the
section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book009.html#softeng1:verify:pytest">Unit tests and test functions</a> in
<a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._main_vib002.html#ref1" id="id6">[Ref1]</a>
for more details on how to construct test functions and utilize nose
or pytest for automatic execution of tests. Our recommendation is to
use pytest and run all test functions in <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> by</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; py.test -s -v vib_undamped.py
============================= test session starts ======...
platform linux2 -- Python 2.7.9 -- ...
collected 2 items

vib_undamped.py::test_three_steps PASSED
vib_undamped.py::test_convergence_rates PASSED

=========================== 2 passed in 0.19 seconds ===...
</pre></div>
</div>
</div>
<div class="section" id="testing-very-simple-polynomial-solutions">
<span id="index-15"></span><h3>Testing very simple polynomial solutions<a class="headerlink" href="#testing-very-simple-polynomial-solutions" title="Permalink to this headline">¶</a></h3>
<p>Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here <span class="math">\([D_tD_tt^2]^n=2\)</span>, which is the exact
result. A solution <span class="math">\(u=t^2\)</span> leads to <span class="math">\(u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0\)</span>.  We must therefore add a source in the equation: <span class="math">\(u^{\prime\prime} +
\omega^2 u = f\)</span> to allow a solution <span class="math">\(u=t^2\)</span> for <span class="math">\(f=2 + (\omega t)^2\)</span>.  By
simple insertion we can show that the mesh function <span class="math">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.  <a class="reference internal" href="._main_vib002.html#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!</p>
</div>
<div class="section" id="checking-convergence-rates">
<span id="index-16"></span><h3>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Empirical computation of convergence rates yields a good method for
verification. The method and its computational details are explained
in detail for a simple ODE model in the section
<a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/html/._decay-book007.html#decay:convergence:rate">Computing convergence rates</a>
in <a class="reference external" href="http://tinyurl.com/nclmcng/web">Finite Difference Computing with Exponential Decay Models</a> <a class="reference internal" href="._main_vib002.html#ref1" id="id7">[Ref1]</a>.  Readers not
familiar with the concept should look up this reference before
proceeding.</p>
<p>In the present problem, computing convergence rates means that we must</p>
<blockquote>
<div><ul class="simple">
<li>perform <span class="math">\(m\)</span> simulations, halving the time steps as: <span class="math">\(\Delta t_i=2^{-i}\Delta t_0\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,</li>
<li>compute the <span class="math">\(L^2\)</span> norm of the error,
<span class="math">\(E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-{u_{\small\mbox{e}}}(t_n))^2}\)</span> in each case,</li>
<li>estimate the convergence rates <span class="math">\(r_i\)</span> based on two consecutive
experiments <span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math">\(E_i=C(\Delta t_i)^{r}\)</span> and <span class="math">\(E_{i-1}=C(\Delta t_{i-1})^{r}\)</span>.
From these equations it follows that
<span class="math">\(r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>. Since this <span class="math">\(r\)</span>
will vary with <span class="math">\(i\)</span>, we equip it with an index and call it <span class="math">\(r_{i-1}\)</span>,
where <span class="math">\(i\)</span> runs from <span class="math">\(1\)</span> to <span class="math">\(m-1\)</span>.</li>
</ul>
</div></blockquote>
<p>The computed rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> hopefully converge to the
number 2 in the present
problem, because theory (from the section <a class="reference internal" href="#vib-ode1-analysis"><em>Analysis of the numerical scheme</em></a>) shows
that the error of the numerical method we use behaves like <span class="math">\(\Delta t^2\)</span>.
The convergence of the sequence of rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span>
demands that the time steps
<span class="math">\(\Delta t_i\)</span> are sufficiently small for the error model <span class="math">\(E_i=C(\Delta t_i)^r\)</span>
to be valid.</p>
<p>All the implementational details of computing the sequence
<span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> appear below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The error analysis in the section <a class="reference internal" href="#vib-ode1-analysis"><em>Analysis of the numerical scheme</em></a> is quite
detailed and results in <span class="math">\(r=2\)</span>, but other methods like truncation error
analysis
also points to <span class="math">\(r=2\)</span>,
as well as the related quick reasoning that we have used a
second-order accurate finite difference approximation <span class="math">\([D_tD_tu]^n\)</span> to
the ODE and a second-order accurate finite difference formula for the
initial condition for <span class="math">\(u^{\prime}\)</span>.</p>
<p>In the present problem, when <span class="math">\(\Delta t_0\)</span> corresponds to 30 time steps
per period, the returned <tt class="docutils literal"><span class="pre">r</span></tt> list has all its values equal to 2.00
(if rounded to two decimals). This amazingly accurate result means that all
<span class="math">\(\Delta t_i\)</span> values are well into the asymptotic regime where the
error model <span class="math">\(E_i = C(\Delta t_i)^r\)</span> is valid.</p>
<p>We can now construct a proper test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. This unit test
goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>The complete code appears in the file <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>.</p>
</div>
</div>
<div class="section" id="scaled-model">
<h2>Scaled model<a class="headerlink" href="#scaled-model" title="Permalink to this headline">¶</a></h2>
<p>It is advantageous to use dimensionless variables in simulations,
because fewer parameters need to be set. The present problem is made
dimensionless by introducing dimensionless variables <span class="math">\(\bar t = t/t_c\)</span>
and <span class="math">\(\bar u = u/u_c\)</span>, where <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span> are characteristic scales
for <span class="math">\(t\)</span> and <span class="math">\(u\)</span>, respectively. We refer to the section
<a class="reference external" href="http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book006.html#sec:scale:vib:undamped">Undamped vibrations without forcing</a>
in the book <a class="reference external" href="http://tinyurl.com/qfjgxmf/web">Scaling of differential equations</a> <a class="reference internal" href="._main_vib002.html#ref2" id="id8">[Ref2]</a> for all
details about this scaling.</p>
<p>The scaled ODE problem reads</p>
<div class="math">
\[\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0{\thinspace .}\]</div>
<p>A common choice is to take <span class="math">\(t_c\)</span> as one period of
the oscillations, <span class="math">\(t_c = 2\pi/w\)</span>, and <span class="math">\(u_c=I\)</span>.
This gives the dimensionless model</p>
<div class="math" id="eq-vib-ode1-model-scaled">
\[\tag{13}
\frac{d^2\bar u}{\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\
    \bar u^{\prime}(0)=0{\thinspace .}\]</div>
<p>Observe that there are no physical parameters in <a class="reference internal" href="#eq-vib-ode1-model-scaled"><em>(13)</em></a>!
We can therefore perform
a single numerical simulation <span class="math">\(\bar u(\bar t)\)</span> and afterwards
recover any <span class="math">\(u(t; \omega, I)\)</span> by</p>
<div class="math">
\[u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(\omega t/(2\pi)){\thinspace .}\]</div>
<p>We can easily check this assertion: the solution of the scaled problem
is <span class="math">\(\bar u(\bar t) = \cos(2\pi\bar t)\)</span>. The formula for <span class="math">\(u\)</span> in terms
of <span class="math">\(\bar u\)</span> gives <span class="math">\(u = I\cos(\omega t)\)</span>, which is nothing but the solution
of the original problem with dimensions.</p>
<p>The scaled model can by run by calling <tt class="docutils literal"><span class="pre">solver(I=1,</span> <span class="pre">w=2*pi,</span> <span class="pre">dt,</span> <span class="pre">T)</span></tt>.
Each period is now 1 and <tt class="docutils literal"><span class="pre">T</span></tt> simply counts the number of periods.
Choosing <tt class="docutils literal"><span class="pre">dt</span></tt> as <tt class="docutils literal"><span class="pre">1./M</span></tt> gives <tt class="docutils literal"><span class="pre">M</span></tt> time steps per period.</p>
</div>
</div>
<div class="section" id="long-time-simulations">
<span id="vib-ode1-longseries"></span><h1>Long time simulations<a class="headerlink" href="#long-time-simulations" title="Permalink to this headline">¶</a></h1>
<p>Figure <a class="reference internal" href="#vib-ode1-2dt"><em>Effect of halving the time step</em></a> shows a comparison of the exact and numerical
solution for the scaled model <a class="reference internal" href="#eq-vib-ode1-model-scaled"><em>(13)</em></a> with
<span class="math">\(\Delta t=0.1, 0.05\)</span>.
From the plot we make the following observations:</p>
<blockquote>
<div><ul class="simple">
<li>The numerical solution seems to have correct amplitude.</li>
<li>There is a angular frequency error which is reduced by reducing the time step.</li>
<li>The total angular frequency error grows with time.</li>
</ul>
</div></blockquote>
<p>By angular frequency error we mean that the numerical angular frequency differs
from the exact <span class="math">\(\omega\)</span>. This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematical expressed by writing the numerical solution
as <span class="math">\(I\cos\tilde\omega t\)</span>, where <span class="math">\(\tilde\omega\)</span> is not exactly
equal to <span class="math">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical angular frequency <span class="math">\(\tilde\omega\)</span>.</p>
<div class="figure" id="vib-ode1-2dt">
<a class="reference internal image-reference" href="_images/vib_freq_err1.png"><img alt="_images/vib_freq_err1.png" src="_images/vib_freq_err1.png" style="width: 800px;" /></a>
<p class="caption"><em>Effect of halving the time step</em></p>
</div>
<div class="section" id="using-a-moving-plot-window">
<h2>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h2>
<p>In vibration problems it is often of interest to investigate the system&#8217;s
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the <span class="math">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a> package contains
a convenient tool for this: <tt class="docutils literal"><span class="pre">MovingPlotWindow</span></tt>. Typing
<tt class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></tt> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <tt class="docutils literal"><span class="pre">main</span></tt> function the <tt class="docutils literal"><span class="pre">vib_undamped</span></tt> module
if the number of periods in the simulation exceeds 10.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_frames</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    Plots are saved to files if savefig is True.</span>
<span class="sd">    Only each skip_frames-th plot is saved (e.g., if</span>
<span class="sd">    skip_frame=10, only each 10th plot is saved to file;</span>
<span class="sd">    this is convenient if plot files corresponding to</span>
<span class="sd">    different time steps are to be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

    <span class="c"># Remove all old plot files tmp_*.png</span>
    <span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">frame_counter</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>We run the scaled problem (the default values for the command-line arguments
<tt class="docutils literal"><span class="pre">--I</span></tt> and <tt class="docutils literal"><span class="pre">--w</span></tt> correspond to the scaled problem) for 40 periods with 20
time steps per period:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</div>
<p>The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, but it becomes more
prominent with time. A new run with <span class="math">\(\Delta t=0.1\)</span> (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.</p>
</div>
<div class="section" id="making-animations">
<span id="vib-ode1-anim"></span><h2>Making animations<a class="headerlink" href="#making-animations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-17"></span><span class="target" id="index-18"></span><span class="target" id="index-19"></span><span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><div class="section" id="producing-standard-video-formats">
<span id="index-23"></span><h3>Producing standard video formats<a class="headerlink" href="#producing-standard-video-formats" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">visualize_front</span></tt> function stores all the plots in
files whose names are numbered:
<tt class="docutils literal"><span class="pre">tmp_0000.png</span></tt>, <tt class="docutils literal"><span class="pre">tmp_0001.png</span></tt>, <tt class="docutils literal"><span class="pre">tmp_0002.png</span></tt>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ffmpeg -r 12 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ffmpeg</span></tt> program can be replaced by the <tt class="docutils literal"><span class="pre">avconv</span></tt> program in
the above command if desired (but at the time of this writing it seems
to be more momentum in the <tt class="docutils literal"><span class="pre">ffmpeg</span></tt> project).
The <tt class="docutils literal"><span class="pre">-r</span></tt> option should come first and
describes the number of frames per second in the movie. The
<tt class="docutils literal"><span class="pre">-i</span></tt> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Codec and filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Flash</td>
<td><tt class="docutils literal"><span class="pre">-c:v</span> <span class="pre">flv</span> <span class="pre">movie.flv</span></tt></td>
</tr>
<tr class="row-odd"><td>MP4</td>
<td><tt class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libx264</span> <span class="pre">movie.mp4</span></tt></td>
</tr>
<tr class="row-even"><td>WebM</td>
<td><tt class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libvpx</span> <span class="pre">movie.webm</span></tt></td>
</tr>
<tr class="row-odd"><td>Ogg</td>
<td><tt class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libtheora</span> <span class="pre">movie.ogg</span></tt></td>
</tr>
</tbody>
</table>
<p id="index-24">The video file can be played by some video player like <tt class="docutils literal"><span class="pre">vlc</span></tt>, <tt class="docutils literal"><span class="pre">mplayer</span></tt>,
<tt class="docutils literal"><span class="pre">gxine</span></tt>, or <tt class="docutils literal"><span class="pre">totem</span></tt>, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; vlc movie.webm
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today&#8217;s standard is
to use the HTML5 <tt class="docutils literal"><span class="pre">video</span></tt> tag:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.mp4&#39;</span>   <span class="na">type=</span><span class="s">&#39;video/mp4;</span>
<span class="s"> codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm;</span>
<span class="s"> codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>The MP4 format should appear first to ensure that Apple devices will
load the video correctly.</p>
<div class="admonition-caution-number-the-plot-files-correctly admonition">
<p class="first admonition-title">Caution: number the plot files correctly</p>
<p class="last">To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <tt class="docutils literal"><span class="pre">%04d</span></tt> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <tt class="docutils literal"><span class="pre">tmp_*.png</span></tt>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <tt class="docutils literal"><span class="pre">tmp_11.png</span></tt> would appear
before <tt class="docutils literal"><span class="pre">tmp_2.png</span></tt> in the movie.</p>
</div>
</div>
<div class="section" id="paying-png-files-in-a-web-browser">
<h3>Paying PNG files in a web browser<a class="headerlink" href="#paying-png-files-in-a-web-browser" title="Permalink to this headline">¶</a></h3>
<p id="index-25">The <tt class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></tt> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <tt class="docutils literal"><span class="pre">tmp_*.png</span></tt> goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">fps</span></tt> argument controls the speed of the movie (&#8220;frames per second&#8221;).</p>
<p>To watch the movie, load the video file <tt class="docutils literal"><span class="pre">vib.html</span></tt> into some browser, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
</div>
<p>Clicking on <tt class="docutils literal"><span class="pre">Start</span> <span class="pre">movie</span></tt> to see the result. Moving this movie to
some other place requires moving <tt class="docutils literal"><span class="pre">vib.html</span></tt> <em>and all the PNG files</em>
<tt class="docutils literal"><span class="pre">tmp_*.png</span></tt>:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; mkdir vib_dt0.1
Terminal&gt; mv tmp_*.png vib_dt0.1
Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>
</div>
</div>
<div class="section" id="making-animated-gif-files">
<h3>Making animated GIF files<a class="headerlink" href="#making-animated-gif-files" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">convert</span></tt> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-delay</span></tt> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with <span class="math">\(\Delta t=0.05\)</span> and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible. Animated GIFs are best suited for animations with
not so many frames and where you want to see each frame and play them
slowly.</p>
<p>[<strong>hpl 2</strong>: Combine two simulations side by side!]</p>
</div>
</div>
<div class="section" id="using-bokeh-to-compare-graphs">
<h2>Using Bokeh to compare graphs<a class="headerlink" href="#using-bokeh-to-compare-graphs" title="Permalink to this headline">¶</a></h2>
<p>Instead of a moving plot frame, one can use tools that allows panning
by the mouse. For example, we can show four periods of several signals in
several plots and then scroll with the mouse through the rest of the
simulation <em>simultaneously</em> in all the plot windows.
The <a class="reference external" href="http://bokeh.pydata.org/en/latest/docs/quickstart.html">Bokeh</a> plotting library offers such tools, but the plots must be displayed in
a web browser. The documentation of Bokeh is excellent, so here we just
show how the library can be used to compare a set of <span class="math">\(u\)</span> curves corresponding
to long time simulations. (By the way, the guidance to correct
pronunciation of Bokeh in
the <a class="reference external" href="http://bokeh.pydata.org/en/0.10.0/docs/faq.html#how-do-you-pronounce-bokeh">documentation</a> and on <a class="reference external" href="https://en.wikipedia.org/wiki/Bokeh">Wikipedia</a> is not directly compatible with a <a class="reference external" href="https://www.youtube.com/watch?v=OR8HSHevQTM">YouTube video</a>...).</p>
<p>Imagine we have performed experiments for a set of <span class="math">\(\Delta t\)</span> values.
We want each curve, together with the exact solution, to appear in
a plot, and then arrange all plots in a grid-like fashion:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot1.png"><img alt="_images/bokeh_gridplot1.png" src="_images/bokeh_gridplot1.png" style="width: 800px;" /></a>
</div>
<p>Furthermore, we want the axes to couple such that if we move into
the future in one plot, all the other plots follows (note the
displaced <span class="math">\(t\)</span> axes!):</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/bokeh_gridplot2.png"><img alt="_images/bokeh_gridplot2.png" src="_images/bokeh_gridplot2.png" style="width: 800px;" /></a>
</div>
<p>A function for creating a Bokeh plot, given a list of <tt class="docutils literal"><span class="pre">u</span></tt> arrays
and corresponding <tt class="docutils literal"><span class="pre">t</span></tt> arrays, from different simulations, described
compactly in a list of strings <tt class="docutils literal"><span class="pre">legends</span></tt>, is implemented below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make plots for u vs t using the Bokeh library.</span>
<span class="sd">    u and t are lists (several experiments can be compared).</span>
<span class="sd">    legens contain legend strings for the various u,t pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>  <span class="c"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>  <span class="c"># wrap in list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">legends</span> <span class="o">=</span> <span class="p">[</span><span class="n">legends</span><span class="p">]</span>  <span class="c"># wrap in list</span>

    <span class="kn">import</span> <span class="nn">bokeh.plotting</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">output_file</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;cdn&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#39;Comparison&#39;</span><span class="p">)</span>
    <span class="c"># Assume that all t arrays have the same range</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># fine mesh for u_e</span>
    <span class="n">tools</span> <span class="o">=</span> <span class="s">&#39;pan,wheel_zoom,box_zoom,reset,&#39;</span>\
            <span class="s">&#39;save,box_select,lasso_select&#39;</span>
    <span class="n">u_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="s">&#39;8pt&#39;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># list of plot objects</span>
    <span class="c"># Make the first figure</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">x_axis_label</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
        <span class="n">x_range</span><span class="o">=</span><span class="n">t_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">u_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
        <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span><span class="o">=</span><span class="n">font_size</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;blue&#39;</span><span class="p">)</span>
    <span class="c"># Add exact solution</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s">&#39;4 4&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
    <span class="c"># Make the rest of the figures and attach their axes to</span>
    <span class="c"># the first figure&#39;s axes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">p_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">plot_height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">legends</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">x_axis_label</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">y_axis_label</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span>
            <span class="n">x_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x_range</span><span class="p">,</span> <span class="n">y_range</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y_range</span><span class="p">,</span> <span class="n">tools</span><span class="o">=</span><span class="n">tools</span><span class="p">,</span>
            <span class="n">title_text_font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label_text_font_size</span> <span class="o">=</span> <span class="n">font_size</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;blue&#39;</span><span class="p">)</span>
        <span class="n">p_</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s">&#39;red&#39;</span><span class="p">,</span> <span class="n">line_dash</span><span class="o">=</span><span class="s">&#39;4 4&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>

    <span class="c"># Arrange all plots in a grid with 3 plots per row</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># New row</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gridplot</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">toolbar_location</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span>
</pre></div>
</div>
<p>A particular example using the <tt class="docutils literal"><span class="pre">bokeh_plot</span></tt> function appears below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">demo_bokeh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Solve a scaled ODE u&#39;&#39; + u = 0.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c"># Scaled problem (frequency)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># Period</span>
    <span class="n">num_steps_per_period</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">40</span><span class="o">*</span><span class="n">P</span>       <span class="c"># Simulation time: 40 periods</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c"># List of numerical solutions</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c"># List of corresponding meshes</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">num_steps_per_period</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">n</span>
        <span class="n">u_</span><span class="p">,</span> <span class="n">t_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;# time steps per period: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">bokeh_plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">legends</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">P</span><span class="p">],</span>
               <span class="n">filename</span><span class="o">=</span><span class="s">&#39;tmp.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h2>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h2>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen.
The tool
<tt class="docutils literal"><span class="pre">scitools.avplotter.Plotter</span></tt> makes it easy to create such plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> \
              <span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>
</pre></div>
</div>
<p>The call <tt class="docutils literal"><span class="pre">p.plot</span></tt> returns a line of text, with the <span class="math">\(t\)</span> axis marked and
a symbol <tt class="docutils literal"><span class="pre">+</span></tt> for the first function (<tt class="docutils literal"><span class="pre">u</span></tt>) and <tt class="docutils literal"><span class="pre">o</span></tt> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (<span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t=0.05\)</span>)
looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre>                         |                       o+      14.0
                         |                      + o      14.0
                         |                  +    o       14.1
                         |             +     o           14.1
                         |     +        o                14.2
                        +|       o                       14.2
                +        |                               14.2
         +       o       |                               14.3
    +     o              |                               14.4
 +   o                   |                               14.4
+o                       |                               14.5
o +                      |                               14.5
 o    +                  |                               14.6
     o      +            |                               14.6
          o        +     |                               14.7
                 o       | +                             14.7
                         |        +                      14.8
                         |       o       +               14.8
                         |              o     +          14.9
                         |                   o   +       14.9
                         |                       o+      15.0
</pre></div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<span id="vib-ode1-empirical"></span><h2>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h2>
<p>For oscillating functions like those in Figure <a class="reference internal" href="#vib-ode1-2dt"><em>Effect of halving the time step</em></a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<div class="math" id="eq-auto4">
\[\begin{split}\tag{14}
u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,\end{split}\]</div>
<p>and the local minima are recognized by</p>
<div class="math" id="eq-auto5">
\[\begin{split}\tag{15}
u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
    {\thinspace .}\end{split}\]</div>
<p>In computer code this becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
<p>Note that the two returned objects are lists of tuples.</p>
<p>Let <span class="math">\((t_i, e_i)\)</span>, <span class="math">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math">\(M\)</span> maxima points, where <span class="math">\(t_i\)</span>
is the time value and <span class="math">\(e_i\)</span> the corresponding <span class="math">\(u\)</span> value.
The local period can be defined as <span class="math">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The list <tt class="docutils literal"><span class="pre">p</span></tt> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <tt class="docutils literal"><span class="pre">2*pi/p</span></tt>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The code segments are found in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_empirical_analysis.py">vib_empirical_analysis.py</a>.</p>
<p>Since <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">p[i]</span></tt> correspond to
the <span class="math">\(i\)</span>-th amplitude estimate and the <span class="math">\(i\)</span>-th period estimate, respectively,
it is most convenient to visualize the <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> values with the
index <tt class="docutils literal"><span class="pre">i</span></tt> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">a</span></tt> instead of <span class="math">\(u\)</span> to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and <span class="math">\(\Delta t=0.1, 0.05, 0.01\)</span>.
A ready-made function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <tt class="docutils literal"><span class="pre">I</span></tt>
and the exact angular frequency <tt class="docutils literal"><span class="pre">w</span></tt>. We can make a little program
for creating the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">plot_empirical_freq_and_amplitude</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">u_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
    <span class="c"># Simulate scaled problem for 40 periods</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">u_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">t_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u_cases</span><span class="p">,</span> <span class="n">t_cases</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#vib-ode1-fig-freq-ampl"><em>Empirical amplitude and angular frequency for three cases of time steps</em></a> shows the result: we clearly see that
lowering <span class="math">\(\Delta t\)</span> improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
<span class="math">\(\Delta t=0.01\)</span>, corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good and frequencies
are more inaccurate.</p>
<div class="figure" id="vib-ode1-fig-freq-ampl">
<a class="reference internal image-reference" href="_images/empirical_ampl_freq.png"><img alt="_images/empirical_ampl_freq.png" src="_images/empirical_ampl_freq.png" style="width: 800px;" /></a>
<p class="caption"><em>Empirical amplitude and angular frequency for three cases of time steps</em></p>
</div>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<span id="vib-ode1-analysis"></span><h1>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h1>
<div class="section" id="deriving-a-solution-of-the-numerical-scheme">
<h2>Deriving a solution of the numerical scheme<a class="headerlink" href="#deriving-a-solution-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h2>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
<a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
<span class="math">\(u^n=CA^n\)</span>, where <span class="math">\(A\)</span> is some number
to be determined from the difference equation and <span class="math">\(C\)</span> is found as the
initial condition (<span class="math">\(C=I\)</span>).  Recall that <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span> is a
superscript labeling the time level, while <span class="math">\(n\)</span> in <span class="math">\(A^n\)</span> is an
exponent.</p>
<p>With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an <span class="math">\(A\)</span> on the form</p>
<div class="math">
\[A=e^{i\tilde\omega \Delta t},\]</div>
<p>and solve for the numerical frequency <span class="math">\(\tilde\omega\)</span> rather than
<span class="math">\(A\)</span>. Note that <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math">
\[A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t_n} =
\cos (\tilde\omega t_n) + i\sin(\tilde \omega t_n)
{\thinspace .}\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations go as</p>
<div class="math">
\[\begin{split}[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\
&amp;= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t_n+\Delta t)} - 2e^{i\tilde\omega t_n} + e^{i\tilde\omega(t_n-\Delta t)})\\
&amp;= Ie^{i\tilde\omega t_n}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&amp;= Ie^{i\tilde\omega t_n}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&amp;= -Ie^{i\tilde\omega t_n}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})\end{split}\]</div>
<p>The last line follows from the relation
<span class="math">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <tt class="docutils literal"><span class="pre">cos(x)-1</span></tt> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
with <span class="math">\(u^n=Ie^{i\tilde\omega\Delta t\, n}\)</span> inserted now gives</p>
<div class="math" id="eq-auto6">
\[\tag{16}
-Ie^{i\tilde\omega t_n}
    \frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
    + \omega^2 Ie^{i\tilde\omega t_n} = 0,\]</div>
<p>which after dividing by <span class="math">\(Ie^{i\tilde\omega t_n}\)</span> results in</p>
<div class="math" id="eq-auto7">
\[\tag{17}
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
    {\thinspace .}\]</div>
<p>The first step in solving for the unknown <span class="math">\(\tilde\omega\)</span> is</p>
<div class="math">
\[\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
{\thinspace .}\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math">\(2/\Delta t\)</span>, results in</p>
<div class="math" id="eq-vib-ode1-tildeomega">
\[\tag{18}
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    {\thinspace .}\]</div>
<p>The first observation of <a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a> tells that
there is a phase error since the numerical frequency <span class="math">\(\tilde\omega\)</span>
never equals the exact frequency <span class="math">\(\omega\)</span>. But how good is
the approximation <a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a>? That is, what
is the error <span class="math">\(\omega - \tilde\omega\)</span> or <span class="math">\(\tilde\omega/\omega\)</span>?
Taylor series expansion
for small <span class="math">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in <a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">w_tilde_series</span>
<span class="go">w + dt**2*w**3/24 + O(dt**4)</span>
</pre></div>
</div>
<p>This means that</p>
<div class="math" id="eq-vib-ode1-tildeomega-series">
\[\tag{19}
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
    + {\mathcal{O}(\Delta t^4)}
    {\thinspace .}\]</div>
<p>The error in the numerical frequency is of second-order in
<span class="math">\(\Delta t\)</span>, and the error vanishes as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We see that <span class="math">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>
and this is by far the biggest term in the series expansion for small
<span class="math">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore &#8220;lags behind&#8221; the exact
oscillations, a feature that can be seen in the left plot in Figure
<a class="reference internal" href="#vib-ode1-2dt"><em>Effect of halving the time step</em></a>.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-tildeomega-plot"><em>Exact discrete frequency and its second-order series expansion</em></a> plots the discrete frequency
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a>
and its approximation <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a> for <span class="math">\(\omega =1\)</span> (based
on the program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_plot_freq.py">vib_plot_freq.py</a>).
Although <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(\Delta t\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a>,
it is misleading to think of <span class="math">\(\Delta t\)</span> as the important
discretization parameter. It is the product <span class="math">\(\omega\Delta t\)</span> that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set <span class="math">\(P=N_P\Delta t\)</span>, where <span class="math">\(P\)</span> is the length of
a period, and <span class="math">\(N_P\)</span> is the number of time steps during a period.
Since <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> are related by <span class="math">\(P=2\pi/\omega\)</span>,
we get that <span class="math">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows that
<span class="math">\(\omega\Delta t\)</span> is directly related to <span class="math">\(N_P\)</span>.</p>
<p>The plot shows
that at least <span class="math">\(N_P\sim 25-30\)</span> points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (<span class="math">\(T\)</span>) as
the total phase error due to the frequency error grows linearly with time
(see <a class="reference internal" href="._main_vib002.html#vib-exer-phase-err-growth"><em>Exercise 2: Show linear growth of the phase with time</em></a>).</p>
<div class="figure" id="vib-ode1-tildeomega-plot">
<a class="reference internal image-reference" href="_images/discrete_freq.png"><img alt="_images/discrete_freq.png" src="_images/discrete_freq.png" style="width: 400px;" /></a>
<p class="caption"><em>Exact discrete frequency and its second-order series expansion</em></p>
</div>
</div>
<div class="section" id="exact-discrete-solution">
<span id="vib-ode1-analysis-sol"></span><h2>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p>Perhaps more important than the <span class="math">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<div class="math" id="eq-vib-ode1-un-exact">
\[\tag{20}
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
    \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
    {\thinspace .}\]</div>
<p>We can then compute the error mesh function</p>
<div class="math" id="eq-vib-ode1-en">
\[\tag{21}
e^n = {u_{\small\mbox{e}}}(t_n) - u^n =
    I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right){\thinspace .}\]</div>
<p>From the formula <span class="math">\(\cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y)\)</span> we can
rewrite <span class="math">\(e^n\)</span> so the expression is easier to interpret:</p>
<div class="math" id="eq-vib-ode1-en2">
\[\tag{22}
e^n = -2I\sin\left(t\frac{1}{2}\left( \omega - \tilde\omega\right)\right)
    \sin\left(t\frac{1}{2}\left( \omega + \tilde\omega\right)\right){\thinspace .}\]</div>
<p>The error mesh function is ideal for verification purposes
and you are strongly encouraged to make a test based on <a class="reference internal" href="#eq-vib-ode1-un-exact"><em>(20)</em></a>
by doing <a class="reference internal" href="._main_vib002.html#vib-exer-discrete-omega"><em>Exercise 10: Use an exact discrete solution for verification</em></a>.</p>
</div>
<div class="section" id="convergence">
<span id="vib-ode1-analysis-conv"></span><h2>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h2>
<p>We can use <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a>, <a class="reference internal" href="#eq-vib-ode1-en"><em>(21)</em></a>, or
<a class="reference internal" href="#eq-vib-ode1-en2"><em>(22)</em></a> to show <em>convergence</em> of the
numerical scheme, i.e., <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>,
which implies that the numerical solution approaches the exact solution
as <span class="math">\(\Delta t\)</span> approaches to zero.
We have that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,\]</div>
<p>by L&#8217;Hopital&#8217;s rule. This result could also been computed <a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a>, or
we could use the limit functionality in <tt class="docutils literal"><span class="pre">sympy</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">((</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
<span class="go">w</span>
</pre></div>
</div>
<p>Also <a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a> can be used to establish
this result that
<span class="math">\(\tilde\omega\rightarrow\omega\)</span>. It then follows from the expression(s)
for <span class="math">\(e^n\)</span> that <span class="math">\(e^n\rightarrow 0\)</span>.</p>
</div>
<div class="section" id="the-global-error">
<h2>The global error<a class="headerlink" href="#the-global-error" title="Permalink to this headline">¶</a></h2>
<p id="index-26">To achieve more analytical insight into the nature of the global error,
we can Taylor expand the error mesh function <a class="reference internal" href="#eq-vib-ode1-en"><em>(21)</em></a>.
Since <span class="math">\(\tilde\omega\)</span> in <a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a>
contains <span class="math">\(\Delta t\)</span> in the denominator we use the series expansion
for <span class="math">\(\tilde\omega\)</span> inside the cosine function. A relevant <tt class="docutils literal"><span class="pre">sympy</span></tt>
session is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">w + dt**2*w**3/24 + O(dt**4)</span>
</pre></div>
</div>
<p>Series expansions in <tt class="docutils literal"><span class="pre">sympy</span></tt> have the inconvenient <tt class="docutils literal"><span class="pre">O()</span></tt> term that
prevents further calculations with the series. We can use the
<tt class="docutils literal"><span class="pre">removeO()</span></tt> command to get rid of the <tt class="docutils literal"><span class="pre">O()</span></tt> term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">dt**2*w**3/24 + w</span>
</pre></div>
</div>
<p>Using this <tt class="docutils literal"><span class="pre">w_tilde_series</span></tt> expression
for <span class="math">\(\tilde w\)</span> in <a class="reference internal" href="#eq-vib-ode1-en"><em>(21)</em></a>,
dropping <span class="math">\(I\)</span> (which is a common factor), and performing a series
expansion of the error yields</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24 + dt**4*t**2*w**6*cos(t*w)/1152 + O(dt**6)</span>
</pre></div>
</div>
<p>Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in <span class="math">\(\Delta t\)</span>, which
goes most slowly to zero), we use the <tt class="docutils literal"><span class="pre">.as_leading_term(dt)</span></tt>
construction to pick out this term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24</span>
</pre></div>
</div>
<p>The last result
means that the leading order global (true) error at a point <span class="math">\(t\)</span>
is proportional to <span class="math">\(\omega^3t\Delta t^2\)</span>. Considering only the
discrete <span class="math">\(t_n\)</span> values for <span class="math">\(t\)</span>, <span class="math">\(t_n\)</span> is related
to <span class="math">\(\Delta t\)</span> through <span class="math">\(t_n=n\Delta t\)</span>. The factor
<span class="math">\(\sin(\omega t)\)</span> can at most be 1, so we use this value to
bound the leading-order expression to its maximum value</p>
<div class="math">
\[e^n = \frac{1}{24}n\omega^3\Delta t^3{\thinspace .}\]</div>
<p>This is the dominating term of the error <em>at a point</em>.</p>
<p>We are interested in the accumulated global error, which can
be taken as the <span class="math">\(\ell^2\)</span> norm of <span class="math">\(e^n\)</span>.
The norm is simply computed by summing contributions from all mesh
points:</p>
<div class="math">
\[||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2{\thinspace .}\]</div>
<p>The sum <span class="math">\(\sum_{n=0}^{N_t} n^2\)</span> is approximately equal to
<span class="math">\(\frac{1}{3}N_t^3\)</span>. Replacing <span class="math">\(N_t\)</span> by <span class="math">\(T/\Delta t\)</span> and taking
the square root gives the expression</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2{\thinspace .}\]</div>
<p>This is our expression for the global (or integrated) error.
The main result from this expression is that the global error
is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="stability">
<h2>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p>Looking at <a class="reference internal" href="#eq-vib-ode1-un-exact"><em>(20)</em></a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only <span class="math">\(\Delta t\)</span> is large
enough, the magnitude of the argument to <span class="math">\(\sin^{-1}\)</span> in
<a class="reference internal" href="#eq-vib-ode1-tildeomega"><em>(18)</em></a> may be larger than 1, i.e.,
<span class="math">\(\omega\Delta t/2 &gt; 1\)</span>. In this case, <span class="math">\(\sin^{-1}(\omega\Delta t/2)\)</span>
has a complex value and therefore <span class="math">\(\tilde\omega\)</span> becomes complex.
Type, for example, <tt class="docutils literal"><span class="pre">asin(x)</span></tt> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math">\(\sin^{-1} (x)\)</span>).</p>
<p>A complex <span class="math">\(\tilde\omega\)</span> can be written <span class="math">\(\tilde\omega = \tilde\omega_r +
i\tilde\omega_i\)</span>. Since <span class="math">\(\sin^{-1}(x)\)</span> has a <em>negative</em> imaginary part for
<span class="math">\(x&gt;1\)</span>, <span class="math">\(\tilde\omega_i &lt; 0\)</span>, which means that
<span class="math">\(e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t}\)</span>
will lead to exponential growth in time because
<span class="math">\(e^{-\tilde\omega_i t}\)</span> with <span class="math">\(\tilde\omega_i &lt;0\)</span> has a positive
exponent.</p>
<div class="admonition-stability-criterion admonition" id="index-27">
<p class="first admonition-title">Stability criterion</p>
<p class="last">We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em> so that
the argument in the inverse sine function leads
to real and not complex values of <span class="math">\(\tilde\omega\)</span>. The stability
criterion reads</p>
</div>
<div class="math" id="eq-auto8">
\[\tag{23}
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
       \Delta t \leq \frac{2}{\omega}
       {\thinspace .}\]</div>
<p>With <span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. Figure <a class="reference internal" href="#vib-ode1-dt-unstable"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></a>
displays what happens when <span class="math">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<div class="figure" id="vib-ode1-dt-unstable">
<a class="reference internal image-reference" href="_images/vib_unstable.png"><img alt="_images/vib_unstable.png" src="_images/vib_unstable.png" style="width: 400px;" /></a>
<p class="caption"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></p>
</div>
</div>
<div class="section" id="about-the-accuracy-at-the-stability-limit">
<h2>About the accuracy at the stability limit<a class="headerlink" href="#about-the-accuracy-at-the-stability-limit" title="Permalink to this headline">¶</a></h2>
<p>An interesting question is whether the stability condition
<span class="math">\(\Delta t &lt; 2/\omega\)</span> is unfortunate, or more precisely:
would it be meaningful to take larger time steps to speed up computations?
The answer is a clear no. At the stability limit, we have that
<span class="math">\(\sin^{-1}\omega\Delta t/2 = \sin^{-1} 1 = \pi/2\)</span>, and therefore
<span class="math">\(\tilde\omega = \pi/\Delta t\)</span>. (Note that the approximate formula
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a> is very inaccurate for this
value of <span class="math">\(\Delta t\)</span> as it predicts <span class="math">\(\tilde\omega = 2.34/pi\)</span>, which is
a 25 percent reduction.) The corresponding
period of the numerical solution
is <span class="math">\(\tilde P=2\pi/\tilde\omega = 2\Delta t\)</span>, which means that there is
just one time step <span class="math">\(\Delta t\)</span> between a peak (maximum)
and a <a class="reference external" href="https://simple.wikipedia.org/wiki/Wave_(physics)">through</a>
(minimum) in the
numerical solution. This is the shortest possible wave that can be
represented in the mesh! In other words, it is not meaningful to
use a larger time step than the stability limit.</p>
<p>Also, the error in angular frequency
when <span class="math">\(\Delta t = 2/\omega\)</span> is severe: Figure
<a class="reference internal" href="#vib-ode1-dt-stablimit"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></a> shows a comparison of the numerical and
analytical solution with <span class="math">\(\omega = 2\pi\)</span> and
<span class="math">\(\Delta t = 2/\omega = \pi^{-1}\)</span>. Already after one period, the
numerical solution has a through while the exact solution has a peak (!).
The error in frequency when <span class="math">\(\Delta t\)</span> is at the stability limit
becomes <span class="math">\(\omega - \tilde\omega = \omega(1-\pi/2)\approx -0.57\omega\)</span>.
The corresponding error in the period is <span class="math">\(P - \tilde P \approx 0.36P\)</span>.
The error after <span class="math">\(m\)</span> periods is then <span class="math">\(0.36mP\)</span>. This error has reached
half a period when <span class="math">\(m=1/(2\cdot 0.36)\approx 1.38\)</span>, which theoretically
confirms the observations in Figure <a class="reference internal" href="#vib-ode1-dt-stablimit"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></a>
that the numerical solution is a through ahead of a peak already after
one and a half period. Consequently, <span class="math">\(\Delta t\)</span> should be chosen much
less than the stability limit to achieve meaningful numerical computations.</p>
<div class="figure" id="vib-ode1-dt-stablimit">
<a class="reference internal image-reference" href="_images/vib_stability_limit.png"><img alt="_images/vib_stability_limit.png" src="_images/vib_stability_limit.png" style="width: 400px;" /></a>
<p class="caption"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></p>
</div>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>From the accuracy and stability
analysis we can draw three important conclusions:</p>
<ol class="last arabic simple">
<li>The key parameter in the formulas is <span class="math">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math">\(p=\omega\Delta t = 2\pi/N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math">\(N_P\)</span> is 2, showing that <span class="math">\(p\in (0,\pi]\)</span>.</li>
<li>Provided <span class="math">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</li>
<li>The ratio of the numerical angular frequency and the exact
one is
<span class="math">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
The error <span class="math">\(\frac{1}{24}p^2\)</span> leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference internal" href="._main_vib002.html#vib-exer-phase-err-growth"><em>Exercise 2: Show linear growth of the phase with time</em></a>).</li>
</ol>
</div>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<span id="vib-model2x2"></span><h1>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h1>
<p>A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then choose a
solution strategy from the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\]</div>
<p>we introduce the auxiliary variable <span class="math">\(v=u^{\prime}\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>:</p>
<div class="math" id="eq-vib-model2x2-ueq">
\[\tag{24}
u^{\prime} = v,\]</div>
<div class="math" id="eq-vib-model2x2-veq">
\[\tag{25}
v' = -\omega^2 u\]\[    {\thinspace .}\]</div>
<p>The initial conditions become <span class="math">\(u(0)=I\)</span> and <span class="math">\(v(0)=0\)</span>.</p>
<div class="section" id="the-forward-euler-scheme">
<h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Forward Euler approximation to our <span class="math">\(2\times 2\)</span> system of ODEs
<a class="reference internal" href="#eq-vib-model2x2-ueq"><em>(24)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-veq"><em>(25)</em></a>
becomes</p>
<div class="math" id="eq-auto9">
\[\tag{26}
\lbrack D_t^+ u = v\rbrack^n,
    \lbrack D_t^+ v = -\omega^2 u\rbrack^n,\]</div>
<p>or written out,</p>
<div class="math" id="eq-vib-undamped-fe1">
\[\tag{27}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-undamped-fe2">
\[\tag{28}
v^{n+1} = v^n -\Delta t \omega^2 u^n\]\[    {\thinspace .}\]</div>
<p>Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from <a class="reference internal" href="#eq-vib-undamped-fe1"><em>(27)</em></a> and
<a class="reference internal" href="#eq-vib-undamped-fe2"><em>(28)</em></a> applied at levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span> that</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}){\thinspace .}\]</div>
<p>Since from <a class="reference internal" href="#eq-vib-undamped-fe1"><em>(27)</em></a></p>
<div class="math">
\[v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),\]</div>
<p>it follows that</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},\]</div>
<p>which is very close to the centered difference scheme, but
the last term is evaluated at <span class="math">\(t_{n-1}\)</span> instead of <span class="math">\(t_n\)</span>.
Rewriting, so that <span class="math">\(\Delta t^2\omega^2u^{n-1}\)</span> appears alone on the
right-hand side, and then dividing
by <span class="math">\(\Delta t^2\)</span>, the new left-hand side is an approximation to
<span class="math">\(u^{\prime\prime}\)</span> at <span class="math">\(t_n\)</span>, while the right-hand side is sampled at <span class="math">\(t_{n-1}\)</span>.
All terms should be sampled at the same mesh point, so using
<span class="math">\(\omega^2 u^{n-1}\)</span> instead of <span class="math">\(\omega^2 u^n\)</span> points to a kind of
mathematical error in the derivation of the scheme. This error
turns out to be rather
crucial for the accuracy of
the Forward Euler method applied to vibration problems (the section <a class="reference internal" href="#vib-model2x2-compare"><em>Comparison of schemes</em></a> has examples).</p>
<p>The reasoning above does not imply that the Forward Euler scheme is not
correct, but more that it is almost equivalent to a second-order accurate
scheme for the second-order ODE formulation, and that the error
committed has to do with a wrong sampling point.</p>
</div>
<div class="section" id="the-backward-euler-scheme">
<h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Backward Euler approximation to the ODE system is equally easy to
write up in the operator notation:</p>
<div class="math" id="eq-auto10">
\[\tag{29}
\lbrack D_t^- u = v\rbrack^{n+1},\]</div>
<div class="math" id="eq-auto11">
\[\tag{30}
\lbrack D_t^- v = -\omega u\rbrack^{n+1} {\thinspace .}\]</div>
<p>This becomes a coupled system for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="eq-vib-undamped-be1">
\[\tag{31}
u^{n+1} - \Delta t v^{n+1} = u^{n},\]</div>
<div class="math" id="eq-vib-undamped-be2">
\[\tag{32}
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}\]\[    {\thinspace .}\]</div>
<p>We can compare <a class="reference internal" href="#eq-vib-undamped-be1"><em>(31)</em></a>-<a class="reference internal" href="#eq-vib-undamped-be2"><em>(32)</em></a> with
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
for the second-order differential equation.
To this end, we eliminate <span class="math">\(v^{n+1}\)</span> in <a class="reference internal" href="#eq-vib-undamped-be1"><em>(31)</em></a>
using <a class="reference internal" href="#eq-vib-undamped-be2"><em>(32)</em></a> solved with respect to <span class="math">\(v^{n+1}\)</span>.
Thereafter, we eliminate <span class="math">\(v^n\)</span> using <a class="reference internal" href="#eq-vib-undamped-be1"><em>(31)</em></a>
solved with respect to <span class="math">\(v^{n+1}\)</span> and also replacing <span class="math">\(n+1\)</span> by <span class="math">\(n\)</span> and
<span class="math">\(n\)</span> by <span class="math">\(n-1\)</span>.
The resulting equation involving only <span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span>
can be ordered as</p>
<div class="math">
\[\frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},\]</div>
<p>which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at <span class="math">\(u^{n+1}\)</span> and not <span class="math">\(u^n\)</span>. This inconsistent sampling
of terms has a dramatic effect on the numerical solution, as we
demonstrate in the section <a class="reference internal" href="#vib-model2x2-compare"><em>Comparison of schemes</em></a>.</p>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<span id="vib-undamped-cn"></span><h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<div class="math" id="eq-auto12">
\[\tag{33}
\lbrack D_t u = \overline{v}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math" id="eq-auto13">
\[\tag{34}
\lbrack D_t v = -\omega^2 \overline{u}^t\rbrack^{n+\frac{1}{2}}
    {\thinspace .}\]</div>
<p>Writing the equations out and rearranging terms,
shows that this is also a coupled system of two linear equations
at each time level:</p>
<div class="math" id="eq-auto14">
\[\tag{35}
u^{n+1} - \frac{1}{2}\Delta t v^{n+1} = u^{n} + \frac{1}{2}\Delta t v^{n},\]</div>
<div class="math" id="eq-auto15">
\[\tag{36}
v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} = v^{n}
    - \frac{1}{2}\Delta t \omega^2 u^{n}
    {\thinspace .}\]</div>
<p>We may compare also this scheme to the centered discretization of
the second-order ODE. It turns out that the Crank-Nicolson scheme is
equivalent to the discretization</p>
<div class="math" id="eq-vib-undamped-cn-equiv-utt">
\[\tag{37}
\frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2} = - \omega^2
    \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) = -\omega^2 u^{n} +
    {\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>That is, the Crank-Nicolson is equivalent to <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
for the second-order ODE, apart from an extra term of size
<span class="math">\(\Delta t^2\)</span>, but this is an error of the same order as in
the finite difference approximation on the left-hand side of the
equation anyway. The fact that the Crank-Nicolson scheme is so
close to <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> makes it a much better method than
the Forward or Backward Euler methods for vibration problems,
as will be illustrated in the section <a class="reference internal" href="#vib-model2x2-compare"><em>Comparison of schemes</em></a>.</p>
<p>Deriving <a class="reference internal" href="#eq-vib-undamped-cn-equiv-utt"><em>(37)</em></a> is a bit tricky.
We start with rewriting the Crank-Nicolson equations as follows</p>
<div class="math" id="eq-vib-undamped-cn3a">
\[\tag{38}
u^{n+1} - u^n = \frac{1}{2}\Delta t(v^{n+1} + v^n),\]</div>
<div class="math" id="eq-vib-undamped-cn4a">
\[\tag{39}
v^{n+1}  = v^n -\frac{1}{2}\Delta t\omega^2 (u^{n+1} + u^n),\]</div>
<p>and add the latter at the previous time level as well:</p>
<div class="math" id="eq-vib-undamped-cn4b1">
\[\tag{40}
v^{n}  = v^{n-1} -\frac{1}{2}\Delta t\omega^2(u^{n} + u^{n-1})\]</div>
<p>We can also rewrite <a class="reference internal" href="#eq-vib-undamped-cn3a"><em>(38)</em></a> at the previous time level
as</p>
<div class="math" id="eq-vib-undamped-cn4b">
\[\tag{41}
v^{n} + v^{n-1} = \frac{2}{\Delta t}(u^{n} - u^{n-1}){\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-vib-undamped-cn4a"><em>(39)</em></a> for <span class="math">\(v^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><em>(38)</em></a> and
<a class="reference internal" href="#eq-vib-undamped-cn4b1"><em>(40)</em></a> for <span class="math">\(v^{n}\)</span> in
<a class="reference internal" href="#eq-vib-undamped-cn3a"><em>(38)</em></a> yields after some reordering:</p>
<div class="math">
\[u^{n+1} - u^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^n + v^{n-1}){\thinspace .}\]</div>
<p>Now, <span class="math">\(v^n + v^{n-1}\)</span> can be eliminated by means of
<a class="reference internal" href="#eq-vib-undamped-cn4b"><em>(41)</em></a>. The result becomes</p>
<div class="math" id="eq-vib-undamped-cn5">
\[\tag{42}
u^{n+1} - 2u^n + u^{n-1} = -\Delta t^2\omega^2
    \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}){\thinspace .}\]</div>
<p>It can be shown that</p>
<div class="math">
\[\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + {\mathcal{O}(\Delta t^2)},\]</div>
<p>meaning that <a class="reference internal" href="#eq-vib-undamped-cn5"><em>(42)</em></a> is an approximation to
the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> for the second-order ODE where
the sampling error in the term <span class="math">\(\Delta t^2\omega^2 u^n\)</span> is of the same
order as the approximation errors in the finite differences, i.e.,
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. The Crank-Nicolson scheme written as
<a class="reference internal" href="#eq-vib-undamped-cn5"><em>(42)</em></a> therefore has consistent sampling of all
terms at the same time point <span class="math">\(t_n\)</span>.</p>
</div>
<div class="section" id="comparison-of-schemes">
<span id="vib-model2x2-compare"></span><h2>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h2>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c"># v, u numbering for EulerCromer to work well</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>  <span class="c"># u is array of length 2 holding our [v, u]</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a>
for details. Observe that keyword arguments in <tt class="docutils literal"><span class="pre">f(u,t,w=1)</span></tt> can
be supplied through a solver parameter <tt class="docutils literal"><span class="pre">f_kwargs</span></tt> (dictionary of
additional keyword arguments to <tt class="docutils literal"><span class="pre">f</span></tt>).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p id="index-28">The <tt class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></tt>
program makes two plots of the computed solutions with the various
methods in the <tt class="docutils literal"><span class="pre">solvers</span></tt> list: one plot with <span class="math">\(u(t)\)</span> versus <span class="math">\(t\)</span>, and
one <em>phase plane plot</em> where <span class="math">\(v\)</span> is plotted against <span class="math">\(u\)</span>.
That is, the phase plane plot is the curve <span class="math">\((u(t),v(t))\)</span> parameterized
by <span class="math">\(t\)</span>. Analytically, <span class="math">\(u=I\cos(\omega t)\)</span> and <span class="math">\(v=u^{\prime}=-\omega I\sin(\omega t)\)</span>.
The exact curve <span class="math">\((u(t),v(t))\)</span> is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that the exact curve <span class="math">\((u(t),v(t))\)</span> is
closed and repeats itself for every period. Not all numerical schemes
are capable of doing that, meaning that the amplitude instead shrinks or
grows with time.</p>
<p>Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><em>Comparison of classical schemes in the phase plane for two time step values</em></a> show the results. Note that
Odespy applies the label MidpointImplicit for what we have specified
as <tt class="docutils literal"><span class="pre">CrankNicolson</span></tt> in the code (<tt class="docutils literal"><span class="pre">CrankNicolson</span></tt> is just a synonym for
class <tt class="docutils literal"><span class="pre">MidpointImplicit</span></tt> in the Odespy code).
The Forward Euler scheme in Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><em>Comparison of classical schemes in the phase plane for two time step values</em></a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta"><em>Comparison of solution curves for classical schemes</em></a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.</p>
<div class="figure" id="vib-ode1-1st-odespy-theta-phaseplane">
<a class="reference internal image-reference" href="_images/vib_theta_1_pp.png"><img alt="_images/vib_theta_1_pp.png" src="_images/vib_theta_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><em>Comparison of classical schemes in the phase plane for two time step values</em></p>
</div>
<div class="figure" id="vib-ode1-1st-odespy-theta">
<a class="reference internal image-reference" href="_images/vib_theta_1_u.png"><img alt="_images/vib_theta_1_u.png" src="_images/vib_theta_1_u.png" style="width: 800px;" /></a>
<p class="caption"><em>Comparison of solution curves for classical schemes</em></p>
</div>
</div>
<div class="section" id="runge-kutta-methods">
<h2>Runge-Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>We may run two other popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a class="reference internal" href="#vib-ode1-1st-odespy-rk-phaseplane"><em>Comparison of Runge-Kutta schemes in the phase plane</em></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-rk"><em>Comparison of Runge-Kutta schemes</em></a> show the solutions with larger <span class="math">\(\Delta
t\)</span> values than what was used in the previous two plots.</p>
<div class="figure" id="vib-ode1-1st-odespy-rk-phaseplane">
<a class="reference internal image-reference" href="_images/vib_RK_1_pp.png"><img alt="_images/vib_RK_1_pp.png" src="_images/vib_RK_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><em>Comparison of Runge-Kutta schemes in the phase plane</em></p>
</div>
<div class="figure" id="vib-ode1-1st-odespy-rk">
<a class="reference internal image-reference" href="_images/vib_RK_1_u.png"><img alt="_images/vib_RK_1_u.png" src="_images/vib_RK_1_u.png" style="width: 800px;" /></a>
<p class="caption"><em>Comparison of Runge-Kutta schemes</em></p>
</div>
<p>The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, while the 2nd-order scheme suffers from amplitude errors
unless the time step is very small.</p>
<p>The corresponding results for the Crank-Nicolson scheme are shown in
Figure <a class="reference internal" href="#vib-ode1-1st-odespy-cn-long-phaseplane"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></a>.
It is clear that the Crank-Nicolson
scheme outperforms the 2nd-order Runge-Kutta method. Both schemes have
the same order of accuracy <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, but their differences
in the accuracy that matters in a real physical application is very
clearly pronounced in this example.  <a class="reference internal" href="._main_vib002.html#vib-exer-undamped-odespy"><em>Exercise 12: Investigate the amplitude errors of many solvers</em></a> invites you to investigate how the amplitude
is computed by a series of famous methods for first-order ODEs.</p>
<div class="figure" id="vib-ode1-1st-odespy-cn-long-phaseplane">
<a class="reference internal image-reference" href="_images/vib_CN_10_pp.png"><img alt="_images/vib_CN_10_pp.png" src="_images/vib_CN_10_pp.png" style="width: 800px;" /></a>
<p class="caption"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme">
<h2>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We may try to find exact solutions of the discrete
equations <a class="reference internal" href="#eq-vib-undamped-fe1"><em>(27)</em></a>-<a class="reference internal" href="#eq-vib-undamped-fe2"><em>(28)</em></a>
in the Forward Euler method to better understand why this
otherwise useful method has so bad performance for vibration
ODEs. An &#8220;ansatz&#8221; for the solution of the discrete equations
is</p>
<div class="math">
\[\begin{split}u^n &amp;= IA^n,\\
v^n &amp;= qIA^n,\end{split}\]</div>
<p>where <span class="math">\(q\)</span> and <span class="math">\(A\)</span> are scalars to be determined. We could have used a complex
exponential form <span class="math">\(e^{i\tilde\omega n\Delta t}\)</span> since we get
oscillatory solutions, but the oscillations grow in the Forward Euler
method, so the numerical frequency <span class="math">\(\tilde\omega\)</span> will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex <span class="math">\(A\)</span> and <span class="math">\(q\)</span> as introduced
above.</p>
<p>The Forward Euler scheme leads to</p>
<div class="math">
\[\begin{split}A &amp;= 1 + \Delta t q,\\
A &amp;= 1 - \Delta t\omega^2 q^{-1}{\thinspace .}\end{split}\]</div>
<p>We can easily eliminate <span class="math">\(A\)</span>, get <span class="math">\(q^2 + \omega^2=0\)</span>, and solve for</p>
<div class="math">
\[q = \pm i\omega,\]</div>
<p>which gives</p>
<div class="math">
\[A = 1 \pm \Delta t i\omega{\thinspace .}\]</div>
<p>We shall take the real part of <span class="math">\(A^n\)</span> as the solution. The two
values of <span class="math">\(A\)</span> are complex conjugates, and the real part of
<span class="math">\(A^n\)</span> will be the same for both roots. This is easy to realize if
we rewrite the complex numbers in polar form,
which is also convenient
for further analysis and understanding.
The polar form <span class="math">\(re^{i\theta}\)</span> of a complex number <span class="math">\(x+iy\)</span> has
<span class="math">\(r=\sqrt{x^2+y^2}\)</span> and <span class="math">\(\theta = \tan^{-1}(y/x)\)</span>.
Hence, the polar form of the two values for <span class="math">\(A\)</span> becomes</p>
<div class="math">
\[1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Now it is very easy to compute <span class="math">\(A^n\)</span>:</p>
<div class="math">
\[(1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Since <span class="math">\(\cos (\theta n) = \cos (-\theta n)\)</span>, the real parts of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.</p>
<p>The general solution is <span class="math">\(u^n = CA^n\)</span>, where
<span class="math">\(C\)</span> is a constant determined from the initial condition:
<span class="math">\(u^0=C=I\)</span>. We have <span class="math">\(u^n=IA^n\)</span> and
<span class="math">\(v^n=qIA^n\)</span>. The final solutions
are just the real part of the expressions in polar form:</p>
<div class="math" id="eq-auto16">
\[\tag{43}
u^n  =
    I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),\]</div>
<div class="math" id="eq-auto17">
\[\tag{44}
v^n =- \omega
    I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t)){\thinspace .}\]</div>
<p>The expression <span class="math">\((1+\omega^2\Delta t^2)^{n/2}\)</span> causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent <span class="math">\(n/2\)</span>. We can develop a series expression to better understand
the formula for the amplitude. Introducing <span class="math">\(p=\omega\Delta t\)</span> as the
key variable and using <tt class="docutils literal"><span class="pre">sympy</span></tt> gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 + n*p**2/2 + O(p**4)</span>
</pre></div>
</div>
<p>The amplitude goes like <span class="math">\(1 + \frac{1}{2} n\omega^2\Delta t^2\)</span>, clearly growing
linearly in time (with <span class="math">\(n\)</span>).</p>
<p>We can also investigate the error in the angular frequency by a
series expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">n*(p - p**3/3 + O(p**4))</span>
</pre></div>
</div>
<p>This means that the solution for <span class="math">\(u^n\)</span> can be written as</p>
<div class="math">
\[u^n = (1 + \frac{1}{2} n\omega^2\Delta t^2 + {\mathcal{O}(\Delta t^4)})
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + {\mathcal{O}(\Delta t^4)}\right)
{\thinspace .}\]</div>
<p>The error in the angular frequency is of the same order as in the
scheme <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> for the second-order ODE, but the error
in the amplitude is severe.</p>
</div>
</div>
<div class="section" id="energy-considerations">
<span id="vib-model1-energy"></span><h1>Energy considerations<a class="headerlink" href="#energy-considerations" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-29"></span><p id="index-30">The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,</p>
<div class="math">
\[E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2,\]</div>
<p>is <em>constant</em> for all <span class="math">\(t\)</span>. Checking that <span class="math">\(E(t)\)</span> really remains constant
brings evidence that the numerical computations are sound.
It turns out that <span class="math">\(E\)</span> is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations, so it is well invested time to
dive into this subject.</p>
<div class="section" id="derivation-of-the-energy-expression">
<span id="vib-model1-energy-expr"></span><h2>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h2>
<p>We start out with multiplying</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\]</div>
<p>by <span class="math">\(u^{\prime}\)</span> and integrating from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>:</p>
<div class="math">
\[\int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0{\thinspace .}\]</div>
<p>Observing that</p>
<div class="math">
\[u^{\prime\prime}u^{\prime} = \frac{d}{dt}\frac{1}{2}(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\frac{1}{2}}u^2,\]</div>
<p>we get</p>
<div class="math">
\[\int_0^T (\frac{d}{dt}\frac{1}{2}(u^{\prime})^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0)=0,\]</div>
<p>where we have introduced</p>
<div class="math" id="eq-vib-model1-energy-balance1">
\[\tag{45}
E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2{\thinspace .}\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math">
\[E(t) = E(0){\thinspace .}\]</div>
<div class="admonition-math-e-t-is-closely-related-to-the-system-s-energy admonition">
<p class="first admonition-title"><span class="math">\(E(t)\)</span> is closely related to the system&#8217;s energy</p>
<p>The quantity <span class="math">\(E(t)\)</span> derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton&#8217;s second law <span class="math">\(F=ma\)</span> (<span class="math">\(F\)</span> is the sum of forces, <span class="math">\(m\)</span>
is the mass of the system, and <span class="math">\(a\)</span> is the acceleration).
The displacement <span class="math">\(u\)</span> is related to <span class="math">\(a\)</span> through
<span class="math">\(a=u^{\prime\prime}\)</span>. With a spring force as the only force we have <span class="math">\(F=-ku\)</span>, where
<span class="math">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton&#8217;s second law then implies the differential equation</p>
<div class="math">
\[-ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0{\thinspace .}\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math">\(du=u^{\prime}dt\)</span> and integrate:</p>
<div class="math">
\[\int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0{\thinspace .}\]</div>
<p>The result is</p>
<div class="math">
\[\tilde E(t) = E_k(t) + E_p(t) = 0,\]</div>
<p class="last">where</p>
</div>
<div class="math" id="eq-vib-model1-energy-kinetic">
\[ \tag{46}
 E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},\]\[is the *kinetic energy* of the system, and\]\[.. _Eq:vib:model1:energy:potential:\]</div>
<div class="math">
\[ \tag{47}
 E_p(t) = {\frac{1}{2}}ku^2\]\[is the *potential energy*. The sum  \( \tilde E(t) \)  is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in the system, as we do in the section :ref:`vib:model2`.)\]\[The equation  \( mu^{\prime\prime}+ku=0 \)  can be divided by  \( m \)  and written as
 \( u^{\prime\prime} + \omega^2u=0 \)  for  \( \omega=\sqrt{k/m} \) . The energy expression
 \( E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2 \)  derived earlier is then
 \( \tilde E(t)/m \) , i.e., mechanical energy per unit mass.\]</div>
<div class="section" id="energy-of-the-exact-solution">
<h3>Energy of the exact solution<a class="headerlink" href="#energy-of-the-exact-solution" title="Permalink to this headline">¶</a></h3>
<p>Analytically, we have <span class="math">\(u(t)=I\cos\omega t\)</span>, if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>,
so we can easily check the energy evolution and confirm that <span class="math">\(E(t)\)</span>
is constant:</p>
<div class="math">
\[E(t) = {\frac{1}{2}}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="an-error-measure-based-on-energy">
<span id="vib-model1-energy-measure"></span><h2>An error measure based on energy<a class="headerlink" href="#an-error-measure-based-on-energy" title="Permalink to this headline">¶</a></h2>
<p>The constant energy is well expressed by its initial value <span class="math">\(E(0)\)</span>, so that
the error in mechanical energy can be computed as a mesh function by</p>
<div class="math" id="eq-auto18">
\[\tag{48}
e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
    + \frac{1}{2}\omega^2 (u^n)^2 - E(0),
    \quad n=1,\ldots,N_t-1,\]</div>
<p>where</p>
<div class="math">
\[E(0) = {\frac{1}{2}}V^2 + \frac{1}{2}\omega^2I^2,\]</div>
<p>if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=V\)</span>. Note that we have used
a centered approximation to <span class="math">\(u^{\prime}\)</span>: <span class="math">\(u^{\prime}(t_n)\approx
[D_{2t}u]^n\)</span>.</p>
<p>A useful norm of the mesh function <span class="math">\(e_E^n\)</span>
for the discrete mechanical energy
can be the maximum absolute value of <span class="math">\(e_E^n\)</span>:</p>
<div class="math">
\[\begin{split}||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|{\thinspace .}\end{split}\]</div>
<p>Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.</p>
<p>A vectorized Python implementation of <span class="math">\(e_E^n\)</span> takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <tt class="docutils literal"><span class="pre">e_E_norm</span></tt> can be used for verification.
The value of <tt class="docutils literal"><span class="pre">e_E_norm</span></tt> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the relative error in total energy for various schemes
(computed by the <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a>
program). The test problem is <span class="math">\(u^{\prime\prime} + 4\pi^2 u =0\)</span>
with <span class="math">\(u(0)=1\)</span> and <span class="math">\(u'(0)=0\)</span>, so the period is 1 and
<span class="math">\(E(t)\approx 4.93\)</span>. We clearly see that
the Crank-Nicolson and the Runge-Kutta schemes are superior to
the Forward and Backward Euler schemes already after one period.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="10%" />
<col width="17%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.678\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.235\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.076\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.214\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>However, after 10 periods, the picture is much more dramatic:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="11%" />
<col width="17%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.788\cdot 10^{4}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.250\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.288\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>The Runge-Kutta and Crank-Nicolson methods hardly change their
energy error with <span class="math">\(T\)</span>, while the error in the Forward Euler method grows
to huge levels and a relative error of 1 in the Backward Euler method
points to <span class="math">\(E(t)\rightarrow 0\)</span> as <span class="math">\(t\)</span> grows large.</p>
<p>Running multiple values of <span class="math">\(\Delta t\)</span>, we can get some insight into
the convergence of the energy error:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="11%" />
<col width="17%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.120\cdot 10^{8}\)</span></td>
</tr>
<tr class="row-odd"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.788\cdot 10^{4}\)</span></td>
</tr>
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(1.374\cdot 10^{2}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-even"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.000\cdot 10^{0}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(9.928\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(4.756\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.221\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(3.125\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.152\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.250\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(7.631\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(3.510\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(8.288\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(2.058\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>A striking fact from this table is that the error of the Forward Euler
method is reduced by the same factor as <span class="math">\(\Delta t\)</span> is reduced by,
while the error in the
Crank-Nicolson method has a reduction proportional to <span class="math">\(\Delta t^2\)</span> (we cannot
say anything for the Backward Euler method). However, for the RK2
method, halving <span class="math">\(\Delta t\)</span> reduces the error by almost a factor of 10
(!), and for the RK4 method the reduction seems proportional to
<span class="math">\(\Delta t^2\)</span> only (and the trend is confirmed by running smaller time
steps, so for <span class="math">\(\Delta t = 3.9\cdot 10^{-4}\)</span> the relative error of RK2
is a factor 10 smaller than that of RK4!).</p>
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<span id="vib-model2x2-eulercromer"></span><h1>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h1>
<p>While the Runge-Kutta methods and the
Crank-Nicolson scheme work well for the vibration equation modeled as a
first-order ODE system,
both were inferior to the straightforward centered
difference scheme for the second-order equation
<span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>. However, there is a similarly successful scheme
available for the first-order system <span class="math">\(u^{\prime}=v\)</span>, <span class="math">\(v'=-\omega^2u\)</span>, to be
presented next.</p>
<div class="section" id="forward-backward-discretization">
<span id="index-31"></span><h2>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h2>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as</p>
<div class="math" id="eq-auto19">
\[\tag{49}
\lbrack D_t^+u = v\rbrack^n,\]</div>
<div class="math" id="eq-auto20">
\[\tag{50}
\lbrack D_t^-v = -\omega^2 u\rbrack^{n+1}
    {\thinspace .}\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1">
\[\tag{51}
u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1">
\[\tag{52}
v^{n+1} = v^n -\Delta t \omega^2u^{n+1}\]\[    {\thinspace .}\]</div>
<p>We realize that after <span class="math">\(u^{n+1}\)</span> has been computed from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><em>(51)</em></a>, it may be used directly
in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><em>(52)</em></a> to compute <span class="math">\(v^{n+1}\)</span>.</p>
<p>In physics, it is more common to update the <span class="math">\(v\)</span> equation first, with
a forward difference, and thereafter the <span class="math">\(u\)</span> equation, with a backward
difference that applies the most recently computed <span class="math">\(v\)</span> value:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-veq1b">
\[\tag{53}
v^{n+1} = v^n -\Delta t \omega^2u^{n},\]</div>
<div class="math" id="eq-vib-model2x2-eulercromer-ueq1b">
\[\tag{54}
u^{n+1} = u^n + \Delta t v^{n+1}{\thinspace .}\]</div>
<p>The advantage of ordering the ODEs as in
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>
becomes evident
when considering complicated models. Such models are included if
we write our vibration ODE more generally as</p>
<div class="math">
\[u^{\prime\prime} + g(u, u^{\prime}, t)=0{\thinspace .}\]</div>
<p>We can rewrite this second-order ODE as two first-order ODEs,</p>
<div class="math">
\[\begin{split}v' &amp;= -g(u,v,t),\\
u^{\prime} &amp;= v{\thinspace .}\end{split}\]</div>
<p>This rewrite allows the following scheme to be used:</p>
<div class="math">
\[\begin{split}v^{n+1} &amp;= v^n -\Delta t\, g(u^n,v^n,t),\\
u^{n+1} &amp;= u^n + \Delta t\, v^{n+1}{\thinspace .}\end{split}\]</div>
<p>We realize that the first update works well with any <span class="math">\(g\)</span> since old
values <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span> are used. Switching the equations would
demand <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span> values in <span class="math">\(g\)</span> and result in nonlinear
algebraic equations to be solved at each time level.</p>
<p>The scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>
goes under several names: forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">semi-implicit Euler method</a>, semi-explicit Euler,
symplectic Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. This is explained below.</p>
<p>How does the Euler-Cromer method preserve the total energy?
We may run the example from the section <a class="reference internal" href="#vib-model1-energy-measure"><em>An error measure based on energy</em></a>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="12%" />
<col width="19%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert/e_E^0\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(2.530\cdot 10^{-2}\)</span></td>
</tr>
<tr class="row-odd"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(6.206\cdot 10^{-3}\)</span></td>
</tr>
<tr class="row-even"><td>Euler-Cromer</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.0125\)</span></td>
<td><span class="math">\(1.544\cdot 10^{-3}\)</span></td>
</tr>
</tbody>
</table>
<p>The relative error in the total energy decreases as <span class="math">\(\Delta t^2\)</span>,
and the error level is slightly lower than for the Crank-Nicolson and
Runge-Kutta methods.</p>
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<span id="vib-model2x2-eulercromer-equiv"></span><h2>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h2>
<p>We shall now show that the Euler-Cromer scheme for the system of
first-order equations is equivalent to the centered finite difference
method for the second-order vibration ODE (!).</p>
<p>We may eliminate the <span class="math">\(v^n\)</span> variable from
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><em>(51)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><em>(52)</em></a>
or
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>.
The <span class="math">\(v^{n+1}\)</span> term in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a> can
be eliminated from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>:</p>
<div class="math" id="eq-vib-model2x2-eulercromer-elim1">
\[\tag{55}
u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t u^n){\thinspace .}\]</div>
<p>The <span class="math">\(v^{n}\)</span> quantity can be expressed by <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>
using <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>:</p>
<div class="math">
\[v^{n} = \frac{u^n - u^{n-1}}{\Delta t},\]</div>
<p>and when this is inserted in <a class="reference internal" href="#eq-vib-model2x2-eulercromer-elim1"><em>(55)</em></a> we get</p>
<div class="math" id="eq-auto21">
\[\tag{56}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},\]</div>
<p>which is nothing but the centered scheme <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>!
The two seemingly different numerical methods are mathematically
equivalent. Consequently,
the previous analysis of
<a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> also applies to the Euler-Cromer
method. In particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
<a class="reference internal" href="#eq-vib-ode1-tildeomega-series"><em>(19)</em></a>. <a class="reference internal" href="._main_vib002.html#vib-exer-eulercromer-analysis"><em>Exercise 17: Analysis of the Euler-Cromer scheme</em></a>
gives guidance on how to derive the exact discrete solution of
the two equations in the Euler-Cromer method.</p>
<p>Although the Euler-Cromer scheme and the method <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> are
equivalent, there could be differences in the way they handle
the initial conditions. Let is look into this topic.
The initial condition <span class="math">\(u^{\prime}=0\)</span> means <span class="math">\(u^{\prime}=v=0\)</span>.  From
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a> we get</p>
<div class="math">
\[v^1=v^0-\Delta t\omega^2 u^0
=\Delta t\omega^2 u^0,\]</div>
<p>and from <a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>
it follows that</p>
<div class="math">
\[u^1=u^0 + \Delta t v^1 = u^0 - \omega^2\Delta t^2 u^0{\thinspace .}\]</div>
<p>When we previously used
a centered approximation of <span class="math">\(u^{\prime}(0)=0\)</span> combined with
the discretization <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a> of the second-order ODE, we
got a slightly different result:
<span class="math">\(u^1=u^0 - \frac{1}{2}\omega^2\Delta t^2 u^0\)</span>. The difference is
<span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>, which is of second order in
<span class="math">\(\Delta t\)</span>, seemingly consistent with the overall error in the scheme
for the differential equation model.</p>
<p>A different view can also be taken.
If we approximate <span class="math">\(u^{\prime}(0)=0\)</span> by a backward difference,
<span class="math">\((u^0-u^{-1})/\Delta t =0\)</span>, we get <span class="math">\(u^{-1}=u^0\)</span>, and when combined
with <a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>, it results in
<span class="math">\(u^1=u^0 - \omega^2\Delta t^2 u^0\)</span>. This means that
the Euler-Cromer method based on
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a>
corresponds to using only a first-order approximation to the initial condition
in the method from the section <a class="reference internal" href="#vib-ode1-fdm"><em>A centered finite difference scheme</em></a>.</p>
<p>Correspondingly, using the formulation
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1"><em>(51)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1"><em>(52)</em></a>
with <span class="math">\(v^n=0\)</span> leads to <span class="math">\(u^1=u^0\)</span>, which can be interpreted as using
a forward difference approximation for the initial condition <span class="math">\(u^{\prime}(0)=0\)</span>.
Both Euler-Cromer formulations lead to slightly different values for
<span class="math">\(u^1\)</span> compared to the method in the section <a class="reference internal" href="#vib-ode1-fdm"><em>A centered finite difference scheme</em></a>.
The error is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span> and of the same order
as the overall scheme.</p>
</div>
<div class="section" id="implementation-2">
<span id="vib-model2x2-eulercromer-impl"></span><h2>Implementation<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h2>
<p>The function below, found in <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_EulerCromer.py">vib_EulerCromer.py</a>, implements the Euler-Cromer scheme
<a class="reference internal" href="#eq-vib-model2x2-eulercromer-veq1b"><em>(53)</em></a>-<a class="reference internal" href="#eq-vib-model2x2-eulercromer-ueq1b"><em>(54)</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve v&#39; = - w**2*u, u&#39;=v for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span> (see the section <a class="reference internal" href="#vib-model2x2-eulercromer-equiv"><em>Equivalence with the scheme for the second-order ODE</em></a>), the performance of the above
<tt class="docutils literal"><span class="pre">solver</span></tt> function is the same as for the <tt class="docutils literal"><span class="pre">solver</span></tt> function in the section <a class="reference internal" href="#vib-impl1"><em>Implementation</em></a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><em>Exact discrete solution</em></a> is not a solution of the Euler-Cromer
scheme!</p>
<p>To verify the implementation of the Euler-Cromer method we
can adjust <tt class="docutils literal"><span class="pre">v[1]</span></tt> so that the computer-generated values can be
compared with the formula
<a class="reference internal" href="#eq-vib-ode1-un-exact"><em>(20)</em></a> from in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><em>Exact discrete solution</em></a>. This
adjustment is done in an alternative solver function, <tt class="docutils literal"><span class="pre">solver_ic_fix</span></tt>
in <tt class="docutils literal"><span class="pre">vib_EulerCromer.py</span></tt>. Since we now have an exact solution of the
discrete equations available, we can write a test function
<tt class="docutils literal"><span class="pre">test_solver</span></tt> for checking the equality of computed values with the
formula <a class="reference internal" href="#eq-vib-ode1-un-exact"><em>(20)</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test solver with fixed initial condition against</span>
<span class="sd">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c"># longest possible time step</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_ic_fix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>  <span class="c"># 2nd-order ODE</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Another function, <tt class="docutils literal"><span class="pre">demo</span></tt>,
visualizes the difference between the Euler-Cromer scheme and the scheme
<a class="reference internal" href="#eq-vib-ode1-step4"><em>(7)</em></a>
for the second-oder ODE, arising from the mismatch in the first time level.</p>
<p>The Euler-Cromer method is also available in the Odespy package.
The important thing to remember is that we must order the unknowns as
<span class="math">\(v\)</span> and <span class="math">\(u\)</span>, so the <tt class="docutils literal"><span class="pre">u</span></tt> vector at each time level consists of the
velocity <span class="math">\(v\)</span> as first component and the displacement <span class="math">\(u\)</span> as
second component:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Define ODE</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>

<span class="c"># Initialize solver</span>
<span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="kn">import</span> <span class="nn">odespy</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">I</span><span class="p">])</span>

<span class="c"># Compute time mesh</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># duration of one period</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Solve ODE</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Extract displacement</span>
</pre></div>
</div>
</div>
<div class="section" id="the-velocity-verlet-algorithm">
<h2>The velocity Verlet algorithm<a class="headerlink" href="#the-velocity-verlet-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Another very popular algorithm for vibration problems <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>
can be derived as follows. First, we step <span class="math">\(u\)</span> forward from <span class="math">\(t_n\)</span> to
<span class="math">\(t_{n+1}\)</span> using a three-term Taylor series,</p>
<div class="math">
\[u(t_{n+1}) = u(t_n) + u^{\prime}(t_n)\Delta t + \frac{1}{2}u^{\prime\prime}(t_n)\Delta t^2{\thinspace .}\]</div>
<p>Using <span class="math">\(u^{\prime}=v\)</span> and <span class="math">\(u^{\prime\prime}=-\omega^2u\)</span>, we get the updating formula</p>
<div class="math">
\[u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta t^2\omega^2u^n{\thinspace .}\]</div>
<p>Second, the first-order equation for <span class="math">\(v\)</span>,</p>
<div class="math">
\[v'=-\omega^2u,\]</div>
<p>is discretized by a centered difference
in a Crank-Nicolson fashion at <span class="math">\(t_{n+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = -\omega^2\frac{1}{2}(u^n + u^{n+1}){\thinspace .}\]</div>
<p>To summarize, we have the scheme</p>
<div class="math" id="eq-vib-model2x2-verlet-dueq">
\[\tag{57}
u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n\]</div>
<div class="math" id="eq-vib-model2x2-verlet-dveq">
\[\tag{58}
v^{n+1} = v^n -\frac{1}{2}\Delta t\omega^2 (u^n + u^{n+1}),\]</div>
<p>known as the <em>velocity Verlet</em> algorithm.
Observe that this scheme is explicit since <span class="math">\(u^{n+1}\)</span> in
<a class="reference internal" href="#eq-vib-model2x2-verlet-dveq"><em>(58)</em></a> is already computed
from <a class="reference internal" href="#eq-vib-model2x2-verlet-dueq"><em>(57)</em></a>.</p>
<p>The algorithm can be straightforwardly implemented as shown below (the
code appears in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_velocity_Verlet.py">vib_undamped_velocity_Verlet.py</a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">convergence_rates</span><span class="p">,</span> <span class="n">main</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">return_v</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39;=-w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by the velocity Verlet method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_v</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Return just u and t as in the vib_undamped.py&#39;s solver</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We provide the option that this <tt class="docutils literal"><span class="pre">solver</span></tt> function returns the same data
as the <tt class="docutils literal"><span class="pre">solver</span></tt> function from the section <a class="reference internal" href="#vib-impl1-solver"><em>Making a solver function</em></a> (if <tt class="docutils literal"><span class="pre">return_v</span></tt>
is <tt class="docutils literal"><span class="pre">False</span></tt>), but alternatively, it may return <tt class="docutils literal"><span class="pre">v</span></tt> along with <tt class="docutils literal"><span class="pre">u</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt>.</p>
<p>The error in the Taylor series expansion behind
<a class="reference internal" href="#eq-vib-model2x2-verlet-dueq"><em>(57)</em></a> is <span class="math">\({\mathcal{O}(\Delta t^3)}\)</span>, while the error
in the central difference for <span class="math">\(v\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.  The overall
error is then no better than <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, which can be verified
empirically using the <tt class="docutils literal"><span class="pre">convergence_rates</span></tt> function from
<a class="reference internal" href="#vib-ode1-verify"><em>Verification</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">vib_undamped_velocity_Verlet</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">convergence_rates</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
<span class="go">[2.0036366687367346, 2.0009497328124835, 2.000240105995295]</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference discretization</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-vibrations">A basic model for vibrations</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme">A centered finite difference scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#computing-the-first-step">Computing the first step</a></li>
<li><a class="reference internal" href="#the-computational-algorithm">The computational algorithm</a></li>
<li><a class="reference internal" href="#operator-notation">Operator notation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#computing">Computing <span class="math">\(u^{\prime}\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification</a><ul>
<li><a class="reference internal" href="#manual-calculation">Manual calculation</a></li>
<li><a class="reference internal" href="#testing-very-simple-polynomial-solutions">Testing very simple polynomial solutions</a></li>
<li><a class="reference internal" href="#checking-convergence-rates">Checking convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaled-model">Scaled model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#long-time-simulations">Long time simulations</a><ul>
<li><a class="reference internal" href="#using-a-moving-plot-window">Using a moving plot window</a></li>
<li><a class="reference internal" href="#making-animations">Making animations</a><ul>
<li><a class="reference internal" href="#producing-standard-video-formats">Producing standard video formats</a></li>
<li><a class="reference internal" href="#paying-png-files-in-a-web-browser">Paying PNG files in a web browser</a></li>
<li><a class="reference internal" href="#making-animated-gif-files">Making animated GIF files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-bokeh-to-compare-graphs">Using Bokeh to compare graphs</a></li>
<li><a class="reference internal" href="#using-a-line-by-line-ascii-plotter">Using a line-by-line ascii plotter</a></li>
<li><a class="reference internal" href="#empirical-analysis-of-the-solution">Empirical analysis of the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-numerical-scheme">Analysis of the numerical scheme</a><ul>
<li><a class="reference internal" href="#deriving-a-solution-of-the-numerical-scheme">Deriving a solution of the numerical scheme</a></li>
<li><a class="reference internal" href="#exact-discrete-solution">Exact discrete solution</a></li>
<li><a class="reference internal" href="#convergence">Convergence</a></li>
<li><a class="reference internal" href="#the-global-error">The global error</a></li>
<li><a class="reference internal" href="#stability">Stability</a></li>
<li><a class="reference internal" href="#about-the-accuracy-at-the-stability-limit">About the accuracy at the stability limit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">Alternative schemes based on 1st-order equations</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#comparison-of-schemes">Comparison of schemes</a></li>
<li><a class="reference internal" href="#runge-kutta-methods">Runge-Kutta methods</a></li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme">Analysis of the Forward Euler scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#energy-considerations">Energy considerations</a><ul>
<li><a class="reference internal" href="#derivation-of-the-energy-expression">Derivation of the energy expression</a><ul>
<li><a class="reference internal" href="#energy-of-the-exact-solution">Energy of the exact solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#an-error-measure-based-on-energy">An error measure based on energy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-method">The Euler-Cromer method</a><ul>
<li><a class="reference internal" href="#forward-backward-discretization">Forward-backward discretization</a></li>
<li><a class="reference internal" href="#equivalence-with-the-scheme-for-the-second-order-ode">Equivalence with the scheme for the second-order ODE</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation</a></li>
<li><a class="reference internal" href="#the-velocity-verlet-algorithm">The velocity Verlet algorithm</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_vib000.html"
                        title="previous chapter">Finite difference methods for vibration problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_vib002.html"
                        title="next chapter">Generalization: damping, nonlinear spring, and external excitation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_vib001.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_vib002.html" title="Generalization: damping, nonlinear spring, and external excitation"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_vib000.html" title="Finite difference methods for vibration problems"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;H. P. Langtangen.
  </div>
</div>

  </body>
</html>