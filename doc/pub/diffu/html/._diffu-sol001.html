<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for diffusion processes">
<meta name="keywords" content="diffusion equation, 1D,heat equation, 1D,stationary solution,explicit discretization methods,Forward Euler scheme,implicit discretization methods,amplification factor,energy estimates (diffusion)">

<title>Finite difference methods for diffusion processes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('An explicit method for the 1D diffusion equation',
               1,
               None,
               '___sec0'),
              ('The initial-boundary value problem for 1D diffusion',
               2,
               None,
               '___sec1'),
              ('Forward Euler scheme', 2, 'diffu:pde1:FE', 'diffu:pde1:FE'),
              ('Implementation',
               2,
               'diffu:pde1:FE:code',
               'diffu:pde1:FE:code'),
              ('Verification',
               2,
               'diffu:pde1:FE:verify',
               'diffu:pde1:FE:verify'),
              ('Numerical experiments',
               2,
               'diffu:pde1:FE:experiments',
               'diffu:pde1:FE:experiments'),
              ('Implicit methods for the 1D diffusion equation',
               1,
               None,
               '___sec6'),
              ('Backward Euler scheme', 2, 'diffu:pde1:BE', 'diffu:pde1:BE'),
              ('Sparse matrix implementation',
               2,
               'diffu:pde1:impl:sparse',
               'diffu:pde1:impl:sparse'),
              ('Crank-Nicolson scheme', 2, 'diffu:pde1:CN', 'diffu:pde1:CN'),
              ('The $\\theta$ rule',
               2,
               'diffu:pde1:theta',
               'diffu:pde1:theta'),
              ('Experiments',
               2,
               'diffu:pde1:theta:experiments',
               'diffu:pde1:theta:experiments'),
              ('The Laplace and Poisson equation', 2, None, '___sec12'),
              ('Analysis of schemes for the diffusion equation',
               1,
               'diffu:pde1:analysis',
               'diffu:pde1:analysis'),
              ('Properties of the solution',
               2,
               'diffu:pde1:analysis:uex',
               'diffu:pde1:analysis:uex'),
              ('Similarity solution', 3, None, '___sec15'),
              ('Solution for a Gaussian pulse', 3, None, '___sec16'),
              ('Solution for a sine component', 3, None, '___sec17'),
              ('Example: Diffusion of a discontinues profile',
               2,
               None,
               '___sec18'),
              ('Analysis of discrete equations', 2, None, '___sec19'),
              ('Analysis of the finite difference schemes',
               2,
               'diffu:pde1:analysis:details',
               'diffu:pde1:analysis:details'),
              ('Stability', 3, None, '___sec21'),
              ('Accuracy', 3, None, '___sec22'),
              ('Analysis of the Forward Euler scheme',
               2,
               'diffu:pde1:analysis:FE',
               'diffu:pde1:analysis:FE'),
              ('Stability', 3, None, '___sec24'),
              ('Accuracy', 3, None, '___sec25'),
              ('Analysis of the Backward Euler scheme',
               2,
               'diffu:pde1:analysis:BE',
               'diffu:pde1:analysis:BE'),
              ('Stability', 3, None, '___sec27'),
              ('Analysis of the Crank-Nicolson scheme',
               2,
               'diffu:pde1:analysis:CN',
               'diffu:pde1:analysis:CN'),
              ('Stability', 3, None, '___sec29'),
              ('Summary of accuracy of amplification factors',
               2,
               None,
               '___sec30'),
              ('Exercise 1: Explore symmetry in a 1D problem',
               2,
               'diffu:exer:1D:gaussian:symmetric',
               'diffu:exer:1D:gaussian:symmetric'),
              ('Exercise 2: Investigate approximation errors from a $u_x=0$ boundary condition',
               2,
               'diffu:exer:1D:ux:onesided',
               'diffu:exer:1D:ux:onesided'),
              ('Exercise 3: Experiment with open boundary conditions in 1D',
               2,
               'diffu:exer:1D:openBC',
               'diffu:exer:1D:openBC'),
              ('Exercise 4: Simulate a diffused Gaussian peak in 2D/3D',
               2,
               None,
               '___sec34'),
              ('Exercise 5: Examine stability of a diffusion model with a source term',
               2,
               'diffu:exer:uterm',
               'diffu:exer:uterm'),
              ('Diffusion in heterogeneous media', 1, None, '___sec36'),
              ('Stationary solution', 2, None, '___sec37'),
              ('Piecewise constant medium', 2, None, '___sec38'),
              ('Implementation', 2, None, '___sec39'),
              ('Diffusion equation in axi-symmetric geometries',
               2,
               'diffu:fd2:radial',
               'diffu:fd2:radial'),
              ('Diffusion equation in spherically-symmetric geometries',
               2,
               'diffu:fd2:spherical',
               'diffu:fd2:spherical'),
              ('Discretization in spherical coordinates',
               3,
               None,
               '___sec42'),
              ('Discretization in Cartesian coordinates',
               3,
               None,
               '___sec43'),
              ('Exercises', 1, None, '___sec44'),
              ('Exercise 6: Stabilizing the Crank-Nicolson method by Rannacher time stepping',
               2,
               'diffu:exer:CN:Rannacher',
               'diffu:exer:CN:Rannacher'),
              ('Project 7: Energy estimates for diffusion problems',
               2,
               'diffu:exer:energy:estimates',
               'diffu:exer:energy:estimates'),
              ('Bibliography', 1, None, '___sec47')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="diffu-sol.html">Finite difference methods for diffusion processes</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;">An explicit method for the 1D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">Implicit methods for the 1D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis" style="font-size: 80%;">Analysis of schemes for the diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;">Diffusion in heterogeneous media</a></li>
     <!-- navigation toc: --> <li><a href="#___sec44" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._diffu-sol002.html#___sec47" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0001"></a>
<!-- !split -->

<h1 id="___sec0">An explicit method for the 1D diffusion equation </h1>

<p>
The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2},
$$

where \( u(x,t) \) is the unknown function to be solved for, \( x \) is a coordinate
in space, and \( t \) is time. The coefficient \( \dfc \) is the <em>diffusion
coefficient</em> and determines how fast \( u \) changes in time. A quick
short form for the diffusion equation is \( u_t = \dfc u_{xx} \).

<p>
Compared to the wave equation, \( u_{tt}=c^2u_{xx} \), which looks very similar,
but the diffusion equation features solutions that are very different from
those of the wave equation. Also, the diffusion equation
makes quite different demands to the numerical
methods.

<p>
Typical diffusion problems may experience rapid change in the very
beginning, but then the evolution of \( u \) becomes slower and slower.
The solution is usually very smooth, and after some time, one cannot
recognize the initial shape of \( u \). This is in sharp contrast to solutions
of the wave equation where the initial shape is preserved - the solution
is basically a moving initial condition. The standard wave equation
\( u_{tt}=c^2u_{xx} \) has solutions that propagates with speed \( c \) forever,
without  changing shape, while the diffusion equation converges to
a <em>stationary solution</em> \( \bar u(x) \) as \( t\rightarrow\infty \). In this
limit, \( u_t=0 \), and \( \bar u \) is governed by \( \bar u''(x)=0 \).
This stationary limit of the diffusion equation is called
the <em>Laplace</em> equation and arises in a very wide range of applications
throughout the sciences.

<p>
It is possible to solve for \( u(x,t) \) using a explicit scheme,
but the time step restrictions soon become much less favorable than for
an explicit scheme for the wave equation. And of more importance,
since the solution \( u \) of the diffusion equation is very smooth and changes
slowly, small time steps are not convenient and not
required by accuracy as the diffusion process converges to a stationary
state.

<h2 id="___sec1">The initial-boundary value problem for 1D diffusion </h2>

<p>
To obtain a unique solution of the diffusion equation, or equivalently,
to apply numerical methods, we need initial and boundary conditions.
The diffusion equation goes with one initial condition \( u(x,0)=I(x) \), where
\( I \) is a prescribed function. One boundary condition is required at
each point on the boundary, which in 1D means that \( u \) must be known,
\( u_x \) must be known, or some combination of them.

<p>
We shall start
with the simplest boundary condition: \( u=0 \). The complete
initial-boundary value diffusion problem in one
space dimension can then be specified as

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2} + f, \quad x\in (0,L),\ t\in (0,T]
\tag{1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\tag{2}\\ 
u(0,t) & = 0, \quad  t>0,
\tag{3}\\ 
u(L,t) & = 0, \quad  t>0\tp
\tag{4}
\end{align}
$$

Equation <a href="#mjx-eqn-1">(1)</a> is known as a one-dimensional
<em>diffusion equation</em>, also often referred to as a
<em>heat equation</em>. With only a first-order derivative in time,
only one <em>initial condition</em> is needed, while the second-order
derivative in space leads to a demand for two <em>boundary conditions</em>.
The parameter \( \dfc \) must be given and is referred to as the
<em>diffusion coefficient</em>. We have added a source term \( f=f(x,t) \) for
convenience when testing implementations.

<p>
Diffusion equations like <a href="#mjx-eqn-1">(1)</a> have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
\( u(x,t) \) represents the temperature of some substance at point \( x \) and
time \( t \).

<h2 id="diffu:pde1:FE">Forward Euler scheme</h2>

<p>
The first step in the discretization procedure is to replace the
domain \( [0,L]\times [0,T] \) by a set of mesh points. Here we apply
equally spaced mesh points

$$
\begin{equation*} x_i=i\Delta x,\quad i=0,\ldots,N_x,\end{equation*}
$$

and

$$
\begin{equation*} t_n=n\Delta t,\quad n=0,\ldots,N_t \tp  \end{equation*}
$$

Moreover, \( u^n_i \) denotes the mesh function that
approximates \( u(x_i,t_n) \) for \( i=0,\ldots,N_x \) and \( n=0,\ldots,N_t \).
Requiring the PDE <a href="#mjx-eqn-1">(1)</a> to be fulfilled at a mesh point \( (x_i,t_n) \)
leads to the equation

$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n) + f(x_i,t_n),
\tag{5}
\end{equation}
$$

The next step is to replace the derivatives by finite difference approximations.
The computationally simplest method arises from
using a forward difference in time and a central difference in
space:

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u + f]^n_i \tp
\tag{6}
\end{equation}
$$

Written out,

$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{7}
\end{equation}
$$

We have turned the PDE into algebraic equations, also often called
discrete equations. The key property of the equations is that they
are algebraic, which makes them easy to solve.
As usual, we anticipate that \( u^n_i \) is already computed such that
\( u^{n+1}_i \) is the only unknown in <a href="#mjx-eqn-7">(7)</a>.
Solving with respect to this unknown is easy:

$$
\begin{equation}
u^{n+1}_i = u^n_i + F\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) + \Delta t f_i^n,
\tag{8}
\end{equation}
$$

where we have introduced the <em>mesh Fourier number</em>:

$$
\begin{equation}
F = \dfc\frac{\Delta t}{\Delta x^2}\tp
\tag{9}
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>\( F \) is the key parameter in the discrete diffusion equation.</b>
Note that \( F \) is a <em>dimensionless</em> number that lumps the key physical
parameter in the problem, \( \dfc \), and the discretization parameters
\( \Delta x \) and \( \Delta t \) into a single parameter. All the properties
of the numerical method are critically dependent upon the value of
\( F \) (see the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> for details).
</div>


<p>
The computational algorithm then becomes

<ol>
 <li> compute $u^0_i=I(x_i)$for \( i=0,\ldots,N_x \)</li>
 <li> for \( n=0,1,\ldots,N_t \):</li>

<ol>
   <li> apply <a href="#mjx-eqn-8">(8)</a> for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>

</ol>

The algorithm is compactly fully specified in Python:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
F <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
u   <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_1 <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
	       f(x[i], t[n])

    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1[:]<span style="color: #666666">=</span> u
</pre></div>
<p>
Note that we use <code>a</code> for \( \dfc \) in the code, motivated by easy visual
mapping between the variable name and the mathematical symbol in formulas.

<p>
We need to state already now that the shown algorithm does not
produce meaningful results unless \( F\leq 1/2 \). Why is explained in
the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a>.

<h2 id="diffu:pde1:FE:code">Implementation</h2>

<p>
The file <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a complete function <code>solver_FE_simple</code>
for solving the 1D diffusion equation with \( u=0 \) on the boundary
as specified in the algorithm above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE_simple</span>(I, a, f, L, dt, F, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Simplest expression of the computational algorithm</span>
<span style="color: #BA2121; font-style: italic">    using the Forward Euler method and explicit Python loops.</span>
<span style="color: #BA2121; font-style: italic">    f must be a Python function of x and t. If None, a</span>
<span style="color: #BA2121; font-style: italic">    default f=0 is used.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()

    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>

    <span style="color: #008000; font-weight: bold">if</span> f <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000">None</span>:
        f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, t: <span style="color: #666666">0</span>

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)
    u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
            u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
                   dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_1, u <span style="color: #666666">=</span> u, u_1

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #408080; font-style: italic"># Return u_1 as u since we set u_1=u above</span>
    <span style="color: #008000; font-weight: bold">return</span> u_1, x, t, t1<span style="color: #666666">-</span>t0
</pre></div>
<p>
A faster version, based on vectorization of the finite difference
scheme, is available in the function <code>solver_FE</code>.
The vectorized version replaces the explicit loop

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) \ 
           <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[i], t[n])
</pre></div>
<p>
by arithmetics on displaced slices of the <code>u</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
<span style="color: #408080; font-style: italic"># or</span>
u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>], t[n])
</pre></div>
<p>
For example,
the
vectorized version runs 70 times faster than the scalar version
in a case with 100 time steps and a spatial mesh of \( 10^5 \) cells.

<p>
The <code>solver_FE</code> function also features a callback function such that the
user can process the solution at each time level. The callback
function looks like <code>user_action(u, x, t, n)</code>, where <code>u</code> is the array
containing the solution at time level <code>n</code>, <code>x</code> holds all the
spatial mesh points, while <code>t</code> holds all the temporal mesh points.
Apart from the vectorized loop over the spatial mesh points, the
callback function, and a bit more complicated setting of the source
<code>f</code> it is not specified (<code>None</code>), the <code>solver_FE</code> is identical to
<code>solver_FE_simple</code> above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE</span>(I, a, f, L, dt, F, T,
              user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Vectorized implementation of solver_FE_simple.</span>
<span style="color: #BA2121; font-style: italic">    If version=&#39;vectorized&#39;, f must be a vectorized</span>
<span style="color: #BA2121; font-style: italic">    function of x and t (if f is None, a default version</span>
<span style="color: #BA2121; font-style: italic">    f=0 is made).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()

    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>

    <span style="color: #008000; font-weight: bold">if</span> f <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000">None</span>:
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, t: <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, t: np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(x))

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array</span>
    u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t-dt</span>

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_1, x, t, <span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Update all inner points</span>
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
                u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
                       dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;vectorized&#39;</span>:
            u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span>  \ 
                      F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
                      dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">ValueError</span>(<span style="color: #BA2121">&#39;version=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> version)

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, x, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
        <span style="color: #408080; font-style: italic">#u_1[:]= u</span>
        u_1, u <span style="color: #666666">=</span> u, u_1

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #408080; font-style: italic"># Return u_1 as solution since we set u_1=u above</span>
    <span style="color: #008000; font-weight: bold">return</span> u_1, x, t, t1<span style="color: #666666">-</span>t0
</pre></div>

<h2 id="diffu:pde1:FE:verify">Verification</h2>

<p>
Before thinking about running the functions in the previous section, we need to
construct a suitable test example for verification. It appears that
a manufactured solution
that is linear in time and at most quadratic in space fulfills
the Forward Euler scheme exactly. With the restriction that \( u=0 \) for \( x=0,L \),
we can try the solution

$$ u(x,t) = 5tx(L-x)\tp$$

Inserted in the PDE, it requires a source term

$$ f(x,t) = 10\dfc t + 5x(L-x)\tp$$

Let us check
that the manufactured <code>u</code> fulfills the scheme:

$$
\begin{align*}
\lbrack D_t^+ u = \dfc D_x D_x u + f\rbrack^n_i &=
\lbrack 5x(L-x)D_t^+ t  = 5 t\dfc D_x D_x (xL-x^2) +
10\dfc t + 5x(L-x)\rbrack^n_i\\ 
&=
\lbrack 5x(L-x)  = 5 t\dfc (-2) + 10\dfc t + 5x(L-x) \rbrack^n_i\tp
\end{align*}
$$

<p>
The computation of the source term, given any \( u \),
is easily automated with SymPy:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, t, a, L <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x t a L&#39;</span>)
u <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x)<span style="color: #666666">*5*</span>t

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">pde</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym<span style="color: #666666">.</span>diff(u, t) <span style="color: #666666">-</span> a<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x, x)

f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(pde(u))
</pre></div>
<p>
Now we can choose any expression for <code>u</code> and automatically
get the suitable source term <code>f</code>.

<p>
The numerical code will need to access the <code>u</code> and <code>f</code> above
as Python function. The exact solution is wanted as a Python
function <code>u_exact(x, t)</code>, while the source term is wanted as
<code>f(x, t)</code>. The parameters <code>a</code> and <code>L</code> in <code>u</code> and <code>f</code> above
are symbols and must be replaced by <code>float</code> objects in a Python
function. This can be done by redefining <code>a</code> and <code>L</code> as
<code>float</code> objects and performing substitutions of symbols by
numbers in <code>u</code> and <code>f</code>. The appropriate code looks like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
u_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], u<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
I <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: u_exact(x, <span style="color: #666666">0</span>)
</pre></div>
<p>
Here we also make a function <code>I</code> for the initial condition.

<p>
The idea now is that our manufactured solution should be
exactly reproduced by the code (to machine precision).
For this purpose we make a test function for comparing
the exact and numerical solutions at the end of the
time interval:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver_FE</span>():
    <span style="color: #408080; font-style: italic"># Define u_exact, f, I as explained above</span>

    dx <span style="color: #666666">=</span> L<span style="color: #666666">/3</span>  <span style="color: #408080; font-style: italic"># 3 cells</span>
    F <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    dt <span style="color: #666666">=</span> F<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE_simple(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE_simple: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, scalar: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;vectorized&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, vectorized: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff
</pre></div>
<p>
We emphasize that the value <code>F=0.5</code> is critical: the tests above
will fail if <code>F</code> has a larger value (this is because the Forward
Euler scheme is unstable for \( F>1/2 \)).

<h2 id="diffu:pde1:FE:experiments">Numerical experiments</h2>

<p>
When a test function like the one above runs silently without
errors, we have some evidence for a correct implementation of the
numerical method.
The next step is to do some experiments with more interesting solutions.

<p>
We target a scaled diffusion problem where \( x/L \) is a new spatial
coordinate and \( \dfc t/L^2 \) is a new time coordinate. The source term
\( f \) is omitted, and \( u \) is scaled by \( \max_{x\in [0,L]}|I(x)| \)
(see <a href="http://hplgit.github.io/scaling-book/doc/pub/book/sphinx/._book007.html" target="_self">Scaling of the diffusion equation</a> in <a href="._diffu-sol002.html#Langtangen_scaling">[1]</a> for details).
The governing PDE is then

$$ \frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2},$$

in the spatial domain \( [0,L] \), with boundary conditions \( u(0)=u(1)=0 \).
Two initial conditions will be tested: a discontinuous plug,

$$ I(x) = \left\lbrace\begin{array}{ll}
0, & |x-L/2| > 0.1\\ 
1, & \hbox{otherwise}
\end{array}\right.$$

and a smooth Gaussian function,

$$ I(x) = e^{-\frac{1}{2\sigma^2}(x-L/2)^2}\tp$$

The functions <code>plug</code> and <code>gaussian</code> in <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a> run the two cases,
respectively:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plug</span>(solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;solver_FE&#39;</span>, F<span style="color: #666666">=0.5</span>, dt<span style="color: #666666">=0.0002</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plug profile as initial condition.&quot;&quot;&quot;</span>
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span> <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>) <span style="color: #666666">&gt;</span> <span style="color: #666666">0.1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>

    u, cpu <span style="color: #666666">=</span> viz(I, a, <span style="color: #008000">None</span>, L, dt, F, T, umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
                 solver<span style="color: #666666">=</span>solver, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">gaussian</span>(solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;solver_FE&#39;</span>, F<span style="color: #666666">=0.5</span>, dt<span style="color: #666666">=0.0002</span>, sigma<span style="color: #666666">=0.1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Gaussian profile as initial condition.&quot;&quot;&quot;</span>
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>exp(<span style="color: #666666">-0.5*</span>((x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>sigma<span style="color: #666666">**2</span>)

    u, cpu <span style="color: #666666">=</span> viz(I, a, <span style="color: #008000">None</span>, L, dt, F, T, umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
                 solver<span style="color: #666666">=</span>solver, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
These functions make use of the function <code>viz</code> for running the
solver and visualizing the solution using a callback function
with plotting:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">viz</span>(I, a, f, L, dt, F, T, umin, umax,
        solver<span style="color: #666666">=</span><span style="color: #BA2121">&#39;solver_FE&#39;</span>, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>):

    solutions <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> plot, savefig

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_u</span>(u, x, t, n):
        <span style="color: #008000; font-weight: bold">if</span> n <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            <span style="color: #408080; font-style: italic"># Store x and t first in solutions</span>
            solutions<span style="color: #666666">.</span>append(x)
            solutions<span style="color: #666666">.</span>append(t)
        solutions<span style="color: #666666">.</span>append(u<span style="color: #666666">.</span>copy())
        plot(x, u, <span style="color: #BA2121">&#39;r-&#39;</span>, axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, L, umin, umax], title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n])
        <span style="color: #008000; font-weight: bold">if</span> framefiles:
            savefig(<span style="color: #BA2121">&#39;tmp_frame</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> n)
            <span style="color: #008000; font-weight: bold">if</span> n <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">10</span>, <span style="color: #666666">25</span>, <span style="color: #666666">50</span>, <span style="color: #666666">250</span>, <span style="color: #666666">500</span>]: savefig(<span style="color: #BA2121">&#39;tmp_frame</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.pdf&#39;</span> <span style="color: #666666">%</span> n)
        <span style="color: #008000; font-weight: bold">if</span> t[n] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">2</span>)
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #AA22FF; font-weight: bold">not</span> framefiles:
            <span style="color: #408080; font-style: italic"># It takes time to write files so pause is needed</span>
            <span style="color: #408080; font-style: italic"># for screen only animation</span>
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.2</span>)

    user_action <span style="color: #666666">=</span> plot_u <span style="color: #008000; font-weight: bold">if</span> animate <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">lambda</span> u,x,t,n: <span style="color: #008000">None</span>

    u, x, t, cpu <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(solver)(I, a, f, L, dt, F, T,
                                user_action<span style="color: #666666">=</span>user_action)
    <span style="color: #008000; font-weight: bold">return</span> solutions, cpu
</pre></div>
<p>
Notice that this <code>viz</code> function stores all the solutions in a
list <code>solutions</code> in the callback function. Modern computers have
hardly any problem with storing a lot of such solutions for moderate
values of \( N_x \) in 1D problems, but for 2D and 3D problems, this
technique cannot be used and solutions must be stored in files.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Better to show the scalable file solution here?)</font>
<!-- end inline comment -->

<p>
Our experiments employs a time step \( \Delta t = 0.0002 \) and
simulate for \( t\in [0,0.1] \). First we try the highest value of
\( F \): \( F=0.5 \). This resolution corresponds to
\( N_x=50 \). A possible terminal command is

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;from diffu1D_u0 import gaussian
&gt; gaussian(&quot;solver_FE&quot;, F=0.5, dt=0.0002)&#39;
</pre></div>
<p>
The \( u(x,t) \) curve as a function of \( x \) is shown
in Figure <a href="#diffu:pde1:FE:fig:F=0.5">1</a> at four time
levels.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<p>
We see that the curves have saw-tooth waves in the beginning of the
simulation. This non-physical noise is smoothed out with time, but
solutions of the diffusion equations are known to be smooth, and
this numerical solution is definitely not smooth.
Lowering \( F \) helps: \( F\leq 0.25 \) gives a smooth solution, see
Figure <a href="#diffu:pde1:FE:fig:F=0.25">2</a>.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<p>
Increasing \( F \) slightly beyond the limit 0.5, to \( F=0.51 \),
gives growing, non-physical instabilities,
as seen in Figure <a href="#diffu:pde1:FE:fig:F=0.51">3</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Forward Euler scheme for \( F=0.5 \). <div id="diffu:pde1:FE:fig:F=0.5"></div> </p></center>
<p><img src="fig-diffu/plug_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Forward Euler scheme for \( F=0.25 \). <div id="diffu:pde1:FE:fig:F=0.25"></div> </p></center>
<p><img src="fig-diffu/plug_FE_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Forward Euler scheme for \( F=0.51 \). <div id="diffu:pde1:FE:fig:F=0.51"></div> </p></center>
<p><img src="fig-diffu/plug_FE_F051.png" align="bottom" width=800></p>
</center>

<p>
Instead of a discontinuous initial condition we now try the smooth
Gaussian function for \( I(x) \). A simulation for \( F=0.5 \)
is shown in Figure <a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>. Now the numerical solution
is smooth for all times, and this is true for any \( F\leq 0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Forward Euler scheme for \( F=0.5 \). <div id="diffu:pde1:FE:fig:gauss:F=0.5"></div> </p></center>
<p><img src="fig-diffu/gaussian_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
Experiments with these two choices of \( I(x) \) reveal some
important observations:

<ul>
 <li> The Forward Euler scheme leads to growing solutions if \( F>\half \).</li>
 <li> \( I(x) \) as a discontinuous plug leads to a saw tooth-like noise
   for \( F=\half \), which is absent for \( F\leq\frac{1}{4} \).</li>
 <li> The smooth Gaussian initial function leads to a smooth solution
   for all relevant \( F \) values (\( F\geq \half \)).</li>
</ul>

<h1 id="___sec6">Implicit methods for the 1D diffusion equation </h1>

<p>
Simulations with the Forward Euler scheme shows that the time step
restriction, \( F\leq\half \), which means \( \Delta t \leq \Delta x^2/(2\dfc) \),
may be relevant in the beginning of the diffusion process, when the
solution changes quite fast, but as time increases, the process slows
down, and a small \( \Delta t \) may be inconvenient. By using
<em>implicit schemes</em>, which lead to a coupled system of linear equations
to be solved at each time level, any size of \( \Delta t \) is possible
(but the accuracy decreases with increasing \( \Delta t \)).
The Backward Euler scheme, derived and implemented below, is the
simplest implicit scheme for the diffusion equation.

<h2 id="diffu:pde1:BE">Backward Euler scheme</h2>

<p>
We now apply a backward difference in time in <a href="#mjx-eqn-5">(5)</a>,
but the same central difference in space:

$$
\begin{equation}
[D_t^- u = D_xD_x u + f]^n_i,
\tag{10}
\end{equation}
$$

which written out reads

$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{11}
\end{equation}
$$

Now we assume \( u^{n-1}_i \) is computed, but all quantities at the "new"
time level \( n \) are unknown. This time it is not possible to solve
with respect to \( u_i^{n} \) because this value couples to its neighbors
in space, \( u^n_{i-1} \) and \( u^n_{i+1} \), which are also unknown.
Let us examine this fact for the case when \( N_x=3 \). Equation <a href="#mjx-eqn-11">(11)</a> written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2} + f_1^n
\tag{12}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2} + f_2^n
\tag{13}
\end{align}
$$

The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero. Collecting the
unknown new values \( u^n_1 \) and \( u^n_2 \) on the left-hand side and multiplying
by \( \Delta t \) gives

$$
\begin{align}
\left(1+  2F\right) u^{n}_1 - F u^{n}_{2}    &= u^{n-1}_1 + \Delta t f_1^n,
\tag{14}\\ 
- F u^{n}_{1} + \left(1+  2F\right) u^{n}_2  &= u^{n-1}_2 + \Delta t f_2^n\tp
\tag{15}
\end{align}
$$

This is a coupled \( 2\times 2 \) system of algebraic equations for
the unknowns \( u^n_1 \) and \( u^n_2 \). The equivalent matrix form is

$$ \left(\begin{array}{cc}
1+  2F &   - F\\ 
- F    & 1+  2F
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_2
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1 + \Delta t f_1^n\\ 
u^{n-1}_2 + \Delta t f_2^n
\end{array}\right)
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Implicit vs. explicit methods.</b>
Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
<em>implicit methods</em>.
The counterpart, <em>explicit methods</em>, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.
</div>


<p>
In the general case, <a href="#mjx-eqn-11">(11)</a> gives rise to
a coupled \( (Nx-1)\times (Nx-1) \) system of algebraic equations for
all the unknown \( u^n_i \) at the interior spatial points \( i=1,\ldots,Nx-1 \).
Collecting the unknowns on the left-hand side,
<a href="#mjx-eqn-11">(11)</a> can be written

$$
\begin{equation}
- F u^n_{i-1} + \left(1+  2F \right) u^{n}_i - F u^n_{i+1} =
u_{i-1}^{n-1},
\tag{16}
\end{equation}
$$

for \( i=1,\ldots,Nx-1 \).
One can either view these equations as a system for where the
\( u^{n}_i \) values at the internal mesh points, \( i=1,\ldots,N_x-1 \), are
unknown, or we may append the boundary values \( u^n_0 \) and \( u^n_{N_x} \)
to the system. In the latter case, all \( u^n_i \) for \( i=0,\ldots,N_x \)
are unknown and we must add the boundary equations to
the \( N_x-1 \) equations in <a href="#mjx-eqn-16">(16)</a>:

$$
\begin{align}
u_0^n &= 0,label{diffu:pde1:step4BE:BC:0}\\ 
u_{N_x}^n &= 0\tp
\tag{18}
\end{align}
$$

<p>
A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations <a href="#mjx-eqn-16">(16)</a>
and <a href="#mjx-eqn-17">(17)</a>--<a href="#mjx-eqn-18">(18)</a>
correspond to the matrix equation

$$
\begin{equation*} AU = b\end{equation*}
$$

where \( U=(u^n_0,\ldots,u^n_{N_x}) \), and
the matrix \( A \) has the following structure:

$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & 0 & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\tag{19}
\end{equation}
$$

The nonzero elements are given by

$$
\begin{align}
A_{i,i-1} &= -F
\tag{20}\\ 
A_{i,i} &= 1+ 2F
\tag{21}\\ 
A_{i,i+1} &= -F
\tag{22}
\end{align}
$$

for the equations for internal points, \( i=1,\ldots,N_x-1 \). The equations
for the boundary points correspond to

$$
\begin{align}
A_{0,0} &= 1,
\tag{23}\\ 
A_{0,1} &= 0,
\tag{24}\\ 
A_{N_x,N_x-1} &= 0,
\tag{25}\\ 
A_{N_x,N_x} &= 1\tp
\tag{26}
\end{align}
$$

The right-hand side \( b \) is written as

$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\tag{27}
\end{equation}
$$

with

$$
\begin{align}
b_0 &= 0,
\tag{28}\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1,
\tag{29}\\ 
b_{N_x} &= 0 \tp   \tag{30}
\end{align}
$$

<p>
We observe that the matrix \( A \) contains quantities that do not change
in time. Therefore, \( A \) can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side \( b \), however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
u   <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_1 <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Data structures for the linear system</span>
A <span style="color: #666666">=</span> zeros((Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>))
b <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    A[i,i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[Nx,Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute b and solve linear system</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        b[i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>u_1[i]
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1[:] <span style="color: #666666">=</span> u
</pre></div>

<h2 id="diffu:pde1:impl:sparse">Sparse matrix implementation</h2>

<p>
We have seen from <a href="#mjx-eqn-19">(19)</a> that the matrix \( A \)
is tridiagonal. The code segment above used a full, dense matrix
representation of \( A \), which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these zeros.
With \( N_x+1 \) unknowns, the work by the solution algorithm is \( \frac{1}{3}
(N_x+1)^3 \) and the storage requirements \( (N_x+1)^2 \). By utilizing
the fact that \( A \) is tridiagonal and employing corresponding software
tools, the work and storage demands can be proportional to \( N_x \) only.

<p>
The key idea is to apply a data structure for a
tridiagonal or sparse matrix. The <code>scipy.sparse</code> package has
relevant utilities. For example, we can store the nonzero diagonals of
a matrix. The package also has linear system solvers that operate on
sparse matrix data structures. The code below illustrates how we
can store only the main diagonal and the upper and lower diagonals.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
main  <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)
lower <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">-1</span>)
upper <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">-1</span>)
b     <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Precompute sparse matrix</span>
main[:] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
lower[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F  <span style="color: #408080; font-style: italic">#1</span>
upper[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F  <span style="color: #408080; font-style: italic">#1</span>
<span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
main[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
main[Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
    diagonals<span style="color: #666666">=</span>[main, lower, upper],
    offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>], shape<span style="color: #666666">=</span>(Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>),
    format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span> A<span style="color: #666666">.</span>todense()  <span style="color: #408080; font-style: italic"># Check that A is correct</span>

<span style="color: #408080; font-style: italic"># Set initial condition</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    b <span style="color: #666666">=</span> u_1
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>  <span style="color: #408080; font-style: italic"># boundary conditions</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
    u_1[:] <span style="color: #666666">=</span> u
</pre></div>
<p>
The <code>scipy.sparse.linalg.spsolve</code> function utilizes the sparse storage
structure of <code>A</code> and performs in this case a very efficient Gaussian
elimination solve.

<p>
The program <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a function <code>solver_BE</code>, which implements the Backward Euler scheme
sketched above.
As mentioned in the section <a href="#diffu:pde1:FE">Forward Euler scheme</a>,
the functions <code>plug</code> and <code>gaussian</code>
runs the case with \( I(x) \) as a discontinuous plug or a smooth
Gaussian function. All experiments point to two characteristic
features of the Backward Euler scheme: 1) it is always stable, and
2) it always gives a smooth, decaying solution.

<h2 id="diffu:pde1:CN">Crank-Nicolson scheme</h2>

<p>
The idea in the Crank-Nicolson scheme is to apply centered
differences in space and time, combined with an average in time.
We demand the PDE to be fulfilled at the spatial mesh points, but
in between the points in the time mesh:

$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half}) + f(x_i,t_{n+\half}),
$$

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
With centered differences in space and time, we get

$$ [D_t u = \dfc D_xD_x u + f]^{n+\half}_i\tp$$

On the right-hand side we get an expression

$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right) + f_i^{n+\half}\tp$$

This expression is problematic since \( u^{n+\half}_i \) is not one of
the unknown we compute. A possibility is to replace \( u^{n+\half}_i \)
by an arithmetic average:

$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)\tp
$$

In the compact notation, we can use the arithmetic average
notation \( \overline{u}^t \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + f]^{n+\half}_i\tp$$

We can also use an average for \( f_i^{n+\half} \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + \overline{f}^t]^{n+\half}_i\tp$$

<p>
After writing out the differences and average, multiplying by \( \Delta t \),
and collecting all unknown terms on the left-hand side, we get

$$
\begin{align}
u^{n+1}_i - \half F(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
&= u^{n}_i + \half F(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})\nonumber\\ 
&\qquad \half f_i^{n+1} + \half f_i^n\tp
\tag{31}
\end{align}
$$

<p>
Also here, as in the Backward Euler scheme, the new unknowns
\( u^{n+1}_{i-1} \), \( u^{n+1}_{i} \), and \( u^{n+1}_{i+1} \) are coupled
in a linear system \( AU=b \), where \( A \) has the same structure
as in <a href="#mjx-eqn-19">(19)</a>, but with slightly
different entries:

$$
\begin{align}
A_{i,i-1} &= -\half F
\tag{32}\\ 
A_{i,i} &= \half + F
\tag{33}\\ 
A_{i,i+1} &= -\half F
\tag{34}
\end{align}
$$

for the equations for internal points, \( i=1,\ldots,N_x-1 \). The equations
for the boundary points correspond to

$$
\begin{align}
A_{0,0} &= 1,
\tag{35}\\ 
A_{0,1} &= 0,
\tag{36}\\ 
A_{N_x,N_x-1} &= 0,
\tag{37}\\ 
A_{N_x,N_x} &= 1\tp
\tag{38}
\end{align}
$$

The right-hand side \( b \) has entries

$$
\begin{align}
b_0 &= 0,
\tag{39}\\ 
b_i &= u^{n-1}_i + \half(f_i^n + f_i^{n+1}),\quad i=1,\ldots,N_x-1,
\tag{40}\\ 
b_{N_x} &= 0 \tp   \tag{41}
\end{align}
$$

<h2 id="diffu:pde1:theta">The \( \theta \) rule</h2>

<p>
For the equation

$$ \frac{\partial u}{\partial t} = G(u),$$

where \( G(u) \) is some
a spatial differential operator, the \( \theta \)-rule
looks like

$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} =
\theta G(u^{n+1}_i) + (1-\theta) G(u^{n}_i)\tp$$

The important feature of this time discretization scheme is that
we can implement one formula and then generate a family of
well-known and widely used schemes:

<ul>
 <li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>

Applied to the 1D diffusion problem, the \( \theta \)-rule gives

$$
\begin{align*}
\frac{u^{n+1}_i-u^n_i}{\Delta t} &=
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)\\ 
&\qquad + \theta f_i^{n+1} + (1-\theta)f_i^n
\tp
\end{align*}
$$

This scheme also leads to a matrix system with entries

$$ A_{i,i-1} = -F\theta,\quad A_{i,i} = 1+2F\theta\quad,
A_{i,i+1} = -F\theta,$$

while right-hand side entry \( b_i \) is

$$ b_i = u^n_{i} + F(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} +
\Delta t\theta f_i^{n+1} + \Delta t(1-\theta)f_i^n\tp
$$

The corresponding entries for the boundary points are as in the Backward
Euler and Crank-Nicolson schemes listed earlier.

<h2 id="diffu:pde1:theta:experiments">Experiments</h2>

<p>
We can repeat the experiments from the section <a href="#diffu:pde1:FE:experiments">Numerical experiments</a>
to see if the Backward Euler or Crank-Nicolson schemes have problems
with sawtooth-like noise when starting with a discontinuous initial
condition. We can also verify that we can have \( F>\half \),
which in practice often means choosing larger time steps.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Backward Euler scheme for \( F=0.5 \). <div id="diffu:pde1:BE:fig:F=0.5"></div> </p></center>
<p><img src="fig-diffu/plug_BE_F05.png" align="bottom" width=800></p>
</center>

<p>
The Backward Euler scheme always produces smooth solutions for any \( F \).
Figure <a href="#diffu:pde1:BE:fig:F=0.5">5</a> shows one example.
The Crank-Nicolson method produces smooth solutions for small \( F \),
\( F\leq\half \), but small noise is more and more evident as \( F \)
increases. Figures <a href="#diffu:pde1:CN:fig:F=3">6</a> and <a href="#diffu:pde1:CN:fig:F=10">7</a>
demonstrates the effect for \( F=3 \) and \( F=10 \), respectively.
The section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> explains why such noise occur.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Crank-Nicolson scheme for \( F=3 \). <div id="diffu:pde1:CN:fig:F=3"></div> </p></center>
<p><img src="fig-diffu/plug_CN_F3.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Crank-Nicolson scheme for \( F=10 \). <div id="diffu:pde1:CN:fig:F=10"></div> </p></center>
<p><img src="fig-diffu/plug_CN_F10.png" align="bottom" width=800></p>
</center>

<h2 id="___sec12">The Laplace and Poisson equation </h2>

<p>
The Laplace equation, \( \nabla^2 u = 0 \), or the Poisson equation,
\( -\nabla^2 u = f \), occur in numerous applications throughout science and
engineering. In 1D these equations read
\( u''(x)=0 \) and \( -u''(x)=f(x) \), respectively.
We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret \( u_{xx}=0 \) as the limiting solution
of \( u_t = \dfc u_{xx} \) when \( u \) reach a steady state limit where
\( u_t\rightarrow 0 \).
Similarly, Poisson's equation \( -u_{xx}=f \) arises from solving
\( u_t = u_{xx} + f \) and letting \( t\rightarrow \) so \( u_t\rightarrow 0 \).

<p>
Technically in a program, we can simulate \( t\rightarrow\infty \)
by just taking one large time step:
\( \Delta t\rightarrow\infty \). In the limit the Backward Euler
scheme gives

$$ -\frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = f^{n+1}_i,$$

which is nothing but the discretization \( [-D_xD_x u = f]^{n+1}_i=0 \) of
\( -u_{xx}=f \).

<p>
The result above means that
the Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since \( \Delta t >
\Delta x^2/\dfc \)
is illegal and leads to instability.
We may interpret this time stepping
as solving the equation system from \( -u_{xx}=f \) by iterating on a time
pseudo time variable.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 2</b>: Better to say the last sentence when we treat iterative methods.)</font>
<!-- end inline comment -->

<h1 id="diffu:pde1:analysis">Analysis of schemes for the diffusion equation</h1>

<p>
The numerical experiments in the sections <a href="#diffu:pde1:theta:experiments">Experiments</a>
and <a href="#diffu:pde1:FE:experiments">Numerical experiments</a> reveal that there are some
numerical problems with the Forward Euler and Crank-Nicolson schemes:
sawtooth-like noise is sometimes present in solutions that are,
from a mathematical point of view, expected to be smooth.
This section presents a mathematical analysis that explains the
observed behavior and arrives at criteria for obtaining numerical
solutions that reproduce the qualitative properties of the exact
solutions. In short, we shall explain what is observed in
Figures <a href="#diffu:pde1:FE:fig:F=0.5">1</a>,
<a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>,
<a href="#diffu:pde1:FE:fig:F=0.25">2</a>,
<a href="#diffu:pde1:FE:fig:F=0.51">3</a>,
<a href="#diffu:pde1:BE:fig:F=0.5">5</a>,
<a href="#diffu:pde1:CN:fig:F=3">6</a>,
and
<a href="#diffu:pde1:CN:fig:F=10">7</a>.

<h2 id="diffu:pde1:analysis:uex">Properties of the solution</h2>

<p>
A particular characteristic of diffusive processes, governed
by an equation like

$$
\begin{equation}
u_t = \alpha u_{xx},
\tag{42}
\end{equation}
$$

is that the
initial shape \( u(x,0)=I(x) \) spreads out in space with time,
along with a decaying amplitude.
Three different examples will illustrate the spreading of \( u \) in
space and the decay in time.

<h3 id="___sec15">Similarity solution </h3>

<p>
The diffusion equation <a href="#mjx-eqn-42">(42)</a> admits solutions
that depend on \( \eta = (x-c)/\sqrt{4\alpha t} \) for a given value
of \( c \). One particular solution
is

$$
\begin{equation}
u(x,t) = a\,\mbox{erf}(\eta) + b,
\tag{43}
\end{equation}
$$

where

$$
\begin{equation}
\mbox{erf}(\eta) = \frac{2}{\sqrt{\pi}}\int_0^\eta e^{-\zeta^2}d\zeta,
\tag{44}
\end{equation}
$$

is the <em>error function</em>, and \( a \) and \( b \) are arbitrary constants.
The error function lies in \( (-1,1) \), is odd around \( \eta =0 \), and
goes relatively quickly to \( \pm 1 \):

$$
\begin{align*}
\lim_{\eta\rightarrow -\infty}\mbox{erf}(\eta) &=-1,\\ 
\lim_{\eta\rightarrow \infty}\mbox{erf}(\eta) &=1,\\ 
\mbox{erf}(\eta) &= -\mbox{erf}(-\eta),\\ 
\mbox{erf}(0) &=0,\\ 
\mbox{erf}(2) &=0.99532227,\\ 
\mbox{erf}(3) &=0.99997791
\tp
\end{align*}
$$

<p>
As \( t\rightarrow 0 \), the error function approaches a step function centered
at \( x=c \). For a diffusion problem posed on the unit interval \( [0,1] \),
we may choose the step at \( x=1/2 \) (meaning \( c=1/2 \)), \( a=-1/2 \), \( b=1/2 \).
Then

$$
\begin{equation}
u(x,t) = \half\left(1 -
\mbox{erf}\left(\frac{x-\half}{\sqrt{4\alpha t}}\right)\right) =
\half\mbox{erfc}\left(\frac{x-\half}{\sqrt{4\alpha t}}\right),
\tag{45}
\end{equation}
$$

where we have introduced the <em>complementary error function</em>
\( \mbox{erfc}(\eta) = 1-\mbox{erf}(\eta) \).
The solution <a href="#mjx-eqn-45">(45)</a>
implies the boundary conditions

$$
\begin{align}
u(0,t) &= \half\left(1 - \mbox{erf}\left(\frac{-1/2}{\sqrt{4\alpha t}}\right)\right),
\tag{46} \\ 
u(1,t) &= \half\left(1 - \mbox{erf}\left(\frac{1/2}{\sqrt{4\alpha t}}\right)\right)
\tag{47}
\tp
\end{align}
$$

For small enough \( t \), \( u(0,t)\approx 1 \) and \( u(1,t)\approx 1 \), but as
\( t\rightarrow\infty \), \( u(x,t)\rightarrow 1/2 \) on \( [0,1] \).

<h3 id="___sec16">Solution for a Gaussian pulse </h3>

<p>
The standard diffusion equation \( u_t = \alpha u_{xx} \) admits a
Gaussian function as solution:

$$
\begin{equation}
u(x,t) = \frac{1}{\sqrt{4\pi\alpha t}} \exp{\left({-\frac{(x-c)^2}{4\alpha t}}\right)}
\tag{48}
\tp
\end{equation}
$$

At \( t=0 \) this is a Dirac delta function, so for computational
purposes one must start to view the solution at some time \( t=t_\epsilon>0 \).
Replacing \( t \) by \( t_\epsilon +t \) in <a href="#mjx-eqn-48">(48)</a>
makes it easy to operate with a (new) \( t \) that starts at \( t=0 \)
with an initial condition with a finite width.
The important feature of <a href="#mjx-eqn-48">(48)</a> is that
the standard deviation \( \sigma \) of a sharp initial Gaussian pulse
increases in time according to \( \sigma = \sqrt{2\alpha t} \), making
the pulse diffuse and flatten out.

<p>
<!-- Mention combinations of such kernels to build up a general analytical sol? -->
<!-- Or maybe an exercise for verification. -->

<h3 id="___sec17">Solution for a sine component </h3>

<p>
For example, <a href="#mjx-eqn-42">(42)</a>
admits a solution of the form

$$
\begin{equation}
u(x,t) = Qe^{-at}\sin\left( kx\right)
\tag{49}
\tp
\end{equation}
$$

The parameters \( Q \) and \( k \) can be freely chosen, while
inserting <a href="#mjx-eqn-49">(49)</a> in <a href="#mjx-eqn-42">(42)</a> gives the constraint

$$
\begin{equation*} a = -\alpha k^2
\tp
\end{equation*}
$$

<p>
A very important feature is that the initial shape \( I(x)=Q\sin kx \)
undergoes a damping \( \exp{(-\alpha k^2t)} \), meaning that
rapid oscillations in space, corresponding to large \( k \), are very much
faster dampened than slow oscillations in space, corresponding to small
\( k \). This feature leads to a smoothing of the initial condition with time.

<p>
The following examples illustrates the damping properties of <a href="#mjx-eqn-49">(49)</a>. We consider the specific problem

$$
\begin{align*}
u_t &= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\ 
u(0,t) &= u(1,t) = 0,\quad t\in (0,T],\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\tp
\end{align*}
$$

The initial condition has been chosen such that adding
two solutions like <a href="#mjx-eqn-49">(49)</a> constructs
an analytical solution to the problem:

$$
\begin{equation}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
\tag{50}
\tp
\end{equation}
$$

Figure <a href="#diffu:pde1:fig:damping">8</a> illustrates the rapid damping of
rapid oscillations \( \sin (100\pi x) \) and the very much slower damping of the
slowly varying \( \sin (\pi x) \) term. After about \( t=0.5\cdot10^{-4} \) the rapid
oscillations do not have a visible amplitude, while we have to wait
until \( t\sim 0.5 \) before the amplitude of the long wave \( \sin (\pi x) \)
becomes very small.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right). <div id="diffu:pde1:fig:damping"></div> </p></center>
<p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p>
</center>

<p>
<!-- x/sqrt(t) solution, kernel with integral -->

<h2 id="___sec18">Example: Diffusion of a discontinues profile </h2>

<p>
We shall see how different schemes predict the evolution of a
discontinuous initial condition:

$$
u(x,0)=\left\lbrace
\begin{array}{ll}
U_L, & x < L/2\\ 
U_R,& x\geq L/2
\end{array}\right.
$$

Such a discontinuous initial condition may arise when two insulated
blocks of metals at different temperature are brought in contact at
\( t=0 \). Alternatively, signaling in the brain is based on release
of a huge ion concentration on one side of a synapse, which implies
diffusive transport of a discontinuous concentration function.

<p>
<b>More to be written...</b>

<h2 id="___sec19">Analysis of discrete equations </h2>

<p>
A counterpart to <a href="#mjx-eqn-49">(49)</a> is the complex representation
of the same function:

$$ u(x,t) = Qe^{-at}e^{ikx},$$

where \( i=\sqrt{-1} \) is the imaginary unit.
We can add such functions, often referred to as wave components,
to make a Fourier representation
of a general solution of the diffusion equation:

$$
\begin{equation}
u(x,t) \approx \sum_{k\in K} b_k e^{-\alpha k^2t}e^{ikx},
\tag{51}
\end{equation}
$$

where \( K \) is a set of an infinite number of \( k \) values needed to construct
the solution. In practice, however, the series is truncated and
\( K \) is a finite set of \( k \) values
need build a good approximate solution.
Note that <a href="#mjx-eqn-50">(50)</a> is a special case of
<a href="#mjx-eqn-51">(51)</a> where \( K=\{\pi, 100\pi\} \), \( b_{\pi}=1 \),
and \( b_{100\pi}=0.1 \).

<p>
The amplitudes \( b_k \) of the individual Fourier waves must be determined
from the initial condition. At \( t=0 \) we have \( u\approx\sum_kb_k\exp{(ikx)} \)
and find \( K \) and \( b_k \) such that

$$
\begin{equation}
I(x) \approx \sum_{k\in K} b_k e^{ikx}\tp
\tag{52}
\end{equation}
$$

(The relevant formulas for \( b_k \) come from Fourier analysis, or
equivalently, a least-squares method for approximating \( I(x) \)
in a function space with basis \( \exp{(ikx)} \).)

<p>
Much insight about the behavior of numerical methods can be obtained
by investigating how a wave component \( \exp{(-\alpha k^2 t)}\exp{(ikx)} \)
is treated by the numerical scheme. It appears that such wave
components are also solutions of the schemes, but the damping
factor \( \exp{(-\alpha k^2 t)} \) varies among the schemes.
To ease the forthcoming algebra, we write the damping factor
as \( A^n \). The exact amplification factor corresponding to \( A \)
is \( \Aex = \exp{(-\alpha k^2\Delta t)} \).

<h2 id="diffu:pde1:analysis:details">Analysis of the finite difference schemes</h2>

<p>
We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components

$$
\begin{equation*} e^{-\alpha k^2t}e^{ikx} \tp  \end{equation*}
$$

A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude \( \exp{(-\alpha k^2t)} \) might be modified (which also happens when
solving the ODE counterpart \( u'=-\alpha u \)).
We therefore look for numerical solutions of the form

$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},
\tag{53}
\end{equation}
$$

where the amplification factor \( A \)
must be determined by inserting the component into an actual scheme.

<h3 id="___sec21">Stability </h3>

<p>
The exact amplification factor is \( \Aex=\exp{(-\alpha^2 k^2\Delta t)} \).
We should therefore require \( |A| < 1 \) to have a decaying numerical
solution as well. If
\( -1\leq A < 0 \), \( A^n \) will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.

<h3 id="___sec22">Accuracy </h3>

<p>
To determine how accurately a finite difference scheme treats one
wave component <a href="#mjx-eqn-53">(53)</a>, we see that the basic
deviation from the exact solution is reflected in how well
\( A^n \) approximates \( \Aex^n \),
or how well \( A \) approximates \( \Aex \).
We can plot \( \Aex \) and the various expressions for \( A \), and we can
make Taylor expansions of \( A/\Aex \) to see the error more analytically.

<p>
<!-- We shall in particular investigate the error \( \Aex - A \) in the -->
<!-- amplification factor. -->

<h2 id="diffu:pde1:analysis:FE">Analysis of the Forward Euler scheme</h2>

<p>
<!-- 2DO: refer to vib and wave -->

<p>
The Forward Euler finite difference scheme for \( u_t = \alpha u_{xx} \) can
be written as

$$
\begin{equation*} [D_t^+ u = \alpha D_xD_x u]^n_q\tp  \end{equation*}
$$

Inserting a wave component <a href="#mjx-eqn-53">(53)</a>
in the scheme demands calculating the terms

$$ e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},$$

and

$$ A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)\right)
\tp  $$

Inserting these terms in the discrete equation and
dividing by \( A^n e^{ikq\Delta x} \) leads to

$$
\begin{equation*}
\frac{A-1}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and consequently

$$
\begin{equation}
A = 1 -4F\sin^2\left(
\frac{k\Delta x}{2}\right),
\tag{54}
\end{equation}
$$

where

$$
\begin{equation}
F = \frac{\alpha\Delta t}{\Delta x^2}
\tag{55}
\end{equation}
$$

is the <em>numerical Fourier number</em>.
The complete numerical solution is then

$$
\begin{equation}
u^n_q = \left(1 -4F\sin^2\left(
\frac{k\Delta x}{2}\right)\right)^ne^{ikq\Delta x}
\tp
\tag{56}
\end{equation}
$$

<h3 id="___sec24">Stability </h3>

<p>
We easily see that \( A\leq 1 \). However, the \( A \) can be less than \( -1 \),
which will lead
to growth of a numerical wave component. The criterion \( A\geq -1 \) implies

$$ 4F\sin^2 (p/2)\leq 2
\tp
$$

The worst case is when \( \sin^2 (p/2)=1 \), so a sufficient criterion for
stability is

$$
\begin{equation}
F\leq {\half},
\tag{57}
\end{equation}
$$

or expressed as a condition on \( \Delta t \):

$$
\begin{equation}
\Delta t\leq \frac{\Delta x^2}{2\alpha}\tp
\tag{58}
\end{equation}
$$

Note that halving the spatial mesh size, \( \Delta x \rightarrow {\half}
\Delta x \), requires \( \Delta t \) to be reduced by a factor of \( 1/4 \).
The method hence becomes very expensive for fine spatial meshes.

<p>
<!-- 2DO: verification based on exact solutions -->

<h3 id="___sec25">Accuracy </h3>

<p>
Since \( A \) is expressed in terms of \( F \) and the parameter we now call
\( p=k\Delta x/2 \), we should also express \( \Aex \) by \( F \) and \( p \). The exponent
in \( \Aex \) is \( -\dfc k^2\Delta t \), which equals \( -F k^2\Delta x^2=-F4p^2 \).
Consequently,

$$ \Aex = \exp{(-\alpha k^2\Delta t)} = \exp{(-4Fp^2)}
\tp $$

All our \( A \) expressions as well as \( \Aex \) are now functions of the two
dimensionless parameters \( F \) and \( p \).

<p>
Computing
the Taylor series expansion of \( A/\Aex \) in terms of \( F \)
can easily be done with aid of <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_exact</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-4*</span>F<span style="color: #666666">*</span>p<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_FE</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> <span style="color: #666666">4*</span>F<span style="color: #666666">*</span>sin(p)<span style="color: #666666">**2</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
F, p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;F p&#39;</span>)
A_err_FE <span style="color: #666666">=</span> A_FE(F, p)<span style="color: #666666">/</span>A_exact(F, p)
<span style="color: #008000; font-weight: bold">print</span> A_err_FE<span style="color: #666666">.</span>series(F, <span style="color: #666666">0</span>, <span style="color: #666666">6</span>)
</pre></div>
<p>
The result is

$$ \frac{A}{\Aex} = 1 - 4 F \sin^{2}p + 2F p^{2} - 16F^{2} p^{2} \sin^{2}p + 8 F^{2} p^{4} + \cdots
$$

Recalling that \( F=\alpha\Delta t/\Delta x \), \( p=k\Delta x/2 \), and that
\( \sin^2p\leq 1 \), we
realize that the dominating error terms are at most

$$ 1 - 4\alpha \frac{\Delta t}{\Delta x^2} +
\alpha\Delta t - 4\alpha^2\Delta t^2
+ \alpha^2 \Delta t^2\Delta x^2 + \cdots
\tp
$$

<h2 id="diffu:pde1:analysis:BE">Analysis of the Backward Euler scheme</h2>

<p>
Discretizing \( u_t = \alpha u_{xx} \) by a Backward Euler scheme,

$$
\begin{equation*} [D_t^- u = \alpha D_xD_x u]^n_q,\end{equation*}
$$

and inserting a wave component <a href="#mjx-eqn-53">(53)</a>,
leads to calculations similar to those arising from the Forward Euler scheme,
but since

$$ e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},$$

we get

$$
\begin{equation*}
\frac{1-A^{-1}}{\Delta t} = -\alpha \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and then

$$
\begin{equation}
A = \left(1  + 4F\sin^2p\right)^{-1}
\tag{59}
\tp
\end{equation}
$$

The complete numerical solution can be written

$$
\begin{equation}
u^n_q = \left(1  + 4F\sin^2 p\right)^{-n}
e^{ikq\Delta x} \tp
\tag{60}
\end{equation}
$$

<h3 id="___sec27">Stability </h3>

<p>
We see from <a href="#mjx-eqn-59">(59)</a> that \( 0 < A < 1 \), which means
that all numerical wave components are stable and non-oscillatory
for any \( \Delta t >0 \).

<h2 id="diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</h2>

<p>
The Crank-Nicolson scheme can be written as

$$ [D_t u = \alpha D_xD_x \overline{u}^x]^{n+\half}_q, $$

or

$$ [D_t u]^{n+\half}_q = \half\alpha\left( [D_xD_x u]^{n}_q +
[D_xD_x u]^{n+1}_q\right)
\tp
$$

Inserting <a href="#mjx-eqn-53">(53)</a> in the time derivative approximation
leads to

$$ [D_t A^n e^{ikq\Delta x}]^{n+\half} = A^{n+\half} e^{ikq\Delta x}\frac{A^{\half}-A^{-\half}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
\tp $$

Inserting <a href="#mjx-eqn-53">(53)</a> in the other terms
and dividing by
\( A^ne^{ikq\Delta x} \) gives the relation

$$
\frac{A-1}{\Delta t} = -\half\alpha\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)
(1 + A),
$$

and after some more algebra,

$$
\begin{equation}
A = \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}
\tp
\tag{61}
\end{equation}
$$

The exact numerical solution is hence

$$
\begin{equation}
u^n_q = \left(\frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\right)^ne^{ikp\Delta x}
\tp
\tag{62}
\end{equation}
$$

<h3 id="___sec29">Stability </h3>

<p>
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \).

<h2 id="___sec30">Summary of accuracy of amplification factors </h2>

<p>
We can plot the various amplification factors against \( p=k\Delta x/2 \) for
different choices of the \( F \) parameter. Figures <a href="#diffu:pde1:fig:A:err:C20">9</a>,
<a href="#diffu:pde1:fig:A:err:C0.5">10</a>, and <a href="#diffu:pde1:fig:A:err:C0.1">11</a>
show how long and small waves are damped by the various schemes compared
to the exact damping. As long as all schemes are stable, the amplification
factor is positive, except for Crank-Nicolson when \( F>0.5 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Amplification factors for large time steps. <div id="diffu:pde1:fig:A:err:C20"></div> </p></center>
<p><img src="fig-diffu/diffusion_A_F20_F2.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Amplification factors for time steps around the Forward Euler stability limit. <div id="diffu:pde1:fig:A:err:C0.5"></div> </p></center>
<p><img src="fig-diffu/diffusion_A_F05_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Amplification factors for small time steps. <div id="diffu:pde1:fig:A:err:C0.1"></div> </p></center>
<p><img src="fig-diffu/diffusion_A_F01_F001.png" align="bottom" width=800></p>
</center>

<p>
The effect of negative amplification factors is that \( A^n \) changes sign
from one time level to the next, thereby giving rise to oscillations in
time in an animation of the solution. We see from Figure <a href="#diffu:pde1:fig:A:err:C20">9</a> that for \( F=20 \), waves with \( p\geq \pi/2 \) undergo a damping close to
\( -1 \), which means that the amplitude does not decay and that the wave component
jumps up and down in time. For \( F=2 \) we have a damping of a factor of 0.5
from one time level to the next, which is very much smaller than the
exact damping. Short waves will therefore fail to be effectively dampened.
These waves will manifest themselves as high frequency
oscillatory noise in the solution.

<p>
A value \( p=\pi/4 \) corresponds to
four mesh points per wave length of \( e^{ikx} \), while
\( p=\pi/2 \) implies only two points per wave length, which is the smallest number
of points we can have to represent the wave on the mesh.

<p>
To demonstrate the oscillatory behavior of the Crank-Nicolson scheme, we
choose an initial condition that leads to short waves with
significant amplitude. A discontinuous \( I(x) \) will in particular serve
this purpose.

<p>
Run \( F=... \)...

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</h2>

<p>
This exercise simulates the exact solution <a href="#mjx-eqn-48">(48)</a>.
Suppose for simplicity that \( c=0 \).

<p>
<b>a)</b>
Formulate an initial-boundary value problem that has
<a href="#mjx-eqn-48">(48)</a> as solution in the domain \( [-L,L] \).
Use the exact solution <a href="#mjx-eqn-48">(48)</a> as Dirichlet
condition at the boundaries.
Simulate the diffusion of the Gaussian peak. Observe that the
solution is symmetric around \( x=0 \).

<p>
<b>b)</b>
Show from <a href="#mjx-eqn-48">(48)</a> that \( u_x(c,t)=0 \).
Since the solution is symmetric around \( x=c=0 \), we can solve the
numerical problem in half of the domain, using a <em>symmetry boundary condition</em>
\( u_x=0 \) at \( x=0 \). Set up the
initial-boundary value problem in this case. Simulate the
diffusion problem in \( [0,L] \) and compare with the solution in a).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

$$
\begin{align*}
u_t &= \dfc u_xx,\\ 
u_x(0,t) &= 0,\\ 
u(L,t)& =\frac{1}{\sqrt{4\pi\alpha t}} \exp{\left({-\frac{x^2}{4\alpha t}}\right)}\tp
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>diffu_symmetric_gaussian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:ux:onesided">Exercise 2: Investigate approximation errors from a \( u_x=0 \) boundary condition</h2>

<p>
We consider the problem solved in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</a>
part b). The boundary condition \( u_x(0,t)=0 \) can be implemented in
two ways: 1) by a standard symmetric finite difference \( [D_{2x}u]_i^n=0 \),
or 2) by a one-sided difference \( [D^+u=0]^n_i=0 \).
Investigate the effect of these two conditions on the
convergence rate in space.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
If you use a Forward Euler scheme, choose a discretization parameter
\( h=\Delta t = \Delta x^2 \) and assume the error goes like \( E\sim h^r \).
The error in the scheme is \( \Oof{\Delta t,\Delta x^2} \) so one should
expect that the estimated \( r \) approaches 1. The question is if
a one-sided difference approximation to \( u_x(0,t)=0 \) destroys this
convergence rate.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>diffu_onesided_fd</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:openBC">Exercise 3: Experiment with open boundary conditions in 1D</h2>

<p>
We address diffusion of a Gaussian function
as in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</a>,
in the domain \( [0,L] \),
but now we shall explore different types of boundary
conditions on \( x=L \). In real-life problems we do not know
the exact solution on \( x=L \) and must use something simpler.

<p>
<b>a)</b>
Imagine that we want to solve the problem numerically on
\( [0,L] \), with a symmetry boundary condition \( u_x=0 \) at \( x=0 \),
but we do not know the exact solution and cannot of that
reason assign a correct Dirichlet condition at \( x=L \).
One idea is to simply set \( u(L,t)=0 \) since this will be an
accurate approximation before the diffused pulse reaches \( x=L \)
and even thereafter it might be a satisfactory condition if the exact \( u \) has
a small value.
Let \( \uex \) be the exact solution and let \( u \) be the solution
of \( u_t=\alpha u_{xx} \) with an initial Gaussian pulse and
the boundary conditions \( u_x(0,t)=u(L,t)=0 \). Derive a diffusion
problem for the error \( e=\uex - u \). Solve this problem
numerically using an exact Dirichlet condition at \( x=L \).
Animate the evolution of the error and make a curve plot of
the error measure

$$ E(t)=\sqrt{\frac{\int_0^L e^2dx}{\int_0^L udx}}\tp $$

Is this a suitable error measure for the present problem?

<p>
<b>b)</b>
Instead of using \( u(L,t)=0 \) as approximate boundary condition for
letting the diffused Gaussian pulse move out of our finite domain,
one may try \( u_x(L,t)=0 \) since the solution for large \( t \) is
quite flat. Argue that this condition gives a completely wrong
asymptotic solution as \( t\rightarrow 0 \). To do this,
integrate the diffusion equation from \( 0 \) to \( L \), integrate
\( u_{xx} \) by parts (or use Gauss' divergence theorem in 1D) to
arrive at the important property

$$ \frac{d}{dt}\int_{0}^L u(x,t)dx = 0,$$

implying that \( \int_0^Ludx \) must be constant in time, and therefore

$$ \int_{0}^L u(x,t)dx = \int_{0}^LI(x)dx\tp $$

The integral of the initial pulse is 1.

<p>
<b>c)</b>
Another idea for an artificial boundary condition at \( x=L \)
is to use a cooling law

$$
\begin{equation}
-\alpha u_x = q(u - u_S),
\tag{63}
\end{equation}
$$

where \( q \) is an unknown heat transfer coefficient and \( u_S \) is
the surrounding temperature in the medium outside of \( [0,L] \).
(Note that arguing that \( u_S \) is approximately \( u(L,t) \) gives
the \( u_x=0 \) condition from the previous subexercise that is
qualitatively wrong for large \( t \).)
Develop a diffusion problem for the error in the solution using
<a href="#mjx-eqn-63">(63)</a> as boundary condition.
Assume one can take \( u_S=0 \) &quot;outside the domain&quot; since
\( \uex\rightarrow 0 \) as \( x\rightarrow\infty \).
Find a function \( q=q(t) \) such that the exact solution
obeys the condition <a href="#mjx-eqn-63">(63)</a>.
Test some constant values of \( q \) and animate how the corresponding
error function behaves. Also compute \( E(t) \) curves as defined above.

<p>
Filename: <code>diffu_open_BC</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec34">Exercise 4: Simulate a diffused Gaussian peak in 2D/3D </h2>

<p>
<b>a)</b>
Generalize <a href="#mjx-eqn-48">(48)</a> to multi dimensions by
assuming that one-dimensional solutions can be multiplied to solve
\( u_t = \alpha\nabla^2 u \). Set \( c=0 \) such that the peak of
the Gaussian is at the origin.

<p>
<b>b)</b>
One can from the exact solution show
that \( u_x=0 \) on \( x=0 \), \( u_y=0 \) on \( y=0 \), and \( u_z=0 \) on \( z=0 \).
The approximately correct condition \( u=0 \) can be set
on the remaining boundaries (say \( x=L \), \( y=L \), \( z=L \)), cf. <a href="#diffu:exer:1D:openBC">Exercise 3: Experiment with open boundary conditions in 1D</a>.
Simulate a 2D case and make an animation of the diffused Gaussian peak.

<p>
<b>c)</b>
The formulation in b) makes use of symmetry of the solution such that we
can solve the problem in the first quadrant (2D) or octant (3D) only.
To check that the symmetry assumption is correct, formulate the problem
without symmetry in a domain \( [-L,L]\times [L,L] \) in 2D. Use \( u=0 \) as
approximately correct boundary condition. Simulate the same case as
in b), but in a four times as large domain. Make an animation and compare
it with the one in b).

<p>
Filename: <code>diffu_symmetric_gaussian_2D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:uterm">Exercise 5: Examine stability of a diffusion model with a source term</h2>

<p>
Consider a diffusion equation with a linear \( u \) term:

$$ u_t = \alpha u_{xx} + \beta u\tp$$

<p>
<b>a)</b>
Derive in detail a Forward Euler scheme, a Backward Euler scheme,
and a Crank-Nicolson for this type of diffusion model.
Thereafter, formulate a \( \theta \)-rule to summarize the three schemes.

<p>
<b>b)</b>
Assume a solution like <a href="#mjx-eqn-49">(49)</a> and find the relation
between \( a \), \( k \), \( \alpha \), and \( \beta \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
Insert <a href="#mjx-eqn-49">(49)</a> in the PDE problem.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Calculate the stability of the Forward Euler scheme. Design
numerical experiments to confirm the results.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_2">

<p>
Insert the discrete counterpart to <a href="#mjx-eqn-49">(49)</a> in the
numerical scheme. Run experiments at the stability limit and slightly above.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat c) for the Backward Euler scheme.

<p>
<b>e)</b>
Repeat c) for the Crank-Nicolson scheme.

<p>
<b>f)</b>
How does the extra term \( bu \) impact the accuracy of the three schemes?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_3" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_3">

<p>
For analysis of the accuracy,
compare the numerical and exact amplification factors, in
graphs and/or by Taylor series expansion.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>diffu_stability_uterm</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="___sec36">Diffusion in heterogeneous media </h1>

<p>
Diffusion in heterogeneous media will normally imply a non-constant
diffusion coefficient \( \alpha = \alpha (x) \).
A 1D diffusion model with such a variable diffusion coefficient reads

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\frac{\partial}{\partial x}\left( \alpha (x) \frac{\partial u}{\partial x^2}
\right), \quad x\in (0,L),\ t\in (0,T]
\tag{64}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\tag{65}\\ 
u(0,t) & = U_0, \quad  t>0,
\tag{66}\\ 
u(L,t) & = U_L, \quad  t>0\tp
\tag{67}
\end{align}
$$

A short form of the diffusion equation with variable coefficients is
\( u_t = (\alpha u_x)_x \).

<h2 id="___sec37">Stationary solution </h2>

<p>
As \( t\rightarrow\infty \), the solution of the above problem will approach
a stationary limit where \( \partial u/\partial t=0 \). The governing
equation is then

$$
\begin{equation}
\frac{d}{dx}\left(\alpha\frac{du}{dx}\right) =0,
\tag{68}
\end{equation}
$$

with boundary conditions \( u(0)=U_0 \) and \( u(L)=u_L \).
It is possible to obtain an exact solution of <a href="#mjx-eqn-68">(68)</a>
for any \( \alpha \). Integrating twice and applying the boundary conditions
to determine the integration constants gives

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)\frac{\int_0^x (\alpha(\xi))^{-1}d\xi}{\int_0^L (\alpha(\xi))^{-1}d\xi}
\tp
\tag{69}
\end{equation}
$$

<h2 id="___sec38">Piecewise constant medium </h2>

<p>
Consider a medium built of \( M \) layers. The boundaries between the
layers are denoted by \( b_0, \ldots, b_M \),
where \( b_0=0 \) and \( b_M=L \).
If the material in each layer potentially differs from the others, but
is otherwise constant, we can express \( \alpha \) as a
<em>piecewise constant function</em> according to

$$
\begin{equation}
\alpha (x) = \left\lbrace\begin{array}{ll}
\alpha_0,& b_0 \leq x < b_1,\\ 
\vdots &\\ 
\alpha_i,& b_i \leq x < b_{i+1},\\ 
\vdots &\\ 
\alpha_0,& b_{M-1} \leq x \leq b_M.
\end{array}\right.
\end{equation}
\tag{70}
$$

<p>
The exact solution <a href="#mjx-eqn-69">(69)</a> in case of such a
piecewise constant \( \alpha \) function is easy to derive. Assume that
\( x \) is in the \( m \)-th layer: \( x\in [b_m, b_{m+1}] \). In the integral
\( \int_0^x (a(\xi))^{-1}d\xi \) we must integrate through the first
\( m-1 \) layers and then add the contribution from the remaining part
\( x-b_m \) into the \( m \)-th layer:

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)
\frac{\sum_{j=0}^{m-1} (b_{j+1}-b_j)/\alpha(b_j) + (x-b_m)/\alpha(b_m)}{\sum_{j=0}^{M-1} (b_{j+1}-b_j)/\alpha(b_j)}
\tag{71}
\end{equation}
$$

<p>
<b>Remark.</b>
It may sound strange to have a discontinuous \( \alpha \) in a differential
equation where one is to differentiate, but a discontinuous \( \alpha \)
is compensated by a discontinuous \( u_x \) such that \( \alpha u_x \) is
continues and therefore can be differentiated as \( (\alpha u_x)_x \).

<h2 id="___sec39">Implementation </h2>

<p>
Programming with piecewise function definition quickly becomes
cumbersome as the most naive approach is to test for which interval
\( x \) lies, and then start evaluating a formula like
<a href="#mjx-eqn-71">(71)</a>. In Python, vectorized expressions may
help to speed up the computations.
The convenience classes <code>PiecewiseConstant</code> and
<code>IntegratedPiecewiseConstant</code> were made to simplify programming with
functions like <a href="#mjx-eqn-70">(70)</a> and expressions like
<a href="#mjx-eqn-71">(71)</a>. These utilities not only represent
piecewise constant functions, but also <em>smoothed</em> versions of them
where the discontinuities can be smoothed out in a controlled fashion.
This is advantageous in many computational contexts (although seldom
for pure finite difference computations of the solution \( u \)).

<p>
The <code>PiecewiseConstant</code> class is created by sending in the domain as a
2-tuple or 2-list and a <code>data</code> object describing the boundaries
\( b_0,\ldots,b_M \) and the corresponding function values
\( \alpha_0,\ldots,\alpha_{M-1} \). More precisely, <code>data</code> is a nested
list, where <code>data[i][0]</code> holds \( b_i \) and <code>data[i][1]</code> holds the
corresponding value \( \alpha_i \), for \( i=0,\ldots,M-1 \). Given \( b_i \) and
\( \alpha_i \) in arrays <code>b</code> and <code>a</code>, it is easy to fill out the nested
list <code>data</code>.

<p>
In our application, we want to represent \( \alpha \) and \( 1/\alpha \)
as piecewise constant function, in addition to the \( u(x) \) function
which involves the integrals of \( 1/\alpha \). A class creating the
functions we need and a method for evaluating \( u \), can take the
form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    b: coordinates of boundaries of layers, b[0] is left boundary</span>
<span style="color: #BA2121; font-style: italic">    and b[-1] is right boundary of the domain [0,L].</span>
<span style="color: #BA2121; font-style: italic">    a: values of the functions in each layer (len(a) = len(b)-1).</span>
<span style="color: #BA2121; font-style: italic">    U_0: u(x) value at left boundary x=0=b[0].</span>
<span style="color: #BA2121; font-style: italic">    U_L: u(x) value at right boundary x=L=b[0].</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b, U_0, U_L, eps<span style="color: #666666">=0</span>):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(a), np<span style="color: #666666">.</span>asarray(b)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">=</span> eps  <span style="color: #408080; font-style: italic"># smoothing parameter for smoothed a</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0, <span style="color: #008000">self</span><span style="color: #666666">.</span>U_L <span style="color: #666666">=</span> U_0, U_L

        a_data <span style="color: #666666">=</span> [[bi, ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        domain <span style="color: #666666">=</span> [b[<span style="color: #666666">0</span>], b[<span style="color: #666666">-1</span>]]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func <span style="color: #666666">=</span> PiecewiseConstant(domain, a_data, eps)

        <span style="color: #408080; font-style: italic"># inv_a = 1/a is needed in formulas</span>
        inv_a_data <span style="color: #666666">=</span> [[bi, <span style="color: #666666">1./</span>ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_func <span style="color: #666666">=</span> \ 
             PiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func <span style="color: #666666">=</span> \ 
             IntegratedPiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #408080; font-style: italic"># Denominator in the exact formula is constant</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(b[<span style="color: #666666">-1</span>])

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, x):
        solution <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0 <span style="color: #666666">+</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>U_L<span style="color: #666666">-</span><span style="color: #008000">self</span><span style="color: #666666">.</span>U_0)<span style="color: #666666">*</span>\ 
                   <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(x)<span style="color: #666666">/</span><span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L
        <span style="color: #008000; font-weight: bold">return</span> solution
</pre></div>
<p>
A visualization method is also convenient to have. Below we plot \( u(x) \)
along with \( \alpha (x) \) (which works well as long as \( \max \alpha(x) \)
is of the same size as \( \max u = \max(U_0,U_L) \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #666666">...</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot</span>(<span style="color: #008000">self</span>):
        x, y_a <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func<span style="color: #666666">.</span>plot()
        x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(x); y_a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(y_a)
        y_u <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u_exact(x)
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(x, y_u, <span style="color: #BA2121">&#39;b&#39;</span>)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)  <span style="color: #408080; font-style: italic"># Matlab style</span>
        plt<span style="color: #666666">.</span>plot(x, y_a, <span style="color: #BA2121">&#39;r&#39;</span>)
        ymin <span style="color: #666666">=</span> <span style="color: #666666">-0.1</span>
        ymax <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span><span style="color: #008000">max</span>(y_u<span style="color: #666666">.</span>max(), y_a<span style="color: #666666">.</span>max())
        plt<span style="color: #666666">.</span>axis([x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], ymin, ymax])
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;solution $u$&#39;</span>, <span style="color: #BA2121">&#39;coefficient $a$&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
            plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Smoothing eps: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
        plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Figure <a href="#diffu:fd2:pde:st:sol:pc:fig1">12</a> shows the case where

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]   <span style="color: #408080; font-style: italic"># material boundaries</span>
a <span style="color: #666666">=</span> [<span style="color: #666666">0.2</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">4</span>]       <span style="color: #408080; font-style: italic"># material values</span>
U_0 <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>;  U_L <span style="color: #666666">=</span> <span style="color: #666666">5</span>     <span style="color: #408080; font-style: italic"># boundary conditions</span>
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Solution of the stationary diffusion equation corresponding to a piecewise constant diffusion coefficient. <div id="diffu:fd2:pde:st:sol:pc:fig1"></div> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1.png" align="bottom" width=400></p>
</center>

<p>
By adding the <code>eps</code> parameter to the constructor of the <code>SerialLayers</code>
class, we can experiment with smoothed versions of \( \alpha \) and see
the (small) impact on \( u \). Figure <a href="#diffu:fd2:pde:st:sol:pc:fig2">13</a>
shows the result.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  Solution of the stationary diffusion equation corresponding to a <em>smoothed</em> piecewise constant diffusion coefficient. <div id="diffu:fd2:pde:st:sol:pc:fig2"></div> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1_eps.png" align="bottom" width=400></p>
</center>

<h2 id="diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</h2>

<p>
Suppose we have a diffusion process taking care in a straight tube
with radius \( R \). We assume axi-symmetry such that \( u \) is just a
function of \( r \) and \( t \). A model problem is

$$
\begin{align}
\frac{\partial u}{\partial t} &= \frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc(r)\frac{\partial u}{\partial r}\right) + f(t), & r\in (0,R),\ t\in (0,T],
\tag{72}\\ 
\frac{\partial u}{\partial r}(0,t) &= 0, & t\in (0,T],
\tag{73}\\ 
u(R,t) &= 0, & t\in (0,T],
\tag{74}\\ 
u(r,0) &= I(r), & r\in [0,R].
\tag{75}
\end{align}
$$

The condition <a href="#mjx-eqn-73">(73)</a> is a necessary symmetry condition
at \( r=0 \), while <a href="#mjx-eqn-74">(74)</a> could be any Dirichlet
or Neumann condition (or Robin condition in case of cooling or heating).

<p>
The finite difference approximation at \( r=0 \) of the spatial derivative term
is the only new challenge in this problem. Let us in case of
constant \( \dfc \) expand the derivative to

$$ \frac{\partial^2 u}{\partial r^2} + \frac{1}{r}\frac{\partial u}{\partial r}\tp$$

The last term faces a difficulty at \( r=0 \) since it becomes a \( 0/0 \) expression
because of the symmetry condition.
L'Hosptial's rule can be used:

$$ \lim_{r\rightarrow 0} \frac{1}{r}\frac{\partial u}{\partial r}
= \lim_{r\rightarrow 0} \frac{\partial^2 u}{\partial r^2}\tp$$

The PDE at \( r=0 \) therefore becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = 2\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{76}
\end{equation}
$$

For a variable coefficient \( \dfc(r) \) the expanded derivative reads

$$ \dfc(r)\frac{\partial^2 u}{\partial r^2} +
\frac{1}{r}(\dfc(r) + r\dfc'(r))\frac{\partial u}{\partial r}\tp$$

We have that the <a href="https://en.wikibooks.org/wiki/Calculus/Proofs_of_Some_Basic_Limit_Rules" target="_self">limit of a product</a> is

$$ \lim_{r\rightarrow 0}
\frac{1}{r}(\dfc(r) + r\dfc'(r))\frac{\partial u}{\partial r} =
\lim_{r\rightarrow 0} (\dfc(r) + r\dfc'(r))\ 
\lim_{x\rightarrow c}
\frac{1}{r}\frac{\partial u}{\partial r}\tp
$$

The second limit becomes as above, so the PDE at \( r=0 \),
assuming \( (\dfc(0) + r\dfc'(0))\neq 0 \),
looks like

$$
\begin{equation}
\frac{\partial u}{\partial t} = (2\dfc + r\dfc')
\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{77}
\end{equation}
$$

<p>
The second-order derivative is discretized in the usual way.
Consider first constant \( \dfc \):

$$ 2\dfc\frac{\partial^2}{\partial r^2}u(r_0,t_n) \approx
[2\dfc 2D_rD_r u]^n_0 =
2\dfc \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}\tp$$

The fictitious value \( u^n_{-1} \) can be eliminated using the discrete
symmetry condition

$$ [D_{2r} u =0]^n_0 \quad\Rightarrow\quad u^n_{-1} = u^n_1,$$

which then gives the modified approximation to the second-order derivative
of \( u \) in \( r \) at \( r=0 \):

$$
\begin{equation}
4\dfc \frac{u^{n}_{1} - u^{n}_0}{\Delta r^2}\tp
\tag{78}
\end{equation}
$$

With variable \( \dfc \) we simply get

$$(2\dfc + r\dfc')2D_rD_r u]^n_0 =
(2\dfc(0) + r\dfc'(0)) \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}\tp$$

<p>
The discretization of the second-order derivative in \( r \) at another
internal mesh point is straightforward:

$$
\left.\frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc\frac{\partial u}{\partial r}\right)\right\vert_{r=r_i}^{t=t_n}
\approx [r^{-1} D_r (r \dfc D_r u)]_i^n
= \frac{1}{\Delta r^2}\left(
r_{i+\half}\dfc_{i+\half}(u_{i+1}^n - u_i^n) - r_{i-\half}\dfc_{i-\half}(u_{i}^n - u_{i-1}^n)\right)\tp
$$

<p>
\( \theta \)-rule in time...

<h2 id="diffu:fd2:spherical">Diffusion equation in spherically-symmetric geometries</h2>

<h3 id="___sec42">Discretization in spherical coordinates </h3>

<p>
Let us now pose the problem from the section <a href="#diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</a>
in spherical coordinates, where \( u \) only depends on the radial coordinate
\( r \) and time \( t \). That is, we have spherical symmetry.
For simplicity we restrict the diffusion coefficient \( \dfc \) to be
a constant. The PDE reads

$$
\begin{equation}
\frac{\partial u}{\partial t} = \frac{\dfc}{r^\gamma}\frac{\partial}{\partial r}
\left(r^\gamma\frac{\partial u}{\partial r}\right) + f(t),
\tag{79}
\end{equation}
$$

for \( r\in (0,R) \) and \( t\in (0,T] \). The parameter \( \gamma \) is 2 for
spherically-symmetric problems and 1 for axi-symmetric problems.
The boundary and initial conditions
have the same mathematical form as
in <a href="#mjx-eqn-72">(72)</a>-<a href="#mjx-eqn-75">(75)</a>.

<p>
Since the PDE in spherical coordinates has the same form as the PDE
in the section <a href="#diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</a>, just with the \( \gamma \) parameter
being different, we can use the same discretization approach.
At the origin \( r=0 \) we get problems with the term

$$ \frac{\gamma}{r}\frac{\partial u}{\partial t},$$

but L'Hosptial's rule shows that this term equals \( \gamma\partial^2 u/
\partial r^2 \), and the PDE at \( r=0 \) becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = (\gamma+1)\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{80}
\end{equation}
$$

<p>
Same discretization, write up with \( \gamma \).

<h3 id="___sec43">Discretization in Cartesian coordinates </h3>

<p>
The spherically-symmetric spatial derivative can be transformed to
the Cartesian counterpart by introducing

$$ v(r,t) = ru(r,t)\tp$$

Inserting \( u=v/r \) in the PDE yields

$$ \frac{1}{r^2}\frac{\partial}{\partial r}
\left(\dfc(r)r^2\frac{\partial u}{\partial t}\right), $$

and then

$$ r\left(\frac{d c^2}{dr}\frac{\partial v}{\partial r} +
\dfc\frac{\partial^2 v}{\partial r^2}\right) - \frac{d c^2}{dr}v
\tp
$$

The two terms in the parenthesis can be combined to
$$ r\frac{\partial}{\partial r}\left( \dfc\frac{\partial v}{\partial r}\right),
$$

which is recognized as the variable-coefficient Laplace operator in
one Cartesian coordinate.

<h1 id="___sec44">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:CN:Rannacher">Exercise 6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</h2>

<p>
It is well known that the Crank-Nicolson method may give rise to
non-physical oscillations in the solution of diffusion equations
if the initial data exhibit jumps (see the section <a href="#diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</a>).
Rannacher <a href="._diffu-sol002.html#Rannacher_1984">[2]</a> suggested a stabilizing technique
consisting of using the Backward Euler scheme for the first two
time steps with step length \( \half\Delta t \). One can generalize
this idea to taking \( 2m \) time steps of size \( \half\Delta t \) with
the Backward Euler method and then continuing with the
Crank-Nicolson method, which is of second-order in time.
The idea is that the high frequencies of the initial solution are
quickly damped out, and the Backward Euler scheme treats these
high frequencies correctly. Thereafter, the high frequency content of
the solution is gone and the Crank-Nicolson method will do well.

<p>
Test this idea for \( m=1,2,3 \) on a diffusion problem with a
discontinuous initial condition. Measure the convergence rate using
the solution <a href="#mjx-eqn-45">(45)</a> with the boundary
conditions
<a href="#mjx-eqn-46">(46)</a>-<a href="#mjx-eqn-47">(47)</a>
for \( t \) values such that the conditions are in the vicinity of \( \pm 1 \).
For example, \( t < 5a 1.6\cdot 10^{-2} \) makes the solution diffusion from
a step to almost a straight line. The
program <code>diffu_erf_sol.py</code> shows how to compute the analytical
solution.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:energy:estimates">Project 7: Energy estimates for diffusion problems</h2>

<p>
This project concerns so-called <em>energy estimates</em> for diffusion problems
that can be used for qualitative analytical insight and for
verification of implementations.

<p>
<b>a)</b>
We start with a 1D homogeneous diffusion equation with zero Dirichlet
conditions:

$$
\begin{align}
u_t &= \alpha u_xx, & x\in \Omega =(0,L),\ t\in (0,T],
\tag{81} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{82}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{83}
\tp
\end{align}
$$

The energy estimate for this problem reads

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2},
\tag{84}
\end{equation}
$$

where the \( ||\cdot ||_{L^2} \) norm is defined by

$$
\begin{equation}
||g||_{L^2} = \sqrt{\int_0^L g^2dx}\tp
\tag{85}
\end{equation}
$$

The quantify  \( ||u||_{L^2} \) or \( \half ||u||_{L^2} \) is known
as the <em>energy</em> of the solution, although it is not the physical
energy of the system. A mathematical tradition has introduced the
notion <em>energy</em> in this context.

<p>
The estimate <a href="#mjx-eqn-84">(84)</a> says that the
"size of $u$" never exceeds that of the initial condition, or
more equivalently, that the area under the \( u \) curve decreases
with time.

<p>
To show <a href="#mjx-eqn-84">(84)</a>, multiply the PDE
by \( u \) and integrate from \( 0 \) to \( L \). Use that \( uu_t \) can be
expressed as the time derivative of \( u^2 \) and that \( u_xxu \) can
integrated by parts to form an integrand \( u_x^2 \). Show that
the time derivative of \( ||u||_{L^2}^2 \) must be less than or equal
to zero. Integrate this expression and derive
<a href="#mjx-eqn-84">(84)</a>.

<p>
<!-- <a href="http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf" target="_self"><tt>http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf</tt></a> -->

<p>
<b>b)</b>
Now we address a slightly different problem,

$$
\begin{align}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{86} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{87}\\ 
u(x,0) &= 0, & x\in [0,L]
\tag{88}
\tp
\end{align}
$$

The associated energy estimate is

$$
\begin{equation}
||u||_{L^2} \leq ||f||_{L^2}\tp
\tag{89}
\end{equation}
$$

(This result is more difficult to derive.)

<p>
Now consider the compound problem with an initial condition \( I(x) \) and
a right-hand side \( f(x,t) \):

$$
\begin{align}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{90} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{91}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{92}
\tp
\end{align}
$$

Show that if \( w_1 \) fulfills
<a href="#mjx-eqn-81">(81)</a>-<a href="#mjx-eqn-83">(83)</a>
and \( w_2 \) fulfills
<a href="#mjx-eqn-86">(86)</a>-<a href="#mjx-eqn-88">(88)</a>,
then \( u=w_1 + w_2 \) is the solution of
<a href="#mjx-eqn-90">(90)</a>-<a href="#mjx-eqn-92">(92)</a>.
Using the triangle inequality for norms,

$$ ||a + b|| \leq ||a|| + ||b||,$$

show that the energy estimate for
<a href="#mjx-eqn-90">(90)</a>-<a href="#mjx-eqn-92">(92)</a>
becomes

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2} + ||f||_{L^2}\tp
\tag{93}
\end{equation}
$$

<p>
<b>c)</b>
One application of <a href="#mjx-eqn-93">(93)</a> is to prove uniqueness
of the solution.
Suppose \( u_1 \) and \( u_2 \) both fulfill
<a href="#mjx-eqn-90">(90)</a>-<a href="#mjx-eqn-92">(92)</a>.
Show that \( u=u_1 - u_2 \) then fulfills
<a href="#mjx-eqn-90">(90)</a>-<a href="#mjx-eqn-92">(92)</a>
with \( f=0 \) and \( I=0 \). Use <a href="#mjx-eqn-93">(93)</a>
to deduce that the energy must be zero for all times and therefore
that \( u_1=u_2 \), which proves that the solution is unique.

<p>
<b>d)</b>
Generalize <a href="#mjx-eqn-93">(93)</a> to a 2D/3D
diffusion equation \( u_t = \nabla\cdot (\alpha \nabla u) \) for \( x\in\Omega \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_1">

<p>
Use integration by parts in multi dimensions:

$$ \int_\Omega u \nabla\cdot (\alpha\nabla u)\dx =
- \int_\Omega \alpha \nabla u\cdot\nabla u\dx
+ \int_{\partial\Omega} u \alpha\frac{\partial u}{\partial n},$$

where \( \frac{\partial u}{\partial n} = \boldsymbol{n}\cdot\nabla u \),
\( \boldsymbol{n} \) being the outward unit normal to the boundary \( \partial\Omega \)
of the domain \( \Omega \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Now we also consider the multi-dimensional PDE \( u_t =
\nabla\cdot (\alpha \nabla u) \). Integrate both sides over \( \Omega \)
and use Gauss' divergence theorem, \( \int_\Omega \nabla\cdot\boldsymbol{q}\dx
= \int_{\partial\Omega}\boldsymbol{q}\cdot\boldsymbol{n}\ds \) for a vector field
\( \boldsymbol{q} \). Show that if we have homogeneous Neumann conditions
on the boundary, \( \partial u/\partial n=0 \), area under the
\( u \) surface remains constant in time and

$$
\begin{equation}
\int_{\Omega} u\dx = \int_{\Omega} I\dx
\tp
\tag{94}
\end{equation}
$$

<p>
<b>f)</b>
Establish a code in 1D, 2D, or 3D that can solve a diffusion equation with a
source term \( f \), initial condition \( I \), and zero Dirichlet or
Neumann conditions on the whole boundary.

<p>
We can use <a href="#mjx-eqn-93">(93)</a>
and <a href="#mjx-eqn-94">(94)</a> as a partial verification
of the code. Choose some functions \( f \) and \( I \) and
check that <a href="#mjx-eqn-93">(93)</a> is obeyed at any
time when zero Dirichlet conditions are used.
Iterate over the same \( I \) functions and check that
<a href="#mjx-eqn-94">(94)</a> is fulfilled
when using zero Neumann conditions.

<p>
<b>g)</b>
Make a list of some possible bugs in the code, such as indexing errors
in arrays, failure to set the correct boundary conditions,
evaluation of a term at a wrong time level, and similar.
For each of the bugs, see if the verification tests from the previous
subexercise pass or fail. This investigation shows how strong
the energy estimates and the estimate <a href="#mjx-eqn-94">(94)</a>
are for pointing out errors in the implementation.

<p>
Filename: <code>diffu_energy</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._diffu-sol000.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._diffu-sol002.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

