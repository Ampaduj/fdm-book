<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for diffusion processes">
<meta name="keywords" content="diffusion equation 1D,heat equation,diffusion coefficient,diffusion equation diffusion coefficient,diffusion equation stationary solution,stationary solution,Laplace equation,diffusion equation  1D, explicit scheme,diffusion equation  1D, initial boundary value problem,diffusion equation  1D, initial condition,diffusion equation  1D, boundary condition,diffusion equation source term,explicit discretization methods,diffusion equation  1D, Forward Euler scheme,domain,mesh points,mesh function,forward difference approximation,central difference approximation,diffusion equation  1D, discrete equations,diffusion equation  1D, Fourier number,diffusion equation  1D, mesh Fourier number,dimensionless number,diffusion equation  1D, implementation (FE),diffusion equation  1D, verification (FE),test function,verification  convergence rates,diffusion equation  1D, numerical experiments,diffusion equation  1D, implicit schemes,coupled system,interior spatial points,ready-made software,matrix  equation,matrix  form,diffusion equation  1D, verification (BE),diffusion equation  1D, tridiagonal matrix,diffusion equation  1D, dense matrix,diffusion equation  1D, sparse matrix,diffusion equation  1D, implementation (sparse),Gaussian elimination,smooth Gaussian function,discontinuous plug,diffusion equation  1D, Crank-Nicolson scheme,linear system,diffusion equation  1D, verification (CN),diffusion equation  1D, theta rule,sawtooth-like noise,discontinuous initial condition,steady state,Laplace equation,Poisson equation,noise  sawtooth-like,error function (erf) ,step function,error function (erf)  complementary,Dirac delta function,smoothing,noise  removing,signal processing,stability,amplification factor,accuracy,diffusion equation  truncation error,diffusion equation  numerical Fourier number,Taylor series,Leapfrog scheme,diffusion coefficient non-constant,diffusion equation  1D, Implementation,diffusion equation stationary solution,diffusion coefficient  piecewise constant,diffusion equation  implementation,diffusion equation axi-symmetric diffusion,cylindrical coordinates,diffusion equation spherically-symmetric diffusion,spherical coordinates,diffusion equation 2D,diffusion equation 2D, numbering of mesh points,diffusion equation 2D, sparse matrix,diffusion equation 2D, banded matrix,diffusion equation 2D, implementation,dense coefficient matrix,callback function,diffusion equation 2D, verification (exact num. sol.),diffusion equation 2D, verification (conv. rates),verification  convergence rates,diffusion equation 2D, implementation (sparse),sparse Gaussian elimination,Jacobi iterative method,linear system,iterative methods,relaxation,Gauss-Seidel method,successive over-relaxation (SOR),red-black numbering,LU factorization,Cholesky factorization,matrix  half-bandwidth,spectral radius,symmetric successive over-relaxation (SSOR),conjugate gradient method,matrix  positive definite,preconditioning,random walk,stochastic variable,Bernoulli variable,expectation,vectorization,seed (random numbers),verification,diffusion limit of random walk,interrupt a program by Ctrl+c,stochastic difference equation,stochastic ODE,Fokker-Planck equation,Wiener process,Fick's law,internal energy,radioactive rock,equation of state,heat capacity,Fourier's law,heat conduction  coefficient of,mass balance,incompressible fluid,Darcy's law,dynamic viscosity,viscous effects,stationary fluid flow,stream function,Navier-Stokes equations,cylindrical coordinates,friction,neuronal fibers,cable equation,energy estimates (diffusion),Richardson iteration,preconditioning">

<title>Finite difference methods for diffusion processes</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('An explicit method for the 1D diffusion equation',
               1,
               'diffu:pde1:FEsec',
               'diffu:pde1:FEsec'),
              ('The initial-boundary value problem for 1D diffusion',
               2,
               None,
               '___sec1'),
              ('Forward Euler scheme', 2, 'diffu:pde1:FE', 'diffu:pde1:FE'),
              ('Implementation',
               2,
               'diffu:pde1:FE:code',
               'diffu:pde1:FE:code'),
              ('Verification',
               2,
               'diffu:pde1:FE:verify',
               'diffu:pde1:FE:verify'),
              ('Exact solution of discrete equations',
               3,
               'diffu:pde1:FE:verify:exact',
               'diffu:pde1:FE:verify:exact'),
              ('Checking convergence rates',
               3,
               'diffu:pde1:FE:verify:convrates',
               'diffu:pde1:FE:verify:convrates'),
              ('Numerical experiments',
               2,
               'diffu:pde1:FE:experiments',
               'diffu:pde1:FE:experiments'),
              ('Implicit methods for the 1D diffusion equation',
               1,
               'diffu:pde1:implicit',
               'diffu:pde1:implicit'),
              ('Backward Euler scheme', 2, 'diffu:pde1:BE', 'diffu:pde1:BE'),
              ('Sparse matrix implementation',
               2,
               'diffu:pde1:impl:sparse',
               'diffu:pde1:impl:sparse'),
              ('Crank-Nicolson scheme', 2, 'diffu:pde1:CN', 'diffu:pde1:CN'),
              ('The unifying $\\theta$ rule',
               2,
               'diffu:pde1:theta',
               'diffu:pde1:theta'),
              ('Experiments',
               2,
               'diffu:pde1:theta:experiments',
               'diffu:pde1:theta:experiments'),
              ('The Laplace and Poisson equation', 2, None, '___sec14'),
              ('Analysis of schemes for the diffusion equation',
               1,
               'diffu:pde1:analysis',
               'diffu:pde1:analysis'),
              ('Properties of the solution',
               2,
               'diffu:pde1:analysis:uex',
               'diffu:pde1:analysis:uex'),
              ('Similarity solution', 3, None, '___sec17'),
              ('Solution for a Gaussian pulse', 3, None, '___sec18'),
              ('Solution for a sine component', 3, None, '___sec19'),
              ('Analysis of discrete equations', 2, None, '___sec20'),
              ('Analysis of the finite difference schemes',
               2,
               'diffu:pde1:analysis:details',
               'diffu:pde1:analysis:details'),
              ('Stability', 3, None, '___sec22'),
              ('Accuracy', 3, None, '___sec23'),
              ('Truncation error', 3, None, '___sec24'),
              ('Analysis of the Forward Euler scheme',
               2,
               'diffu:pde1:analysis:FE',
               'diffu:pde1:analysis:FE'),
              ('Stability', 3, None, '___sec26'),
              ('Accuracy', 3, None, '___sec27'),
              ('Truncation error', 3, None, '___sec28'),
              ('Analysis of the Backward Euler scheme',
               2,
               'diffu:pde1:analysis:BE',
               'diffu:pde1:analysis:BE'),
              ('Stability', 3, None, '___sec30'),
              ('Truncation error', 3, None, '___sec31'),
              ('Analysis of the Crank-Nicolson scheme',
               2,
               'diffu:pde1:analysis:CN',
               'diffu:pde1:analysis:CN'),
              ('Stability', 3, None, '___sec33'),
              ('Truncation error', 3, None, '___sec34'),
              ('Analysis of the Leapfrog scheme',
               2,
               'diffu:pde1:analysis:leapfrog',
               'diffu:pde1:analysis:leapfrog'),
              ('Summary of accuracy of amplification factors',
               2,
               None,
               '___sec36'),
              ('Analysis of the 2D diffusion equation',
               2,
               'diffu:2D:analysis',
               'diffu:2D:analysis'),
              ('The Forward Euler scheme', 3, None, '___sec38'),
              ('The Backward Euler scheme', 3, None, '___sec39'),
              ('The Crank-Nicolson scheme', 3, None, '___sec40'),
              ('Explanation of numerical artifacts', 2, None, '___sec41'),
              ('Exercises', 1, None, '___sec42'),
              ('Exercise 1: Explore symmetry in a 1D problem',
               2,
               'diffu:exer:1D:gaussian:symmetric',
               'diffu:exer:1D:gaussian:symmetric'),
              ('Exercise 2: Investigate approximation errors from a $u_x=0$ boundary condition',
               2,
               'diffu:exer:1D:ux:onesided',
               'diffu:exer:1D:ux:onesided'),
              ('Exercise 3: Experiment with open boundary conditions in 1D',
               2,
               'diffu:exer:1D:openBC',
               'diffu:exer:1D:openBC'),
              ('Exercise 4: Simulate a diffused Gaussian peak in 2D/3D',
               2,
               None,
               '___sec46'),
              ('Exercise 5: Examine stability of a diffusion model with a source term',
               2,
               'diffu:exer:uterm',
               'diffu:exer:uterm'),
              ('Diffusion in heterogeneous media',
               1,
               'diffu:varcoeff',
               'diffu:varcoeff'),
              ('Discretization',
               2,
               'diffu:varcoeff:discr',
               'diffu:varcoeff:discr'),
              ('Implementation',
               2,
               'diffu:varcoeff:impl',
               'diffu:varcoeff:impl'),
              ('Stationary solution',
               2,
               'diffu:varcoeff:stationary',
               'diffu:varcoeff:stationary'),
              ('Piecewise constant medium',
               2,
               'diffu:varcoeff:piecewise',
               'diffu:varcoeff:piecewise'),
              ('Implementation of diffusion in a piecewise constant medium',
               2,
               'diffu:varcoeff:impl:piecewise',
               'diffu:varcoeff:impl:piecewise'),
              ('Axi-symmetric diffusion',
               2,
               'diffu:fd2:radial',
               'diffu:fd2:radial'),
              ('Spherically-symmetric diffusion',
               2,
               'diffu:fd2:spherical',
               'diffu:fd2:spherical'),
              ('Discretization in spherical coordinates',
               3,
               None,
               '___sec56'),
              ('Discretization in Cartesian coordinates',
               3,
               None,
               '___sec57'),
              ('Diffusion in 2D', 1, 'diffu:2D', 'diffu:2D'),
              ('Discretization', 2, 'diffu:2D:discr', 'diffu:2D:discr'),
              ('Numbering of mesh points versus equations and unknowns',
               2,
               'diffu:2D:numbering',
               'diffu:2D:numbering'),
              ('Algorithm for setting up the coefficient matrix',
               2,
               'diffu:2D:alg',
               'diffu:2D:alg'),
              ('Implementation with a dense coefficient matrix',
               2,
               'diffu:2D:impl:dense',
               'diffu:2D:impl:dense'),
              ('Verification: exact numerical solution',
               2,
               'diffu:2D:verify',
               'diffu:2D:verify'),
              ('Verification: convergence rates',
               2,
               'diffu:2D:convrate',
               'diffu:2D:convrate'),
              ('Implementation with a sparse coefficient matrix',
               2,
               'diffu:2D:impl:sparse',
               'diffu:2D:impl:sparse'),
              ('Understanding the diagonals', 3, None, '___sec66'),
              ('Filling the diagonals', 3, None, '___sec67'),
              ('Filling the right-hand side; scalar version',
               3,
               None,
               '___sec68'),
              ('Filling the right-hand side; vectorized version',
               3,
               None,
               '___sec69'),
              ('Verification', 3, None, '___sec70'),
              ('The Jacobi iterative method', 2, None, '___sec71'),
              ('Numerical scheme and linear system', 3, None, '___sec72'),
              ('Iterations', 3, None, '___sec73'),
              ('Initial guess', 3, None, '___sec74'),
              ('Relaxation', 3, None, '___sec75'),
              ('Stopping criteria', 3, None, '___sec76'),
              ('Code-friendly notation', 3, None, '___sec77'),
              ('Generalization of the scheme', 3, None, '___sec78'),
              ('Implementation of the Jacobi method',
               2,
               'diffu:2D:Jacobi:impl',
               'diffu:2D:Jacobi:impl'),
              ('Test problem: diffusion of a sine hill',
               2,
               'diffu:2D:Jacobi:impl:hill',
               'diffu:2D:Jacobi:impl:hill'),
              ('The relaxed Jacobi method and its relation to the Forward Euler method',
               2,
               'diffu:2D:Jacobi_vs_FE',
               'diffu:2D:Jacobi_vs_FE'),
              ('The Gauss-Seidel and SOR methods',
               2,
               'diffu:2D:SOR',
               'diffu:2D:SOR'),
              ('Scalar implementation of the SOR method',
               2,
               'diffu:2D:SOR:impl:scalar',
               'diffu:2D:SOR:impl:scalar'),
              ('Vectorized implementation of the SOR method',
               2,
               'diffu:2D:SOR:impl:vectorized',
               'diffu:2D:SOR:impl:vectorized'),
              ('Direct versus iterative methods',
               2,
               'diffu:2D:direct_vs_iter',
               'diffu:2D:direct_vs_iter'),
              ('Direct methods', 3, None, '___sec86'),
              ('Iterative methods', 3, None, '___sec87'),
              ('The Conjugate gradient method',
               2,
               'diffu:2D:CG',
               'diffu:2D:CG'),
              ('What is the recommended method for solving linear systems?',
               2,
               None,
               '___sec89'),
              ('Random walk', 1, 'diffu:randomwalk', 'diffu:randomwalk'),
              ('Random walk in 1D',
               2,
               'diffu:randomwalk:1D',
               'diffu:randomwalk:1D'),
              ('Statistical considerations',
               2,
               'diffu:randomwalk:1D:EVar',
               'diffu:randomwalk:1D:EVar'),
              ('Playing around with some code',
               2,
               'diffu:randomwalk:1D:code1',
               'diffu:randomwalk:1D:code1'),
              ('Scalar code', 3, None, '___sec94'),
              ('Vectorized code', 3, None, '___sec95'),
              ('Fixing the random sequence', 3, None, '___sec96'),
              ('Verification', 3, None, '___sec97'),
              ('Equivalence with diffusion',
               2,
               'diffu:randomwalk:1D:pde',
               'diffu:randomwalk:1D:pde'),
              ('Implementation of multiple walks', 2, None, '___sec99'),
              ('Scalar version', 3, None, '___sec100'),
              ('Vectorized version', 3, None, '___sec101'),
              ('Improved vectorized version', 3, None, '___sec102'),
              ('Remark on vectorized code and parallelization',
               3,
               None,
               '___sec103'),
              ('Test function', 3, None, '___sec104'),
              ('Demonstration of multiple walks', 2, None, '___sec105'),
              ('Ascii visualization of 1D random walk',
               2,
               'diffu:randomwalk:1D:avplotter',
               'diffu:randomwalk:1D:avplotter'),
              ('Random walk as a stochastic equation',
               2,
               'diffu:randomwalk:1D:ode',
               'diffu:randomwalk:1D:ode'),
              ('Random walk in 2D', 2, None, '___sec108'),
              ('Random walk in any number of space dimensions',
               2,
               None,
               '___sec109'),
              ('Multiple random walks in any number of space dimensions',
               2,
               None,
               '___sec110'),
              ('Scalar code', 3, None, '___sec111'),
              ('Vectorized code', 3, None, '___sec112'),
              ('Applications', 1, 'diffu:app', 'diffu:app'),
              ('Diffusion of a substance',
               2,
               'diffu:app:substance',
               'diffu:app:substance'),
              ('Heat conduction', 2, 'diffu:app:heat', 'diffu:app:heat'),
              ('Porous media flow',
               2,
               'diffu:app:porous',
               'diffu:app:porous'),
              ('Potential fluid flow', 2, None, '___sec117'),
              ('Streamlines for 2D fluid flow', 2, None, '___sec118'),
              ('The potential of an electric field', 2, None, '___sec119'),
              ('Development of flow between two flat plates',
               2,
               'diffu:app:Couette',
               'diffu:app:Couette'),
              ('Flow in a straight tube',
               2,
               'diffu:app:pipeflow',
               'diffu:app:pipeflow'),
              ('Tribology: thin film fluid flow', 2, None, '___sec122'),
              ('Propagation of electrical signals in the brain',
               2,
               None,
               '___sec123'),
              ('Exercises', 1, None, '___sec124'),
              ('Exercise 6: Stabilizing the Crank-Nicolson method by Rannacher time stepping',
               2,
               'diffu:exer:CN:Rannacher',
               'diffu:exer:CN:Rannacher'),
              ('Project 7: Energy estimates for diffusion problems',
               2,
               'diffu:exer:energy:estimates',
               'diffu:exer:energy:estimates'),
              ('Exercise 8: Splitting methods and preconditioning',
               2,
               'diffu:exer:splitting_prec',
               'diffu:exer:splitting_prec'),
              ('Problem 9: Oscillating surface temperature of the earth',
               2,
               'diffu:exer:earthosc',
               'diffu:exer:earthosc'),
              ('Problem 10: Oscillating and pulsating flow in tubes',
               2,
               'diffu:exer:bloodflow',
               'diffu:exer:bloodflow'),
              ('Problem 11: Scaling a welding problem',
               2,
               'diffu:exer:welding',
               'diffu:exer:welding'),
              ('Exercise 12: Implement a Forward Euler scheme for axi-symmetric diffusion',
               2,
               'diffu:exer:axisymm',
               'diffu:exer:axisymm'),
              ('Bibliography', 1, None, '___sec132')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\q}{\boldsymbol{q}}
\newcommand{\g}{\boldsymbol{g}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="diffu-sol.html">Finite difference methods for diffusion processes</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FEsec" style="font-size: 80%;"><b>An explicit method for the 1D diffusion equation</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The initial-boundary value problem for 1D diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:verify:exact" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solution of discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:verify:convrates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checking convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:experiments" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical experiments</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:implicit" style="font-size: 80%;"><b>Implicit methods for the 1D diffusion equation</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Sparse matrix implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:theta" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The unifying \( \theta \) rule</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:theta:experiments" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Laplace and Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis" style="font-size: 80%;"><b>Analysis of schemes for the diffusion equation</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:uex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Properties of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution for a Gaussian pulse</a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution for a sine component</a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:details" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the finite difference schemes</a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accuracy</a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accuracy</a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:leapfrog" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the Leapfrog scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Summary of accuracy of amplification factors</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the 2D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Explanation of numerical artifacts</a></li>
     <!-- navigation toc: --> <li><a href="#___sec42" style="font-size: 80%;"><b>Exercises</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:gaussian:symmetric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 1: Explore symmetry in a 1D problem</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:ux:onesided" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 2: Investigate approximation errors from a \( u_x=0 \) boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:openBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 3: Experiment with open boundary conditions in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 4: Simulate a diffused Gaussian peak in 2D/3D</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:uterm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 5: Examine stability of a diffusion model with a source term</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff" style="font-size: 80%;"><b>Diffusion in heterogeneous media</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:discr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:stationary" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Stationary solution</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:piecewise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Piecewise constant medium</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:impl:piecewise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of diffusion in a piecewise constant medium</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:fd2:radial" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Axi-symmetric diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:fd2:spherical" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Spherically-symmetric diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization in spherical coordinates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization in Cartesian coordinates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D" style="font-size: 80%;"><b>Diffusion in 2D</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:discr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:numbering" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numbering of mesh points versus equations and unknowns</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Algorithm for setting up the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:impl:dense" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation with a dense coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Verification: exact numerical solution</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:convrate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Verification: convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation with a sparse coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#___sec66" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Understanding the diagonals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the diagonals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the right-hand side; scalar version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec69" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the right-hand side; vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Jacobi iterative method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical scheme and linear system</a></li>
     <!-- navigation toc: --> <li><a href="#___sec73" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec74" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial guess</a></li>
     <!-- navigation toc: --> <li><a href="#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="#___sec77" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code-friendly notation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization of the scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of the Jacobi method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi:impl:hill" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Test problem: diffusion of a sine hill</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi_vs_FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The relaxed Jacobi method and its relation to the Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Gauss-Seidel and SOR methods</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR:impl:scalar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Scalar implementation of the SOR method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR:impl:vectorized" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Vectorized implementation of the SOR method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:direct_vs_iter" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Direct versus iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:CG" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Conjugate gradient method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What is the recommended method for solving linear systems?</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk" style="font-size: 80%;"><b>Random walk</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Random walk in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:EVar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Statistical considerations</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:code1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Playing around with some code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixing the random sequence</a></li>
     <!-- navigation toc: --> <li><a href="#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:pde" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Equivalence with diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation of multiple walks</a></li>
     <!-- navigation toc: --> <li><a href="#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Improved vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark on vectorized code and parallelization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec105" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Demonstration of multiple walks</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:avplotter" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Ascii visualization of 1D random walk</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:ode" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Random walk as a stochastic equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Random walk in 2D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Random walk in any number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multiple random walks in any number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized code</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app" style="font-size: 80%;"><b>Applications</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:substance" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Diffusion of a substance</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:heat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Heat conduction</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:porous" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Porous media flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Potential fluid flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Streamlines for 2D fluid flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The potential of an electric field</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:Couette" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Development of flow between two flat plates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:pipeflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Flow in a straight tube</a></li>
     <!-- navigation toc: --> <li><a href="#___sec122" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Tribology: thin film fluid flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec123" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Propagation of electrical signals in the brain</a></li>
     <!-- navigation toc: --> <li><a href="#___sec124" style="font-size: 80%;"><b>Exercises</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:CN:Rannacher" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:energy:estimates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Project 7: Energy estimates for diffusion problems</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:splitting_prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 8: Splitting methods and preconditioning</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:earthosc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 9: Oscillating surface temperature of the earth</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:bloodflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 10: Oscillating and pulsating flow in tubes</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:welding" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 11: Scaling a welding problem</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:axisymm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 12: Implement a Forward Euler scheme for axi-symmetric diffusion</a></li>
     <!-- navigation toc: --> <li><a href="._diffu-sol002.html#___sec132" style="font-size: 80%;"><b>Bibliography</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0001"></a>
<!-- !split -->

<p>
The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2},
$$

where \( u(x,t) \) is the unknown function to be solved for, \( x \) is a coordinate
in space, and \( t \) is time. The coefficient \( \dfc \) is the <em>diffusion
coefficient</em> and determines how fast \( u \) changes in time. A quick
short form for the diffusion equation is \( u_t = \dfc u_{xx} \).

<p>
Compared to the wave equation, \( u_{tt}=c^2u_{xx} \), which looks very similar,
the diffusion equation features solutions that are very different from
those of the wave equation. Also, the diffusion equation
makes quite different demands to the numerical
methods.

<p>
Typical diffusion problems may experience rapid change in the very
beginning, but then the evolution of \( u \) becomes slower and slower.
The solution is usually very smooth, and after some time, one cannot
recognize the initial shape of \( u \). This is in sharp contrast to
solutions of the wave equation where the initial shape is preserved in
homogeneous media &ndash; the solution is then basically a moving initial
condition. The standard wave equation \( u_{tt}=c^2u_{xx} \) has solutions
that propagate with speed \( c \) forever, without changing shape, while
the diffusion equation converges to a <em>stationary solution</em> \( \bar
u(x) \) as \( t\rightarrow\infty \). In this limit, \( u_t=0 \), and \( \bar u \) is
governed by \( \bar u''(x)=0 \).  This stationary limit of the diffusion
equation is called the <em>Laplace</em> equation and arises in a very wide
range of applications throughout the sciences.

<p>
It is possible to solve for \( u(x,t) \) using an explicit scheme, as we
do in the section <a href="#diffu:pde1:FEsec">An explicit method for the 1D diffusion equation</a>, but the time step restrictions
soon become much less favorable than for an explicit scheme applied to
the wave equation. And of more importance, since the solution \( u \) of
the diffusion equation is very smooth and changes slowly, small time
steps are not convenient and not required by accuracy as the diffusion
process converges to a stationary state. Therefore, implicit schemes
(as described in the section <a href="#diffu:pde1:implicit">Implicit methods for the 1D diffusion equation</a>) are popular, but
these require solutions of systems of algebraic equations. We shall
use ready-made software for this purpose, but also program some simple
iterative methods.
The exposition is, as usual in this book, very basic and focuses on
the basic ideas and how to implement. More comprehensive mathematical
treatments and classical analysis
of the methods are found in lots of textbooks. A favorite
of ours in this respect is the one by LeVeque <a href="._diffu-sol002.html#LeVeque_2007">[1]</a>.
The books by Strikwerda <a href="._diffu-sol002.html#Strikwerda_2007">[2]</a> and by
Lapidus and Pinder <a href="._diffu-sol002.html#Lapidus_Pinder_1982">[3]</a> are also highly recommended
as additional material on the topic.

<h1 id="diffu:pde1:FEsec">An explicit method for the 1D diffusion equation</h1>

<p>
Explicit finite difference methods for the wave equation \( u_{tt}=c^2u_{xx} \)
can be used, with small modifications, for solving \( u_t = \dfc u_{xx} \)
as well.

<h2 id="___sec1">The initial-boundary value problem for 1D diffusion </h2>

<p>
To obtain a unique solution of the diffusion equation, or equivalently,
to apply numerical methods, we need initial and boundary conditions.
The diffusion equation goes with one initial condition \( u(x,0)=I(x) \), where
\( I \) is a prescribed function. One boundary condition is required at
each point on the boundary, which in 1D means that \( u \) must be known,
\( u_x \) must be known, or some combination of them.

<p>
We shall start with the simplest boundary condition: \( u=0 \). The
complete initial-boundary value diffusion problem in one space
dimension can then be specified as

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2} + f, \quad x\in (0,L),\ t\in (0,T]
\tag{1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\tag{2}\\ 
u(0,t) & = 0, \quad  t>0,
\tag{3}\\ 
u(L,t) & = 0, \quad  t>0\tp
\tag{4}
\end{align}
$$

With only a first-order derivative in time,
only one <em>initial condition</em> is needed, while the second-order
derivative in space leads to a demand for two <em>boundary conditions</em>.
We have added a source term \( f=f(x,t) \), which is
convenient when testing implementations.

<p>
Diffusion equations like <a href="#mjx-eqn-1">(1)</a> have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
\( u(x,t) \) represents the temperature of some substance at point \( x \) and
time \( t \). Other applications are listed in the section <a href="#diffu:app">Applications</a>.

<h2 id="diffu:pde1:FE">Forward Euler scheme</h2>

<p>
The first step in the discretization procedure is to replace the
domain \( [0,L]\times [0,T] \) by a set of mesh points. Here we apply
equally spaced mesh points

$$
\begin{equation*} x_i=i\Delta x,\quad i=0,\ldots,N_x,\end{equation*}
$$

and

$$
\begin{equation*} t_n=n\Delta t,\quad n=0,\ldots,N_t \tp  \end{equation*}
$$

Moreover, \( u^n_i \) denotes the mesh function that
approximates \( u(x_i,t_n) \) for \( i=0,\ldots,N_x \) and \( n=0,\ldots,N_t \).
Requiring the PDE <a href="#mjx-eqn-1">(1)</a> to be fulfilled at a mesh point \( (x_i,t_n) \)
leads to the equation

$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n) + f(x_i,t_n),
\tag{5}
\end{equation}
$$

The next step is to replace the derivatives by finite difference approximations.
The computationally simplest method arises from
using a forward difference in time and a central difference in
space:

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u + f]^n_i \tp
\tag{6}
\end{equation}
$$

Written out,

$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{7}
\end{equation}
$$

We have turned the PDE into algebraic equations, also often called
discrete equations. The key property of the equations is that they
are algebraic, which makes them easy to solve.
As usual, we anticipate that \( u^n_i \) is already computed such that
\( u^{n+1}_i \) is the only unknown in <a href="#mjx-eqn-7">(7)</a>.
Solving with respect to this unknown is easy:

$$
\begin{equation}
u^{n+1}_i = u^n_i + F\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) + \Delta t f_i^n,
\tag{8}
\end{equation}
$$

where we have introduced the <em>mesh Fourier number</em>:

$$
\begin{equation}
F = \dfc\frac{\Delta t}{\Delta x^2}\tp
\tag{9}
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>\( F \) is the key parameter in the discrete diffusion equation.</b>
Note that \( F \) is a <em>dimensionless</em> number that lumps the key physical
parameter in the problem, \( \dfc \), and the discretization parameters
\( \Delta x \) and \( \Delta t \) into a single parameter. Properties
of the numerical method are critically dependent upon the value of
\( F \) (see the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> for details).
</div>


<p>
The computational algorithm then becomes

<ol>
 <li> compute \( u^0_i=I(x_i) \) for \( i=0,\ldots,N_x \)</li>
 <li> for \( n=0,1,\ldots,N_t \):

<ol type="a"></li>
   <li> apply <a href="#mjx-eqn-8">(8)</a> for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>

</ol>

The algorithm is compactly and fully specified in Python:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
F <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_n[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        u[i] <span style="color: #666666">=</span> u_n[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
	       dt<span style="color: #666666">*</span>f(x[i], t[n])

    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n[:]<span style="color: #666666">=</span> u
</pre></div>
<p>
Note that we use <code>a</code> for \( \dfc \) in the code, motivated by easy visual
mapping between the variable name and the mathematical symbol in formulas.

<p>
We need to state already now that the shown algorithm does not
produce meaningful results unless \( F\leq 1/2 \). Why is explained in
the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a>.

<h2 id="diffu:pde1:FE:code">Implementation</h2>

<p>
The file <a href="http://tinyurl.com/nu656p2/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a complete function <code>solver_FE_simple</code>
for solving the 1D diffusion equation with \( u=0 \) on the boundary
as specified in the algorithm above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE_simple</span>(I, a, f, L, dt, F, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Simplest expression of the computational algorithm</span>
<span style="color: #BA2121; font-style: italic">    using the Forward Euler method and explicit Python loops.</span>
<span style="color: #BA2121; font-style: italic">    For this method F &lt;= 0.5 for stability.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>;  t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()  <span style="color: #408080; font-style: italic"># For measuring the CPU time</span>

    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># Mesh points in space</span>
    <span style="color: #408080; font-style: italic"># Make sure dx and dt are compatible with x and t</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)
    u_n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
        u_n[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
            u[i] <span style="color: #666666">=</span> u_n[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
                   dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        <span style="color: #408080; font-style: italic">#u_n[:] = u  # safe, but slow</span>
        u_n, u <span style="color: #666666">=</span> u, u_n

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> u_n, x, t, t1<span style="color: #666666">-</span>t0  <span style="color: #408080; font-style: italic"># u_n holds latest u</span>
</pre></div>
<p>
A faster alternative is available in the function <code>solver_FE</code>, which 
adds the possibility of solving the finite difference scheme by vectorization.
The vectorized version replaces the explicit loop

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    u[i] <span style="color: #666666">=</span> u_n[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">+1</span>]) \ 
           <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[i], t[n])
</pre></div>
<p>
by arithmetics on displaced slices of the <code>u</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_n[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_n[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_n[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
<span style="color: #408080; font-style: italic"># or</span>
u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_n[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_n[<span style="color: #666666">2</span>:]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>], t[n])
</pre></div>
<p>
For example,
the vectorized version runs 70 times faster than the scalar version
in a case with 100 time steps and a spatial mesh of \( 10^5 \) cells.

<p>
The <code>solver_FE</code> function also features a callback function such that the
user can process the solution at each time level. The callback
function looks like <code>user_action(u, x, t, n)</code>, where <code>u</code> is the array
containing the solution at time level <code>n</code>, <code>x</code> holds all the
spatial mesh points, while <code>t</code> holds all the temporal mesh points.
The <code>solver_FE</code> function is very similar to <code>solver_FE_simple</code> above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE</span>(I, a, f, L, dt, F, T,
              user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Vectorized implementation of solver_FE_simple.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>;  t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()  <span style="color: #408080; font-style: italic"># for measuring the CPU time</span>

    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># Mesh points in space</span>
    <span style="color: #408080; font-style: italic"># Make sure dx and dt are compatible with x and t</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array</span>
    u_n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t-dt</span>

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
        u_n[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_n, x, t, <span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Update all inner points</span>
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
                u[i] <span style="color: #666666">=</span> u_n[i] <span style="color: #666666">+</span>\ 
                       F<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span>\ 
                       dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;vectorized&#39;</span>:
            u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_n[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span>  \ 
                      F<span style="color: #666666">*</span>(u_n[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_n[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span>\ 
                      dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">ValueError</span>(<span style="color: #BA2121">&#39;version=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> version)

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, x, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_n, u <span style="color: #666666">=</span> u, u_n

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> t1<span style="color: #666666">-</span>t0
</pre></div>

<h2 id="diffu:pde1:FE:verify">Verification</h2>

<h3 id="diffu:pde1:FE:verify:exact">Exact solution of discrete equations</h3>

<p>
Before thinking about running the functions in the previous section,
we need to construct a suitable test example for verification. It
appears that a manufactured solution that is linear in time and at
most quadratic in space fulfills the Forward Euler scheme
exactly. With the restriction that \( u=0 \) for \( x=0,L \), we can try the
solution

$$ u(x,t) = 5tx(L-x)\tp$$

Inserted in the PDE, it requires a source term

$$ f(x,t) = 10\dfc t + 5x(L-x)\tp$$

Let us check
that the manufactured <code>u</code> fulfills the scheme:

$$
\begin{align*}
\lbrack D_t^+ u = \dfc D_x D_x u + f\rbrack^n_i &=
\lbrack 5x(L-x)D_t^+ t  = 5 t\dfc D_x D_x (xL-x^2) +\\ 
&\quad\quad 10\dfc t + 5x(L-x)\rbrack^n_i\\ 
&=
\lbrack 5x(L-x)  = 5 t\dfc (-2) + 10\dfc t + 5x(L-x) \rbrack^n_i,
\end{align*}
$$

which is a 0=0 expression.
The computation of the source term, given any \( u \),
is easily automated with <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, t, a, L <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x t a L&#39;</span>)
u <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x)<span style="color: #666666">*5*</span>t

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">pde</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym<span style="color: #666666">.</span>diff(u, t) <span style="color: #666666">-</span> a<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x, x)

f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(pde(u))
</pre></div>
<p>
Now we can choose any expression for <code>u</code> and automatically
get the suitable source term <code>f</code>. However, the manufactured solution
<code>u</code> will in general
not be exactly reproduced by the scheme: only constant and linear
functions are differentiated correctly by a forward difference, while only
constant, linear, and quadratic functions are differentiated exactly by
a \( [D_xD_x u]^n_i \) difference.

<p>
The numerical code will need to access the <code>u</code> and <code>f</code> above
as Python functions. The exact solution is wanted as a Python
function <code>u_exact(x, t)</code>, while the source term is wanted as
<code>f(x, t)</code>. The parameters <code>a</code> and <code>L</code> in <code>u</code> and <code>f</code> above
are symbols and must be replaced by <code>float</code> objects in a Python
function. This can be done by redefining <code>a</code> and <code>L</code> as
<code>float</code> objects and performing substitutions of symbols by
numbers in <code>u</code> and <code>f</code>. The appropriate code looks like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
u_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], u<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
I <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: u_exact(x, <span style="color: #666666">0</span>)
</pre></div>
<p>
Here we also make a function <code>I</code> for the initial condition.

<p>
The idea now is that our manufactured solution should be
exactly reproduced by the code (to machine precision).
For this purpose we make a test function for comparing
the exact and numerical solutions at the end of the
time interval:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver_FE</span>():
    <span style="color: #408080; font-style: italic"># Define u_exact, f, I as explained above</span>

    dx <span style="color: #666666">=</span> L<span style="color: #666666">/3</span>  <span style="color: #408080; font-style: italic"># 3 cells</span>
    F <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    dt <span style="color: #666666">=</span> F<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE_simple(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE_simple: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, scalar: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;vectorized&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, vectorized: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>The critical value \( F=0.5 \).</b>
We emphasize that the value <code>F=0.5</code> is critical: the tests above
will fail if <code>F</code> has a larger value. This is because the Forward
Euler scheme is unstable for \( F>1/2 \).

<p>
The reader may wonder if
\( F=1/2 \) is safe or if \( F < 1/2 \) should be required. Experiments show
that \( F=1/2 \) works fine for \( u_t=\dfc u_{xx} \), so
there is no accumulation of rounding
errors in this case and hence no need to introduce any safety factor
to keep \( F \) away from the limiting value 0.5.
</div>


<h3 id="diffu:pde1:FE:verify:convrates">Checking convergence rates</h3>

<p>
If our chosen exact solution does not satisfy the discrete equations
exactly, we are left with checking the convergence rates, just as we did
previously for the wave equation. However, with the Euler scheme here,
we have different accuracies in time and space, since we use a second
order approximation to the spatial derivative and a first order approximation
to the time derivative. Thus, we must expect different convergence rates in
time and space. For the numerical error,

$$ E = C_t\Delta t^r + C_x\Delta x^p,$$

we should get convergence rates \( r=1 \) and \( p=2 \) (\( C_t \) and \( C_x \) are unknown constants).
As previously,
in the section ref{wave:pde2:fd:MMS},
we simplify matters by introducing a single discretization parameter \( h \):

$$ h = \Delta t,\quad \Delta x = Kh^{r/p},$$

where \( K \) is any constant. This allows us to factor out only <em>one</em>
discretization parameter \( h \) from the formula:

$$
E = C_t h + C_x (Kh^{r/p})^p = \tilde C h^r,\quad
\tilde C = C_t + C_sK^r\tp$$

The computed rate \( r \) should approach 1 with increasing resolution.

<p>
It is tempting, for simplicity,
to choose \( K=1 \), which gives \( \Delta x = h^{r/p} \), expected to be
\( \sqrt{\Delta t} \). However,
we have to control the stability requirement: \( F\leq\half \),
which means

$$ \frac{\dfc\Delta t}{\Delta x^2}\leq\half\quad\Rightarrow
\quad \Delta x \geq \sqrt{2\dfc}h^{1/2} ,$$

implying that \( K=\sqrt{2\dfc} \) is our choice in experiments where we
lie on the stability limit \( F=1/2 \).

<h2 id="diffu:pde1:FE:experiments">Numerical experiments</h2>

<p>
When a test function like the one above runs silently without errors,
we have some evidence for a correct implementation of the numerical
method.  The next step is to do some experiments with more interesting
solutions.

<p>
We target a scaled diffusion problem where \( x/L \) is a new spatial
coordinate and \( \dfc t/L^2 \) is a new time coordinate. The source term
\( f \) is omitted, and \( u \) is scaled by \( \max_{x\in [0,L]}|I(x)| \) (see Section 3.2 in
 <a href="._diffu-sol002.html#Langtangen_scaling">[4]</a> for details).
The governing PDE is then

$$ \frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2},$$

in the spatial domain \( [0,L] \), with boundary conditions \( u(0)=u(1)=0 \).
Two initial conditions will be tested: a discontinuous plug,

$$ I(x) = \left\lbrace\begin{array}{ll}
0, & |x-L/2| > 0.1\\ 
1, & \hbox{otherwise}
\end{array}\right.$$

and a smooth Gaussian function,

$$ I(x) = e^{-\frac{1}{2\sigma^2}(x-L/2)^2}\tp$$

The functions <code>plug</code> and <code>gaussian</code> in <a href="http://tinyurl.com/nu656p2/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a> run the two cases,
respectively:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plug</span>(scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, F<span style="color: #666666">=0.5</span>, Nx<span style="color: #666666">=50</span>):
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    <span style="color: #408080; font-style: italic"># Compute dt from Nx and F</span>
    dx <span style="color: #666666">=</span> L<span style="color: #666666">/</span>Nx;  dt <span style="color: #666666">=</span> F<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plug profile as initial condition.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>) <span style="color: #666666">&gt;</span> <span style="color: #666666">0.1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>

    cpu <span style="color: #666666">=</span> viz(I, a, L, dt, F, T,
              umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
              scheme<span style="color: #666666">=</span>scheme, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;CPU time:&#39;</span>, cpu

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">gaussian</span>(scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, F<span style="color: #666666">=0.5</span>, Nx<span style="color: #666666">=50</span>, sigma<span style="color: #666666">=0.05</span>):
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    <span style="color: #408080; font-style: italic"># Compute dt from Nx and F</span>
    dx <span style="color: #666666">=</span> L<span style="color: #666666">/</span>Nx;  dt <span style="color: #666666">=</span> F<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Gaussian profile as initial condition.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-0.5*</span>((x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>sigma<span style="color: #666666">**2</span>)

    u, cpu <span style="color: #666666">=</span> viz(I, a, L, dt, F, T,
                 umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
                 scheme<span style="color: #666666">=</span>scheme, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;CPU time:&#39;</span>, cpu
</pre></div>
<p>
These functions make use of the function <code>viz</code> for running the
solver and visualizing the solution using a callback function
with plotting:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">viz</span>(I, a, L, dt, F, T, umin, umax,
        scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>):

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_u</span>(u, x, t, n):
        plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;r-&#39;</span>, axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, L, umin, umax],
                 title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n])
        <span style="color: #008000; font-weight: bold">if</span> framefiles:
            plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_frame</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> n)
        <span style="color: #008000; font-weight: bold">if</span> t[n] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">2</span>)
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #AA22FF; font-weight: bold">not</span> framefiles:
            <span style="color: #408080; font-style: italic"># It takes time to write files so pause is needed</span>
            <span style="color: #408080; font-style: italic"># for screen only animation</span>
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.2</span>)

    user_action <span style="color: #666666">=</span> plot_u <span style="color: #008000; font-weight: bold">if</span> animate <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">lambda</span> u,x,t,n: <span style="color: #008000">None</span>

    cpu <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(<span style="color: #BA2121">&#39;solver_&#39;</span><span style="color: #666666">+</span>scheme)(I, a, L, dt, F, T,
                                 user_action<span style="color: #666666">=</span>user_action)
    <span style="color: #008000; font-weight: bold">return</span> cpu
</pre></div>
<p>
Notice that this <code>viz</code> function stores all the solutions in a
list <code>solutions</code> in the callback function. Modern computers have
hardly any problem with storing a lot of such solutions for moderate
values of \( N_x \) in 1D problems, but for 2D and 3D problems, this
technique cannot be used and solutions must be stored in files.

<p>
Our experiments employ a time step \( \Delta t = 0.0002 \) and
simulate for \( t\in [0,0.1] \). First we try the highest value of
\( F \): \( F=0.5 \). This resolution corresponds to
\( N_x=50 \). A possible terminal command is

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;from diffu1D_u0 import gaussian
          gaussian(&quot;solver_FE&quot;, F=0.5, dt=0.0002)&#39;
</pre></div>
<p>
The \( u(x,t) \) curve as a function of \( x \) is shown in Figure
<a href="#diffu:pde1:FE:fig:F=0.5">1</a> at four time levels.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<!-- <a href="http://tinyurl.com/pu5uyfn/pub/pub/diffu/html/mov-diffu/diffu1D_u0_FE_plug/movie.ogg" target="_self">movie</a> -->
<!-- Does not work: -->
<!-- http://tinyurl.com/pu5uyfn/pub/diffu/html/mov-diffu/diffu1D_u0_FE_plug/movie.ogg -->
<!-- Works: -->
<!-- https://raw.githubusercontent.com/hplgit/fdm-book/master/doc/.src/book/mov-diffu/diffu1D_u0_FE_plug/movie.ogg -->

<p>
We see that the curves have saw-tooth waves in the beginning of the
simulation. This non-physical noise is smoothed out with time, but
solutions of the diffusion equations are known to be smooth, and
this numerical solution is definitely not smooth.
Lowering \( F \) helps: \( F\leq 0.25 \) gives a smooth solution, see
Figure <a href="#diffu:pde1:FE:fig:F=0.25">2</a>.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
Increasing \( F \) slightly beyond the limit 0.5, to \( F=0.51 \),
gives growing, non-physical instabilities,
as seen in Figure <a href="#diffu:pde1:FE:fig:F=0.51">3</a>.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 1:  Forward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.5 --> </p></center>
<p><img src="fig-diffu/plug_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.25"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 2:  Forward Euler scheme for \( F=0.25 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.25 --> </p></center>
<p><img src="fig-diffu/plug_FE_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.51"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Forward Euler scheme for \( F=0.51 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.51 --> </p></center>
<p><img src="fig-diffu/plug_FE_F051.png" align="bottom" width=800></p>
</center>

<p>
Instead of a discontinuous initial condition we now try the smooth
Gaussian function for \( I(x) \). A simulation for \( F=0.5 \)
is shown in Figure <a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>. Now the numerical solution
is smooth for all times, and this is true for any \( F\leq 0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:gauss:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 4:  Forward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:FE:fig:gauss:F=0.5 --> </p></center>
<p><img src="fig-diffu/gaussian_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
Experiments with these two choices of \( I(x) \) reveal some
important observations:

<ul>
 <li> The Forward Euler scheme leads to growing solutions if \( F>\half \).</li>
 <li> \( I(x) \) as a discontinuous plug leads to a saw tooth-like noise
   for \( F=\half \), which is absent for \( F\leq\frac{1}{4} \).</li>
 <li> The smooth Gaussian initial function leads to a smooth solution
   for all relevant \( F \) values (\( F\leq \half \)).</li>
</ul>

<h1 id="diffu:pde1:implicit">Implicit methods for the 1D diffusion equation</h1>

<p>
Simulations with the Forward Euler scheme show that the time step
restriction, \( F\leq\half \), which means \( \Delta t \leq \Delta x^2/(2\dfc) \),
may be relevant in the beginning of the diffusion process, when the
solution changes quite fast, but as time increases, the process slows
down, and a small \( \Delta t \) may be inconvenient. With 
<em>implicit schemes</em>, which lead to coupled systems of linear equations
to be solved at each time level, any size of \( \Delta t \) is possible
(but the accuracy decreases with increasing \( \Delta t \)).
The Backward Euler scheme, derived and implemented below, is the
simplest implicit scheme for the diffusion equation.

<h2 id="diffu:pde1:BE">Backward Euler scheme</h2>

<p>
In <a href="#mjx-eqn-5">(5)</a>, we now apply a backward difference in time,
but the same central difference in space:

$$
\begin{equation}
[D_t^- u = D_xD_x u + f]^n_i,
\tag{10}
\end{equation}
$$

which written out reads

$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{11}
\end{equation}
$$

Now we assume \( u^{n-1}_i \) is already computed, but that all quantities at the &quot;new&quot;
time level \( n \) are unknown. This time it is not possible to solve
with respect to \( u_i^{n} \) because this value couples to its neighbors
in space, \( u^n_{i-1} \) and \( u^n_{i+1} \), which are also unknown.
Let us examine this fact for the case when \( N_x=3 \). Equation <a href="#mjx-eqn-11">(11)</a> written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2} + f_1^n
\tag{12}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2} + f_2^n
\tag{13}
\end{align}
$$

The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero. Collecting the
unknown new values \( u^n_1 \) and \( u^n_2 \) on the left-hand side and multiplying
by \( \Delta t \) gives

$$
\begin{align}
\left(1+  2F\right) u^{n}_1 - F u^{n}_{2}    &= u^{n-1}_1 + \Delta t f_1^n,
\tag{14}\\ 
- F u^{n}_{1} + \left(1+  2F\right) u^{n}_2  &= u^{n-1}_2 + \Delta t f_2^n\tp
\tag{15}
\end{align}
$$

This is a coupled \( 2\times 2 \) system of algebraic equations for
the unknowns \( u^n_1 \) and \( u^n_2 \). The equivalent matrix form is

$$ \left(\begin{array}{cc}
1+  2F &   - F\\ 
- F    & 1+  2F
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_2
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1 + \Delta t f_1^n\\ 
u^{n-1}_2 + \Delta t f_2^n
\end{array}\right)
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Terminology: implicit vs. explicit methods.</b>
Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
<em>implicit methods</em>.
The counterpart, <em>explicit methods</em>, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.
With explicit methods we have a closed-form formula for the value of
the unknown at each mesh point.

<p>
Very often explicit schemes have a restriction on the size of the time
step that can be relaxed by using implicit schemes. In fact,
implicit schemes are frequently unconditionally stable, so the size of the
time step is governed by accuracy and not by stability. This is the great
advantage of implicit schemes.
</div>


<p>
In the general case, <a href="#mjx-eqn-11">(11)</a> gives rise to
a coupled \( (N_x-1)\times (N_x-1) \) system of algebraic equations for
all the unknown \( u^n_i \) at the interior spatial points \( i=1,\ldots,N_x-1 \).
Collecting the unknowns on the left-hand side,
<a href="#mjx-eqn-11">(11)</a> can be written

$$
\begin{equation}
- F u^n_{i-1} + \left(1+  2F \right) u^{n}_i - F u^n_{i+1} =
u_{i-1}^{n-1},
\tag{16}
\end{equation}
$$

for \( i=1,\ldots,N_x-1 \).
One can either view these equations as a system where the
\( u^{n}_i \) values at the internal mesh points, \( i=1,\ldots,N_x-1 \), are
unknown, or we may append the boundary values \( u^n_0 \) and \( u^n_{N_x} \)
to the system. In the latter case, all \( u^n_i \) for \( i=0,\ldots,N_x \)
are considered unknown, and we must add the boundary equations to
the \( N_x-1 \) equations in <a href="#mjx-eqn-16">(16)</a>:

$$
\begin{align}
u_0^n &= 0,label{diffu:pde1:step4BE:BC:0}\\ 
u_{N_x}^n &= 0\tp
\tag{18}
\end{align}
$$

<p>
A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations <a href="#mjx-eqn-16">(16)</a>
and <a href="#mjx-eqn-17">(17)</a>--<a href="#mjx-eqn-18">(18)</a>
correspond to the matrix equation

$$
\begin{equation*} AU = b\end{equation*}
$$

where \( U=(u^n_0,\ldots,u^n_{N_x}) \), and
the matrix \( A \) has the following structure:

$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & A_{1,2} & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\tag{19}
\end{equation}
$$

The nonzero elements are given by

$$
\begin{align}
A_{i,i-1} &= -F
\tag{20}\\ 
A_{i,i} &= 1+ 2F
\tag{21}\\ 
A_{i,i+1} &= -F
\tag{22}
\end{align}
$$

in the equations for internal points, \( i=1,\ldots,N_x-1 \). The first and last
equation correspond to the boundary condition, where we know the solution,
and therefore we must have

$$
\begin{align}
A_{0,0} &= 1,
\tag{23}\\ 
A_{0,1} &= 0,
\tag{24}\\ 
A_{N_x,N_x-1} &= 0,
\tag{25}\\ 
A_{N_x,N_x} &= 1\tp
\tag{26}
\end{align}
$$

The right-hand side \( b \) is written as

$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\tag{27}
\end{equation}
$$

with

$$
\begin{align}
b_0 &= 0,
\tag{28}\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1,
\tag{29}\\ 
b_{N_x} &= 0 \tp   \tag{30}
\end{align}
$$

<p>
We observe that the matrix \( A \) contains quantities that do not change
in time. Therefore, \( A \) can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side \( b \), however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Data structures for the linear system</span>
A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>))
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    A[i,i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[Nx,Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_n[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute b and solve linear system</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        b[i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>u_n[i]
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n[:] <span style="color: #666666">=</span> u
</pre></div>
<p>
Regarding verification, the same considerations apply as for the
Forward Euler method (the section <a href="#diffu:pde1:FE:verify">Verification</a>).

<h2 id="diffu:pde1:impl:sparse">Sparse matrix implementation</h2>

<p>
We have seen from <a href="#mjx-eqn-19">(19)</a> that the matrix
\( A \) is tridiagonal. The code segment above used a full, dense matrix
representation of \( A \), which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these
zeros.  With \( N_x+1 \) unknowns, the work by the solution algorithm is
\( \frac{1}{3} (N_x+1)^3 \) and the storage requirements \( (N_x+1)^2 \). By
utilizing the fact that \( A \) is tridiagonal and employing corresponding
software tools that work with the three diagonals, the work and
storage demands can be proportional to \( N_x \) only.  This leads to a
dramatic improvement: with \( N_x=200 \), which is a realistic resolution,
the code runs about 40,000 times faster and reduces the storage to
just 1.5%! It is no doubt that we should take advantage of the fact
that \( A \) is tridiagonal.

<p>
The key idea is to apply a data structure for a tridiagonal or sparse
matrix. The <code>scipy.sparse</code> package has relevant utilities. For
example, we can store only the nonzero diagonals of a matrix. The
package also has linear system solvers that operate on sparse matrix
data structures. The code below illustrates how we can store only the
main diagonal and the upper and lower diagonals.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
main  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)
lower <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx)
upper <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx)
b     <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Precompute sparse matrix</span>
main[:] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
lower[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
upper[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
<span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
main[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
main[Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
    diagonals<span style="color: #666666">=</span>[main, lower, upper],
    offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>], shape<span style="color: #666666">=</span>(Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>),
    format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span> A<span style="color: #666666">.</span>todense()  <span style="color: #408080; font-style: italic"># Check that A is correct</span>

<span style="color: #408080; font-style: italic"># Set initial condition</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
    u_n[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    b <span style="color: #666666">=</span> u_n
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>  <span style="color: #408080; font-style: italic"># boundary conditions</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
    u_n[:] <span style="color: #666666">=</span> u
</pre></div>
<p>
The <code>scipy.sparse.linalg.spsolve</code> function utilizes the sparse storage
structure of <code>A</code> and performs, in this case, a very efficient Gaussian
elimination solve.

<p>
The program <a href="http://tinyurl.com/nu656p2/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a function <code>solver_BE</code>, which implements the Backward Euler scheme
sketched above.
As mentioned in the section <a href="#diffu:pde1:FE">Forward Euler scheme</a>,
the functions <code>plug</code> and <code>gaussian</code>
run the case with \( I(x) \) as a discontinuous plug or a smooth
Gaussian function. All experiments point to two characteristic
features of the Backward Euler scheme: 1) it is always stable, and
2) it always gives a smooth, decaying solution.

<h2 id="diffu:pde1:CN">Crank-Nicolson scheme</h2>

<p>
The idea in the Crank-Nicolson scheme is to apply centered
differences in space and time, combined with an average in time.
We demand the PDE to be fulfilled at the spatial mesh points, but
midway between the points in the time mesh:

$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half}) + f(x_i,t_{n+\half}),
$$

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
With centered differences in space and time, we get

$$ [D_t u = \dfc D_xD_x u + f]^{n+\half}_i\tp$$

On the right-hand side we get an expression

$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right) + f_i^{n+\half}\tp$$

This expression is problematic since \( u^{n+\half}_i \) is not one of
the unknowns we compute. A possibility is to replace \( u^{n+\half}_i \)
by an arithmetic average:

$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)\tp
$$

In the compact notation, we can use the arithmetic average
notation \( \overline{u}^t \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + f]^{n+\half}_i\tp$$

We can also use an average for \( f_i^{n+\half} \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + \overline{f}^t]^{n+\half}_i\tp$$

<p>
After writing out the differences and average, multiplying by \( \Delta t \),
and collecting all unknown terms on the left-hand side, we get

$$
\begin{align}
u^{n+1}_i - \half F(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
&= u^{n}_i + \half F(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})\nonumber\\ 
&\qquad \half f_i^{n+1} + \half f_i^n\tp
\tag{31}
\end{align}
$$

<p>
Also here, as in the Backward Euler scheme, the new unknowns
\( u^{n+1}_{i-1} \), \( u^{n+1}_{i} \), and \( u^{n+1}_{i+1} \) are coupled
in a linear system \( AU=b \), where \( A \) has the same structure
as in <a href="#mjx-eqn-19">(19)</a>, but with slightly
different entries:

$$
\begin{align}
A_{i,i-1} &= -\half F
\tag{32}\\ 
A_{i,i} &= 1 + F
\tag{33}\\ 
A_{i,i+1} &= -\half F
\tag{34}
\end{align}
$$

in the equations for internal points, \( i=1,\ldots,N_x-1 \). The equations
for the boundary points correspond to

$$
\begin{align}
A_{0,0} &= 1,
\tag{35}\\ 
A_{0,1} &= 0,
\tag{36}\\ 
A_{N_x,N_x-1} &= 0,
\tag{37}\\ 
A_{N_x,N_x} &= 1\tp
\tag{38}
\end{align}
$$

The right-hand side \( b \) has entries

$$
\begin{align}
b_0 &= 0,
\tag{39}\\ 
b_i &= u^{n-1}_i + \half(f_i^n + f_i^{n+1}),\quad i=1,\ldots,N_x-1,
\tag{40}\\ 
b_{N_x} &= 0 \tp   \tag{41}
\end{align}
$$

<p>
When verifying some implementation of the Crank-Nicolson scheme by convergence rate testing,
one should note that the scheme is second order accurate in both space and time. The numerical
error then reads

$$ E = C_t\Delta t^r + C_x\Delta x^r,$$

where \( r=2 \) (\( C_t \) and \( C_x \) are unknown constants, as before).
When introducing a single discretization parameter, we may now simply choose

$$ h = \Delta x = \Delta t,$$

which gives
$$ E = C_th^r + C_xh^r = (C_t + C_x)h^r,$$

where \( r \) should approach 2 as resolution is increased in the convergence rate computations.

<h2 id="diffu:pde1:theta">The unifying \( \theta \) rule</h2>

<p>
For the equation

$$ \frac{\partial u}{\partial t} = G(u),$$

where \( G(u) \) is some
spatial differential operator, the \( \theta \)-rule
looks like

$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} =
\theta G(u^{n+1}_i) + (1-\theta) G(u^{n}_i)\tp$$

The important feature of this time discretization scheme is that
we can implement one formula and then generate a family of
well-known and widely used schemes:

<ul>
 <li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>

In the compact difference notation, we write the \( \theta \) rule
as

$$ [\overline{D}_t u = \dfc D_xD_x u]^{n+\theta}\tp$$

We have that \( t_{n+\theta} = \theta t_{n+1} + (1-\theta)t_n \).

<p>
Applied to the 1D diffusion problem, the \( \theta \)-rule gives

$$
\begin{align*}
\frac{u^{n+1}_i-u^n_i}{\Delta t} &=
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)\\ 
&\qquad + \theta f_i^{n+1} + (1-\theta)f_i^n
\tp
\end{align*}
$$

This scheme also leads to a matrix system with entries

$$ A_{i,i-1} = -F\theta,\quad A_{i,i} = 1+2F\theta\quad,
A_{i,i+1} = -F\theta,$$

while right-hand side entry \( b_i \) is

$$ b_i = u^n_{i} + F(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} +
\Delta t\theta f_i^{n+1} + \Delta t(1-\theta)f_i^n\tp
$$

The corresponding entries for the boundary points are as in the Backward
Euler and Crank-Nicolson schemes listed earlier.

<p>
Note that convergence rate testing with implementations of the theta rule must
adjust the error expression according to which of the underlying schemes is actually being run.
That is, if \( \theta=0 \) (i.e., Forward Euler) or \( \theta=1 \) (i.e., Backward Euler), there should
be first order convergence, whereas with \( \theta=0.5 \) (i.e., Crank-Nicolson), one should get
second order convergence (as outlined in previous sections).

<h2 id="diffu:pde1:theta:experiments">Experiments</h2>

<p>
We can repeat the experiments from the section <a href="#diffu:pde1:FE:experiments">Numerical experiments</a>
to see if the Backward Euler or Crank-Nicolson schemes have problems
with sawtooth-like noise when starting with a discontinuous initial
condition. We can also verify that we can have \( F>\half \),
which allows larger time steps than in the Forward Euler method.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:BE:fig:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 5:  Backward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:BE:fig:F=0.5 --> </p></center>
<p><img src="fig-diffu/plug_BE_F05.png" align="bottom" width=800></p>
</center>

<p>
The Backward Euler scheme always produces smooth solutions for any \( F \).
Figure <a href="#diffu:pde1:BE:fig:F=0.5">5</a> shows one example.
Note that the mathematical discontinuity at \( t=0 \) leads to a linear
variation on a mesh, but the approximation to a jump becomes better
as \( N_x \) increases. In our simulation, we specify \( \Delta t \) and \( F \),
and set \( N_x \) to \( L/\sqrt{\dfc\Delta t/F} \). Since \( N_x\sim\sqrt{F} \),
the discontinuity looks sharper in the Crank-Nicolson
simulations with larger \( F \).

<p>
The Crank-Nicolson method produces smooth solutions for small \( F \),
\( F\leq\half \), but small noise gets more and more evident as \( F \)
increases. Figures <a href="#diffu:pde1:CN:fig:F=3">6</a> and <a href="#diffu:pde1:CN:fig:F=10">7</a>
demonstrate the effect for \( F=3 \) and \( F=10 \), respectively.
The section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> explains why such noise occur.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:CN:fig:F=3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 6:  Crank-Nicolson scheme for \( F=3 \).  <!-- caption label: diffu:pde1:CN:fig:F=3 --> </p></center>
<p><img src="fig-diffu/plug_CN_F3.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:CN:fig:F=10"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 7:  Crank-Nicolson scheme for \( F=10 \).  <!-- caption label: diffu:pde1:CN:fig:F=10 --> </p></center>
<p><img src="fig-diffu/plug_CN_F10.png" align="bottom" width=800></p>
</center>

<h2 id="___sec14">The Laplace and Poisson equation </h2>

<p>
The Laplace equation, \( \nabla^2 u = 0 \), and the Poisson equation,
\( -\nabla^2 u = f \), occur in numerous applications throughout science and
engineering. In 1D these equations read
\( u''(x)=0 \) and \( -u''(x)=f(x) \), respectively.
We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret \( u_{xx}=0 \) as the limiting solution
of \( u_t = \dfc u_{xx} \) when \( u \) reaches a steady state limit where
\( u_t\rightarrow 0 \).
Similarly, Poisson's equation \( -u_{xx}=f \) arises from solving
\( u_t = u_{xx} + f \) and letting \( t\rightarrow\infty \) so \( u_t\rightarrow 0 \).

<p>
Technically in a program, we can simulate \( t\rightarrow\infty \)
by just taking one large time step:
\( \Delta t\rightarrow\infty \). In the limit, the Backward Euler
scheme gives

$$ -\frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = f^{n+1}_i,$$

which is nothing but the discretization \( [-D_xD_x u = f]^{n+1}_i=0 \) of
\( -u_{xx}=f \).

<p>
The result above means that
the Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since \( \Delta t >
\Delta x^2/\dfc \)
is illegal and leads to instability.
We may interpret this time stepping
as solving the equation system from \( -u_{xx}=f \) by iterating on a
pseudo time variable.

<h1 id="diffu:pde1:analysis">Analysis of schemes for the diffusion equation</h1>

<p>
The numerical experiments in the sections <a href="#diffu:pde1:FE:experiments">Numerical experiments</a> and <a href="#diffu:pde1:theta:experiments">Experiments</a>
reveal that there are some
numerical problems with the Forward Euler and Crank-Nicolson schemes:
sawtooth-like noise is sometimes present in solutions that are,
from a mathematical point of view, expected to be smooth.
This section presents a mathematical analysis that explains the
observed behavior and arrives at criteria for obtaining numerical
solutions that reproduce the qualitative properties of the exact
solutions. In short, we shall explain what is observed in
Figures <a href="#diffu:pde1:FE:fig:F=0.5">1</a>-<a href="#diffu:pde1:CN:fig:F=10">7</a>.
<!-- <a href="#diffu:pde1:FE:fig:F=0.5">1</a>, -->
<!-- <a href="#diffu:pde1:FE:fig:F=0.25">2</a>, -->
<!-- <a href="#diffu:pde1:FE:fig:F=0.51">3</a>, -->
<!-- <a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>, -->
<!-- <a href="#diffu:pde1:BE:fig:F=0.5">5</a>, -->
<!-- <a href="#diffu:pde1:CN:fig:F=3">6</a>, -->
<!-- and -->
<!-- <a href="#diffu:pde1:CN:fig:F=10">7</a>. -->

<h2 id="diffu:pde1:analysis:uex">Properties of the solution</h2>

<p>
A particular characteristic of diffusive processes, governed
by an equation like

$$
\begin{equation}
u_t = \dfc u_{xx},
\tag{42}
\end{equation}
$$

is that the initial shape \( u(x,0)=I(x) \) spreads out in space with
time, along with a decaying amplitude.  Three different examples will
illustrate the spreading of \( u \) in space and the decay in time.

<h3 id="___sec17">Similarity solution </h3>

<p>
The diffusion equation <a href="#mjx-eqn-42">(42)</a> admits solutions
that depend on \( \eta = (x-c)/\sqrt{4\dfc t} \) for a given value
of \( c \). One particular solution
is

$$
\begin{equation}
u(x,t) = a\,\mbox{erf}(\eta) + b,
\tag{43}
\end{equation}
$$

where

$$
\begin{equation}
\mbox{erf}(\eta) = \frac{2}{\sqrt{\pi}}\int_0^\eta e^{-\zeta^2}d\zeta,
\tag{44}
\end{equation}
$$

is the <em>error function</em>, and \( a \) and \( b \) are arbitrary constants.
The error function lies in \( (-1,1) \), is odd around \( \eta =0 \), and
goes relatively quickly to \( \pm 1 \):

$$
\begin{align*}
\lim_{\eta\rightarrow -\infty}\mbox{erf}(\eta) &=-1,\\ 
\lim_{\eta\rightarrow \infty}\mbox{erf}(\eta) &=1,\\ 
\mbox{erf}(\eta) &= -\mbox{erf}(-\eta),\\ 
\mbox{erf}(0) &=0,\\ 
\mbox{erf}(2) &=0.99532227,\\ 
\mbox{erf}(3) &=0.99997791
\tp
\end{align*}
$$

<p>
As \( t\rightarrow 0 \), the error function approaches a step function centered
at \( x=c \). For a diffusion problem posed on the unit interval \( [0,1] \),
we may choose the step at \( x=1/2 \) (meaning \( c=1/2 \)), \( a=-1/2 \), \( b=1/2 \).
Then

$$
\begin{equation}
u(x,t) = \half\left(1 -
\mbox{erf}\left(\frac{x-\half}{\sqrt{4\dfc t}}\right)\right) =
\half\mbox{erfc}\left(\frac{x-\half}{\sqrt{4\dfc t}}\right),
\tag{45}
\end{equation}
$$

where we have introduced the <em>complementary error function</em>
\( \mbox{erfc}(\eta) = 1-\mbox{erf}(\eta) \).
The solution <a href="#mjx-eqn-45">(45)</a>
implies the boundary conditions

$$
\begin{align}
u(0,t) &= \half\left(1 - \mbox{erf}\left(\frac{-1/2}{\sqrt{4\dfc t}}\right)\right),
\tag{46} \\ 
u(1,t) &= \half\left(1 - \mbox{erf}\left(\frac{1/2}{\sqrt{4\dfc t}}\right)\right)
\tag{47}
\tp
\end{align}
$$

For small enough \( t \), \( u(0,t)\approx 1 \) and \( u(1,t)\approx 0 \), but as
\( t\rightarrow\infty \), \( u(x,t)\rightarrow 1/2 \) on \( [0,1] \).

<h3 id="___sec18">Solution for a Gaussian pulse </h3>

<p>
The standard diffusion equation \( u_t = \dfc u_{xx} \) admits a
Gaussian function as solution:

$$
\begin{equation}
u(x,t) = \frac{1}{\sqrt{4\pi\dfc t}} \exp{\left({-\frac{(x-c)^2}{4\dfc t}}\right)}
\tag{48}
\tp
\end{equation}
$$

At \( t=0 \) this is a Dirac delta function, so for computational
purposes one must start to view the solution at some time \( t=t_\epsilon>0 \).
Replacing \( t \) by \( t_\epsilon +t \) in <a href="#mjx-eqn-48">(48)</a>
makes it easy to operate with a (new) \( t \) that starts at \( t=0 \)
with an initial condition with a finite width.
The important feature of <a href="#mjx-eqn-48">(48)</a> is that
the standard deviation \( \sigma \) of a sharp initial Gaussian pulse
increases in time according to \( \sigma = \sqrt{2\dfc t} \), making
the pulse diffuse and flatten out.

<p>
<!-- Mention combinations of such kernels to build up a general analytical sol? -->
<!-- Or maybe an exercise for verification. -->

<h3 id="___sec19">Solution for a sine component </h3>

<p>
Also, <a href="#mjx-eqn-42">(42)</a> admits a solution of the form

$$
\begin{equation}
u(x,t) = Qe^{-at}\sin\left( kx\right)
\tag{49}
\tp
\end{equation}
$$

The parameters \( Q \) and \( k \) can be freely chosen, while
inserting <a href="#mjx-eqn-49">(49)</a> in <a href="#mjx-eqn-42">(42)</a> gives the constraint

$$
\begin{equation*} a = -\dfc k^2
\tp
\end{equation*}
$$

<p>
A very important feature is that the initial shape \( I(x)=Q\sin\left( kx\right) \)
undergoes a damping \( \exp{(-\dfc k^2t)} \), meaning that
rapid oscillations in space, corresponding to large \( k \), are very much
faster dampened than slow oscillations in space, corresponding to small
\( k \). This feature leads to a smoothing of the initial condition with time.
(In fact, one can use a few steps of the diffusion equation as
a method for removing noise in signal processing.)
To judge how good a numerical method is, we may look at its ability to
smoothen or dampen the solution in the same way as the PDE does.

<p>
The following example illustrates the damping properties of
<a href="#mjx-eqn-49">(49)</a>. We consider the specific problem

$$
\begin{align*}
u_t &= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\ 
u(0,t) &= u(1,t) = 0,\quad t\in (0,T],\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\tp
\end{align*}
$$

The initial condition has been chosen such that adding
two solutions like <a href="#mjx-eqn-49">(49)</a> constructs
an analytical solution to the problem:

$$
\begin{equation}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
\tag{50}
\tp
\end{equation}
$$

Figure <a href="#diffu:pde1:fig:damping">8</a> illustrates the rapid damping of
rapid oscillations \( \sin (100\pi x) \) and the very much slower damping of the
slowly varying \( \sin (\pi x) \) term. After about \( t=0.5\cdot10^{-4} \) the rapid
oscillations do not have a visible amplitude, while we have to wait
until \( t\sim 0.5 \) before the amplitude of the long wave \( \sin (\pi x) \)
becomes very small.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:damping"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 8:  Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right).  <!-- caption label: diffu:pde1:fig:damping --> </p></center>
<p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p>
</center>

<p>
<!-- x/sqrt(t) solution, kernel with integral -->

<h2 id="___sec20">Analysis of discrete equations </h2>

<p>
A counterpart to <a href="#mjx-eqn-49">(49)</a> is the complex representation
of the same function:

$$ u(x,t) = Qe^{-at}e^{ikx},$$

where \( i=\sqrt{-1} \) is the imaginary unit.
We can add such functions, often referred to as wave components,
to make a Fourier representation
of a general solution of the diffusion equation:

$$
\begin{equation}
u(x,t) \approx \sum_{k\in K} b_k e^{-\dfc k^2t}e^{ikx},
\tag{51}
\end{equation}
$$

where \( K \) is a set of an infinite number of \( k \) values needed to construct
the solution. In practice, however, the series is truncated and
\( K \) is a finite set of \( k \) values
needed to build a good approximate solution.
Note that <a href="#mjx-eqn-50">(50)</a> is a special case of
<a href="#mjx-eqn-51">(51)</a> where \( K=\{\pi, 100\pi\} \), \( b_{\pi}=1 \),
and \( b_{100\pi}=0.1 \).

<p>
The amplitudes \( b_k \) of the individual Fourier waves must be determined
from the initial condition. At \( t=0 \) we have \( u\approx\sum_kb_k\exp{(ikx)} \)
and find \( K \) and \( b_k \) such that

$$
\begin{equation}
I(x) \approx \sum_{k\in K} b_k e^{ikx}\tp
\tag{52}
\end{equation}
$$

(The relevant formulas for \( b_k \) come from Fourier analysis, or
equivalently, a least-squares method for approximating \( I(x) \)
in a function space with basis \( \exp{(ikx)} \).)

<p>
Much insight about the behavior of numerical methods can be obtained
by investigating how a wave component \( \exp{(-\dfc k^2
t)}\exp{(ikx)} \) is treated by the numerical scheme. It appears that
such wave components are also solutions of the schemes, but the
damping factor \( \exp{(-\dfc k^2 t)} \) varies among the schemes.  To
ease the forthcoming algebra, we write the damping factor as
\( A^n \). The exact amplification factor corresponding to \( A \) is \( \Aex =
\exp{(-\dfc k^2\Delta t)} \).

<h2 id="diffu:pde1:analysis:details">Analysis of the finite difference schemes</h2>

<p>
We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components

$$
\begin{equation*} e^{-\dfc k^2t}e^{ikx} \tp  \end{equation*}
$$

A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude \( \exp{(-\dfc k^2t)} \) might be modified (which also happens when
solving the ODE counterpart \( u'=-\dfc u \)).
We therefore look for numerical solutions of the form

$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},
\tag{53}
\end{equation}
$$

where the amplification factor \( A \)
must be determined by inserting the component into an actual scheme.
Note that \( A^n \) means \( A \) raised to the power of \( n \), \( n \) being the
index in the time mesh, while the superscript \( n \) in \( u^n_q \) just
denotes \( u \) at time \( t_n \).

<h3 id="___sec22">Stability </h3>

<p>
The exact amplification factor is \( \Aex=\exp{(-\dfc^2 k^2\Delta t)} \).
We should therefore require \( |A| < 1 \) to have a decaying numerical
solution as well. If
\( -1\leq A < 0 \), \( A^n \) will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.

<h3 id="___sec23">Accuracy </h3>

<p>
To determine how accurately a finite difference scheme treats one
wave component <a href="#mjx-eqn-53">(53)</a>, we see that the basic
deviation from the exact solution is reflected in how well
\( A^n \) approximates \( \Aex^n \),
or how well \( A \) approximates \( \Aex \).
We can plot \( \Aex \) and the various expressions for \( A \), and we can
make Taylor expansions of \( A/\Aex \) to see the error more analytically.

<p>
<!-- We shall in particular investigate the error \( \Aex - A \) in the -->
<!-- amplification factor. -->

<h3 id="___sec24">Truncation error </h3>

<p>
As an alternative to examining the accuracy of the damping of a wave
component, we can perform a general truncation error analysis as
explained in "Truncation error analysis": ""
<a href="._diffu-sol002.html#Langtangen_deqbook_trunc">[5]</a>. Such results are more general, but
less detailed than what we get from the wave component analysis.  The
truncation error can almost always be computed and represents the
error in the numerical model when the exact solution is substituted
into the equations. In particular, the truncation error analysis tells
the order of the scheme, which is of fundamental importance when
verifying codes based on empirical estimation of convergence rates.

<h2 id="diffu:pde1:analysis:FE">Analysis of the Forward Euler scheme</h2>

<p>
<!-- 2DO: refer to vib and wave -->

<p>
The Forward Euler finite difference scheme for \( u_t = \dfc u_{xx} \) can
be written as

$$
\begin{equation*} [D_t^+ u = \dfc D_xD_x u]^n_q\tp  \end{equation*}
$$

Inserting a wave component <a href="#mjx-eqn-53">(53)</a>
in the scheme demands calculating the terms

$$ e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},$$

and

$$ A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)\right)
\tp  $$

Inserting these terms in the discrete equation and
dividing by \( A^n e^{ikq\Delta x} \) leads to

$$
\begin{equation*}
\frac{A-1}{\Delta t} = -\dfc \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and consequently

$$
\begin{equation}
A = 1 -4F\sin^2 p
\tag{54}
\end{equation}
$$

where

$$
\begin{equation}
F = \frac{\dfc\Delta t}{\Delta x^2}
\tag{55}
\end{equation}
$$

is the <em>numerical Fourier number</em>, and \( p=k\Delta x/2 \).
The complete numerical solution is then

$$
\begin{equation}
u^n_q = \left(1 -4F\sin^2 p\right)^ne^{ikq\Delta x}
\tp
\tag{56}
\end{equation}
$$

<h3 id="___sec26">Stability </h3>

<p>
We easily see that \( A\leq 1 \). However, the \( A \) can be less than \( -1 \),
which will lead
to growth of a numerical wave component. The criterion \( A\geq -1 \) implies

$$ 4F\sin^2 (p/2)\leq 2
\tp
$$

The worst case is when \( \sin^2 (p/2)=1 \), so a sufficient criterion for
stability is

$$
\begin{equation}
F\leq {\half},
\tag{57}
\end{equation}
$$

or expressed as a condition on \( \Delta t \):

$$
\begin{equation}
\Delta t\leq \frac{\Delta x^2}{2\dfc}\tp
\tag{58}
\end{equation}
$$

Note that halving the spatial mesh size, \( \Delta x \rightarrow {\half}
\Delta x \), requires \( \Delta t \) to be reduced by a factor of \( 1/4 \).
The method hence becomes very expensive for fine spatial meshes.

<p>
<!-- 2DO: verification based on exact solutions -->

<h3 id="___sec27">Accuracy </h3>

<p>
Since \( A \) is expressed in terms of \( F \) and the parameter we now call
\( p=k\Delta x/2 \), we should also express \( \Aex \) by \( F \) and \( p \). The exponent
in \( \Aex \) is \( -\dfc k^2\Delta t \), which equals \( -F k^2\Delta x^2=-F4p^2 \).
Consequently,

$$ \Aex = \exp{(-\dfc k^2\Delta t)} = \exp{(-4Fp^2)}
\tp $$

All our \( A \) expressions as well as \( \Aex \) are now functions of the two
dimensionless parameters \( F \) and \( p \).

<p>
Computing
the Taylor series expansion of \( A/\Aex \) in terms of \( F \)
can easily be done with aid of <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_exact</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-4*</span>F<span style="color: #666666">*</span>p<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_FE</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> <span style="color: #666666">4*</span>F<span style="color: #666666">*</span>sin(p)<span style="color: #666666">**2</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
F, p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;F p&#39;</span>)
A_err_FE <span style="color: #666666">=</span> A_FE(F, p)<span style="color: #666666">/</span>A_exact(F, p)
<span style="color: #008000; font-weight: bold">print</span> A_err_FE<span style="color: #666666">.</span>series(F, <span style="color: #666666">0</span>, <span style="color: #666666">6</span>)
</pre></div>
<p>
The result is

$$ \frac{A}{\Aex} = 1 - 4 F \sin^{2}p + 2F p^{2} - 16F^{2} p^{2} \sin^{2}p + 8 F^{2} p^{4} + \cdots
$$

Recalling that \( F=\dfc\Delta t/\Delta x^2 \), \( p=k\Delta x/2 \), and that
\( \sin^2p\leq 1 \), we
realize that the dominating terms in \( A/\Aex \) are at most

$$ 1 - 4\dfc \frac{\Delta t}{\Delta x^2} +
\dfc\Delta t - 4\dfc^2\Delta t^2
+ \dfc^2 \Delta t^2\Delta x^2 + \cdots
\tp
$$

<h3 id="___sec28">Truncation error </h3>

<p>
We follow the theory explained in
"Truncation error analysis": ""
<a href="._diffu-sol002.html#Langtangen_deqbook_trunc">[5]</a>. The recipe is to set up the
scheme in operator notation and use formulas from
"Overview of leading-order error terms in finite difference formulas": ""
<a href="._diffu-sol002.html#Langtangen_deqbook_trunc">[5]</a> to derive an expression for
the residual. The details are documented in
"Linear diffusion equation in 1D": ""
<a href="._diffu-sol002.html#Langtangen_deqbook_trunc">[5]</a>. We end up with a truncation error

$$ R^n_i = \Oof{\Delta t} + \Oof{\Delta x^2}\tp$$

Although this is not the true error \( \uex(x_i,t_n) - u^n_i \), it indicates
that the true error is of the form

$$ E = C_t\Delta t + C_x\Delta x^2$$

for two unknown constants \( C_t \) and \( C_x \).

<h2 id="diffu:pde1:analysis:BE">Analysis of the Backward Euler scheme</h2>

<p>
Discretizing \( u_t = \dfc u_{xx} \) by a Backward Euler scheme,

$$
\begin{equation*} [D_t^- u = \dfc D_xD_x u]^n_q,\end{equation*}
$$

and inserting a wave component <a href="#mjx-eqn-53">(53)</a>,
leads to calculations similar to those arising from the Forward Euler scheme,
but since

$$ e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},$$

we get

$$
\begin{equation*}
\frac{1-A^{-1}}{\Delta t} = -\dfc \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and then

$$
\begin{equation}
A = \left(1  + 4F\sin^2p\right)^{-1}
\tag{59}
\tp
\end{equation}
$$

The complete numerical solution can be written

$$
\begin{equation}
u^n_q = \left(1  + 4F\sin^2 p\right)^{-n}
e^{ikq\Delta x} \tp
\tag{60}
\end{equation}
$$

<h3 id="___sec30">Stability </h3>

<p>
We see from <a href="#mjx-eqn-59">(59)</a> that \( 0 < A < 1 \), which means
that all numerical wave components are stable and non-oscillatory
for any \( \Delta t >0 \).

<h3 id="___sec31">Truncation error </h3>

<p>
The derivation of the truncation error for the Backward Euler scheme is almost
identical to that for the Forward Euler scheme. We end up with

$$ R^n_i = \Oof{\Delta t} + \Oof{\Delta x^2}\tp$$

<h2 id="diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</h2>

<p>
The Crank-Nicolson scheme can be written as

$$ [D_t u = \dfc D_xD_x \overline{u}^x]^{n+\half}_q, $$

or

$$ [D_t u]^{n+\half}_q = \half\dfc\left( [D_xD_x u]^{n}_q +
[D_xD_x u]^{n+1}_q\right)
\tp
$$

Inserting <a href="#mjx-eqn-53">(53)</a> in the time derivative approximation
leads to

$$ [D_t A^n e^{ikq\Delta x}]^{n+\half} = A^{n+\half} e^{ikq\Delta x}\frac{A^{\half}-A^{-\half}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
\tp $$

Inserting <a href="#mjx-eqn-53">(53)</a> in the other terms
and dividing by
\( A^ne^{ikq\Delta x} \) gives the relation

$$
\frac{A-1}{\Delta t} = -\half\dfc\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)
(1 + A),
$$

and after some more algebra,

$$
\begin{equation}
A = \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}
\tp
\tag{61}
\end{equation}
$$

The exact numerical solution is hence

$$
\begin{equation}
u^n_q = \left(\frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\right)^ne^{ikq\Delta x}
\tp
\tag{62}
\end{equation}
$$

<h3 id="___sec33">Stability </h3>

<p>
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \).
Therefore, the solution cannot grow, but it will oscillate if
\( 1-2F\sin^p < 0 \). To avoid such non-physical oscillations, we must demand
\( F\leq\half \).

<h3 id="___sec34">Truncation error </h3>

<p>
The truncation error is derived in
"Linear diffusion equation in 1D": ""
<a href="._diffu-sol002.html#Langtangen_deqbook_trunc">[5]</a>:

$$ R^{n+\half}_i = \Oof{\Delta x^2} + \Oof{\Delta t^2}\tp$$

<h2 id="diffu:pde1:analysis:leapfrog">Analysis of the Leapfrog scheme</h2>

<p>
An attractive feature of the Forward Euler scheme is the explicit
time stepping and no need for solving linear systems. However, the
accuracy in time is only \( \Oof{\Delta t} \). We can get an explicit
<em>second-order</em> scheme in time by using the Leapfrog method:

$$ [D_{2t} u = \dfc D_xDx u + f]^n_q\tp$$

Written out,

$$ u_q^{n+1} = u_q^{n-1} + \frac{2\dfc\Delta t}{\Delta x^2}
(u^{n}_{q+1} - 2u^n_q + u^n_{q-1}) + f(x_q,t_n)\tp$$

We need some formula for the first step, \( u^1_q \), but for that we can use
a Forward Euler step.

<p>
Unfortunately, the Leapfrog scheme is always unstable for the
diffusion equation. To see this, we insert a wave component \( A^ne^{ikx} \)
and get

$$ \frac{A - A^{-1}}{\Delta t} = -\dfc \frac{4}{\Delta x^2}\sin^2 p,$$

or

$$ A^2 + 4F \sin^2 p\, A - 1 = 0,$$

which has roots

$$ A = -2F\sin^2 p \pm \sqrt{4F^2\sin^4 p + 1}\tp$$

Both roots have \( |A|>1 \) so the always amplitude grows, which is not in
accordance with physics of the problem.
However, for a PDE with a first-order derivative in space, instead of
a second-order one, the Leapfrog scheme performs very well.

<h2 id="___sec36">Summary of accuracy of amplification factors </h2>

<p>
We can plot the various amplification factors against \( p=k\Delta x/2 \)
for different choices of the \( F \) parameter. Figures
<a href="#diffu:pde1:fig:A:err:C20">9</a>, <a href="#diffu:pde1:fig:A:err:C0.5">10</a>, and
<a href="#diffu:pde1:fig:A:err:C0.1">11</a> show how long and small waves are
damped by the various schemes compared to the exact damping. As long
as all schemes are stable, the amplification factor is positive,
except for Crank-Nicolson when \( F>0.5 \).

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C20"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  Amplification factors for large time steps.  <!-- caption label: diffu:pde1:fig:A:err:C20 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F20_F2.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 10:  Amplification factors for time steps around the Forward Euler stability limit.  <!-- caption label: diffu:pde1:fig:A:err:C0.5 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F05_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C0.1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 11:  Amplification factors for small time steps.  <!-- caption label: diffu:pde1:fig:A:err:C0.1 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F01_F001.png" align="bottom" width=800></p>
</center>

<p>
The effect of negative amplification factors is that \( A^n \) changes
sign from one time level to the next, thereby giving rise to
oscillations in time in an animation of the solution. We see from
Figure <a href="#diffu:pde1:fig:A:err:C20">9</a> that for \( F=20 \), waves with
\( p\geq \pi/4 \) undergo a damping close to \( -1 \), which means that the
amplitude does not decay and that the wave component jumps up and down
(flips amplitude) in time. For \( F=2 \) we have a damping of a factor of
0.5 from one time level to the next, which is very much smaller than
the exact damping. Short waves will therefore fail to be effectively
dampened.  These waves will manifest themselves as high frequency
oscillatory noise in the solution.

<p>
A value \( p=\pi/4 \) corresponds to four mesh points per wave length of
\( e^{ikx} \), while \( p=\pi/2 \) implies only two points per wave length,
which is the smallest number of points we can have to represent the
wave on the mesh.

<p>
To demonstrate the oscillatory behavior of the Crank-Nicolson scheme,
we choose an initial condition that leads to short waves with
significant amplitude. A discontinuous \( I(x) \) will in particular serve
this purpose: Figures <a href="#diffu:pde1:CN:fig:F=3">6</a> and
<a href="#diffu:pde1:CN:fig:F=10">7</a> correspond to \( F=3 \) and \( F=10 \),
respectively, and we see how short waves pollute the overall solution.

<h2 id="diffu:2D:analysis">Analysis of the 2D diffusion equation</h2>

<p>
Diffusion in several dimensions is treated later, but it is appropriate to
include the analysis here. We first consider the 2D diffusion equation

$$ u_{t} = \dfc(u_{xx} + u_{yy}),$$

which has Fourier component solutions of the form

$$ u(x,y,t) = Ae^{-\dfc k^2t}e^{i(k_x x + k_yy)},$$

and the schemes have discrete versions of this Fourier component:

$$ u^{n}_{q,r} = A\xi^{n}e^{i(k_x q\Delta x + k_y r\Delta y)}\tp$$

<h3 id="___sec38">The Forward Euler scheme </h3>

<p>
For the Forward Euler discretization,

$$ [D_t^+u = \dfc(D_xD_x u + D_yD_y u)]_{q,r}^n,$$

we get

$$
\frac{\xi - 1}{\Delta t}
=
-\dfc\frac{4}{\Delta x^2}\sin^2\left(\frac{k_x\Delta x}{2}\right) -
\dfc\frac{4}{\Delta y^2}\sin^2\left(\frac{k_y\Delta y}{2}\right)\tp
$$

Introducing

$$ p_x = \frac{k_x\Delta x}{2},\quad p_y = \frac{k_y\Delta y}{2},$$

we can write the equation for \( \xi \) more compactly as

$$
\frac{\xi - 1}{\Delta t}
=
-\dfc\frac{4}{\Delta x^2}\sin^2 p_x -
\dfc\frac{4}{\Delta y^2}\sin^2 p_y,
$$

and solve for \( \xi \):

$$
\begin{equation}
\xi = 1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y\tp
\tag{63}
\end{equation}
$$

<p>
The complete numerical solution for a wave component is

$$
\begin{equation}
u^{n}_{q,r} = A(1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y)^n
e^{i(k_xq\Delta x + k_yr\Delta y)}\tp
\tag{64}
\end{equation}
$$

<p>
For stability we demand \( -1\leq\xi\leq 1 \), and \( -1\leq\xi \) is the
critical limit, since clearly \( \xi \leq 1 \), and the worst case
happens when the sines are at their maximum. The stability criterion
becomes

$$
\begin{equation}
F_x + F_y \leq \half\tp
\tag{65}
\end{equation}
$$

For the special, yet common, case \( \Delta x=\Delta y=h \), the
stability criterion can be written as

$$ \Delta t \leq \frac{h^2}{2d\dfc},$$

where \( d \) is the number of space dimensions: \( d=1,2,3 \).

<h3 id="___sec39">The Backward Euler scheme </h3>

<p>
The Backward Euler method,

$$ [D_t^-u = \dfc(D_xD_x u + D_yD_y u)]_{q,r}^n,$$

results in

$$ 1 - \xi^{-1} = - 4F_x \sin^2 p_x - 4F_y \sin^2 p_y, $$

and

$$ \xi = (1 + 4F_x \sin^2 p_x + 4F_y \sin^2 p_y)^{-1},$$

which is always in \( (0,1] \). The solution for a wave component becomes

$$
\begin{equation}
u^{n}_{q,r} = A(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n}
e^{i(k_xq\Delta x + k_yr\Delta y)}\tp
\tag{66}
\end{equation}
$$

<h3 id="___sec40">The Crank-Nicolson scheme </h3>

<p>
With a Crank-Nicolson discretization,

$$ [D_tu]^{n+\half}_{q,r} =
\half [\dfc(D_xD_x u + D_yD_y u)]_{q,r}^{n+1} +
\half [\dfc(D_xD_x u + D_yD_y u)]_{q,r}^n,$$

we have, after some algebra,

$$ \xi = \frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}\tp$$

The fraction on the right-hand side is always less than 1, so stability
in the sense of non-growing wave components is guaranteed for all
physical and numerical parameters. However,
the fraction can become negative and result in non-physical
oscillations. This phenomenon happens when

$$ F_x\sin^2 p_x + F_x\sin^2p_y > \half\tp$$

A criterion against non-physical oscillations is therefore

$$ F_x + F_y \leq \half, $$

which is the same limit as the stability criterion for the Forward Euler
scheme.

<p>
The exact discrete solution is

$$
\begin{equation}
u^{n}_{q,r} = A
\left(
\frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
\right)^n
e^{i(k_xq\Delta x + k_yr\Delta y)}\tp
\tag{67}
\end{equation}
$$

<h2 id="___sec41">Explanation of numerical artifacts </h2>

<p>
The behavior of the solution generated by Forward Euler discretization in time (and centered
differences in space) is summarized at the end of
the section <a href="#diffu:pde1:FE:experiments">Numerical experiments</a>. Can we, from the analysis
above, explain the behavior?

<p>
We may start by looking at Figure <a href="#diffu:pde1:FE:fig:F=0.51">3</a>
where \( F=0.51 \). The figure shows that the solution is unstable and
grows in time. The stability limit for such growth is \( F=0.5 \) and
since the \( F \) in this simulation is slightly larger, growth is
unavoidable.

<p>
Figure <a href="#diffu:pde1:FE:fig:F=0.5">1</a> has unexpected features:
we would expect the solution of the diffusion equation to be
smooth, but the graphs in Figure <a href="#diffu:pde1:FE:fig:F=0.5">1</a>
contain non-smooth noise. Turning to Figure
<a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>,  which has a quite similar
initial condition, we see that the curves are indeed smooth.
The problem with the results in Figure <a href="#diffu:pde1:FE:fig:F=0.5">1</a>
is that the initial condition is discontinuous. To represent it, we
need a significant amplitude on the shortest waves in the mesh.
However, for \( F=0.5 \), the shortest wave (\( p=\pi/2 \)) gives
the amplitude in the numerical solution as \( (1-4F)^n \), which oscillates
between negative and positive values at subsequent time levels
for \( F>\frac{1}{4} \). Since the shortest waves have visible amplitudes in
the solution profile, the oscillations becomes visible. The
smooth initial condition in Figure <a href="#diffu:pde1:FE:fig:gauss:F=0.5">4</a>,
on the other hand, leads to very small amplitudes of the shortest waves.
That these waves then oscillate in a non-physical way for
\( F=0.5 \) is not a visible effect. The oscillations
in time in the amplitude \( (1-4F)^n \) disappear for \( F\leq\frac{1}{4} \),
and that is why also the discontinuous initial condition always leads to
smooth solutions in Figure <a href="#diffu:pde1:FE:fig:F=0.25">2</a>, where
\( F=\frac{1}{4} \).

<p>
Turning the attention to the Backward Euler scheme and the experiments
in Figure <a href="#diffu:pde1:BE:fig:F=0.5">5</a>, we see that even the discontinuous
initial condition gives smooth solutions for \( F=0.5 \) (and in fact all other
\( F \) values). From the exact expression of the numerical amplitude,
\( (1  + 4F\sin^2p)^{-1} \), we realize that this factor can never flip between
positive and negative values, and no instabilities can occur. The conclusion
is that the Backward Euler scheme always produces smooth solutions.
Also, the Backward Euler scheme guarantees that the solution cannot grow
in time (unless we add a source term to the PDE, but that is meant to
represent a physically relevant growth).

<p>
Finally, we have some small, strange artifacts when simulating the
development of the initial plug profile with the Crank-Nicolson scheme,
see Figure <a href="#diffu:pde1:CN:fig:F=10">7</a>, where \( F=3 \).
The Crank-Nicolson scheme cannot give growing amplitudes, but it may
give oscillating amplitudes in time. The critical factor is
\( 1 - 2F\sin^2p \), which for the shortest waves (\( p=\pi/2 \)) indicates
a stability limit \( F=0.5 \). With the discontinuous initial condition, we have
enough amplitude on the shortest waves so their wrong behavior is visible,
and this is what we see as small instabilities in
Figure <a href="#diffu:pde1:CN:fig:F=10">7</a>. The only remedy is to lower the \( F \) value.

<h1 id="___sec42">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</h2>

<p>
This exercise simulates the exact solution <a href="#mjx-eqn-48">(48)</a>.
Suppose for simplicity that \( c=0 \).

<p>
<b>a)</b>
Formulate an initial-boundary value problem that has
<a href="#mjx-eqn-48">(48)</a> as solution in the domain \( [-L,L] \).
Use the exact solution <a href="#mjx-eqn-48">(48)</a> as Dirichlet
condition at the boundaries.
Simulate the diffusion of the Gaussian peak. Observe that the
solution is symmetric around \( x=0 \).

<p>
<b>b)</b>
Show from <a href="#mjx-eqn-48">(48)</a> that \( u_x(c,t)=0 \).
Since the solution is symmetric around \( x=c=0 \), we can solve the
numerical problem in half of the domain, using a <em>symmetry boundary condition</em>
\( u_x=0 \) at \( x=0 \). Set up the
initial-boundary value problem in this case. Simulate the
diffusion problem in \( [0,L] \) and compare with the solution in a).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

$$
\begin{align*}
u_t &= \dfc u_xx,\\ 
u_x(0,t) &= 0,\\ 
u(L,t)& =\frac{1}{\sqrt{4\pi\dfc t}} \exp{\left({-\frac{x^2}{4\dfc t}}\right)}\tp
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>diffu_symmetric_gaussian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:ux:onesided">Exercise 2: Investigate approximation errors from a \( u_x=0 \) boundary condition</h2>

<p>
We consider the problem solved in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</a>
part b). The boundary condition \( u_x(0,t)=0 \) can be implemented in
two ways: 1) by a standard symmetric finite difference \( [D_{2x}u]_i^n=0 \),
or 2) by a one-sided difference \( [D^+u=0]^n_i=0 \).
Investigate the effect of these two conditions on the
convergence rate in space.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
If you use a Forward Euler scheme, choose a discretization parameter
\( h=\Delta t = \Delta x^2 \) and assume the error goes like \( E\sim h^r \).
The error in the scheme is \( \Oof{\Delta t,\Delta x^2} \) so one should
expect that the estimated \( r \) approaches 1. The question is if
a one-sided difference approximation to \( u_x(0,t)=0 \) destroys this
convergence rate.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>diffu_onesided_fd</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:openBC">Exercise 3: Experiment with open boundary conditions in 1D</h2>

<p>
We address diffusion of a Gaussian function
as in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 1: Explore symmetry in a 1D problem</a>,
in the domain \( [0,L] \),
but now we shall explore different types of boundary
conditions on \( x=L \). In real-life problems we do not know
the exact solution on \( x=L \) and must use something simpler.

<p>
<b>a)</b>
Imagine that we want to solve the problem numerically on
\( [0,L] \), with a symmetry boundary condition \( u_x=0 \) at \( x=0 \),
but we do not know the exact solution and cannot of that
reason assign a correct Dirichlet condition at \( x=L \).
One idea is to simply set \( u(L,t)=0 \) since this will be an
accurate approximation before the diffused pulse reaches \( x=L \)
and even thereafter it might be a satisfactory condition if the exact \( u \) has
a small value.
Let \( \uex \) be the exact solution and let \( u \) be the solution
of \( u_t=\dfc u_{xx} \) with an initial Gaussian pulse and
the boundary conditions \( u_x(0,t)=u(L,t)=0 \). Derive a diffusion
problem for the error \( e=\uex - u \). Solve this problem
numerically using an exact Dirichlet condition at \( x=L \).
Animate the evolution of the error and make a curve plot of
the error measure

$$ E(t)=\sqrt{\frac{\int_0^L e^2dx}{\int_0^L udx}}\tp $$

Is this a suitable error measure for the present problem?

<p>
<b>b)</b>
Instead of using \( u(L,t)=0 \) as approximate boundary condition for
letting the diffused Gaussian pulse move out of our finite domain,
one may try \( u_x(L,t)=0 \) since the solution for large \( t \) is
quite flat. Argue that this condition gives a completely wrong
asymptotic solution as \( t\rightarrow 0 \). To do this,
integrate the diffusion equation from \( 0 \) to \( L \), integrate
\( u_{xx} \) by parts (or use Gauss' divergence theorem in 1D) to
arrive at the important property

$$ \frac{d}{dt}\int_{0}^L u(x,t)dx = 0,$$

implying that \( \int_0^Ludx \) must be constant in time, and therefore

$$ \int_{0}^L u(x,t)dx = \int_{0}^LI(x)dx\tp $$

The integral of the initial pulse is 1.

<p>
<b>c)</b>
Another idea for an artificial boundary condition at \( x=L \)
is to use a cooling law

$$
\begin{equation}
-\dfc u_x = q(u - u_S),
\tag{68}
\end{equation}
$$

where \( q \) is an unknown heat transfer coefficient and \( u_S \) is
the surrounding temperature in the medium outside of \( [0,L] \).
(Note that arguing that \( u_S \) is approximately \( u(L,t) \) gives
the \( u_x=0 \) condition from the previous subexercise that is
qualitatively wrong for large \( t \).)
Develop a diffusion problem for the error in the solution using
<a href="#mjx-eqn-68">(68)</a> as boundary condition.
Assume one can take \( u_S=0 \) &quot;outside the domain&quot; since
\( \uex\rightarrow 0 \) as \( x\rightarrow\infty \).
Find a function \( q=q(t) \) such that the exact solution
obeys the condition <a href="#mjx-eqn-68">(68)</a>.
Test some constant values of \( q \) and animate how the corresponding
error function behaves. Also compute \( E(t) \) curves as defined above.

<p>
Filename: <code>diffu_open_BC</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec46">Exercise 4: Simulate a diffused Gaussian peak in 2D/3D </h2>

<p>
<b>a)</b>
Generalize <a href="#mjx-eqn-48">(48)</a> to multi dimensions by
assuming that one-dimensional solutions can be multiplied to solve
\( u_t = \dfc\nabla^2 u \). Set \( c=0 \) such that the peak of
the Gaussian is at the origin.

<p>
<b>b)</b>
One can from the exact solution show
that \( u_x=0 \) on \( x=0 \), \( u_y=0 \) on \( y=0 \), and \( u_z=0 \) on \( z=0 \).
The approximately correct condition \( u=0 \) can be set
on the remaining boundaries (say \( x=L \), \( y=L \), \( z=L \)), cf. <a href="#diffu:exer:1D:openBC">Exercise 3: Experiment with open boundary conditions in 1D</a>.
Simulate a 2D case and make an animation of the diffused Gaussian peak.

<p>
<b>c)</b>
The formulation in b) makes use of symmetry of the solution such that we
can solve the problem in the first quadrant (2D) or octant (3D) only.
To check that the symmetry assumption is correct, formulate the problem
without symmetry in a domain \( [-L,L]\times [L,L] \) in 2D. Use \( u=0 \) as
approximately correct boundary condition. Simulate the same case as
in b), but in a four times as large domain. Make an animation and compare
it with the one in b).

<p>
Filename: <code>diffu_symmetric_gaussian_2D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:uterm">Exercise 5: Examine stability of a diffusion model with a source term</h2>

<p>
Consider a diffusion equation with a linear \( u \) term:

$$ u_t = \dfc u_{xx} + \beta u\tp$$

<p>
<b>a)</b>
Derive in detail the Forward Euler, Backward Euler,
and Crank-Nicolson schemes for this type of diffusion model.
Thereafter, formulate a \( \theta \)-rule to summarize the three schemes.

<p>
<b>b)</b>
Assume a solution like <a href="#mjx-eqn-49">(49)</a> and find the relation
between \( a \), \( k \), \( \dfc \), and \( \beta \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
Insert <a href="#mjx-eqn-49">(49)</a> in the PDE problem.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Calculate the stability of the Forward Euler scheme. Design
numerical experiments to confirm the results.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_2">

<p>
Insert the discrete counterpart to <a href="#mjx-eqn-49">(49)</a> in the
numerical scheme. Run experiments at the stability limit and slightly above.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat c) for the Backward Euler scheme.

<p>
<b>e)</b>
Repeat c) for the Crank-Nicolson scheme.

<p>
<b>f)</b>
How does the extra term \( bu \) impact the accuracy of the three schemes?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_3" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_3">

<p>
For analysis of the accuracy,
compare the numerical and exact amplification factors, in
graphs and/or by Taylor series expansion.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>diffu_stability_uterm</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="diffu:varcoeff">Diffusion in heterogeneous media</h1>

<p>
Diffusion in heterogeneous media normally implies a non-constant
diffusion coefficient \( \alpha = \alpha (x) \).
A 1D diffusion model with such a variable diffusion coefficient reads

$$
\begin{alignat}{2}
\frac{\partial u}{\partial t} &=
\frac{\partial}{\partial x}\left( \alpha (x) \frac{\partial u}{\partial x}
\right) + f(x,t), \quad &x\in (0,L),\ t\in (0,T],
\tag{69}\\ 
u(x,0) &= I(x), \quad  &x\in [0,L],
\tag{70}\\ 
u(0,t) & = U_0, \quad  &t>0,
\tag{71}\\ 
u(L,t) & = U_L, \quad  &t>0.
\tag{72}
\end{alignat}
$$

A short form of the diffusion equation with variable coefficients is
\( u_t = (\alpha u_x)_x + f \).

<h2 id="diffu:varcoeff:discr">Discretization</h2>

<p>
We can discretize <a href="#mjx-eqn-69">(69)</a> by a \( \theta \)-rule in time
and centered differences in space:

$$ \lbrack D_t u\rbrack^{n+\half}_i = \theta\lbrack D_x(\overline{\dfc}^x
D_x u) + f\rbrack^{n+1}_i +
(1-\theta)\lbrack D_x(\overline{\dfc}^x
D_x u) + f\rbrack^{n}_i\tp$$

Written out, this becomes

$$
\begin{align*}
\frac{u^{n+1}_i-u^{n}_i}{\Delta t} &=
\theta\frac{1}{\Delta x^2}
(\dfc_{i+\half}(u^{n+1}_{i+1} - u^{n+1}_{i})
- \dfc_{i-\half}(u^{n+1}_i - u^{n+1}_{i-1})) +\\ 
&\quad (1-\theta)\frac{1}{\Delta x^2}
(\dfc_{i+\half}(u^{n}_{i+1} - u^{n}_{i})
- \dfc_{i-\half}(u^{n}_i - u^{n}_{i-1})) +\\ 
&\quad \theta f_i^{n+1} + (1-\theta)f_i^{n},
\end{align*}
$$

where, e.g., an arithmetic mean can to be used for \( \dfc_{i+\half} \):

$$ \dfc_{i+\half} = \half(\dfc_i + \dfc_{i+1})\tp$$

<h2 id="diffu:varcoeff:impl">Implementation</h2>

<p>
Suitable code for solving the discrete equations is very similar to
what we created for a constant \( \dfc \).
Since the Fourier number has no meaning for varying
\( \dfc \), we introduce a related parameter \( D=\Delta t /\Delta x^2 \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_theta</span>(I, a, L, Nx, D, T, theta<span style="color: #666666">=0.5</span>, u_L<span style="color: #666666">=1</span>, u_R<span style="color: #666666">=0</span>,
                 user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>):
    x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> D<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>

    u   <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array at t[n+1]</span>
    u_n <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t[n]</span>

    Dl <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>theta
    Dr <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)

    <span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
    diagonal <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)
    lower    <span style="color: #666666">=</span> zeros(Nx)
    upper    <span style="color: #666666">=</span> zeros(Nx)
    b        <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Precompute sparse matrix (scipy format)</span>
    diagonal[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[:<span style="color: #666666">-2</span>])
    lower[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[:<span style="color: #666666">-2</span>])
    upper[<span style="color: #666666">1</span>:]  <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    diagonal[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    upper[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    diagonal[Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    lower[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
        diagonals<span style="color: #666666">=</span>[diagonal, lower, upper],
        offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>],
        shape<span style="color: #666666">=</span>(Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>),
        format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
        u_n[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_n, x, t, <span style="color: #666666">0</span>)

    <span style="color: #408080; font-style: italic"># Time loop</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        b[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> Dr<span style="color: #666666">*</span>(
            (a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">*</span>(u_n[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">-</span>
            (a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>])<span style="color: #666666">*</span>(u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> u_n[:<span style="color: #666666">-2</span>]))
        <span style="color: #408080; font-style: italic"># Boundary conditions</span>
        b[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> u_L(t[n<span style="color: #666666">+1</span>])
        b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_R(t[n<span style="color: #666666">+1</span>])
        <span style="color: #408080; font-style: italic"># Solve</span>
        u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, x, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>
<p>
The code is found in the file <a href="http://tinyurl.com/nu656p2/diffu/diffu1D_vc.py" target="_self"><tt>diffu1D_vc.py</tt></a>.

<h2 id="diffu:varcoeff:stationary">Stationary solution</h2>

<p>
As \( t\rightarrow\infty \), the solution of the
problem <a href="#mjx-eqn-69">(69)</a>-<a href="#mjx-eqn-72">(72)</a>
will approach
a stationary limit where \( \partial u/\partial t=0 \). The governing
equation is then

$$
\begin{equation}
\frac{d}{dx}\left(\alpha\frac{du}{dx}\right) =0,
\tag{73}
\end{equation}
$$

with boundary conditions \( u(0)=U_0 \) and \( u(L)=U_L \).
It is possible to obtain an exact solution of <a href="#mjx-eqn-73">(73)</a>
for any \( \alpha \). Integrating twice and applying the boundary conditions
to determine the integration constants gives

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)\frac{\int_0^x (\alpha(\xi))^{-1}d\xi}{\int_0^L (\alpha(\xi))^{-1}d\xi}
\tp
\tag{74}
\end{equation}
$$

<h2 id="diffu:varcoeff:piecewise">Piecewise constant medium</h2>

<p>
Consider a medium built of \( M \) layers. The layer boundaries
are denoted \( b_0, \ldots, b_M \),
where \( b_0=0 \) and \( b_M=L \).
If the layers potentially have different material properties, but
these properties are constant within each layer, we can express \( \alpha \) as a
<em>piecewise constant function</em> according to

$$
\begin{equation}
\alpha (x) = \left\lbrace\begin{array}{ll}
\alpha_0,& b_0 \leq x < b_1,\\ 
\vdots &\\ 
\alpha_i,& b_i \leq x < b_{i+1},\\ 
\vdots &\\ 
\alpha_{M-1},& b_{M-1} \leq x \leq b_M.
\end{array}\right.
\end{equation}
\tag{75}
$$

<p>
The exact solution <a href="#mjx-eqn-74">(74)</a> in case of such a
piecewise constant \( \alpha \) function is easy to derive. Assume that
\( x \) is in the \( m \)-th layer: \( x\in [b_m, b_{m+1}] \). In the integral
\( \int_0^x (a(\xi))^{-1}d\xi \) we must integrate through the first
\( m-1 \) layers and then add the contribution from the remaining part
\( x-b_m \) into the \( m \)-th layer:

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)
\frac{\sum_{j=0}^{m-1} (b_{j+1}-b_j)/\alpha(b_j) + (x-b_m)/\alpha(b_m)}{\sum_{j=0}^{M-1} (b_{j+1}-b_j)/\alpha(b_j)}
\tag{76}
\end{equation}
$$

<p>
<b>Remark.</b>
It may sound strange to have a discontinuous \( \alpha \) in a differential
equation where one is to differentiate, but a discontinuous \( \alpha \)
is compensated by a discontinuous \( u_x \) such that \( \alpha u_x \) is
continuous and therefore can be differentiated as \( (\alpha u_x)_x \).

<h2 id="diffu:varcoeff:impl:piecewise">Implementation of diffusion in a piecewise constant medium</h2>

<p>
Programming with piecewise function definitions quickly becomes
cumbersome as the most naive approach is to test for which interval
\( x \) lies, and then start evaluating a formula like
<a href="#mjx-eqn-76">(76)</a>. In Python, vectorized expressions may
help to speed up the computations.
The convenience classes <code>PiecewiseConstant</code> and
<code>IntegratedPiecewiseConstant</code> in the <a href="http://tinyurl.com/nu656p2/diffu/Heaviside.py" target="_self"><tt>Heaviside</tt></a>
module were made to simplify programming with
functions like <a href="#mjx-eqn-75">(75)</a> and expressions like
<a href="#mjx-eqn-76">(76)</a>. These utilities not only represent
piecewise constant functions, but also <em>smoothed</em> versions of them
where the discontinuities can be smoothed out in a controlled fashion.

<p>
The <code>PiecewiseConstant</code> class is created by sending in the domain as a
2-tuple or 2-list and a <code>data</code> object describing the boundaries
\( b_0,\ldots,b_M \) and the corresponding function values
\( \alpha_0,\ldots,\alpha_{M-1} \). More precisely, <code>data</code> is a nested
list, where <code>data[i][0]</code> holds \( b_i \) and <code>data[i][1]</code> holds the
corresponding value \( \alpha_i \), for \( i=0,\ldots,M-1 \). Given \( b_i \) and
\( \alpha_i \) in arrays <code>b</code> and <code>a</code>, it is easy to fill out the nested
list <code>data</code>.

<p>
In our application, we want to represent \( \alpha \) and \( 1/\alpha \)
as piecewise constant functions, in addition to the \( u(x) \) function
which involves the integrals of \( 1/\alpha \). A class creating the
functions we need and a method for evaluating \( u \), can take the
form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    b: coordinates of boundaries of layers, b[0] is left boundary</span>
<span style="color: #BA2121; font-style: italic">    and b[-1] is right boundary of the domain [0,L].</span>
<span style="color: #BA2121; font-style: italic">    a: values of the functions in each layer (len(a) = len(b)-1).</span>
<span style="color: #BA2121; font-style: italic">    U_0: u(x) value at left boundary x=0=b[0].</span>
<span style="color: #BA2121; font-style: italic">    U_L: u(x) value at right boundary x=L=b[0].</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b, U_0, U_L, eps<span style="color: #666666">=0</span>):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(a), np<span style="color: #666666">.</span>asarray(b)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">=</span> eps  <span style="color: #408080; font-style: italic"># smoothing parameter for smoothed a</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0, <span style="color: #008000">self</span><span style="color: #666666">.</span>U_L <span style="color: #666666">=</span> U_0, U_L

        a_data <span style="color: #666666">=</span> [[bi, ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        domain <span style="color: #666666">=</span> [b[<span style="color: #666666">0</span>], b[<span style="color: #666666">-1</span>]]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func <span style="color: #666666">=</span> PiecewiseConstant(domain, a_data, eps)

        <span style="color: #408080; font-style: italic"># inv_a = 1/a is needed in formulas</span>
        inv_a_data <span style="color: #666666">=</span> [[bi, <span style="color: #666666">1./</span>ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_func <span style="color: #666666">=</span> \ 
             PiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func <span style="color: #666666">=</span> \ 
             IntegratedPiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #408080; font-style: italic"># Denominator in the exact formula is constant</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(b[<span style="color: #666666">-1</span>])

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, x):
        solution <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0 <span style="color: #666666">+</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>U_L<span style="color: #666666">-</span><span style="color: #008000">self</span><span style="color: #666666">.</span>U_0)<span style="color: #666666">*</span>\ 
                   <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(x)<span style="color: #666666">/</span><span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L
        <span style="color: #008000; font-weight: bold">return</span> solution
</pre></div>
<p>
A visualization method is also convenient to have. Below we plot \( u(x) \)
along with \( \alpha (x) \) (which works well as long as \( \max \alpha(x) \)
is of the same size as \( \max u = \max(U_0,U_L) \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #666666">...</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot</span>(<span style="color: #008000">self</span>):
        x, y_a <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func<span style="color: #666666">.</span>plot()
        x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(x); y_a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(y_a)
        y_u <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u_exact(x)
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(x, y_u, <span style="color: #BA2121">&#39;b&#39;</span>)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)  <span style="color: #408080; font-style: italic"># Matlab style</span>
        plt<span style="color: #666666">.</span>plot(x, y_a, <span style="color: #BA2121">&#39;r&#39;</span>)
        ymin <span style="color: #666666">=</span> <span style="color: #666666">-0.1</span>
        ymax <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span><span style="color: #008000">max</span>(y_u<span style="color: #666666">.</span>max(), y_a<span style="color: #666666">.</span>max())
        plt<span style="color: #666666">.</span>axis([x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], ymin, ymax])
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;solution $u$&#39;</span>, <span style="color: #BA2121">&#39;coefficient $a$&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
            plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Smoothing eps: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
        plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Figure <a href="#diffu:fd2:pde:st:sol:pc:fig1">12</a> shows the case where

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]   <span style="color: #408080; font-style: italic"># material boundaries</span>
a <span style="color: #666666">=</span> [<span style="color: #666666">0.2</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">4</span>]       <span style="color: #408080; font-style: italic"># material values</span>
U_0 <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>;  U_L <span style="color: #666666">=</span> <span style="color: #666666">5</span>     <span style="color: #408080; font-style: italic"># boundary conditions</span>
</pre></div>
<p>
<center> <!-- figure label: --> <div id="diffu:fd2:pde:st:sol:pc:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 12:  Solution of the stationary diffusion equation corresponding to a piecewise constant diffusion coefficient.  <!-- caption label: diffu:fd2:pde:st:sol:pc:fig1 --> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1.png" align="bottom" width=400></p>
</center>

<p>
By adding the <code>eps</code> parameter to the constructor of the <code>SerialLayers</code>
class, we can experiment with smoothed versions of \( \alpha \) and see
the (small) impact on \( u \). Figure <a href="#diffu:fd2:pde:st:sol:pc:fig2">13</a>
shows the result.

<p>
<center> <!-- figure label: --> <div id="diffu:fd2:pde:st:sol:pc:fig2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 13:  Solution of the stationary diffusion equation corresponding to a <em>smoothed</em> piecewise constant diffusion coefficient.  <!-- caption label: diffu:fd2:pde:st:sol:pc:fig2 --> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1_eps.png" align="bottom" width=400></p>
</center>

<h2 id="diffu:fd2:radial">Axi-symmetric diffusion</h2>

<p>
Suppose we have a diffusion process taking place in a straight tube
with radius \( R \). We assume axi-symmetry such that \( u \) is just a
function of \( r \) and \( t \), with \( r \) being the radial distance from the center
axis of the tube to a point. With such axi-symmetry it is
advantageous to introduce <em>cylindrical coordinates</em> \( r \), \( \theta \), and
\( z \), where \( z \) is in the direction of the tube and \( (r,\theta) \) are
polar coordinates in a cross section. Axi-symmetry means that all
quantities are independent of \( \theta \). From the relations \( x=\cos\theta \),
\( y=\sin\theta \), and \( z=z \), between Cartesian and cylindrical coordinates,
one can (with some effort) derive the diffusion equation in cylindrical
coordinates, which with axi-symmetry takes the form

$$
\frac{\partial u}{\partial t} = \frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc(r,z)\frac{\partial u}{\partial r}\right) + \frac{\partial}{\partial z}
\left(\alpha(r,z)\frac{\partial u}{\partial z}\right) + f(r,z,t)\tp$$

<p>
Let us assume that \( u \) does not change along the tube axis so it
suffices to compute variations in a cross section. Then \( \partial u/\partial
z = 0 \) and the we have a 1D diffusion equation in the radial coordinate
\( r \) and time \( t \). In particular, we shall address the initial-boundary
value problem

$$
\begin{alignat}{2}
\frac{\partial u}{\partial t} &= \frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc(r)\frac{\partial u}{\partial r}\right) + f(t), & r\in (0,R),\ t\in (0,T],
\tag{77}\\ 
\frac{\partial u}{\partial r}(0,t) &= 0, & t\in (0,T],
\tag{78}\\ 
u(R,t) &= 0, & t\in (0,T],
\tag{79}\\ 
u(r,0) &= I(r), & r\in [0,R].
\tag{80}
\end{alignat}
$$

The condition <a href="#mjx-eqn-78">(78)</a> is a necessary symmetry condition
at \( r=0 \), while <a href="#mjx-eqn-79">(79)</a> could be any Dirichlet
or Neumann condition (or Robin condition in case of cooling or heating).

<p>
The finite difference approximation will need the discretized version
of the PDE for \( r=0 \) (just as we use the PDE at the boundary when
implementing Neumann conditions). However, discretizing the PDE at
\( r=0 \) poses a problem because of the \( 1/r \) factor. We therefore need
to work out the PDE for discretization at \( r=0 \) with care.
Let us, for the case of constant \( \dfc \), expand the spatial derivative term to

$$ \alpha\frac{\partial^2 u}{\partial r^2} + \alpha\frac{1}{r}\frac{\partial u}{\partial r}\tp$$

The last term faces a difficulty at \( r=0 \), since it becomes a \( 0/0 \) expression
caused by the symmetry condition at \( r=0 \).
However, L'Hosptial's rule can be used:

$$ \lim_{r\rightarrow 0} \frac{1}{r}\frac{\partial u}{\partial r}
= \frac{\partial^2 u}{\partial r^2}\tp$$

The PDE at \( r=0 \) therefore becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = 2\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{81}
\end{equation}
$$

For a variable coefficient \( \dfc(r) \) the expanded spatial derivative term reads

$$ \dfc(r)\frac{\partial^2 u}{\partial r^2} +
\frac{1}{r}(\dfc(r) + r\dfc'(r))\frac{\partial u}{\partial r}\tp$$

We are interested in this expression for \( r=0 \). A necessary condition
for \( u \) to be axi-symmetric is that all input data, including \( \alpha \),
must also be axi-symmetric, implying that \( \alpha'(0)=0 \) (the second
term vanishes anyway because of \( r=0 \)). The limit of interest is

$$ \lim_{r\rightarrow 0}
\frac{1}{r}\dfc(r)\frac{\partial u}{\partial r} =
\dfc(0)\frac{\partial^2 u}{\partial r^2}\tp
$$

The PDE at \( r=0 \) now looks like

$$
\begin{equation}
\frac{\partial u}{\partial t} = 2\dfc(0)
\frac{\partial^2 u}{\partial r^2}
+ f(t),
\tag{82}
\end{equation}
$$

so there is no essential difference between the constant coefficient
and variable coefficient cases.

<p>
The second-order derivative in <a href="#mjx-eqn-81">(81)</a>
and <a href="#mjx-eqn-82">(82)</a>
is discretized in the usual way.

$$ 2\dfc\frac{\partial^2}{\partial r^2}u(r_0,t_n) \approx
[2\dfc D_rD_r u]^n_0 =
2\dfc \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}\tp$$

The fictitious value \( u^n_{-1} \) can be eliminated using the discrete
symmetry condition

$$ [D_{2r} u =0]^n_0 \quad\Rightarrow\quad u^n_{-1} = u^n_1,$$

which then gives the modified approximation to the term with the second-order derivative
of \( u \) in \( r \) at \( r=0 \):

$$
\begin{equation}
4\dfc \frac{u^{n}_{1} - u^{n}_0}{\Delta r^2}\tp
\tag{83}
\end{equation}
$$

<p>
The discretization of the term with the second-order derivative in \( r \) at any
internal mesh point is straightforward:

$$
\begin{align*}
\left[\frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc\frac{\partial u}{\partial r}\right)\right]_i^n
& \approx [r^{-1} D_r (r \dfc D_r u)]_i^n\\ 
&= \frac{1}{r_i}\frac{1}{\Delta r^2}\left(
r_{i+\half}\dfc_{i+\half}(u_{i+1}^n - u_i^n) - r_{i-\half}\dfc_{i-\half}(u_{i}^n - u_{i-1}^n)\right)\tp
\end{align*}
$$

<p>
To complete the discretization, we need a scheme in time, but that can
be done as before and does not interfere with the discretization in space.

<h2 id="diffu:fd2:spherical">Spherically-symmetric diffusion</h2>

<h3 id="___sec56">Discretization in spherical coordinates </h3>

<p>
Let us now pose the problem from the section <a href="#diffu:fd2:radial">Axi-symmetric diffusion</a>
in spherical coordinates, where \( u \) only depends on the radial coordinate
\( r \) and time \( t \). That is, we have spherical symmetry.
For simplicity we restrict the diffusion coefficient \( \dfc \) to be
a constant. The PDE reads

$$
\begin{equation}
\frac{\partial u}{\partial t} = \frac{\dfc}{r^\gamma}\frac{\partial}{\partial r}
\left(r^\gamma\frac{\partial u}{\partial r}\right) + f(t),
\tag{84}
\end{equation}
$$

for \( r\in (0,R) \) and \( t\in (0,T] \). The parameter \( \gamma \) is 2 for
spherically-symmetric problems and 1 for axi-symmetric problems.
The boundary and initial conditions
have the same mathematical form as
in <a href="#mjx-eqn-77">(77)</a>-<a href="#mjx-eqn-80">(80)</a>.

<p>
Since the PDE in spherical coordinates has the same form as the PDE
in the section <a href="#diffu:fd2:radial">Axi-symmetric diffusion</a>, just with the \( \gamma \) parameter
being different, we can use the same discretization approach.
At the origin \( r=0 \) we get problems with the term

$$ \frac{\gamma}{r}\frac{\partial u}{\partial t},$$

but L'Hosptial's rule shows that this term equals \( \gamma\partial^2 u/
\partial r^2 \), and the PDE at \( r=0 \) becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = (\gamma+1)\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{85}
\end{equation}
$$

The associated discrete form is then

$$
\begin{equation}
[D_t u = \half (\gamma+1)\dfc([D_rD_r \overline{u}^t + \overline{f}^t]^n_i,
\tag{86}
\end{equation}
$$

for a Crank-Nicolson scheme.

<h3 id="___sec57">Discretization in Cartesian coordinates </h3>

<p>
The spherically-symmetric spatial derivative can be transformed to
the Cartesian counterpart by introducing

$$ v(r,t) = ru(r,t)\tp$$

Inserting \( u=v/r \) in

$$ \frac{1}{r^2}\frac{\partial}{\partial r}
\left(\dfc(r)r^2\frac{\partial u}{\partial r}\right), $$

yields

$$ r\left(\frac{d \dfc}{dr}\frac{\partial v}{\partial r} +
\dfc\frac{\partial^2 v}{\partial r^2}\right) - \frac{d \dfc}{dr}v
\tp
$$

The two terms in the parenthesis can be combined to
$$ r\frac{\partial}{\partial r}\left( \dfc\frac{\partial v}{\partial r}\right)\tp
$$

The PDE for \( v \) takes the form

$$
\begin{equation}
\frac{\partial v}{\partial t} = \frac{\partial}{\partial r}\left( \dfc
\frac{\partial v}{\partial r}\right) - \frac{1}{r}\frac{d\dfc}{dr}v + rf(r,t),
\quad r\in (0,R),\ t\in (0,T]\tp
\tag{87}
\end{equation}
$$

For \( \alpha \) constant we immediately realize that we can reuse a
solver in Cartesian coordinates to compute \( v \). With variable \( \alpha \),
a &quot;reaction&quot; term \( v/r \) needs to be added to the Cartesian solver.
The boundary condition \( \partial u/\partial r=0 \) at \( r=0 \), implied
by symmetry, forces \( v(0,t)=0 \), because

$$ \frac{\partial u}{\partial r} = \frac{1}{r^2}\left(
r\frac{\partial v}{\partial r} - v\right) = 0,\quad r=0\tp
$$

<h1 id="diffu:2D">Diffusion in 2D</h1>

<p>
We now address diffusion in two space dimensions:

$$
\begin{align}
\frac{\partial u}{\partial t} & = \dfc\left(
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial x^2}\right) + f(x,y),
\tag{88}
\end{align}
$$

in a domain

$$ (x,y)\in (0,L_x)\times (0,L_y),\ t\in (0,T], $$

with \( u=0 \) on the boundary and \( u(x,y,0)=I(x,y) \) as initial condition.

<h2 id="diffu:2D:discr">Discretization</h2>

<p>
For generality, it is natural to use a \( \theta \)-rule for the time
discretization. Standard, second-order accurate finite differences are
used for the spatial derivatives. We sample the PDE at a space-time
point \( (i,j,n+\half) \) and apply the difference approximations:

$$
\begin{align}
\lbrack D_t u\rbrack^{n+\half} &=
\theta \lbrack \dfc (D_xD_x u + D_yD_yu) + f\rbrack^{n+1} + \nonumber\\ 
&\quad (1-\theta)\lbrack \dfc (D_xD_x u + D_yD_y u) + f\rbrack^{n}\tp
\tag{89}
\end{align}
$$

Written out,

$$
\begin{align}
& \frac{u^{n+1}_{i,j}-u^n_{i,j}}{\Delta t} =\nonumber\\ 
&\qquad \theta (\dfc
(\frac{u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i+1,j}}{\Delta x^2} +
\frac{u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1}}{\Delta y^2}) +
f^{n+1}_{i,j})
+ \nonumber\\ 
&\qquad (1-\theta)(\dfc
(\frac{u^{n}_{i-1,j} - 2u^{n}_{i,j} + u^{n}_{i+1,j}}{\Delta x^2} +
\frac{u^{n}_{i,j-1} - 2u^{n}_{i,j} + u^{n}_{i,j+1}}{\Delta y^2}) +
f^{n}_{i,j})
\tag{90}
\end{align}
$$

We collect the unknowns on the left-hand side

$$
\begin{align}
& u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i+1,j}) +
F_y
(u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= \nonumber\\ 
&\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2u^{n}_{i,j} + u^{n}_{i+1,j}) +
F_y
(u^{n}_{i,j-1} - 2u^{n}_{i,j} + u^{n}_{i,j+1})\right) + \nonumber\\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j}
+ u^n_{i,j},
\tag{91}
\end{align}
$$

where

$$ F_x = \frac{\dfc\Delta t}{\Delta x^2},\quad F_y = \frac{\dfc\Delta t}{\Delta y^2},$$

are the Fourier numbers in \( x \) and \( y \) direction, respectively.

<p>
<center> <!-- figure label: --> <div id="diffu:2D:fig:mesh3x2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 14:  3x2 2D mesh.  <!-- caption label: diffu:2D:fig:mesh3x2 --> </p></center>
<p><img src="fig-diffu/mesh3x2.png" align="bottom" width=500></p>
</center>

<h2 id="diffu:2D:numbering">Numbering of mesh points versus equations and unknowns</h2>

<p>
<!-- Nx=3, Ny=2 -->
The equations <a href="#mjx-eqn-91">(91)</a> are coupled at the new
time level \( n+1 \). That is, we must solve a system of (linear) algebraic
equations, which we will write as \( Ac=b \), where \( A \) is the coefficient
matrix, \( c \) is the vector of unknowns, and \( b \) is the right-hand side.

<p>
Let us examine the equations in \( Ac=b \) on a mesh with \( N_x=3 \) and
\( N_y=2 \) cells in the respective spatial directions.  The spatial mesh is depicted in
Figure <a href="#diffu:2D:fig:mesh3x2">14</a>.  The equations at the boundary just
implement the boundary condition \( u=0 \):

$$
\begin{align*}
& u^{n+1}_{0,0}=
u^{n+1}_{1,0}=
u^{n+1}_{2,0}=
u^{n+1}_{3,0}=
u^{n+1}_{0,1}=\\ 
& u^{n+1}_{3,1}=
u^{n+1}_{0,2}=
u^{n+1}_{1,2}=
u^{n+1}_{2,2}=
u^{n+1}_{3,2}= 0\tp
\end{align*}
$$

We are left with two interior points, with \( i=1 \), \( j=1 \) and \( i=2 \), \( j=1 \).
The corresponding equations are

$$
\begin{align*}
& u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i+1,j}) +
F_y
(u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
=  \\ 
&\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2u^{n}_{i,j} + u^{n}_{i+1,j}) +
F_y
(u^{n}_{i,j-1} - 2u^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j}
+ u^n_{i,j},
\end{align*}
$$

<p>
There are in total 12 unknowns \( u^{n+1}_{i,j} \) for \( i=0,1,2,3 \) and
\( j=0,1,2 \).  To solve the equations, we need to form a matrix system \( Ac=b \).
In that system, the solution vector \( c \) can only have one index. Thus,
we need a numbering of the unknowns with one
index, not two as used in the mesh. We introduce a mapping \( m(i,j) \)
from a mesh point with indices \( (i,j) \) to the corresponding unknown
\( p \) in the equation system:

$$ p = m(i,j) = j(N_x+1) + i\tp$$

When \( i \) and \( j \) run through their values, we see the following mapping
to \( p \):

$$
\begin{align*}
&(0,0)\rightarrow 0,\ 
(0,1)\rightarrow 1,\ 
(0,2)\rightarrow 2,\ 
(0,3)\rightarrow 3,\\ 
&(1,0)\rightarrow 4,\ 
(1,1)\rightarrow 5,\ 
(1,2)\rightarrow 6,\ 
(1,3)\rightarrow 7,\\ 
&(2,0)\rightarrow 8,\ 
(2,1)\rightarrow 9,\ 
(2,2)\rightarrow 10,\ 
(2,3)\rightarrow 11\tp
\end{align*}
$$

That is, we number the points along the \( x \) axis, starting with \( y=0 \),
and then progress one &quot;horizontal&quot; mesh line at a time.
In Figure <a href="#diffu:2D:fig:mesh3x2">14</a> you can see that the \( (i,j) \) and the
corresponding single index (\( p \)) are listed for each mesh point.

<p>
We could equally well have numbered the equations in other ways, e.g.,
let the \( j \) index be the fastest varying index:
\( p = m(i,j) = i(N_y+1) + j \).

<p>
Let us form the coefficient matrix \( A \), or more precisely, insert a
matrix element (according Python's convention with zero as base
index) for each of the nonzero elements in \( A \) (the indices
run through the values of \( p \), i.e., \( p=0,\ldots,11 \)):

$$
{\tiny
\left(\begin{array}{cccccccccccc}
(0,0) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & (1,1) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   & (2,2) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   & (3,3) &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   & (4,4) &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & (5,1) &   0   &   0   & (5,4) & (5,5) & (5,6) &   0   &   0   & (5,9) &   0    &   0    \\ 
  0   &   0   & (6,2) &   0   &   0   & (6,5) & (6,6) & (6,7) &   0   &   0   & (6,10) &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   & (7,7) &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & (8,8) &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & (9,9) &   0    &   0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   & (10,10) &    0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0    & (11,11) \\ 
\end{array}\right)
}
$$

Here is a more compact visualization of the coefficient matrix where we
insert dots for zeros and bullets for non-zero elements:

$$
\footnotesize
\left(\begin{array}{cccccccccccc}
\bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}\right)
$$

It is clearly seen that most of the elements are zero. This is a general
feature of coefficient matrices arising from discretizing PDEs by
finite difference methods. We say that the matrix is <em>sparse</em>.

<p>
Let \( A_{p,q} \) be the value of element \( (p,q) \) in the coefficient matrix \( A \),
where \( p \) and \( q \) now correspond to the numbering of the unknowns in the
equation system.
We have \( A_{p,q}=1 \) for \( p=q=0,1,2,3,4,7,8,9,10,11 \), corresponding
to all the known boundary values. Let \( p \) be \( m(i,j) \), i.e.,
the single index corresponding to mesh point \( (i,j) \). Then we have

$$
\begin{align}
A_{m(i,j),m(i,j)} = A_{p,p} &=
1 +
\theta (F_x + F_y),
\tag{92}\\ 
A_{p, m(i-1,j)} = A_{p,p-1} &= -\theta F_x,
\tag{93}\\ 
A_{p, m(i+1,j)} = A_{p,p+1} &= -\theta F_x,
\tag{94}\\ 
A_{p, m(i,j-1)} = A_{p, p-(N_x+1)} &= -\theta F_y,
\tag{95}\\ 
A_{p, m(i,j+1)} = A_{p, p+(N_x+1)} &= -\theta F_y,
\tag{96}
\end{align}
$$

for the equations associated with the two interior mesh points.
At these interior points, the single index \( p \) takes on the
specific values \( p=5,6 \), corresponding to the
values \( (1,1) \) and \( (1,2) \) of the pair \( (i,j) \).

<p>
The above values for \( A_{p,q} \) can be inserted in the matrix:

$$
{\tiny
\left(\begin{array}{cccccccccccc}
1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & -\theta F_y &   0   &   0   & -\theta F_x & 1+2\theta F_x & -\theta F_x &   0   &   0   & -\theta F_y &   0    &   0    \\ 
  0   &   0   & -\theta F_y &   0   &   0   & -\theta F_x & 1+2\theta F_x & -\theta F_x &   0   &   0   & -\theta F_y &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0    &   0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   & 1 &    0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0    & 1 \\ 
\end{array}\right)
}
$$

The corresponding right-hand side vector in the equation system has
the entries \( b_p \), where \( p \) numbers the equations. We have

$$ b_0=b_1=b_2=b_3=b_4=b_7=b_8=b_9=b_{10}=b_{11}=0,$$

for the boundary values. For the equations associated with the
interior points, we get for \( p=5,6 \), corresponding to \( i=1,2 \) and \( j=1 \):

$$
\begin{align*}
b_p &= u^{n}_{i,j} +
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2u^{n}_{i,j} + u^{n}_{i+1,j}) +
F_y
(u^{n}_{i,j-1} - 2u^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j}\tp
\end{align*}
$$

Recall that \( p=m(i,j)=j(N_x+1)+j \) in this expression.

<p>
We can, as an alternative, leave the boundary mesh points out of the
matrix system. For a mesh with \( N_x=3 \) and \( N_y=2 \) there are only two
internal mesh points whose unknowns will enter the matrix system.
We must now number the unknowns at the interior points:

$$ p = (j-1)(N_x-1) + i,$$

for \( i=1,\ldots,N_x-1 \), \( j=1,\ldots,N_y-1 \).

<p>
<!-- Nx=4, Ny=3 -->

<p>
<center> <!-- figure label: --> <div id="diffu:2D:fig:mesh4x3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 15:  4x3 2D mesh.  <!-- caption label: diffu:2D:fig:mesh4x3 --> </p></center>
<p><img src="fig-diffu/mesh4x3.png" align="bottom" width=700></p>
</center>

<p>
We can continue with illustrating a bit larger mesh, \( N_x=4 \) and \( N_y=3 \),
see Figure <a href="#diffu:2D:fig:mesh4x3">15</a>. The corresponding coefficient matrix
with dots for zeros and bullets for non-zeroes looks as follows (values at boundary points are included in the equation system):

$$
{\tiny
\left(\begin{array}{cccccccccccccccccccc}
\bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}\right)
}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>The coefficient matrix is banded.</b>
Besides being sparse, we observe that the coefficient matrix is <em>banded</em>:
it has five distinct bands. We have the diagonal \( A_{i,i} \), the
subdiagonal \( A_{i-1,j} \), the superdiagonal \( A_{i,i+1} \), a lower
diagonal \( A_{i,i-(Nx+1)} \), and an upper diagonal \( A_{i,i+(Nx+1)} \).
The other matrix entries are known to be zero. With \( N_x+1=N_y+1=N \),
only a fraction \( 5N^{-2} \) of the matrix entries are nonzero, so the
matrix is clearly very sparse for relevant \( N \) values.
The more we can compute with the nonzeros only, the faster the solution
methods will potentially be.
</div>


<h2 id="diffu:2D:alg">Algorithm for setting up the coefficient matrix</h2>

<p>
We looked at a specific mesh in the previous section, formulated
the equations, and saw what the corresponding coefficient matrix and
right-hand side are. Now our aim is to set up a general algorithm, for any
choice of \( N_x \) and \( N_y \), that produces the coefficient matrix and
the right-hand side vector.
We start with a zero matrix and vector, run through each mesh point,
and fill in the values depending on whether the mesh point is an interior
point or on the boundary.

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> for \( j=0,\ldots, N_y \)</li>

<ul>
    <li> \( p=j(N_x+1)+i \)</li>
    <li> if point \( (i,j) \) is on the boundary:</li>

<ul>
      <li> \( A_{p,p}=1 \), \( b_p=0 \)</li>
</ul>

    <li> else:</li>

<ul>
      <li> fill \( A_{p,m(i-1,j)} \), \( A_{p,m(i+1,j)} \), \( A_{p,m(i,j)} \), \( A_{p,m(i,j-1)} \), \( A_{p,m(i,j+1)} \), and \( b_p \)</li>
</ul>

</ul>

</ul>

</ul>

To ease the test on whether \( (i,j) \) is on the boundary or not, we can
split the loops a bit, starting with the boundary line \( j=0 \), then
treat the interior lines \( 1\leq j < N_y \), and finally treat the boundary
line \( j=N_y \):

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=0 \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

 <li> for \( j=0,\ldots,N_y \)</li>

<ul>
  <li> boundary \( i=0 \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
  <li> for \( i=1,\ldots, N_x-1 \)</li>

<ul>
    <li> interior point \( p=j(N_x+1)+i \)</li>
    <li> fill \( A_{p,m(i-1,j)} \), \( A_{p,m(i+1,j)} \), \( A_{p,m(i,j)} \), \( A_{p,m(i,j-1)} \), \( A_{p,m(i,j+1)} \), and \( b_p \)</li>
</ul>

  <li> boundary \( i=N_x \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=N_y \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

</ul>

The right-hand side is set up as follows.

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=0 \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

 <li> for \( j=0,\ldots,N_y \)</li>

<ul>
  <li> boundary \( i=0 \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
  <li> for \( i=1,\ldots, N_x-1 \)</li>

<ul>
    <li> interior point \( p=j(N_x+1)+i \)</li>
    <li> fill \( b_p \)</li>
</ul>

  <li> boundary \( i=N_x \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=N_y \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

</ul>

<h2 id="diffu:2D:impl:dense">Implementation with a dense coefficient matrix</h2>

<p>
The goal now is to map the algorithms in the previous section to
Python code. One should, for computational efficiency reasons, take
advantage of the fact that the coefficient matrix is sparse and/or
banded, i.e., take advantage of all the zeros. However, we first demonstrate
how to fill an \( N\times N \) dense square matrix, where \( N \) is the number
of unknowns, here \( N=(N_x+1)(N_y+1) \). The dense matrix is much easier
to understand than the sparse matrix case.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_dense</span>(
    I, a, f, Lx, Ly, Nx, Ny, dt, T, theta<span style="color: #666666">=0.5</span>, user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u_t = a*(u_xx + u_yy) + f, u(x,y,0)=I(x,y), with u=0</span>
<span style="color: #BA2121; font-style: italic">    on the boundary, on [0,Lx]x[0,Ly]x[0,T], with time step dt,</span>
<span style="color: #BA2121; font-style: italic">    using the theta-scheme.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Lx, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># mesh points in x dir</span>
    y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Ly, Ny<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># mesh points in y dir</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dy <span style="color: #666666">=</span> y[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> y[<span style="color: #666666">0</span>]

    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                    <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>

    <span style="color: #408080; font-style: italic"># Mesh Fourier numbers in each direction</span>
    Fx <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
    Fy <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dy<span style="color: #666666">**2</span>
</pre></div>
<p>
The \( u^{n+1}_{i,j} \) and \( u^n_{i,j} \) mesh functions are represented
by their spatial values at the mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Ny<span style="color: #666666">+1</span>))      <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Ny<span style="color: #666666">+1</span>))      <span style="color: #408080; font-style: italic"># u at the previous time level</span>
</pre></div>
<p>
It is a good habit (for extensions) to
introduce index sets for all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Ix <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>)
Iy <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>)
It <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt<span style="color: #666666">+1</span>)
</pre></div>
<p>
The initial condition is easy to fill in:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Load initial condition into u_n</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
        u_n[i,j] <span style="color: #666666">=</span> I(x[i], y[j])
</pre></div>
<p>
The memory for the coefficient matrix and right-hand side vector
is allocated by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> (Nx<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>(Ny<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># no of unknowns</span>
A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N, N))
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
</pre></div>
<p>
The filling of <code>A</code> goes like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i

<span style="color: #408080; font-style: italic"># Equations corresponding to j=0, i=0,1,... (u known)</span>
j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Loop over all internal mesh points in y diretion</span>
<span style="color: #408080; font-style: italic"># and all mesh points in x direction</span>
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>   <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:                 <span style="color: #408080; font-style: italic"># Interior points</span>
        p <span style="color: #666666">=</span> m(i,j)
        A[p, m(i,j<span style="color: #666666">-1</span>)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
        A[p, m(i<span style="color: #666666">-1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
        A[p, p]        <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
        A[p, m(i<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
        A[p, m(i,j<span style="color: #666666">+1</span>)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
    i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
<span style="color: #408080; font-style: italic"># Equations corresponding to j=Ny, i=0,1,... (u known)</span>
j <span style="color: #666666">=</span> Ny
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
</pre></div>
<p>
Since <code>A</code> is independent of time, it can be filled once and for all before
the time loop. The right-hand side vector must be filled at each
time level inside the time loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>           <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>   <span style="color: #408080; font-style: italic"># Boundary</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:              <span style="color: #408080; font-style: italic"># Interior points</span>
            p <span style="color: #666666">=</span> m(i,j)
            b[p] <span style="color: #666666">=</span> u_n[i,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
              Fx<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>\ 
              Fy<span style="color: #666666">*</span>(u_n[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i,j<span style="color: #666666">-1</span>]))\ 
                <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt)
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    j <span style="color: #666666">=</span> Ny
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>           <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
            u[i,j] <span style="color: #666666">=</span> c[m(i,j)]

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>
<p>
We use <code>solve</code> from <code>scipy.linalg</code> and not from <code>numpy.linalg</code>. The difference
is stated below.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b><code>scipy.linalg</code> versus <code>numpy.linalg</code>.</b>
Quote from the <a href="http://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html" target="_self">SciPy documentation</a>:

<p>
<code>scipy.linalg</code> contains all the functions in <code>numpy.linalg</code>
plus some other more advanced ones not contained in <code>numpy.linalg</code>.

<p>
Another advantage of using <code>scipy.linalg</code> over numpy.linalg is that it is always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore, the SciPy version might be faster depending on how NumPy was installed.

<p>
Therefore, unless you don't want to add SciPy as a dependency to your NumPy program, use <code>scipy.linalg</code> instead of <code>numpy.linalg</code>.
</div>


<p>
The code shown above is available in the <code>solver_dense</code> function
in the file <a href="http://tinyurl.com/nu656p2/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>, differing only
in the boundary conditions, which in the code can be an arbitrary function along
each side of the domain.

<p>
We do not bother to look at vectorized versions of filling <code>A</code> since
a dense matrix is just used of pedagogical reasons for the very first
implementation. Vectorization will be treated when <code>A</code> has a sparse
matrix representation, as in the section <a href="#diffu:2D:impl:sparse">Implementation with a sparse coefficient matrix</a>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How to debug the computation of \( A \) and \( b \).</b>
A good starting point for debugging the filling of \( A \) and \( b \) is
to choose a very coarse mesh, say \( N_x=N_y=2 \), where there is just
one internal mesh point, compute the equations by hand, and
print out <code>A</code> and <code>b</code> for comparison in the code. If wrong elements
in <code>A</code> or <code>b</code> occur, print out each assignment to elements in
<code>A</code> and <code>b</code> inside the loops and compare with what you expect.
</div>


<p>
To let the user store, analyze, or visualize the solution at each
time level, we include a callback function, named <code>user_action</code>,
to be called before the time loop and in each pass in that loop.
The function has the signature

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">user_action(u, x, xv, y, yv, t, n)
</pre></div>
<p>
where <code>u</code> is a two-dimensional array holding the solution at time level <code>n</code>
and time <code>t[n]</code>. The \( x \) and \( y \) coordinates of the mesh points are given by
the arrays <code>x</code> and <code>y</code>, respectively. The arrays <code>xv</code> and <code>yv</code> are
vectorized representations of the mesh points such that vectorized
function evaluations can be invoked. The <code>xv</code> and <code>yv</code> arrays are
defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">xv <span style="color: #666666">=</span> x[:,np<span style="color: #666666">.</span>newaxis]
yv <span style="color: #666666">=</span> y[np<span style="color: #666666">.</span>newaxis,:]
</pre></div>
<p>
One can then evaluate, e.g., \( f(x,y,t) \) at all internal mesh points at time
level <code>n</code> by first evaluating \( f \) at all points,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a <span style="color: #666666">=</span> f(xv, yv, t[n])
</pre></div>
<p>
and then use slices to extract a view of the values at the internal
mesh points: <code>f_a[1:-1,1:-1]</code>.
The next section features an example on writing a <code>user_action</code>
callback function.

<h2 id="diffu:2D:verify">Verification: exact numerical solution</h2>

<p>
A good test example to start with is one that preserves the solution
\( u=0 \), i.e., \( f=0 \) and \( I(x,y)=0 \). This trivial solution can uncover
some bugs.

<p>
The first real test example is based on having an exact solution of
the discrete equations. This solution is linear in time and quadratic
in space:

$$ u(x,y,t) = 5tx(L_x-x)y(y-L_y)\tp$$

Inserting this manufactured solution in the PDE shows that the
source term \( f \) must be

$$ f(x,y,t) = 5x(L_x-x)y(y-L_y) + 10\dfc t (x(L_x-x)+ y(y-L_y))\tp$$

<p>
We can use the <code>user_action</code> function to compare the numerical solution
with the exact solution at each time level. A suitable helper function
for checking the solution goes like this:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">def quadratic(theta, Nx, Ny):

    def u_exact(x, y, t):
        return 5*t*x*(Lx-x)*y*(Ly-y)
    def I(x, y):
        return u_exact(x, y, 0)
    def f(x, y, t):
        return 5*x*(Lx-x)*y*(Ly-y) + 10*a*t*(y*(Ly-y)+x*(Lx-x))

    # Use rectangle to detect errors in switching i and j in scheme
    Lx = 0.75
    Ly = 1.5
    a = 3.5
    dt = 0.5
    T = 2

    def assert_no_error(u, x, xv, y, yv, t, n):
        &quot;&quot;&quot;Assert zero error at all mesh points.&quot;&quot;&quot;
        u_e = u_exact(xv, yv, t[n])
        diff = abs(u - u_e).max()
        tol = 1E-12
        msg = &#39;diff=%g, step %d, time=%g&#39; % (diff, n, t[n])
        print msg
        assert diff &lt; tol, msg

    solver_dense(
        I, a, f, Lx, Ly, Nx, Ny,
        dt, T, theta, user_action=assert_no_error)
</pre></div>
<p>
A true test function for checking the quadratic solution for several
different meshes and \( \theta \) values can take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_quadratic</span>():
    <span style="color: #408080; font-style: italic"># For each of the three schemes (theta = 1, 0.5, 0), a series of</span>
    <span style="color: #408080; font-style: italic"># meshes are tested (Nx &gt; Ny and Nx &lt; Ny)</span>
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>]:
        <span style="color: #008000; font-weight: bold">for</span> Nx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>, <span style="color: #666666">2</span>):
            <span style="color: #008000; font-weight: bold">for</span> Ny <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>, <span style="color: #666666">2</span>):
                <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;testing for </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny)
                quadratic(theta, Nx, Ny)
</pre></div>

<h2 id="diffu:2D:convrate">Verification: convergence rates</h2>

<p>
For 2D verification with convergence rate computations, the expressions
and computations just build naturally on what we saw for 1D diffusion.
Truncation error analysis and other forms of error analysis point to a
numerical error formula like

$$ E = C_t\Delta t^p + C_x\Delta x^2 + C_y\Delta y^2,$$

where \( p \), \( C_t \), \( C_x \), and \( C_y \) are constants. Often, the analysis of
a Crank-Nicolson
method can show that \( p=2 \), while the Forward and Backward Euler schemes
have \( p=1 \).

<p>
When checking the error formula empirically, we need to reduce it to
a form \( E=Ch^r \) with a single discretization parameter \( h \) and some
rate \( r \) to be estimated. For the Backward Euler method,
where \( p=1 \), we can introduce a single discretization parameter
according to

$$ h = \Delta x^2 =  \Delta y^2,\quad h = K^{-1}\Delta t,$$

where \( K \) is a constant. The error formula then becomes

$$ E = C_t Kh + C_xh + C_yh = \tilde C h,\quad \tilde C = C_tK + C_x + C_y\tp$$

The simplest choice is obviously \( K=1 \). With the Forward Euler method, however,
stability requires \( \Delta t = hK \leq h/(4\dfc) \), so \( K\leq 1/(4\dfc) \).

<p>
For the Crank-Nicolson method, \( p=2 \), and we can simply choose

$$ h = \Delta x = \Delta y = \Delta t,$$

since there is no restriction on \( \Delta t \) in terms of \( \Delta x \) and
\( \Delta y \).

<p>
A frequently used error measure is the \( \ell^2 \) norm of the error mesh
point values. The section ref{wave:pde2:fd:MMS} and the formula
\eqref{wave:pde2:fd:MMS:E:l2} shows the error measure for a 1D
time-dependent problem. The extension to the current 2D problem
reads

$$ E = \left(\Delta t\Delta x\Delta y \sum_{n=0}^{N_t}
\sum_{i=0}^{N_x}\sum_{j=0}^{N_y}(\uex(x_i,y_j,t_n)
- u^n_{i,j})^2\right)^{\half}\tp$$

<p>
One attractive manufactured solution is

$$ \uex = e^{-pt}\sin(k_xx)\sin(k_yy),\quad k_x=\frac{\pi}{L_x},
k_y=\frac{\pi}{L_y},$$

where \( p \) can be arbitrary. The required source term is

$$ f = (\dfc(k_x^2 + k_y^2) - p)\uex\tp$$

<p>
The function <code>convergence_rates</code> in
<a href="http://tinyurl.com/nu656p2/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a> implements a convergence
rate test. Two potential difficulties are important to be aware of:

<ol>
<li> The error formula is assumed to be
   correct when \( h\rightarrow 0 \), so for coarse meshes the estimated rate
   \( r \) may be somewhat away from the expected value.
   Fine meshes may lead to prohibitively long execution times.</li>
<li> Choosing \( p=\dfc (k_x^2 + k_y^2) \) in the manufactured solution above
   seems attractive (\( f=0 \)), but leads to a slower approach to the
   asymptotic range where the error formula is valid (i.e., \( r \)
   fluctuates and needs finer meshes to stabilize).</li>
</ol>

<h2 id="diffu:2D:impl:sparse">Implementation with a sparse coefficient matrix</h2>

<p>
We used a sparse matrix implementation in the section <a href="#diffu:pde1:impl:sparse">Sparse matrix implementation</a>
for a 1D problem with a tridiagonal matrix. The present matrix, arising
from a 2D problem, has five diagonals, but we can use the same
sparse matrix data structure <code>scipy.sparse.diags</code>.

<h3 id="___sec66">Understanding the diagonals </h3>

<p>
Let us look closer at the diagonals in the example with a \( 4\times 3 \) mesh
as depicted in Figure <a href="#diffu:2D:fig:mesh4x3">15</a> and its associated matrix
visualized by dots for zeros and bullets for nonzeros. From the example
mesh, we may generalize to an \( N_x\times N_y \) mesh.

$$
{\tiny
\begin{array}{lcccccccccccccccccccc}
0 =m(0,0) & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
1 = m(1,0) & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2 = m(2,0) & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
3 = m(3,0) & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_x=m(N_x,0) & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_x+1=m(0,1) & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+1=m(1,1) & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+2=m(2,1) & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+3=m(3,1) & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+N_x=m(N_x,1) & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2(N_x+1)=m(0,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2(N_x+1)+1=m(1,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
2(N_x+1)+2=m(2,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
2(N_x+1)+3=m(3,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
2(N_x+1)+N_x=m(N_x,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)=m(0,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)+1=m(1,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)+2=m(2,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
N_y(N_x+1)+3=m(3,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
N_y(N_x+1)+N_x=m(N_x,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}
}
$$

<p>
The main diagonal has \( N=(N_x+1)(N_y+1) \) elements, while the sub- and
super-diagonals have \( N-1 \) elements. By looking at the matrix above,
we realize that the lower diagonal starts in row \( N_x+1 \) and goes to
row \( N \), so its length is \( N-(N_x+1) \). Similarly, the upper diagonal
starts at row 0 and lasts to row \( N-(N_x+1) \), so it has the same length.
Based on this information, we declare the diagonals by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">main   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)            <span style="color: #408080; font-style: italic"># diagonal</span>
lower  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-1</span>)          <span style="color: #408080; font-style: italic"># subdiagonal</span>
upper  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-1</span>)          <span style="color: #408080; font-style: italic"># superdiagonal</span>
lower2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-</span>(Nx<span style="color: #666666">+1</span>))     <span style="color: #408080; font-style: italic"># lower diagonal</span>
upper2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-</span>(Nx<span style="color: #666666">+1</span>))     <span style="color: #408080; font-style: italic"># upper diagonal</span>
b      <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)            <span style="color: #408080; font-style: italic"># right-hand side</span>
</pre></div>

<h3 id="___sec67">Filling the diagonals </h3>

<p>
We run through all mesh points and fill in elements on the various
diagonals. The line of mesh points corresponding to \( j=0 \) are all
on the boundary, and only the main diagonal gets a contribution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i
j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># j=0 boundary line</span>
</pre></div>
<p>
Then we run through all interior \( j=\hbox{const} \) lines of mesh points.
The first and the last point on each line, \( i=0 \) and \( i=N_x \), correspond
to boundary points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:             <span style="color: #408080; font-style: italic"># Interior mesh lines j=1,...,Ny-1</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    i <span style="color: #666666">=</span> Nx;  main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
</pre></div>
<p>
For the interior mesh points \( i=1,\ldots,N_x-1 \) on a mesh line \( y=\hbox{const} \)
we can start with the main diagonal. The entries to be filled go from
\( i=1 \) to \( i=N_x-1 \) so the relevant slice in the <code>main</code> vector is
<code>m(1,j):m(Nx,j)</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">main[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
</pre></div>
<p>
The <code>upper</code> array for the superdiagonal has its index 0 corresponding to
row 0 in the matrix, and the array entries
to be set go from \( m(1,j) \) to \( m(N_x-1,j) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">upper[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
</pre></div>
<p>
The subdiagonal (<code>lower</code> array), however, has its index 0
corresponding to row 1, so there is an offset of 1 in indices compared to
the matrix. The first nonzero occurs (interior point) at a mesh line \( j=\hbox{const} \) corresponding to matrix row \( m(1,j) \), and the corresponding array index
in <code>lower</code> is then \( m(1,j) \). To fill the entries from \( m(1,j) \) to \( m(N_x-1,j) \)
we set the following slice in <code>lower</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower_offset <span style="color: #666666">=</span> <span style="color: #666666">1</span>
lower[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower_offset:m(Nx,j)<span style="color: #666666">-</span>lower_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
</pre></div>
<p>
For the upper diagonal, its index 0 corresponds to matrix row 0, so there
is no offset and we can set the entries correspondingly to <code>upper</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">upper2[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
</pre></div>
<p>
The <code>lower2</code> diagonal, however, has its first index 0 corresponding to row
\( N_x+1 \), so here we need to subtract the offset \( N_x+1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower2_offset <span style="color: #666666">=</span> Nx<span style="color: #666666">+1</span>
lower2[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower2_offset:m(Nx,j)<span style="color: #666666">-</span>lower2_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
</pre></div>
<p>
We can now summarize the above code lines for setting the entries in
the sparse matrix representation of the coefficient matrix:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower_offset <span style="color: #666666">=</span> <span style="color: #666666">1</span>
lower2_offset <span style="color: #666666">=</span> Nx<span style="color: #666666">+1</span>
m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i

j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># j=0 boundary line</span>
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:             <span style="color: #408080; font-style: italic"># Interior mesh lines j=1,...,Ny-1</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    i <span style="color: #666666">=</span> Nx;  main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #408080; font-style: italic"># Interior i points: i=1,...,N_x-1</span>
    lower2[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower2_offset:m(Nx,j)<span style="color: #666666">-</span>lower2_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
    lower[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower_offset:m(Nx,j)<span style="color: #666666">-</span>lower_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
    main[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
    upper[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
    upper2[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
j <span style="color: #666666">=</span> Ny; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary line</span>
</pre></div>
<p>
The next task is to create the sparse matrix from these diagonals:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
    diagonals<span style="color: #666666">=</span>[main, lower, upper, lower2, upper2],
    offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-</span>lower_offset, lower_offset,
             <span style="color: #666666">-</span>lower2_offset, lower2_offset],
    shape<span style="color: #666666">=</span>(N, N), format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
</pre></div>

<h3 id="___sec68">Filling the right-hand side; scalar version </h3>

<p>
Setting the entries in the right-hand side is easier, since there are no
offsets in the array to take into account. The right-hand side is in fact similar to
the one previously shown, when we used a dense matrix representation
(the right-hand side vector is, of course, independent of what type of
representation we use for the coefficient matrix). The complete time
loop goes as follows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>                     <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>             <span style="color: #408080; font-style: italic"># Boundary</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
            p <span style="color: #666666">=</span> m(i,j)                            <span style="color: #408080; font-style: italic"># Interior</span>
            b[p] <span style="color: #666666">=</span> u_n[i,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
              Fx<span style="color: #666666">*</span>(u_n[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>\ 
              Fy<span style="color: #666666">*</span>(u_n[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i,j<span style="color: #666666">-1</span>]))\ 
                <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt)
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>            <span style="color: #408080; font-style: italic"># Boundary</span>
    j <span style="color: #666666">=</span> Ny
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>                     <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
            u[i,j] <span style="color: #666666">=</span> c[m(i,j)]

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>

<h3 id="___sec69">Filling the right-hand side; vectorized version </h3>

<p>
Since we use a sparse matrix and try to speed up the computations, we
should examine the loops and see if some can be easily removed by
vectorization. In the filling of \( A \) we have already used vectorized
expressions at each \( j=\hbox{const} \) line of mesh points. We can
very easily do the same in the code above and remove the need for
loops over the <code>i</code> index:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b, vectorized version</span>

    <span style="color: #408080; font-style: italic"># Precompute f in array so we can make slices</span>
    f_a_np1 <span style="color: #666666">=</span> f(xv, yv, t[n<span style="color: #666666">+1</span>])
    f_a_n   <span style="color: #666666">=</span> f(xv, yv, t[n])

    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; b[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>     <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>
        imin <span style="color: #666666">=</span> Ix[<span style="color: #666666">1</span>]
        imax <span style="color: #666666">=</span> Ix[<span style="color: #666666">-1</span>]  <span style="color: #408080; font-style: italic"># for slice, max i index is Ix[-1]-1</span>
        b[m(imin,j):m(imax,j)] <span style="color: #666666">=</span> u_n[imin:imax,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
          u_n[imin<span style="color: #666666">+1</span>:imax<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span>
        <span style="color: #666666">2*</span>u_n[imin:imax,j] <span style="color: #666666">+</span> \ 
          u_n[imin<span style="color: #666666">-1</span>:imax<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                         Fy<span style="color: #666666">*</span>(
          u_n[imin:imax,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span>
        <span style="color: #666666">2*</span>u_n[imin:imax,j] <span style="color: #666666">+</span>
          u_n[imin:imax,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
            theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[imin:imax,j] <span style="color: #666666">+</span> \ 
          (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[imin:imax,j]
    j <span style="color: #666666">=</span> Ny;  b[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    u[:,:] <span style="color: #666666">=</span> c<span style="color: #666666">.</span>reshape(Ny<span style="color: #666666">+1</span>,Nx<span style="color: #666666">+1</span>)<span style="color: #666666">.</span>T

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>
<p>
The most tricky part of this code snippet is the loading of values from
the one-dimensional array <code>c</code>
into the two-dimensional array <code>u</code>. With our numbering of unknowns
from left to right along &quot;horizontal&quot; mesh lines, the correct
reordering of the one-dimensional array <code>c</code> as a two-dimensional array
requires first a reshaping to an <code>(Ny+1,Nx+1)</code> two-dimensional
array and then taking the transpose. The result is an <code>(Nx+1,Ny+1)</code>
array compatible with <code>u</code> both in size and appearance of the function values.

<p>
The <code>spsolve</code> function in <code>scipy.sparse.linalg</code> is an efficient
version of Gaussian elimination suited for matrices described by
diagonals.  The algorithm is known as <em>sparse Gaussian elimination</em>,
and <code>spsolve</code> calls up a well-tested C code called <a href="http://crd-legacy.lbl.gov/~xiaoye/SuperLU/" target="_self">SuperLU</a>.

<p>
The complete code utilizing <code>spsolve</code>
is found in the <code>solver_sparse</code> function in the file
<a href="http://tinyurl.com/nu656p2/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>.

<h3 id="___sec70">Verification </h3>

<p>
We can easily extend the function <code>quadratic</code> from
the section <a href="#diffu:2D:verify">Verification: exact numerical solution</a> to include a test of the
<code>solver_sparse</code> function as well.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">quadratic</span>(theta, Nx, Ny):
    <span style="color: #666666">...</span>
    t, cpu <span style="color: #666666">=</span> solver_sparse(
        I, a, f, Lx, Ly, Nx, Ny,
        dt, T, theta, user_action<span style="color: #666666">=</span>assert_no_error)
</pre></div>

<h2 id="___sec71">The Jacobi iterative method </h2>

<p>
So far we have created a matrix and right-hand side of a linear system
\( Ac=b \) and solved the system for \( c \) by calling an exact algorithm
based on Gaussian elimination. A much simpler implementation, which
requires no memory for the coefficient matrix \( A \), arises if we solve
the system by <em>iterative</em> methods. These methods are only approximate,
and the core algorithm is repeated many times until the solution is
considered to be converged.

<h3 id="___sec72">Numerical scheme and linear system </h3>

<p>
To illustrate the idea of the Jacobi method, we simplify the numerical scheme to the
Backward Euler case, \( \theta=1 \), so there are fewer terms to write:

$$
\begin{align}
& u^{n+1}_{i,j} -
\left(
F_x
(u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i+1,j}) +
F_y
(u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= \nonumber\\ &\qquad u^n_{i,j} + \Delta t f^{n+1}_{i,j}
\tag{97}
\end{align}
$$

The idea of the <em>Jacobi</em> iterative method is to introduce an iteration,
here with index \( r \), where we in each iteration treat \( u^{n+1}_{i,j} \)
as unknown, but use values from the previous iteration for
the other unknowns \( u^{n+1}_{i\pm 1,j\pm 1} \).

<h3 id="___sec73">Iterations </h3>

<p>
Let \( u^{n+1,r}_{i,j} \)
be the approximation to \( u^{n+1}_{i,j} \) in iteration \( r \), for all
relevant \( i \) and \( j \) indices. We first solve with respect to
\( u^{n+1}_{i,j} \) to get the equation to solve:

$$
\begin{align}
& u^{n+1}_{i,j} = (1+2F_x +2F_y)^{-1}
\left(
F_x
(u^{n+1}_{i-1,j} + u^{n+1}_{i+1,j}) +
F_y
(u^{n+1}_{i,j-1} + u^{n+1}_{i,j+1})\right) +
\nonumber\\ &\qquad
u^n_{i,j} + \Delta t f^{n+1}_{i,j}
\tag{98}
\end{align}
$$

The iteration is introduced by using iteration index \( r \), for computed values,
on the right-hand side and \( r+1 \) (unknown in this iteration) on the left-hand
side:

$$
\begin{align}
& u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}\left(
F_x
(u^{n+1,r}_{i-1,j} + u^{n+1,r}_{i+1,j}) +
F_y
(u^{n+1,r}_{i,j-1} + u^{n+1,r}_{i,j+1})\right)
\nonumber\\ &\qquad
+ u^n_{i,j} + \Delta t f^{n+1}_{i,j}
\tag{99}
\end{align}
$$

<h3 id="___sec74">Initial guess </h3>

<p>
We start the iteration with the computed values at the previous time level:

$$
\begin{equation}
u^{n+1,0}_{i,j} = u^{n}_{i,j},\quad i=0,\ldots,N_x,\ j=0,\ldots,N_y\tp
\tag{100}
\end{equation}
$$

<h3 id="___sec75">Relaxation </h3>

<p>
A common technique in iterative methods is to introduce a <em>relaxation</em>,
which means that the new approximation is a weighted mean of the
approximation as suggested by the algorithm and the previous approximation.
Naming the quantity on the left-hand side of <a href="#mjx-eqn-99">(99)</a>
as \( u^{n+1,*}_{i,j} \), a new approximation based on relaxation reads

$$
\begin{equation}
u^{n+1,r+1} = \omega u^{n+1,*}_{i,j} + (1-\omega) u^{n+1,r}_{i,j}\tp
\tag{101}
\end{equation}
$$

Under-relaxation means \( \omega < 1 \), while over-relaxation has
\( \omega > 1 \).

<h3 id="___sec76">Stopping criteria </h3>

<p>
The iteration can be stopped when the change from one iteration to the
next is sufficiently small (\( \leq \epsilon \)), using either an infinity norm,

$$
\begin{equation}
\max_{i,j}\left\vert u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j}
\right\vert \leq \epsilon,
\tag{102}
\end{equation}
$$

or an \( L^2 \) norm,

$$
\begin{equation}
\left(\Delta x\Delta y\sum_{i,j} (u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j})^2
\right)^{\half} \leq \epsilon\tp
\tag{103}
\end{equation}
$$

<p>
Another widely used criterion measures how well the equations are solved
by looking at the residual (essentially \( b-Ac^{r+1} \) if \( c^{r+1} \) is
the approximation to the solution in iteration \( r+1 \)).
The residual, defined in terms of the finite difference stencil, is

$$
\begin{align}
R_{i,j} &= u^{n+1,r+1}_{i,j} -
(F_x(u^{n+1,r+1}_{i-1,j} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i+1,j}) +\nonumber\\ 
&\quad\quad F_y(u^{n+1,r+1}_{i,j-1} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i,j+1}))
- \nonumber\\ 
&\qquad u^n_{i,j} -  \Delta t f^{n+1}_{i,j}
\tag{104}
\end{align}
$$

One can then iterate until the norm of the mesh function \( R_{i,j} \)
is less than some tolerance:

$$
\begin{equation}
\left(\Delta x\Delta y\sum_{i,j} R_{i,j}^2
\right)^{\half} \leq \epsilon\tp
\tag{105}
\end{equation}
$$

<h3 id="___sec77">Code-friendly notation </h3>

<p>
To make the mathematics as close as possible to what we will write in
a computer program, we may introduce some new notation: \( u_{i,j} \) is a
short notation for \( u^{n+1,r+1}_{i,j} \), \( u^{-}_{i,j} \) is a short
notation for \( u^{n+1,r}_{i,j} \), and \( u^{(s)}_{i,j} \) denotes
\( u^{n+1-s}_{i,j} \).  That is, \( u_{i,j} \) is the unknown, \( u^{-}_{i,j} \)
is its most recently computed approximation, and \( s \) counts time
levels backwards in time. The Jacobi method
<a href="#mjx-eqn-99">(99)</a>) takes the following form with the new
notation:

$$
\begin{align}
& u^{*}_{i,j} = (1+2F_x +2F_y)^{-1}((
F_x
(u^{-}_{i-1,j} + u^{-}_{i+1,j}) +
F_y
(u^{-}_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \Delta t f^{n+1}_{i,j})
\tag{106}
\end{align}
$$

<h3 id="___sec78">Generalization of the scheme </h3>

<p>
We can also quite easily introduce the \( \theta \) rule for discretization in
time and write up the Jacobi iteration in that case as well:

$$
\begin{align}
& u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u^{-}_{i-1,j} + u^{-}_{i+1,j}) +
F_y
(u^{-}_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\\ 
&\qquad (1-\theta)(
F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1})))\tp
\tag{107}
\end{align}
$$

The final update of \( u \) applies relaxation:

$$ u_{i,j} = \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}\tp$$

<h2 id="diffu:2D:Jacobi:impl">Implementation of the Jacobi method</h2>

<p>
The Jacobi method needs no coefficient matrix and right-hand side
vector, but it needs an array for \( u \) in the previous iteration.  We
call this array <code>u_</code>, using the notation at the end of the previous
section (at the same time level). The unknown itself is called <code>u</code>,
while <code>u_n</code> is the computed solution one time level back in time.
With a \( \theta \) rule in time, the time loop can be coded like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Solve linear system by Jacobi iteration at time level n+1</span>
    u_[:,:] <span style="color: #666666">=</span> u_n  <span style="color: #408080; font-style: italic"># Start value</span>
    converged <span style="color: #666666">=</span> <span style="color: #008000">False</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #AA22FF; font-weight: bold">not</span> converged:
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])           <span style="color: #408080; font-style: italic"># Boundary</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   u[i,j] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                i <span style="color: #666666">=</span> Nx;  u[i,j] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
		<span style="color: #408080; font-style: italic"># Interior points</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                    u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
                        Fx<span style="color: #666666">*</span>(u_[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                        Fy<span style="color: #666666">*</span>(u_[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u_[i,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
                    u_n[i,j] <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
                    u_n[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                      Fy<span style="color: #666666">*</span>(
                    u_n[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i,j<span style="color: #666666">-1</span>]))\ 
                      <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt))
                    u[i,j] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[i,j]
            j <span style="color: #666666">=</span> Ny
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])      <span style="color: #408080; font-style: italic"># Boundary</span>

        <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;vectorized&#39;</span>:
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[:,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[i,:] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            i <span style="color: #666666">=</span> Nx; u[i,:] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            j <span style="color: #666666">=</span> Ny; u[:,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
	    <span style="color: #408080; font-style: italic"># Internal points</span>
            f_a_np1 <span style="color: #666666">=</span> f(xv, yv, t[n<span style="color: #666666">+1</span>])
            f_a_n   <span style="color: #666666">=</span> f(xv, yv, t[n])
            u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
              u_[<span style="color: #666666">2</span>:,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_[:<span style="color: #666666">-2</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span>
                Fy<span style="color: #666666">*</span>(
              u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,:<span style="color: #666666">-2</span>])) <span style="color: #666666">+</span>\ 
            u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
              u_n[<span style="color: #666666">2</span>:,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_n[:<span style="color: #666666">-2</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span>\ 
                Fy<span style="color: #666666">*</span>(
              u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,:<span style="color: #666666">-2</span>]))\ 
              <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
            u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
        r <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        converged <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u<span style="color: #666666">-</span>u_)<span style="color: #666666">.</span>max() <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> r <span style="color: #666666">&gt;=</span> max_iter
        u_[:,:] <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
    u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>
<p>
The vectorized version should be quite straightforward to understand
once one has an understanding of how a standard 2D finite stencil
is vectorized.

<p>
The first natural verification is to use the test problem
in the function <code>quadratic</code> from
the section <a href="#diffu:2D:verify">Verification: exact numerical solution</a>. This problem is known to have no
approximation error, but any iterative method will produce an
approximate solution with unknown error. For a tolerance \( 10^{-k} \)
in the iterative method, we can, e.g., use a slightly larger
tolerance \( 10^{-(k-1)} \)
for the difference between the exact and the computed solution.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">quadratic</span>(theta, Nx, Ny):
    <span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assert_small_error</span>(u, x, xv, y, yv, t, n):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Assert small error for iterative methods.&quot;&quot;&quot;</span>
        u_e <span style="color: #666666">=</span> u_exact(xv, yv, t[n])
        diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u <span style="color: #666666">-</span> u_e)<span style="color: #666666">.</span>max()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;diff=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, step </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, time=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (diff, n, t[n])
        <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, msg

    <span style="color: #008000; font-weight: bold">for</span> version <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;scalar&#39;</span>, <span style="color: #BA2121">&#39;vectorized&#39;</span>:
        <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>:
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;testing Jacobi, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> version, theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
                  (version, theta)
            t, cpu <span style="color: #666666">=</span> solver_Jacobi(
                I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, Lx<span style="color: #666666">=</span>Lx, Ly<span style="color: #666666">=</span>Ly, Nx<span style="color: #666666">=</span>Nx, Ny<span style="color: #666666">=</span>Ny,
                dt<span style="color: #666666">=</span>dt, T<span style="color: #666666">=</span>T, theta<span style="color: #666666">=</span>theta,
                U_0x<span style="color: #666666">=0</span>, U_0y<span style="color: #666666">=0</span>, U_Lx<span style="color: #666666">=0</span>, U_Ly<span style="color: #666666">=0</span>,
                user_action<span style="color: #666666">=</span>assert_small_error,
                version<span style="color: #666666">=</span>version, iteration<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Jacobi&#39;</span>,
                omega<span style="color: #666666">=1.0</span>, max_iter<span style="color: #666666">=100</span>, tol<span style="color: #666666">=1E-5</span>)
</pre></div>
<p>
Even for a very coarse \( 4\times 4 \) mesh, the Jacobi method requires
26 iterations to reach a tolerance of \( 10^{-5} \),
which is quite many iterations, given that there are only 25 unknowns.

<h2 id="diffu:2D:Jacobi:impl:hill">Test problem: diffusion of a sine hill</h2>

<p>
It can be shown that

$$
\begin{equation}
\uex = Ae^{-\dfc\pi^2(L_x^{-2} + L_y^{-2})t}
\sin\left(\frac{\pi}{L_x}x\right)\sin\left(\frac{\pi}{L_y}y\right),
\tag{108}
\end{equation}
$$

is a solution of the 2D homogeneous diffusion equation
\( u_t = \dfc(u_{xx}+u_{yy}) \) in
a rectangle \( [0,L_x]\times [0,L_y] \), for any value of the amplitude \( A \).
This solution vanishes at the boundaries,
and the initial condition is the product of two sines.
We may choose \( A=1 \) for simplicity.

<p>
It is difficult to know if our solver based on the Jacobi method works
properly since we are faced with two sources of errors: one from the
discretization, \( E_\Delta \), and one from the iterative Jacobi method,
\( E_i \). The total error in the computed \( u \) can be represented as

$$ E_u = E_\Delta + E_i\tp$$

One error measure is to look at the maximum value, which is obtained for
the midpoint \( x=L_x/2 \) and \( y=L_x/2 \). This midpoint is represented in
the discrete <code>u</code> if \( N_x \) and \( N_y \) are even numbers. We can then
compute \( E_u \) as \( E_u = |\max \uex - \max u| \), when we know an exact
solution \( \uex \) of the problem.

<p>
What about \( E_\Delta \)? If we use the maximum value as a measure of the
error, we have in fact analytical insight into the approximation error
in this particular problem. According to the section <a href="#diffu:2D:analysis">Analysis of the 2D diffusion equation</a>, the exact solution
<a href="#mjx-eqn-108">(108)</a> of the PDE problem is also an
exact solution of the discrete equations, except that the damping
factor in time is different. More precisely,
<a href="#mjx-eqn-66">(66)</a> and
<a href="#mjx-eqn-67">(67)</a> are solutions of the discrete
problem for \( \theta=1 \) (Backward Euler) and \( \theta=\half \)
(Crank-Nicolson), respectively.  The factors raised to the power \( n \)
is the numerical amplitude, and the errors in these factors become

$$
\begin{align*}
E_\Delta &= e^{-\dfc k^2t} - \left(
\frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
\right)^n,\quad \theta=\half,\\ 
E_\Delta &= e^{-\dfc k^2t} -
(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n},\quad\theta=1\tp
\end{align*}
$$

We are now in a position to compute \( E_i \) numerically. That is, we can
compute the error due to iterative solution of the linear system and
see if it corresponds to the convergence tolerance used in the method.
Note that the convergence is based on measuring the difference in
two consecutive approximations, which is not exactly the error
due to the iteration, but it is a kind of measure, and it should
have about the same size as \( E_i \).

<p>
The function <code>demo_classic_iterative</code> in <a href="http://tinyurl.com/nu656p2/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a> implements the idea above (also for the
methods in the section <a href="#diffu:2D:SOR">The Gauss-Seidel and SOR methods</a>). The value of \( E_i \) is in
particular printed at each time level. By changing the tolerance in
the convergence criterion of the Jacobi method, we can see that \( E_i \)
is of the same order of magnitude as the prescribed tolerance in the
Jacobi method.  For example: \( E_\Delta\sim 10^{-2} \) with \( N_x=N_y=10 \)
and \( \theta=\half \), as long as \( \max u \) has some significant size
(\( \max u > 0.02 \)). An appropriate value of the tolerance is then
\( 10^{-3} \), such that the error in the Jacobi method does not become
bigger than the discretization error. In that case, \( E_i \) is around
\( 5\cdot 10^{-3} \).  The corresponding number of Jacobi iterations (with
\( \omega=1 \)) varies from 31 to 12 during the time simulation (for \( \max
u > 0.02 \)). Changing the tolerance to \( 10^{-5} \) causes many more
iterations (61 to 42) without giving any contribution to the overall
accuracy, because the total error is dominated by \( E_\Delta \).

<p>
Also, with an \( N_x=N_y=20 \), the spatial accuracy increases and many
more iterations are needed (143 to 45), but the dominating error is
from the time discretization. However, with such a finer spatial mesh,
a higher tolerance in the convergence criterion \( 10^{-4} \) is needed to
keep \( E_i\sim 10^{-3} \).  More experiments show the disadvantage of the
very simple Jacobi iteration method: the number of iterations
increases with the number of unknowns, keeping the tolerance fixed,
but the tolerance should also be lowered to avoid the iteration error
to dominate the total error. A small adjustment of the Jacobi method,
as described in the section <a href="#diffu:2D:SOR">The Gauss-Seidel and SOR methods</a>, provides a better method.

<h2 id="diffu:2D:Jacobi_vs_FE">The relaxed Jacobi method and its relation to the Forward Euler method</h2>

<p>
We shall now show that solving the Poisson equation \( -\dfc\nabla^2 u =
f \) by the Jacobi iterative method is in fact equivalent to using a
Forward Euler scheme on \( u_t = \dfc\nabla^2 u + f \) and letting
\( t\rightarrow\infty \).

<p>
A Forward Euler discretization of the 2D diffusion equation,

$$ \lbrack D_t^+ u = \dfc (D_xD_x u + D_yD_y u) + f\rbrack^n_{i,j},$$

can be written out as

$$ u_{i,j}^{n+1} = u_{i,j}^n + \frac{\Delta t}{\dfc h^2}
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),$$

where \( h=\Delta x = \Delta y \) has been introduced for simplicity. The
scheme can be reordered as

$$ u_{i,j}^{n+1} = \left(1 - \omega\right) u_{i,j}^n
+ \frac{1}{4}\omega
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),$$

with

$$ \omega = 4\frac{\Delta t}{\dfc h^2},$$

but this latter form is nothing but the relaxed Jacobi method applied to

$$ [D_xD_x u + D_yD_y u = -f]^n_{i,j}\tp$$

<p>
From the equivalence above we know a couple of things about the Jacobi
method for solving \( -\nabla^2 u = f \):

<ol>
<li> The method is unstable if \( \omega > 1 \) (since the Forward Euler method
   is then unstable).</li>
<li> The convergence is really slow as the iteration index increases (coming from the fact that
   the Forward Euler scheme requires many small time steps to reach the stationary solution).</li>
</ol>

These observations are quite disappointing: if we already have a
time-dependent diffusion problem and want to take larger time steps by
an implicit time discretization method, we will with the Jacobi method
end up with something close to a slow Forward Euler simulation of the
original problem at each time level.  Nevertheless, the are two
reasons for why the Jacobi method remains a fundamental building block
for solving linear systems arising from PDEs: 1) a couple of
iterations remove large parts of the error and this is effectively
used in the very efficient class of multigrid methods; and 2) the idea
of the Jacobi method can be developed into more efficient methods,
especially the SOR method, which is treated next.

<h2 id="diffu:2D:SOR">The Gauss-Seidel and SOR methods</h2>

<p>
If we update the mesh points according to the Jacobi method
<a href="#mjx-eqn-98">(98)</a> for a Backward Euler discretization with a
loop over \( i=1,\ldots,N_x-1 \) and \( j=1,\ldots,N_y-1 \), we realize that
when \( u^{n+1,r+1}_{i,j} \) is computed, \( u^{n+1,r+1}_{i-1,j} \) and
\( u^{n+1,r+1}_{i,j-1} \) are already computed, so these new values can be
used rather than \( u^{n+1,r}_{i-1,j} \) and \( u^{n+1,r}_{i,j-1} \)
(respectively) in the formula for \( u^{n+1,r+1}_{i,j} \).  This idea
gives rise to the <em>Gauss-Seidel</em> iteration method, which
mathematically is just a small adjustment of <a href="#mjx-eqn-98">(98)</a>:

$$
\begin{align}
& u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}((\nonumber\\ &\qquad
F_x
(u^{n+1,r+1}_{i-1,j} + u^{n+1,r}_{i+1,j}) +
F_y
(u^{n+1,r+1}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
u^n_{i,j} + \Delta t f^{n+1}_{i,j})\tp
\tag{109}
\end{align}
$$

Observe that the way we access the mesh points in the formula
<a href="#mjx-eqn-109">(109)</a> is important: points with \( i-1 \) must be
computed before points with \( i \), and points with \( j-1 \) must be
computed before points with \( j \). Any sequence of mesh points can be
used in the Gauss-Seidel method, but the particular math formula must
distinguish between already visited points in the current iteration
and the points not yet visited.

<p>
The idea of relaxation <a href="#mjx-eqn-101">(101)</a> can equally
well be applied to the Gauss-Seidel method. Actually, the Gauss-Seidel
method with an arbitrary \( 0 < \omega\leq 2 \) has its own name: the
<em>Successive Over-Relaxation</em> method, abbreviated as SOR.

<p>
The SOR method for a \( \theta \) rule discretization, with the
shortened \( u \) and \( u^{-} \) notation, can be written

$$
\begin{align}
& u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u_{i-1,j} + u^{-}_{i+1,j}) +
F_y
(u_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\\ 
&\qquad (1-\theta)(
F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1}))),
\tag{110}\\ 
u_{i,j} &= \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}
\tag{111}
\end{align}
$$

The sequence of mesh points in <a href="#mjx-eqn-110">(110)</a> is
\( i=1,\ldots,N_x-1 \), \( j=1,\ldots,N_y-1 \) (but whether \( i \) runs faster
or slower than \( j \) does not matter).

<h2 id="diffu:2D:SOR:impl:scalar">Scalar implementation of the SOR method</h2>

<p>
Since the Jacobi and Gauss-Seidel methods with relaxation
are so similar, we can easily make a common code for the two:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Solve linear system by Jacobi/SOR iteration at time level n+1</span>
    u_[:,:] <span style="color: #666666">=</span> u_n  <span style="color: #408080; font-style: italic"># Start value</span>
    converged <span style="color: #666666">=</span> <span style="color: #008000">False</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #AA22FF; font-weight: bold">not</span> converged:
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            <span style="color: #008000; font-weight: bold">if</span> iteration <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Jacobi&#39;</span>:
                u__ <span style="color: #666666">=</span> u_
            <span style="color: #008000; font-weight: bold">elif</span> iteration <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;SOR&#39;</span>:
                u__ <span style="color: #666666">=</span> u
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   u[i,j] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                i <span style="color: #666666">=</span> Nx;  u[i,j] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                    u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
                        Fx<span style="color: #666666">*</span>(u_[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u__[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                        Fy<span style="color: #666666">*</span>(u_[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u__[i,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
                    u_n[i,j] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
                      Fx<span style="color: #666666">*</span>(
                    u_n[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                      Fy<span style="color: #666666">*</span>(
                    u_n[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[i,j] <span style="color: #666666">+</span> u_n[i,j<span style="color: #666666">-1</span>]))\ 
                      <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt))
                    u[i,j] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[i,j]
                j <span style="color: #666666">=</span> Ny
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                    u[i,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># boundary</span>
        r <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        converged <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u<span style="color: #666666">-</span>u_)<span style="color: #666666">.</span>max() <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> r <span style="color: #666666">&gt;=</span> max_iter
        u_[:,:] <span style="color: #666666">=</span> u

    u_n, u <span style="color: #666666">=</span> u, u_n  <span style="color: #408080; font-style: italic"># Get ready for next iteration</span>
</pre></div>
<p>
The idea here is to introduce <code>u__</code> to be used for already computed
values (<code>u</code>) in the Gauss-Seidel/SOR version of the implementation, or
just values from the previous iteration (<code>u_</code>) in case of the Jacobi method.

<h2 id="diffu:2D:SOR:impl:vectorized">Vectorized implementation of the SOR method</h2>

<p>
Vectorizing the Gauss-Seidel iteration step turns out to be non-trivial.
The problem is that vectorized operations typically imply
operations on arrays where the sequence in which we visit the elements does
not matter. In particular, this principle makes vectorized code trivial to
parallelize. However, in the Gauss-Seidel algorithm, the sequence in which we
visit the elements in the arrays does matter, and it is well known that
the basic method as explained above cannot be parallelized.
Therefore, also vectorization will require new thinking.

<p>
The strategy for vectorizing (and parallelizing) the Gauss-Seidel
method is to use a special numbering of the mesh points called
red-black numbering: every other point is red or black as in a
checkerboard pattern. This numbering requires \( N_x \) and \( N_y \) to
be even numbers.
Here is an example of a \( 6\times 6 \) mesh:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
<p>
The idea now is to first update all the red points. Each formula for
updating a red point involves only the black neighbors. Thereafter, we
update all the black points, and at each black point, only the
recently computed red points are involved.

<p>
The scalar implementation of the red-black numbered Gauss-Seidel
method is really compact, since we can update values directly in
<code>u</code> (this guarantees that we use the most recently computed
values). Here is the relevant code for the Backward Euler
scheme in time and without a source term:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Update internal points</span>
<span style="color: #008000; font-weight: bold">for</span> sweep <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;red&#39;</span>, <span style="color: #BA2121">&#39;black&#39;</span>:
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ny, <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> sweep <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;red&#39;</span>:
            start <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> j <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">2</span>
        <span style="color: #008000; font-weight: bold">elif</span> sweep <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;black&#39;</span>:
            start <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #008000; font-weight: bold">if</span> j <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(start, Nx, <span style="color: #666666">2</span>):
	    u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(
                     Fx<span style="color: #666666">*</span>(u[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                     Fy<span style="color: #666666">*</span>(u[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u[i,j<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span> u_n[i,j])
</pre></div>
<p>
The vectorized version must be based on slices. Looking at a typical
red-black pattern, e.g.,

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
<p>
we want to update the internal points (marking boundary points with
<code>x</code>):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x b r b r b x
x r b r b r x
x b r b r b x
x r b r b r x
x x x x x x x
</pre></div>
<p>
It is impossible to make one slice that picks out all the internal
red points. Instead, we need two slices. The first involves points
marked with <code>R</code>:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x R b R b R x
x b r b r b x
x R b R b R x
x b r b r b x
x R b R b R x
x x x x x x x
</pre></div>
<p>
This slice is specified as <code>1::2</code> for <code>i</code> and <code>1::2</code> for <code>j</code>, or with
<code>slice</code> objects:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
The second slice involves the red points with <code>R</code>:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x b R b R b x
x r b r b r x
x b R b R b x
x r b r b r x
x x x x x x x
</pre></div>
<p>
The slices are

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
For the black points, the first slice involves the <code>B</code> points:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r B r B r x
x b r b r b x
x r B r B r x
x b r b r b x
x r B r B r x
x x x x x x x
</pre></div>
<p>
with slice objects

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
The second set of black points is shown here:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x B r B r B x
x r b r b r x
x B r B r B x
x r b r b r x
x x x x x x x
</pre></div>
<p>
with slice objects

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
That is, we need four sets of slices. The simplest way of implementing
the algorithm is to make a function with variables for the slices
representing \( i \), \( i-1 \), \( i+1 \), \( j \), \( j-1 \), and \( j+1 \), here called
<code>ic</code> (&quot;i center&quot;), <code>im1</code> (&quot;i minus 1&quot;, <code>ip1</code> (&quot;i plus 1&quot;), <code>jc</code>, <code>jm1</code>,
and <code>jp1</code>, respectively.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">update</span>(u_, u_n, ic, im1, ip1, jc, jm1, jp1):
    <span style="color: #008000; font-weight: bold">return</span> \ 
       <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
           Fx<span style="color: #666666">*</span>(u_[ip1,jc] <span style="color: #666666">+</span> u_[im1,jc]) <span style="color: #666666">+</span>
           Fy<span style="color: #666666">*</span>(u_[ic,jp1] <span style="color: #666666">+</span> u_[ic,jm1])) <span style="color: #666666">+</span>\ 
       u_n[ic,jc] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
         Fx<span style="color: #666666">*</span>(u_n[ip1,jc] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[ic,jc] <span style="color: #666666">+</span> u_n[im1,jc]) <span style="color: #666666">+</span>\ 
         Fy<span style="color: #666666">*</span>(u_n[ic,jp1] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_n[ic,jc] <span style="color: #666666">+</span> u_n[ic,jm1]))<span style="color: #666666">+</span>\ 
         theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[ic,jc] <span style="color: #666666">+</span> \ 
         (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[ic,jc])
</pre></div>
<p>
The formula returned from <code>update</code> is to be compared with
<a href="#mjx-eqn-110">(110)</a>.

<p>
The relaxed Jacobi iteration can be implemented by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">ic  <span style="color: #666666">=</span> jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>)
im1 <span style="color: #666666">=</span> jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>)
ip1 <span style="color: #666666">=</span> jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_, u_n, ic, im1, ip1, jc, jm1, jp1)
u[ic,jc] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new[ic,jc] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[ic,jc]
</pre></div>
<p>
The Gauss-Seidel (or SOR) updates need four different steps.
The <code>ic</code> and <code>jc</code> slices are specified above. For each of these,
we must specify the corresponding <code>im1</code>, <code>ip1</code>, <code>jm1</code>, and <code>jp1</code>
slices. The code below contains the details.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Red points</span>
ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_n, ic, im1, ip1, jc, jm1, jp1)

ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_n, ic, im1, ip1, jc, jm1, jp1)

<span style="color: #408080; font-style: italic"># Black points</span>
ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_n, ic, im1, ip1, jc, jm1, jp1)

ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_n, ic, im1, ip1, jc, jm1, jp1)

<span style="color: #408080; font-style: italic"># Relax</span>
c <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>)
u[c,c] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new[c,c] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[c,c]
</pre></div>
<p>
The function <code>solver_classic_iterative</code> in
<a href="http://tinyurl.com/nu656p2/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>
contains a unified implementation of the relaxed Jacobi and SOR
methods in scalar and vectorized versions using the techniques
explained above.

<h2 id="diffu:2D:direct_vs_iter">Direct versus iterative methods</h2>

<h3 id="___sec86">Direct methods </h3>

<p>
There are two classes of methods for solving linear systems: direct methods
and iterative methods. Direct methods are based on variants of the
Gaussian elimination procedure and will produce an exact solution (in
exact arithmetics) in an a priori known number of steps.
Iterative methods, on the other hand, produce an approximate solution,
and the amount of work for reaching a given accuracy is usually not
known.

<p>
The most common direct method today is to use the <em>LU factorization</em>
procedure to factor the coefficient matrix \( A \) as the product of a
lower-triangular matrix \( L \) (with unit diagonal terms)
and an upper-triangular matrix \( U \):
\( A=LU \). As soon as we have \( L \) and \( U \), a system of equations \( LUc=b \)
is easy to solve because of the triangular nature of \( L \) and \( U \). We
first solve \( Ly=b \) for \( y \) (forward substitution), and
thereafter we find \( c \) from solving \( Uc=y \) (backward
substitution).  When \( A \) is a dense \( N\times N \) matrix, the LU
factorization costs \( \frac{1}{3}N^3 \) arithmetic operations, while the
forward and backward substitution steps each require of
the order \( N^2 \) arithmetic operations.
That is, factorization dominates the costs, while the substitution steps are
cheap.

<p>
Symmetric, positive definite coefficient matrices often arise when
discretizing PDEs. In this case, the LU factorization becomes \( A=LL^T \),
and the associated algorithm is known as <em>Cholesky factorization</em>.
Most linear algebra software offers highly optimized implementations of
LU and Cholesky factorization as well as forward and backward
substitution (<code>scipy.linalg</code> is the relevant Python package).

<p>
Finite difference discretizations lead to sparse coefficient matrices.
An extreme case arose in the section <a href="#diffu:pde1:BE">Backward Euler scheme</a> where \( A \) was
tridiagonal. For a tridiagonal matrix, the amount of arithmetic
operations in the LU and Cholesky factorization algorithms is just of
the order \( N \), not \( N^3 \). Tridiagonal matrices are special cases of
<em>banded matrices</em>, where the matrices contain just a set of diagonal
bands.  Finite difference methods on regularly numbered rectangular
and box-shaped meshes give rise to such banded matrices, with 5 bands
in 2D and 7 in 3D for diffusion problems.  Gaussian elimination only
needs to work within the bands, leading to much more efficient
algorithms.

<p>
If \( A_{i,j}=0 \) for \( j> i+p \) and \( j < i-p \), \( p \) is the <em>half-bandwidth</em>
of the matrix. We have in our 2D problem \( p=N_x+2 \), while in 3D,
\( p=(N_x+1)(N_y+1)+2 \). The cost of Gaussian elimination is then
\( \Oof{Np^2} \), so with \( p\ll N \), we see that banded matrices are much
more efficient to compute with. By reordering the unknowns in clever
ways, one can reduce the work of Gaussian elimination
further. Fortunately, the Python programmer has access to such
algorithms through the <code>scipy.sparse.linalg</code> package.

<p>
Although a direct method is an exact algorithm, rounding errors
may in practice accumulate and pollute the solution. The effect
grows with the size of the linear system, so both for accuracy and
efficiency, iterative methods are better suited than direct methods
for solving really large linear systems.

<h3 id="___sec87">Iterative methods </h3>

<p>
The Jacobi and SOR iterative methods belong to a class of iterative methods
where the idea is to solve \( Au=b \) by splitting A into two parts, \( A=M-N \),
such that solving systems \( Mu=c \) is easy and efficient. With the splitting,
we get a system

$$ Mu = Nu + b,$$

which suggests an iterative method

$$ Mu^{r+1} = Nu^{r} + b,\quad r=0,1,2,\ldots,$$

where \( u^{r+1} \) is a new approximation to \( u \) in the \( r+1 \)-th iteration. To
initiate the iteration, we need a start vector \( u^0 \).

<p>
The Jacobi and SOR methods are based on splitting \( A \) into a lower
tridiagonal part \( L \), the diagonal \( D \), and an upper tridiagonal part \( U \),
such that \( A=L+D+U \). The Jacobi method corresponds to \( M=D \) and \( N=-L-U \).
The Gauss-Seidel method employs \( M=L+D \) and \( N=-U \), while the SOR
method corresponds to

$$ M= \frac{1}{\omega}D + L,\quad N = \frac{1-\omega}{\omega}D - U\tp$$

The relaxed Jacobi method has similar expressions:

$$ M = \frac{1}{\omega}D,\quad N = \frac{1-\omega}{\omega}D - L - U\tp$$

<p>
With the matrix forms of the Jacobi and SOR methods as written above,
we could in an implementation alternatively fill the matrix \( A \) with
entries and call general implementations of the Jacobi or SOR methods
that work on a system \( Au=b \). However, this is almost never done since
forming the matrix \( A \) requires quite some code and storing \( A \) in the
computer's memory is unnecessary. It is much easier to just apply the
Jacobi and SOR ideas to the finite difference stencils directly in an
implementation, as we have shown in detail.

<p>
Nevertheless, the matrix formulation of the Jacobi and SOR methods have
been important for analyzing their convergence behavior. One can show that
the error \( u^r-u \) fulfills \( u^r-u = G^r(u^0-u) \), where \( G=M^{-1}N \)
and \( G^k \) is a matrix exponential. For the method to converge,
\( \lim_{r\rightarrow\infty}||G^r||=0 \) is a necessary and sufficient condition.
This implies that the <em>spectral radius</em> of \( G \) must be less than one.
Since \( G \) is directly related to the finite difference scheme for the
underlying PDE problem, one can in principle compute the spectral radius.
For a given PDE problem, however, this is not a practical strategy, since it
is very difficult to develop useful formulas.
Analysis of model problems, usually
related to the Poisson equation,
reveals some trends of interest: the convergence rate of the Jacobi
method goes like \( h^2 \), while that of SOR with an optimal \( \omega \) goes
like \( h \), where \( h \) is the spatial spacing: \( h=\Delta x=\Delta y \).
That is, the efficiency of the Jacobi method quickly deteriorates with
the increasing mesh resolution, and SOR is much to be preferred
(even if the optimal
\( \omega \) remains an open question). We refer to
Chapter 4 of <a href="._diffu-sol002.html#Saad_2003">[6]</a> for more information on the convergence theory.
One important result is that if \( A \) is symmetric and positive definite,
then SOR will converge for any \( 0 < \omega < 2 \).

<p>
The optimal \( \omega \) parameter can be theoretically established for
a Poisson problem as

$$
\begin{equation}
\omega_{o} = \frac{2}{1 + \sqrt{1-\varrho^2}},\quad \varrho = \frac{\cos(\pi/N_x) + (\Delta x/\Delta y)^2\cos(\pi/N_y)}{1 + (\Delta x/\Delta y)^2}\tp
\tag{112}
\end{equation}
$$

This formula can be used as a guide also in other problems.

<p>
The Jacobi and the SOR methods have their great advantage of being
trivial to implement, so they are obviously popular of this reason.
However, the slow convergence of these methods limits the popularity to fairly
small linear systems (i.e., coarse meshes). As soon as the matrix size
grows, one is better off with more sophisticated iterative methods
like the preconditioned Conjugate gradient method, which we now turn to.

<p>
Finally, we mention that there is a variant of the SOR method, called the
<em>Symmetric Successive Over-relaxation</em> method, known as SSOR, where
one runs a standard SOR sweep through the mesh points and then a
new sweep while visiting the points in reverse order.

<h2 id="diffu:2D:CG">The Conjugate gradient method</h2>

<p>
There is no simple intuitive derivation of the Conjugate gradient
method, so we refer to the many excellent expositions in the
literature for the idea of the method and how the algorithm is
derived. In particular, we recommend the books
<a href="._diffu-sol002.html#Templates_LA">[7]</a> <a href="._diffu-sol002.html#Axelsson_1996">[8]</a> <a href="._diffu-sol002.html#Saad_2003">[6]</a> <a href="._diffu-sol002.html#Greif_Ascher_2011">[9]</a>.
A brief overview is
provided in the <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method" target="_self">Wikipedia article</a>. Here, we
just state the pros and cons of the method from a user's perspective
and how we utilize it in code.

<p>
The original Conjugate gradient method is limited to linear systems \( Au=b \),
where \( A \) is a symmetric and positive definite matrix. There are, however,
extensions of the method to non-symmetric matrices.
<!-- , so when we use the -->
<!-- term <em>Conjugate gradient method</em> hereafter, we usually mean the family of -->
<!-- related methods that can be applied -->
<!-- to most matrix systems arising from discretizing -->
<!-- PDEs. When we need to distinuish between methods for -->
<!-- the symmetric and non-symmetric -->
<!-- cases, we use the terms <em>original Conjugate gradient method</em> and -->
<!-- <em>conjugate gradient-like methods</em>, respectively. -->

<p>
A major advantage of all conjugate gradient methods is that the matrix
\( A \) is only used in matrix-vector products, so we do not need form and
store \( A \) if we can provide code for computing a matrix-vector product
\( Au \).  Another important feature is that the algorithm is very easy to
vectorize and parallelize.  The primary downside of the method is that
it converges slowly unless one has an effective <em>preconditioner</em>
for the system. That is, instead of solving \( Au=b \), we try to solve
\( M^{-1}Au=M^{-1}b \) in the hope that the method works better for this
<em>preconditioned</em> system. The matrix \( M \) is the <em>preconditioner</em> or
preconditioning matrix.  Now we need to perform matrix-vector products
\( y = M^{-1}Au \), which is done in two steps: first the matrix-vector
product \( v=Au \) is carried out and then the system \( My=v \) must be
solved.  Therefore, \( M \) must be cheap to compute and systems \( My=v \)
must be cheap to solve.

<p>
A perfect preconditioner is \( M=A \), but in each iteration in the
Conjugate gradient method one then has so solve a system with \( A \) as
coefficient matrix! A key idea is to let \( M \) be some kind of <em>cheap
approximation</em> to \( A \).  The simplest preconditioner is to set \( M=D \),
where \( D \) is the diagonal of \( A \). This choice means running one Jacobi
iteration as preconditioner. <a href="#diffu:exer:splitting_prec">Exercise 8: Splitting methods and preconditioning</a>
shows that the Jacobi and SOR methods can also be viewed as
preconditioners.

<p>
Constructing good preconditioners is a scientific field on its
own. Here we shall treat the topic just very briefly. For a user
having access to the <code>scipy.sparse.linalg</code> library, there are
Conjugate gradient methods and preconditioners readily available:

<ul>
 <li> For positive definite, symmetric systems: <code>cg</code> (the Conjugate gradient method)</li>
 <li> For symmetric systems: <code>minres</code> (Minimum residual method)</li>
 <li> For non-symmetric systems:</li>

<ul>
  <li> <code>gmres</code> (GMRES: Generalized minimum residual method)</li>
  <li> <code>bicg</code> (BiConjugate gradient method)</li>
  <li> <code>bicgstab</code> (Stabilized BiConjugate gradient method)</li>
  <li> <code>cgs</code> (Conjugate gradient squared method)</li>
  <li> <code>qmr</code> (Quasi-minimal residual iteration)</li>
</ul>

 <li> Preconditioner: <code>spilu</code> (Sparse, incomplete LU factorization)</li>
</ul>

The ILU preconditioner is an attractive all-round type of
preconditioner that is suitable for most problems on serial
computers. A more efficient preconditioner is the multigrid method,
and algebraic multigrid is also an all-round choice as
preconditioner. The Python package <a href="https://github.com/pyamg/pyamg" target="_self">PyAMG</a> offers efficient implementations of
the algebraic multigrid method, to be used both as a preconditioner
and as a stand-alone iterative method.

<p>
The matrix arising from implicit time discretization methods applied to the
diffusion equation is symmetric and positive definite. Thus, we can use
the Conjugate gradient method (<code>cg</code>), typically in combination with an
ILU preconditioner. The code is very similar to the one we created
when solving the linear system by sparse Gaussian elimination, the
main difference is that we now allow for calling up the Conjugate
gradient function as an alternative solver.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_sparse</span>(
    I, a, f, Lx, Ly, Nx, Ny, dt, T, theta<span style="color: #666666">=0.5</span>,
    U_0x<span style="color: #666666">=0</span>, U_0y<span style="color: #666666">=0</span>, U_Lx<span style="color: #666666">=0</span>, U_Ly<span style="color: #666666">=0</span>, user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>,
    method<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, CG_prec<span style="color: #666666">=</span><span style="color: #BA2121">&#39;ILU&#39;</span>, CG_tol<span style="color: #666666">=1E-5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Full solver for the model problem using the theta-rule</span>
<span style="color: #BA2121; font-style: italic">    difference approximation in time. Sparse matrix with</span>
<span style="color: #BA2121; font-style: italic">    dedicated Gaussian elimination algorithm (method=&#39;direct&#39;)</span>
<span style="color: #BA2121; font-style: italic">    or ILU preconditioned Conjugate Gradients (method=&#39;CG&#39; with</span>
<span style="color: #BA2121; font-style: italic">    tolerance CG_tol and preconditioner CG_prec (&#39;ILU&#39; or None)).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Set up data structures as shown before</span>

    <span style="color: #408080; font-style: italic"># Precompute sparse matrix</span>
    <span style="color: #666666">...</span>

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
        diagonals<span style="color: #666666">=</span>[main, lower, upper, lower2, upper2],
        offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-</span>lower_offset, lower_offset,
                 <span style="color: #666666">-</span>lower2_offset, lower2_offset],
        shape<span style="color: #666666">=</span>(N, N), format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>)

    <span style="color: #008000; font-weight: bold">if</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;CG&#39;</span>:
        <span style="color: #008000; font-weight: bold">if</span> CG_prec <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;ILU&#39;</span>:
            <span style="color: #408080; font-style: italic"># Find ILU preconditioner (constant in time)</span>
            A_ilu <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spilu(A)  <span style="color: #408080; font-style: italic"># SuperLU defaults</span>
            M <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>LinearOperator(
                shape<span style="color: #666666">=</span>(N, N), matvec<span style="color: #666666">=</span>A_ilu<span style="color: #666666">.</span>solve)
        <span style="color: #008000; font-weight: bold">else</span>:
            M <span style="color: #666666">=</span> <span style="color: #008000">None</span>
        CG_iter <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># No of CG iterations at time level n</span>

    <span style="color: #408080; font-style: italic"># Time loop</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
        <span style="color: #408080; font-style: italic"># Compute b, vectorized version</span>

        <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
        <span style="color: #008000; font-weight: bold">if</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;direct&#39;</span>:
            c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
        <span style="color: #008000; font-weight: bold">elif</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;CG&#39;</span>:
            x0 <span style="color: #666666">=</span> u_n<span style="color: #666666">.</span>T<span style="color: #666666">.</span>reshape(N)  <span style="color: #408080; font-style: italic"># Start vector is u_n</span>
            CG_iter<span style="color: #666666">.</span>append(<span style="color: #666666">0</span>)

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CG_callback</span>(c_k):
                <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Trick to count the no of iterations in CG.&quot;&quot;&quot;</span>
                CG_iter[<span style="color: #666666">-1</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

            c, info <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>cg(
                A, b, x0<span style="color: #666666">=</span>x0, tol<span style="color: #666666">=</span>CG_tol, maxiter<span style="color: #666666">=</span>N, M<span style="color: #666666">=</span>M,
                callback<span style="color: #666666">=</span>CG_callback)

        <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
        <span style="color: #408080; font-style: italic"># Update u_n before next step</span>
        u_n, u <span style="color: #666666">=</span> u, u_n
</pre></div>
<p>
The number of iterations in the Conjugate gradient method is of interest,
but is unfortunately not available from the <code>cg</code> function. Therefore,
we perform a trick: in each iteration a user function <code>CG_callback</code>
is called where we accumulate the number of iterations in a list
<code>CG_iter</code>.

<h2 id="___sec89">What is the recommended method for solving linear systems? </h2>

<p>
There is no clear answer to this question. If you have enough memory
and computing time available, direct methods such as <code>spsolve</code> are
to be preferred since they are easy to use and finds almost an exact
solution. However, in larger 2D and in 3D problems, direct methods
usually run too slowly or require too much memory, so one is forced
to use iterative methods. The fastest and most reliable methods are
in the Conjugate Gradient family, but these require suitable
preconditioners. ILU is an all-round preconditioner, but it is not
suited for parallel computing. The Jacobi and SOR iterative methods
are easy to implement, and popular for that reason, but run slowly. Jacobi
iteration is not an option in real problems, but SOR may be.
<!-- As we have showed, Jacobi is equivalent to running a Forward Euler scheme -->
<!-- until the stationary state is reached -->

<h1 id="diffu:randomwalk">Random walk</h1>

<p>
Models leading to diffusion equations, see the section <a href="#diffu:app">Applications</a>, are
usually based on reasoning with <em>averaged</em> physical quantities such as
concentration, temperature, and velocity.  The underlying physical
processes involve complicated microscopic movement of atoms and
molecules, but an average of a large number of molecules is performed
in a small volume before the modeling starts, and the averaged
quantity inside this volume is assigned as a point value at the
centroid of the volume. This means that concentration, temperature,
and velocity at a space-time point represent averages around the
point in a small time interval and small spatial volume.

<p>
Random walk is a principally different kind of modeling procedure
compared to the reasoning behind partial differential equations.  The
idea in random walk is to have a large number of &quot;particles&quot; that
undergo random movements. Averaging can then be used afterwards to
compute macroscopic quantities like concentration. The &quot;particles&quot;
and their random movement represent a very simplified microscopic
behavior of molecules, much simpler and computationally much more
efficient than direct <a href="https://en.wikipedia.org/wiki/Molecular_dynamics" target="_self">molecular simulation</a>, yet the random
walk model has been very powerful to describe a wide range of
phenomena, including heat conduction, quantum mechanics, polymer
chains, population genetics, neuroscience, hazard games, and pricing
of financial instruments.

<p>
It can be shown that random walk, when averaged, produces models that
are mathematically equivalent to diffusion equations. This is the
primary reason why we treat random walk in this chapter: two very
different algorithms (finite difference stencils and random walk)
solve the same type of problems. The simplicity of the random walk
algorithm makes it particularly attractive for solving diffusion
equations on massively parallel computers.
The exposition here is as simple as possible, and good thorough
derivation of the models is provided by Hjorth-Jensen <a href="._diffu-sol002.html#hjorten">[10]</a>.

<h2 id="diffu:randomwalk:1D">Random walk in 1D</h2>

<p>
Imagine that we have some particles that perform random moves, either
to the right or to the left. We may flip a coin to decide the movement
of each particle, say head implies movement to the right and tail
means movement to the left. Each move is one unit length.  Physicists
use the term <em>random walk</em> for this type of movement.
The movement is also known as <a href="https://en.wikipedia.org/wiki/The_Drunkard%27s_Walk" target="_self">drunkard's walk</a>.
You may try this yourself: flip the coin and make one step to the left
or right, and repeat the process.

<p>
We introduce the symbol \( N \) for the number of steps in a random walk.
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">16</a> shows four different
random walks with \( N=200 \).

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:ensemble"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 16:  Ensemble of 4 random walks, each with 200 steps.  <!-- caption label: diffu:randomwalk:1D:fig:ensemble --> </p></center>
<p><img src="fig-diffu/rw1D_ensemble4.png" align="bottom" width=800></p>
</center>

<h2 id="diffu:randomwalk:1D:EVar">Statistical considerations</h2>

<p>
Let \( S_k \) be the stochastic variable representing a step to the left
or to the right in step number \( k \). We have that \( S_k=-1 \) with
probability \( p \) and \( S_k=1 \) with probability \( q=1-p \). The variable
\( S_k \) is known as a <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution" target="_self">Bernoulli variable</a>. The
expectation of \( S_k \) is

$$ \E{S_k} = p\cdot (-1) + q\cdot 1 = 1 - 2p,$$

and the variance is

$$ \Var{S_k} = \E{S_k^2} - \E{S_k}^2 = 1 - (1-2p)^2 = 4p(1-p)\tp$$

<p>
The position after \( k \) steps is another stochastic variable

$$ \bar X_k = \sum_{i=0}^{k-1} S_i\tp$$

The expected position is

$$ \E{\bar X_k} =
\E{\sum_{i=0}^{k-1} S_i} = \sum_{i=0}^{k-1} \E{S_i}= k(1-2p)\tp$$

All the \( S_k \) variables are independent. The variance therefore becomes

$$ \Var{\bar X_k} = \Var{\sum_{i=0}^{k-1} S_i} = \sum_{i=0}^{k-1} \Var{S_i}=
k4p(1-p)\tp$$

We see that \( \Var{\bar X_k} \) is proportional with the number of steps \( k \).
For the very important case \( p=q=\half \), \( \E{\bar X_k}=0 \) and
\( \Var{\bar X_k}=k \).

<p>
How can we estimate \( \E{\bar X_k}=0 \) and \( \Var{\bar X_k}=N \)?
We must have many random walks of the type in
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">16</a>. For a given \( k \), say \( k=100 \),
we find all the values of \( \bar X_k \), name them \( \bar x_{0,k} \), \( \bar x_{1,k} \),
\( \bar x_{2,k} \), and so on. The empirical estimate of \( \E{\bar X_k} \) is the
average,

$$ \E{\bar X_k} \approx = \frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k},$$

while an empirical estimate of \( \Var{\bar X_k} \) is

$$ \Var{\bar X_k} \approx \frac{1}{W}\sum_{j=0}^{W-1} (\bar x_{j,k})^2 -
\left(\frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k}\right)^2\tp$$

That is, we take the statistics for a given \( K \) across the ensemble
of random walks (&quot;vertically&quot; in
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">16</a>). The key quantities
to record are \( \sum_i \bar x_{i,k} \) and \( \sum_i \bar x_{i,k}^2 \).

<h2 id="diffu:randomwalk:1D:code1">Playing around with some code</h2>

<h3 id="___sec94">Scalar code </h3>

<p>
Python has a <code>random</code> module for drawing random numbers, and this
module has a function <code>uniform(a, b)</code> for drawing a uniformly
distributed random number in the interval \( [a,b) \).  If an event
happens with probability \( p \), we can simulate this on the computer by
drawing a random number \( r \) in \( [0,1) \), because then \( r\leq p \) with
probability \( p \) and \( r>p \) with probability \( 1-p \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span>
r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
<span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
    <span style="color: #408080; font-style: italic"># Event happens</span>
<span style="color: #008000; font-weight: bold">else</span>:
    <span style="color: #408080; font-style: italic"># Event does not happen</span>
</pre></div>
<p>
A random walk with \( N \) steps, starting at \( x_0 \), where we move
to the left with probability \( p \) and to the right
with probability \( 1-p \) can now be implemented by

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk1D</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;1D random walk with 1 particle.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> x0
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">-1</span>):
        r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
            current_pos <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            current_pos <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        position[k<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>

<h3 id="___sec95">Vectorized code </h3>

<p>
Since \( N \) is supposed to be large and we want to repeat the process for
many particles, we should speed up the code as much as possible.
Vectorization is the obvious technique here: we draw all the random
numbers at once with aid of <code>numpy</code>, and then we formulate vector
operations to get rid of the loop over the steps (<code>k</code>).
The <code>numpy.random</code> module has vectorized versions of the functions in
Python's built-in <code>random</code> module. For example, <code>numpy.random.uniform(a, b, N)</code>
returns <code>N</code> random numbers uniformly distributed between <code>a</code> (included)
and <code>b</code> (not included).

<p>
We can then make an array of all the steps in a random walk: if
the random number is less than or equal to \( p \), the step is \( -1 \),
otherwise the step is \( 1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The value of <code>position[k]</code> is the sum of all steps up to step <code>k</code>.
Such sums are often needed in vectorized algorithms and therefore
available by the <code>numpy.cumsum</code> function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>,<span style="color: #666666">6</span>]))
array([ <span style="color: #666666">1</span>,  <span style="color: #666666">4</span>,  <span style="color: #666666">8</span>, <span style="color: #666666">14</span>])
</pre></div>
<p>
The resulting array in this demo has elements \( 1 \), \( 1+3=4 \), \( 1+3+4=8 \),
and \( 1+3+4+6=14 \).

<p>
We can now vectorize the <code>random_walk1D</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk1D_vec</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walk1D.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
    position[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps)
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
This code runs about 10 times faster than the scalar version.
With a parallel <code>numpy</code> library, the code can also automatically take
advantage of hardware for parallel computing because each of the four
array operations can be trivially parallelized.

<h3 id="___sec96">Fixing the random sequence </h3>

<p>
During software development with random numbers it is advantageous to
always generate the same sequence of random numbers, as this may help
debugging processes. To fix the sequence, we set a <em>seed</em> of the random
number generator to some chosen integer, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
</pre></div>
<p>
Calls to <code>random_walk1D_vec</code> give positions of the particle as
depicted in Figure <a href="#diffu:randomwalk:1D:code1:fig1">17</a>. The particle starts
at the origin and moves with \( p=\half \). Since the seed is the same,
the plot to the left is just a magnification of the first 1,000 steps in
the plot to the right.
<!-- demo_random_walk1D produced the plots -->

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:code1:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 17:  1,000 (left) and 50,000 (right) steps of a random walk.  <!-- caption label: diffu:randomwalk:1D:code1:fig1 --> </p></center>
<p><img src="fig-diffu/rw1D_1sample.png" align="bottom" width=800></p>
</center>

<h3 id="___sec97">Verification </h3>

<p>
When we have a scalar and a vectorized code, it is always a good idea to
develop a unit test for checking that they produce the same result.
A problem in the present context is that the two versions apply to different
random number generators. For a test to be meaningful, we need to fix
the seed and use the same generator. This means that the scalar version
must either use <code>np.random</code> or have this as an option. An option
is the most flexible choice:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">import random

def random_walk1D(x0, N, p, random=random):
    ...
    r = random.uniform(0, 1)
</pre></div>
<p>
Using <code>random=np.random</code>, the <code>r</code> variable gets computed
by <code>np.random.uniform</code>, and the sequence of random numbers will be
the same as in the vectorized version that employs the same generator
(given that the seed is also the same). A proper test function may be
to check that the positions in the walk are the same in the scalar and
vectorized implementations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_random_walk1D</span>():
    <span style="color: #408080; font-style: italic"># For fixed seed, check that scalar and vectorized versions</span>
    <span style="color: #408080; font-style: italic"># produce the same result</span>
    x0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  N <span style="color: #666666">=</span> <span style="color: #666666">4</span>;  p <span style="color: #666666">=</span> <span style="color: #666666">0.6</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    scalar_computed <span style="color: #666666">=</span> random_walk1D(x0, N, p, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized_computed <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (scalar_computed <span style="color: #666666">==</span> vectorized_computed)<span style="color: #666666">.</span>all()
</pre></div>
<p>
Note that we employ <code>==</code> for arrays with real numbers, which is normally
an inadequate test due to rounding errors, but in the present case,
all arithmetics consists of adding or subtracting one, so these operations
are expected to have no rounding errors. Comparing two <code>numpy</code> arrays
with <code>==</code> results in a boolean array, so we need to call the <code>all()</code>
method to ensure that all elements are <code>True</code>, i.e., that all elements
in the two arrays match each other pairwise.

<h2 id="diffu:randomwalk:1D:pde">Equivalence with diffusion</h2>

<p>
The original random walk algorithm can be said to work with
dimensionless coordinates \( \bar x_i = -N + i \), \( i=0,1,\ldots, 2N+1 \)
(\( i\in [-N,N] \)), and \( \bar t_n=n \), \( n=0,1,\ldots,N \).  A mesh with
spacings \( \Delta x \) and \( \Delta t \) with dimensions can be introduced
by

$$ x_i = X_0 + \bar x_i \Delta x,\quad t_n = \bar t_n\Delta t\tp$$

If we implement the algorithm with dimensionless coordinates, we can just
use this rescaling to obtain the movement in a coordinate system
without unit spacings.

<p>
Let \( P^{n+1}_i \) be the probability of finding the particle at mesh point
\( \bar x_i \) at time \( \bar t_{n+1} \). We can reach mesh point \( (i,n+1) \) in two
ways: either coming in from the left from \( (i-1,n) \) or from the
right (\( i+1,n) \). Each has probability \( \half \) (if we assume
\( p=q=\half \)). The fundamental equation for \( P^{n+1}_i \) is

$$
\begin{equation}
P^{n+1}_i = \half P^{n}_{i-1} + \half P^{n}_{i+1}\tp
\tag{113}
\end{equation}
$$

(This equation is easiest to understand if one looks at the random walk
as a Markov process and applies the transition probabilities, but this is
beyond scope of the present text.)

<p>
Subtracting \( P^{n}_i \) from <a href="#mjx-eqn-113">(113)</a> results
in

$$
P^{n+1}_i - P^{n}_i = \half (P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1})\tp
$$

Readers who have seen the Forward Euler discretization of a 1D
diffusion equation recognize this scheme as very close to such a
discretization. We have

$$ \frac{\partial}{\partial t}P(x_i,t_{n})
= \frac{P^{n+1}_i - P^{n}_i}{\Delta t} + \Oof{\Delta t},$$

or in dimensionless coordinates

$$ \frac{\partial}{\partial\bar t}P(\bar x_i,\bar t_n)
\approx P^{n+1}_i - P^{n}_i\tp$$

Similarly, we have

$$
\begin{align*}
\frac{\partial^2}{\partial x^2}P(x_i,t_n) &=
\frac{P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1}}{\Delta x^2}
+ \Oof{\Delta x^2},\\ 
\frac{\partial^2}{\partial x^2}P(\bar x_i,\bar t_n) &\approx
P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1}\tp
\end{align*}
$$

Equation <a href="#mjx-eqn-113">(113)</a> is therefore equivalent with
the dimensionless diffusion equation

$$
\begin{equation}
\frac{\partial P}{\partial\bar t} = \frac{1}{2}
\frac{\partial^2 P}{\partial \bar x^2},
\tag{114}
\end{equation}
$$

or the diffusion equation

$$
\begin{equation}
\frac{\partial P}{\partial t} = D\frac{\partial^2 P}{\partial x^2},
\tag{115}
\end{equation}
$$

with diffusion coefficient

$$ D = \frac{\Delta x^2}{2\Delta t}\tp$$

This derivation shows the tight link between random walk and diffusion.
If we keep track of where the particle is, and repeat the process
many times, or run the algorithms for lots of particles, the histogram
of the positions will approximate the solution of the diffusion equation
for the local probability \( P^n_i \).

<p>
Suppose all the random walks start at the origin. Then the initial
condition for the probability distribution is the Dirac delta
function \( \delta(x) \). The solution of <a href="#mjx-eqn-114">(114)</a>
can be shown to be

$$
\begin{equation}
\bar P(\bar x,\bar t) = \frac{1}{\sqrt{4\pi\dfc t}}e^{-\frac{x^2}{4\dfc t}},
\tag{116}
\end{equation}
$$

where \( \dfc = \half \).

<h2 id="___sec99">Implementation of multiple walks </h2>

<p>
Our next task is to implement an ensemble of walks (for statistics,
see the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a>) and also provide data from
the walks such that we can compute the probabilities of the positions
as introduced in the previous section. An appropriate representation
of probabilities \( P^n_i \) are histograms (with \( i \) along the \( x \) axis)
for a few selected values of \( n \).

<p>
To estimate the expectation and variance of the random walks,
the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a> points to recording
\( \sum_j x_{j,k} \) and \( \sum_j x_{j,k}^2 \), where \( x_{j,k} \) is the
position at time/step level \( k \) in random walk number \( j \).
The histogram of positions needs the individual values \( x_{i,k} \)
for all \( i \) values and some selected \( k \) values.

<p>
We introduce <code>position[k]</code> to hold \( \sum_j x_{j,k} \),
<code>position2[k]</code> to hold \( \sum_j (x_{j,k})^2 \), and
<code>pos_hist[i,k]</code> to hold \( x_{i,k} \). A selection of \( k \) values can be
specified by saying how many, <code>num_times</code>, and let them be equally
spaced through time:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]
</pre></div>
<p>
This is one of the few situations where we want integer division (<code>//</code>) or
real division rounded to an integer.

<h3 id="___sec100">Scalar version </h3>

<p>
Our scalar implementation of running <code>num_walks</code> random walks may go
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>,
                   random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0<span style="color: #666666">*</span>num_walks
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    position2[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0<span style="color: #666666">**2*</span>num_walks
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]
    <span style="color: #408080; font-style: italic">#print &#39;save hist:&#39;, post_hist_times</span>

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        current_pos <span style="color: #666666">=</span> x0
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
            <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
                <span style="color: #408080; font-style: italic">#print &#39;save, k:&#39;, k, num_times_counter, n</span>
                pos_hist[n,num_times_counter] <span style="color: #666666">=</span> current_pos
                num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
            <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos
            position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec101">Vectorized version </h3>

<p>
We have already vectorized a single random walk. The additional
challenge here is to vectorize the computation of the data for the
histogram, <code>pos_hist</code>, but given the selected steps in <code>pos_hist_times</code>,
we can find the corresponding positions by indexing with the
list <code>pos_hist_times</code>: <code>position[post_hist_times]</code>, which are to be
inserted in <code>pos_hist[n,:]</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D_vec1</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walk <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)         <span style="color: #408080; font-style: italic"># Positions of current walk</span>
    walk[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
        steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
        walk[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps)  <span style="color: #408080; font-style: italic"># Positions of this walk</span>
        position  <span style="color: #666666">+=</span> walk
        position2 <span style="color: #666666">+=</span> walk<span style="color: #666666">**2</span>
        pos_hist[n,:] <span style="color: #666666">=</span> walk[pos_hist_times]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec102">Improved vectorized version </h3>

<p>
Looking at the vectorized version above, we still have one potentially
long Python loop over <code>n</code>. Normally, <code>num_walks</code> will be much larger than <code>N</code>.
The vectorization of the loop over <code>N</code> certainly speeds up the program,
but if we think of vectorization as also a way to parallelize the code,
all the independent walks (the <code>n</code> loop) can be executed in parallel.
Therefore, we should include this loop as well in the vectorized
expressions, at the expense of using more memory.

<p>
We introduce the array <code>walks</code> to hold the \( N+1 \) steps of all the walks:
each row represents the steps in one walk.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
walks[:,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
</pre></div>
<p>
Since all the steps are independent, we can just make one long
vector of enough random numbers (<code>N*num_walks</code>), translate these
numbers to \( \pm 1 \), then we reshape the array such that the steps
of each walk are stored in the rows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks)
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N)
</pre></div>
<p>
The next step is to sum up the steps in each walk. We need the
<code>np.cumsum</code> function for this, with the argument <code>axis=1</code> for
indicating a sum across the columns:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">6</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">2</span>,<span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>],
       [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(a, axis<span style="color: #666666">=1</span>)
array([[ <span style="color: #666666">0</span>,  <span style="color: #666666">1</span>,  <span style="color: #666666">3</span>],
       [ <span style="color: #666666">3</span>,  <span style="color: #666666">7</span>, <span style="color: #666666">12</span>]])
</pre></div>
<p>
Now <code>walks</code> can be computed by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">walks[:,<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
</pre></div>
<p>
The <code>position</code> vector is the sum of all the walks. That is, we want to
sum all the rows, obtained by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks, axis<span style="color: #666666">=0</span>)
</pre></div>
<p>
A corresponding expression computes the squares of the positions.
Finally, we need to compute <code>pos_hist</code>, but that is a matter of
grabbing some of the walks (according to <code>pos_hist_times</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">pos_hist[:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times]
</pre></div>
<p>
The complete vectorized algorithm without any loop can now be
summarized:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D_vec2</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
    walks[:,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N)
    walks[:,<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks,    axis<span style="color: #666666">=0</span>)
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks<span style="color: #666666">**2</span>, axis<span style="color: #666666">=0</span>)
    pos_hist[:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
What is the gain of the vectorized implementations? One important gain
is that each vectorized operation can be automatically parallelized
if one applies a parallel <code>numpy</code> library like <a href="http://numba.pydata.org" target="_self">Numba</a>. On a single CPU, however, the speed up of the vectorized operations
is also significant. With \( N=1,000 \) and 50,000 repeated walks,
the two vectorized versions run about 25 and 18 times faster than the scalar
version, with <code>random_walks1D_vec1</code> being fastest.
<!-- The downside of vectorization of random walks is the large -->
<!-- arrays that arise, especially the version in <code>random_walks1D_vec2</code>. -->
<!-- CPU: -->
<!-- N=1000, 50K walks -->
<!-- scalar: 42, vec1: 1.7, vec2: 1.7, factors 25 and 25 -->

<h3 id="___sec103">Remark on vectorized code and parallelization </h3>

<p>
Our first attempt on vectorization removed the loop over the \( N \) steps in
a single walk. However, the number of walks is usually much larger than
\( N \), because of the need for accurate statistics. Therefore, we should
rather remove the loop over all walks. It turns out, from our efficiency
experiments, that the function <code>random_walks1D_vec2</code> (with no loops) is
slower than <code>random_walks1D_vec1</code>. This is a bit surprising and may be
explained by less efficiency in the statements involving very large
arrays, containing all steps for all walks at once.

<p>
From a parallelization and improved vectorization point of view, it
would be more natural to switch the sequence of the loops in the
serial code such that the shortest loop is the outer loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D2</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>, <span style="color: #666666">...</span>):
    <span style="color: #666666">...</span>
    current_pos <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>zeros(num_walks)
    num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">-1</span>

    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
	    num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">True</span>
	<span style="color: #008000; font-weight: bold">else</span>:
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">False</span>

        <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
	    <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos[n] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos[n] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos[n]
            position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos[n]<span style="color: #666666">**2</span>
            <span style="color: #008000; font-weight: bold">if</span> store_hist:
                pos_hist[n,num_times_counter] <span style="color: #666666">=</span> current_pos[n]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
The vectorized version of this code, where we just vectorize the
loop over <code>n</code>, becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D2_vec1</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D2.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(num_walks)
    current_pos[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">-1</span>

    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
	    num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">True</span>  <span style="color: #408080; font-style: italic"># Store histogram data for this k</span>
	<span style="color: #008000; font-weight: bold">else</span>:
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">False</span>

        <span style="color: #408080; font-style: italic"># Move all walks one step</span>
        r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>num_walks)
        steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
        current_pos <span style="color: #666666">+=</span> steps
        position[k<span style="color: #666666">+1</span>]  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(current_pos)
        position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(current_pos<span style="color: #666666">**2</span>)
        <span style="color: #008000; font-weight: bold">if</span> store_hist:
            pos_hist[:,num_times_counter] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
This function runs significantly faster than the <code>random_walks1D_vec1</code>
function above, typically 1.7 times faster. The code is also more appropriate
in a parallel computing context since each vectorized statement
can work with data of size <code>num_walks</code> over the compute units, repeated <code>N</code>
times (compared with data of size <code>N</code>, repeated <code>num_walks</code> times, in
<code>random_walks1D_vec1</code>).

<p>
The scalar code with switched loops, <code>random_walks1D2</code> runs a bit slower
than the original code in <code>random_walks1D</code>, so with the longest loop as
the inner loop, the vectorized function <code>random_walks1D2_vec1</code>
is almost 60 times faster than the scalar counterpart, while the
code <code>random_walks1D_vec2</code> without loops is only around 18 times faster.
Taking into account the very large arrays required by the latter function,
we end up with <code>random_walks1D2_vec1</code> as the preferred implementation.

<h3 id="___sec104">Test function </h3>

<p>
During program development, it is highly recommended to carry out
computations by hand for, e.g., <code>N=4</code> and <code>num_walks=3</code>.  Normally,
this is done by executing the program with these parameters and
checking with pen and paper that the computations make sense.  The
next step is to use this test for correctness in a formal test
function.

<p>
First, we need to check that the simulation of multiple random walks
reproduces the results of <code>random_walk1D</code>, <code>random_walk1D_vec1</code>, and
<code>random_walk1D_vec2</code> for the first walk, if the seed is the
same. Second, we run three random walks (<code>N=4</code>) with the scalar and
the two vectorized versions and check that the returned arrays are
identical.

<p>
For this type of test to be successful, we must be sure that exactly
the same set of random numbers are used in the three versions, a fact
that requires the same random number generator and the same seed, of
course, but also the same sequence of computations.  This is not
obviously the case with the three <code>random_walk1D*</code> functions we
have presented. The critical issue in <code>random_walk1D_vec1</code> is that the
first random numbers are used for the first walk, the second set of
random numbers is used for the second walk and so on, to be compatible
with how the random numbers are used in the function <code>random_walk1D</code>.
For the function <code>random_walk1D_vec2</code> the situation is a bit more
complicated since we generate all the random numbers at once.
However, the critical step now is the reshaping of the array returned
from <code>np.where</code>: we must reshape as <code>(num_walks, N)</code> to ensure that
the first <code>N</code> random numbers are used for the first walk, the next <code>N</code>
numbers are used for the second walk, and so on.

<p>
We arrive at the test function below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_random_walks1D</span>():
    <span style="color: #408080; font-style: italic"># For fixed seed, check that scalar and vectorized versions</span>
    <span style="color: #408080; font-style: italic"># produce the same result</span>
    x0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  N <span style="color: #666666">=</span> <span style="color: #666666">4</span>;  p <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>

    <span style="color: #408080; font-style: italic"># First, check that random_walks1D for 1 walk reproduces</span>
    <span style="color: #408080; font-style: italic"># the walk in random_walk1D</span>
    num_walks <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D(
        x0, N, p, num_walks, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D(
        x0, N, p, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()

    <span style="color: #408080; font-style: italic"># Same for vectorized versions</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D_vec1(x0, N, p, num_walks)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D_vec2(x0, N, p, num_walks)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()

    <span style="color: #408080; font-style: italic"># Second, check multiple walks: scalar == vectorized</span>
    num_walks <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    num_times <span style="color: #666666">=</span> N
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    serial_computed <span style="color: #666666">=</span> random_walks1D(
        x0, N, p, num_walks, num_times, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized1_computed <span style="color: #666666">=</span> random_walks1D_vec1(
        x0, N, p, num_walks, num_times)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized2_computed <span style="color: #666666">=</span> random_walks1D_vec2(
        x0, N, p, num_walks, num_times)
    <span style="color: #408080; font-style: italic"># positions: [0, 1, 0, 1, 2]</span>
    <span style="color: #408080; font-style: italic"># Can test without tolerance since everything is +/- 1</span>
    return_values <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;pos&#39;</span>, <span style="color: #BA2121">&#39;pos2&#39;</span>, <span style="color: #BA2121">&#39;pos_hist&#39;</span>, <span style="color: #BA2121">&#39;pos_hist_times&#39;</span>]
    <span style="color: #008000; font-weight: bold">for</span> s, v, r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(serial_computed,
                       vectorized1_computed,
                       return_values):
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (serial) vs </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (vectorized)&#39;</span> <span style="color: #666666">%</span> (r, s, v)
        <span style="color: #008000; font-weight: bold">assert</span> (s <span style="color: #666666">==</span> v)<span style="color: #666666">.</span>all(), msg
    <span style="color: #008000; font-weight: bold">for</span> s, v, r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(serial_computed,
                       vectorized2_computed,
                       return_values):
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (serial) vs </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (vectorized)&#39;</span> <span style="color: #666666">%</span> (r, s, v)
        <span style="color: #008000; font-weight: bold">assert</span> (s <span style="color: #666666">==</span> v)<span style="color: #666666">.</span>all(), msg
</pre></div>
<p>
Such test functions are indispensable for further development of the code
as we can at any time test whether the basic computations remain correct or not.
This is particularly important in stochastic simulations since without
test functions and fixed seeds, we always experience variations from run to
run, and it can be very difficult to spot bugs through averaged statistical
quantities.

<h2 id="___sec105">Demonstration of multiple walks </h2>

<p>
Assuming now that the code works, we can just scale up the number of
steps in each walk and the number of walks. The latter influences the
accuracy of the statistical estimates.  Figure
<a href="#diffu:randomwalk:1D:fig:demo1:EX">18</a> shows the impact of the number
of walks on the expectation, which should approach zero.  Figure
<a href="#diffu:randomwalk:1D:fig:demo1:VarX">19</a> displays the corresponding
estimate of the variance of the position, which should grow linearly
with the number of steps. It does, seemingly very accurately, but
notice that the scale on the \( y \) axis is so much larger than for the
expectation, so irregularities due to the stochastic nature of the
process become so much less visible in the variance plots.  The
probability of finding a particle at a certain position at time (or
step) 800 is shown in Figure
<a href="#diffu:randomwalk:1D:fig:demo1:HistX">20</a>. The dashed red line is the
theoretical distribution <a href="#mjx-eqn-116">(116)</a>
arising from solving the diffusion equation
<a href="#mjx-eqn-114">(114)</a> instead. As always, we realize
that one needs significantly more statistical samples to estimate a
histogram accurately than the expectation or variance.

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:EX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 18:  Estimated expected value for 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:EX --> </p></center>
<p><img src="fig-diffu/rw1D_EX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:VarX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 19:  Estimated variance over 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:VarX --> </p></center>
<p><img src="fig-diffu/rw1D_VarX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:HistX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 20:  Estimated probability distribution at step 800, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:HistX --> </p></center>
<p><img src="fig-diffu/rw1D_HistX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<h2 id="diffu:randomwalk:1D:avplotter">Ascii visualization of 1D random walk</h2>

<p>
If we want to study (very) long time series of random walks, it can be
convenient to plot the position in a terminal window with the time axis
pointing downwards. The module <code>avplotter</code> in SciTools has a class <code>Plotter</code>
for plotting functions in the terminal window with the aid of ascii symbols
only. Below is the code required to visualize a simple random walk,
starting at the origin, and considered over
when the point \( x=-1 \) is reached. We use a spacing \( \Delta x = 0.05 \) (so
\( x=-1 \) corresponds to \( i=-20 \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">run_random_walk</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.avplotter</span> <span style="color: #008000; font-weight: bold">import</span> Plotter
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    p <span style="color: #666666">=</span> Plotter(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, width<span style="color: #666666">=75</span>)   <span style="color: #408080; font-style: italic"># Horizontal axis: 75 chars wide</span>
    dx <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)

    x <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">True</span>:
        random_step <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>random() <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">-1</span>
        x <span style="color: #666666">=</span> x <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>random_step
        <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">-1</span>:
            <span style="color: #008000; font-weight: bold">break</span>                  <span style="color: #408080; font-style: italic"># Destination reached!</span>
        <span style="color: #008000; font-weight: bold">print</span> p<span style="color: #666666">.</span>plot(<span style="color: #666666">0</span>, x)

        <span style="color: #408080; font-style: italic"># Allow Ctrl+c to abort the simulation</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.1</span>)  <span style="color: #408080; font-style: italic"># Wait for interrupt</span>
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #D2413A; font-weight: bold">KeyboardInterrupt</span>:
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Interrupted by Ctrl+c&#39;</span>
            <span style="color: #008000; font-weight: bold">break</span>
</pre></div>
<p>
Observe that we implement an infinite loop, but allow a smooth interrupt
of the program by <code>Ctrl+c</code> through Python's <code>KeyboardInterrupt</code>
exception. This is a useful recipe that can be used in many occasions!

<p>
The output looks typically like

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">                            *         |
                              *       |
                            *         |
                              *       |
                            *         |
                              *       |
                                *     |
                              *       |
                            *         |
                          *           |
                        *             |
                      *               |
                        *             |
                      *               |
                     *                |
                   *                  |
                 *                    |
               *                      |
</pre></div>
<p>
Positions beyond the limits of the \( x \) axis appear with a value.
<a href="http://bit.ly/1UbULeH" target="_self">A long file</a>
contains the complete ascii plot corresponding to the
function <code>run_random_walk</code> above.
<!-- "https://github.com/hplgit/fdm-book/blob/master/doc/.src/chapters/diffu/fig-diffu/rw_ascii.txt" -->

<h2 id="diffu:randomwalk:1D:ode">Random walk as a stochastic equation</h2>

<p>
The (dimensionless) position in a random walk, \( \bar X_k \), can be expressed as
a stochastic difference equation:

$$
\begin{equation}
\bar X_k = \bar X_{k-1} + s, \quad x_0=0,
\tag{117}
\end{equation}
$$

where \( s \) is a <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution" target="_self">Bernoulli variable</a>,
taking on the two values \( s=-1 \) and \( s=1 \)
with equal probability:

$$ \hbox{P}(s=1)=\half,\quad \hbox{P}(s=-1)=\half\tp$$

The \( s \) variable in a step is independent of the \( s \) variable in other steps.

<p>
The difference equation expresses essentially the sum of independent
Bernoulli variables.  Because of the central limit theorem, \( X_k \),
will then be normally distributed with expectation \( k\E{s} \) and
\( k\Var{s} \).  The expectation and variance of a Bernoulli variable with
values \( r=0 \) and \( r=1 \) are \( p \) and \( p(1-p) \), respectively.
The variable \( s=2r-1 \) then has expectation
\( 2\E{r}-1=2p-1=0 \) and variance \( 2^2\Var{r}=4p(1-p)=1 \).  The position
\( X_k \) is normally distributed with zero expectation and variance \( k \),
as we found in the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a>.

<p>
The central limit theorem tells that as long as \( k \) is not small,
the distribution of \( X_k \) remains the same if
we replace the Bernoulli variable \( s \) by any other stochastic variable with
the same expectation and variance. In particular, we may let \( s \) be a
standardized Gaussian variable (zero mean, unit variance).

<p>
<!-- Let us introduce -->
<!-- !bt -->
<!-- x_k = \Delta x\bar x_k,\] -->
<!-- !et -->
<!-- such that we take steps of length \( \Delta x \). -->
Dividing <a href="#mjx-eqn-117">(117)</a> by \( \Delta t \) gives

$$ \frac{\bar X_k - \bar X_{k-1}}{\Delta t} = \frac{1}{\Delta t} s\tp$$

In the limit \( \Delta t\rightarrow 0 \), \( s/\Delta t \) approaches a white noise
stochastic process.
With \( \bar X(t) \) as the continuous process in the limit
\( \Delta t\rightarrow 0 \) (\( X_k\rightarrow X(t_k) \)),
we formally get the stochastic differential equation

$$
\begin{equation}
d\bar X = dW,
\tag{118}
\end{equation}
$$

where \( W(t) \) is a <a href="https://en.wikipedia.org/wiki/Wiener_process" target="_self">Wiener process</a>. Then \( X \) is also a
Wiener process. It follows from the stochastic ODE \( dX=dW \) that the
probability distribution of \( X \) is given by the <a href="https://en.wikipedia.org/wiki/Fokker-Planck_equation" target="_self">Fokker-Planck
equation</a>
<a href="#mjx-eqn-114">(114)</a>.  In other words, the key
results for random walk we found earlier can alternatively be
derived via a stochastic ordinary differential equation and its
related Fokker-Planck equation.

<h2 id="___sec108">Random walk in 2D </h2>

<p>
The most obvious generalization of 1D random walk to two spatial
dimensions is to allow movements to the north, east, south, and west,
with equal probability \( \frac{1}{4} \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk2D</span>(x0, N, p, random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2D random walk with 1 particle and N moves: N, E, W, S.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))
    position[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.25</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>, <span style="color: #666666">1</span>])   <span style="color: #408080; font-style: italic"># Move north</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0.25</span> <span style="color: #666666">&lt;</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">0</span>])   <span style="color: #408080; font-style: italic"># Move east</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0.5</span> <span style="color: #666666">&lt;</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.75</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>])  <span style="color: #408080; font-style: italic"># Move south</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>])  <span style="color: #408080; font-style: italic"># Move west</span>
        position[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
The left plot in Figure <a href="#diffu:randomwalk:2D:fig:rect_vs_diag">21</a> provides
an example on 200 steps with this kind of walk. We may refer to this walk
as a walk on a <em>rectangular mesh</em> as we move from any spatial
mesh point \( (i,j) \) to one of its four neighbors in the rectangular directions:
\( (i+1,j) \), \( (i-1,j) \), \( (i,j+1) \), or \( (i,j-1) \).

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:2D:fig:rect_vs_diag"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 21:  Random walks in 2D with 200 steps: rectangular mesh (left) and diagonal mesh (right).  <!-- caption label: diffu:randomwalk:2D:fig:rect_vs_diag --> </p></center>
<p><img src="fig-diffu/rw2D_sample200.png" align="bottom" width=800></p>
</center>

<h2 id="___sec109">Random walk in any number of space dimensions </h2>

<p>
From a programming point of view, especially when implementing a random
walk in any number of dimensions, it is more natural to consider a walk
in the diagonal directions NW, NE, SW, and SE. On a two-dimensional spatial mesh
it means that we go from \( (i,j) \) to either \( (i+1,j+1) \), \( (i-1,j+1) \),
\( (i+1,j-1) \), or \( (i-1,j-1) \). We can with such a <em>diagonal mesh</em>
(see right plot in Figure <a href="#diffu:randomwalk:2D:fig:rect_vs_diag">21</a>)
draw a Bernoulli variable for the step in each spatial direction and
trivially write code that works in any number of spatial directions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walkdD</span>(x0, N, p, random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Any-D (diagonal) random walk with 1 particle and N moves.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))
    position[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d):
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
            <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos[i] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos[i] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        position[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
A vectorized version is desired. We follow the ideas from the section <a href="#diffu:randomwalk:1D:code1">Playing around with some code</a>, but each step is now a vector in \( d \)
spatial dimensions. We therefore need to draw \( Nd \) random numbers in <code>r</code>,
compute steps in the various directions through <code>np.where(r &lt;=p, -1, 1)</code>
(each step being \( -1 \) or \( 1 \)),
and then we can reshape this array to an \( N\times d \) array of step
<em>vectors</em>. Doing an <code>np.cumsum</code> summation along axis 0 will add
the vectors, as this demo shows:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">6</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">3</span>,<span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>],
       [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>],
       [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(a, axis<span style="color: #666666">=0</span>)
array([[ <span style="color: #666666">0</span>,  <span style="color: #666666">1</span>],
       [ <span style="color: #666666">2</span>,  <span style="color: #666666">4</span>],
       [ <span style="color: #666666">6</span>,  <span style="color: #666666">9</span>]])
</pre></div>
<p>
With such summation of step vectors, we get all the positions to be
filled in the <code>position</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walkdD_vec</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walkdD.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>,d))
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>d)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(N,d)
    position[<span style="color: #666666">1</span>:,:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=0</span>)
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:2D:fig:samples"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 22:  Four random walks with 5000 steps in 2D.  <!-- caption label: diffu:randomwalk:2D:fig:samples --> </p></center>
<p><img src="fig-diffu/rw2D_samples_5000.png" align="bottom" width=800></p>
</center>

<h2 id="___sec110">Multiple random walks in any number of space dimensions </h2>

<p>
As we did in 1D, we extend one single walk to a number of walks (<code>num_walks</code>
in the code).

<h3 id="___sec111">Scalar code </h3>

<p>
As always, we start with implementing the scalar case:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walksdD</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>,
                   random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))   <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))   <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times, d))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
            <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
                pos_hist[n,num_times_counter,:] <span style="color: #666666">=</span> current_pos
                num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d):
                r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                    current_pos[i] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
                <span style="color: #008000; font-weight: bold">else</span>:
                    current_pos[i] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>,:] <span style="color: #666666">+=</span> current_pos
            position2[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">+=</span> current_pos<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec112">Vectorized code </h3>

<p>
Significant speed-ups can be obtained by vectorization. We get rid of
the loops in the previous function and arrive at the following vectorized
code.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walksdD_vec</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
    walks[:,<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times, d))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks<span style="color: #666666">*</span>d)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N, d)
    walks[:,<span style="color: #666666">1</span>:,:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks,    axis<span style="color: #666666">=0</span>)
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks<span style="color: #666666">**2</span>, axis<span style="color: #666666">=0</span>)
    pos_hist[:,:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times,:]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
<!-- 2D N=4M -->
<!-- scalar/vec (1 walk): 25 -->

<p>
<!-- 2D N=5000 -->
<!-- num_walks=10K -->
<!-- scalar/vec=50 -->
<!-- 3D: 40 -->
<!-- 1D: 100 -->
<!-- scalar is about the same for 1D, 2D, 3D, but vec is 0.3, 0.7, 1.0 -->

<h1 id="diffu:app">Applications</h1>

<h2 id="diffu:app:substance">Diffusion of a substance</h2>

<p>
The first process to be considered is a substance that gets
transported through a fluid at rest by pure diffusion. We consider an
arbitrary volume \( V \) of this fluid, containing the substance with
concentration function \( c(\x,t) \). Physically, we can think of a very
small volume with centroid \( \x \) at time \( t \) and assign the ratio of
the volume of the substance and the total volume to \( c(\x, t) \).  This
means that the mass of the substance in a small volume \( \Delta V \) is
approximately \( \varrho c\Delta V \), where \( \varrho \) is the density of
the substance. Consequently, the total mass of the substance inside
the volume \( V \) is the sum of all \( \varrho c\Delta V \), which becomes
the volume integral \( \int_V\varrho cdV \).

<p>
Let us reason how the mass of the substance changes and thereby derive
a PDE governing the concentration \( c \).  Suppose the substance flows
out of \( V \) with a flux \( \q \).  If \( \Delta S \) is a small part of the
boundary \( \partial V \) of \( V \), the volume of the substance flowing out
through \( dS \) in a small time interval \( \Delta t \) is \( \varrho
\q\cdot\normalvec \Delta t \Delta S \), where \( \normalvec \) is an outward
unit normal to the boundary \( \partial V \), see Figure
<a href="#diffu:app:substance:fig1">23</a>.  We realize that only the normal
component of \( \q \) is able to transport mass in and out of \( V \).  The
total outflow of the mass of the substance in a small time interval
\( \Delta t \) becomes the surface integral

$$ \int\limits_{\partial V} \varrho\q\cdot\normalvec \Delta t\,  dS\tp$$

Assuming conservation of mass, this outflow of mass must be balanced by
a loss of mass inside the volume. The increase of mass inside the volume,
during a small time interval \( \Delta t \), is

$$ \int\limits_V \varrho (c(\x,t+\Delta t) - c(\x,t)) dV,$$

assuming \( \varrho \) is constant, which is reasonable. The outflow of mass
balances the loss of mass in \( V \), which is the increase with a minus sign.
Setting the two contributions equal to each other ensures balance of
mass inside \( V \). Dividing by \( \Delta t \) gives

$$ \int\limits_V \varrho \frac{c(\x,t+\Delta t) - c(\x,t)}{\Delta t} dV =
- \int\limits_{\partial V} \varrho\q\cdot\normalvec\, dS\tp$$

Note the minus sign on the right-hand side: the left-hand side expresses
loss of mass, while the integral on the right-hand side is the gain of
mass.

<p>
Now, letting \( \Delta t\rightarrow 0 \), we have

$$ \frac{c(\x,t+\Delta t) - c(\x,t)}{\Delta t} \rightarrow
\frac{\partial c}{\partial t},$$

so

$$
\begin{equation}
\int\limits_V \varrho \frac{\partial c}{\partial t}dV +
\int\limits_{\partial V} \varrho\q\cdot\normalvec\, dS = 0\tp
\tag{119}
\end{equation}
$$

To arrive at a PDE,
we express the surface integral as a volume integral using Gauss'
divergence theorem:

$$
\int\limits_V (\varrho \frac{\partial c}{\partial t} +
\nabla\cdot(\varrho \q))dV = 0\tp
$$

Since \( \varrho \) is constant, we can divide by this quantity.  If the
integral is to vanish for an arbitrary volume \( V \), the integrand must
vanish too, and we get the mass conservation PDE for the substance:

$$
\begin{equation}
\frac{\partial c}{\partial t} +
\nabla\cdot \q = 0\tp
\tag{120}
\end{equation}
$$

<p>
<center> <!-- figure label: --> <div id="diffu:app:substance:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 23:  An arbitrary volume of a fluid.  <!-- caption label: diffu:app:substance:fig1 --> </p></center>
<p><img src="fig-diffu/continuum.png" align="bottom" width=200></p>
</center>

<p>
A fundamental problem is that this is a scalar PDE for four unknowns:
\( c \) and the three components of \( \q \). We therefore need additional
equations. Here, Fick's law comes at rescue: it models how the flux
\( \q \) of the substance is related to the concentration \( c \). Diffusion
is recognized by mass flowing from regions with high concentration to
regions of low concentration. This principle suggests that \( \q \) is
proportional to the negative gradient of \( c \):

$$
\begin{equation}
\q = -\dfc\nabla c,
\tag{121}
\end{equation}
$$

where \( \dfc \) is an empirically determined constant.
The relation <a href="#mjx-eqn-121">(121)</a> is known as Fick's law.
Inserting <a href="#mjx-eqn-121">(121)</a> in
<a href="#mjx-eqn-120">(120)</a> gives a scalar PDE for the
concentration \( c \):

$$
\begin{equation}
\frac{\partial c}{\partial t} = \dfc\nabla^2 c\tp
\tag{122}
\end{equation}
$$

<h2 id="diffu:app:heat">Heat conduction</h2>

<p>
Heat conduction is a well-known diffusion process. The governing PDE
is in this case based on the first law of thermodynamics: the increase
in energy of a system is equal to the work done on the system, plus
the supplied heat. Here, we shall consider media at rest and neglect work
done on the system. The principle then reduces to a balance between
increase in internal energy and supplied heat flow by conduction.

<p>
Let \( e(x,t) \) be the <em>internal energy</em> per unit mass. The increase of
the internal energy in a small volume \( \Delta V \) in a small time
interval \( \Delta t \) is then

$$ \varrho (e(\x,t+\Delta t) - e(\x,t))\Delta V,$$

where \( \varrho \) is the density of the material subject to heat conduction.
In an arbitrary volume \( V \), as depicted in
Figure <a href="#diffu:app:substance:fig1">23</a>, the corresponding increase in internal
energy becomes the volume integral

$$ \int\limits_V \varrho (e(\x,t+\Delta t) - e(\x,t))dV\tp$$

This increase in internal energy is balanced by heat supplied by
conduction. Let \( \q \) be the heat flow per time unit. Through the
surface \( \partial V \) of \( V \) the following amount of heat flows out
of \( V \) during a time interval \( \Delta t \):

$$
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS\tp$$

The simplified version of the first law of thermodynamics then states that

$$
\int\limits_V \varrho (e(\x,t+\Delta t) - e(\x,t))dV = -
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS\tp
$$

The minus sign on the right-hand side ensures that the integral there
models net <em>inflow</em> of heat (since \( \normalvec \) is an outward unit normal,
\( \q\cdot\normalvec \) models <em>outflow</em>).
Dividing by \( \Delta t \) and notifying that

$$ \lim_{\Delta t\rightarrow 0}
\frac{e(\x,t+\Delta t) - e(\x,t)}{\Delta t} =
\frac{\partial e}{\partial t},$$

we get (in the limit \( \Delta t\rightarrow 0 \))

$$
\int\limits_V \varrho \frac{\partial e}{\partial t} dV +
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS = 0\tp
$$

This is the integral equation for heat conduction, but we aim at a PDE.
The next step is therefore to transform the surface integral to a
volume integral via Gauss' divergence theorem. The result is

$$
\int\limits_V\left( \varrho \frac{\partial e}{\partial t}
+ \nabla\cdot\q\right) dV = 0\tp
$$

If this equality is to hold for all volumes \( V \), the integrand must vanish,
and we have the PDE

$$
\begin{equation}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\q\tp
\tag{123}
\end{equation}
$$

<p>
Sometimes the supplied heat can come from the medium itself. This is
the case, for instance, when radioactive rock generates heat.  Let us
add this effect. If \( f(\x,t) \) is the supplied heat per unit volume per
unit time, the heat supplied in a small volume is \( f\Delta t\Delta V \),
and inside an arbitrary volume \( V \) the supplied generated heat becomes

$$ \int\limits_V f\Delta t dV\tp$$

Adding this to the integral statement of the (simplified) first law of
thermodynamics, and continuing the derivation, leads to the PDE

$$
\begin{equation}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\q + f\tp
\tag{124}
\end{equation}
$$

<p>
There are four unknown scalar fields: \( e \) and \( \q \). Moreover, the
temperature \( T \), which is our primary quantity to compute, does not
enter the model yet. We need an additional equation, called the
<em>equation of state</em>, relating \( e \), \( V=1/\varrho= \), and \( T \):
\( e=e(V,T) \). By the chain rule we have

$$ \frac{\partial e}{\partial t} =
\left.\frac{\partial e}{\partial T}\right\vert_{V}
\frac{\partial T}{\partial t} +
\left.\frac{\partial e}{\partial V}\right\vert_{T}
\frac{\partial V}{\partial t}\tp$$

The first coefficient \( \partial e/\partial T \) is called <em>specific heat
capacity at constant volume</em>, denoted by \( c_v \):

$$ c_v = \left.\frac{\partial e}{\partial T}\right\vert_{V}\tp$$

The specific heat capacity will in general vary with \( T \), but taking it as a
constant is a good approximation in many applications.

<p>
The term \( \partial e/\partial V \) models effects due to compressibility
and volume expansion. These effects are often small and can be
neglected.  We shall do so here. Using \( \partial e/\partial t =
c_v\partial T/\partial t \) in the PDE gives

$$ \varrho c_v\frac{\partial T}{\partial t} = -\nabla\cdot\q + f\tp$$

We still have four unknown scalar fields (\( T \) and \( \q \)). To close the
system, we need a relation between the heat flux \( \q \) and the temperature \( T \)
called <em>Fourier's law</em>:

$$ \q = -k\nabla T,$$

which simply states that heat flows from hot to cold areas, along the
path of greatest variation. In a solid medium, \( k \) depends on the
material of the medium, and in multi-material media one must regard
\( k \) as spatially dependent. In a fluid, it is common to assume that
\( k \) is constant. The value of \( k \) reflects how easy heat is
conducted through the medium, and \( k \) is named the <em>coefficient of
heat conduction</em>.

<p>
We now have one scalar PDE for the unknown temperature field \( T(\x,t) \):

$$
\begin{equation}
\varrho  c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T) + f\tp
\tag{125}
\end{equation}
$$

<h2 id="diffu:app:porous">Porous media flow</h2>

<p>
The requirement of mass balance for
flow of a single, incompressible fluid through a deformable (elastic) porous
medium leads to the equation

$$
S\frac{\partial p}{\partial t} + \nabla\cdot(\q - \alpha\frac{\partial\u}{\partial t}) = 0,
$$

where \( p \) is the fluid pressure, \( \q \) is the fluid velocity, \( \u \)
is the displacement (deformation) of the medium, \( S \) is the storage
coefficient of the medium (related to the compressibility of the
fluid and the material in the medium), and \( \alpha \) is another coefficient.
In many circumstances, the last term with \( \u \) can be neglected,
an assumption that decouples the equation above from a model for
the deformation of the medium. The famous <em>Darcy's law</em> relates
\( \q \) to \( p \):

$$ \q = -\frac{K}{\mu}(\nabla p - \varrho\g),$$

where \( K \) is the permeability of the medium, \( \mu \) is the dynamic
viscosity of the fluid, \( \varrho \) is the density of the fluid, and \( \g \)
is the acceleration of gravity, here taken as \( \g = -g\kk \).
Combining the two equations results in the diffusion model

$$
\begin{equation}
S\frac{\partial p}{\partial t} = \mu^{-1}\nabla(K\nabla p) + \frac{\varrho g}{\mu}\frac{\partial K}{\partial z}\tp
\tag{126}
\end{equation}
$$

Boundary conditions consist of specifying \( p \) or \( \q\cdot\normalvec \) (i.e., normal velocity) at
 each point of the boundary.

<h2 id="___sec117">Potential fluid flow </h2>

<p>
Let \( \v \) be the velocity of a fluid. The condition \( \nabla\times\v =0 \)
is relevant for many flows, especially in geophysics when viscous effects
are negligible. From vector calculus it is known
that \( \nabla\times\v =0 \) implies that \( v \) can be derived
from a scalar potential field \( \phi \): \( \v = \nabla\phi \). If the
fluid is incompressible, \( \nabla\cdot\v = 0 \), it follows that
\( \nabla\cdot\nabla\phi = 0 \), or

$$
\begin{equation}
\nabla^2\phi = 0\tp
\tag{127}
\end{equation}
$$

This Laplace equation is sufficient for determining \( \phi \) and thereby
describe the fluid motion. This type of flow is known as
<a href="https://en.wikipedia.org/wiki/Potential_flow" target="_self">potential flow</a>.
One very important application where potential flow is a good model
is water waves.
As boundary condition we must prescribe
\( \v\cdot\normalvec =\partial\phi/\partial n \). This gives rise to
what is known as a pure Neumann problem and will cause numerical
difficulties because \( \phi \) and \( \phi \) plus any constant are two
solutions of the problem. The simplest remedy is to fix the value of
\( \phi \) at a point.

<h2 id="___sec118">Streamlines for 2D fluid flow </h2>

<p>
The streamlines in a two-dimensional
stationary fluid flow are lines tangential to the flow.
The <a href="https://en.wikipedia.org/wiki/Stream_function" target="_self">stream function</a>
\( \psi \) is often introduced in two-dimensional flow
such that its contour
lines, \( \psi = \hbox{const} \), gives the streamlines. The relation
between \( \psi \) and the velocity field \( \v=(u,v) \) is

$$ u = \frac{\partial\psi}{\partial y},\quad v = -
\frac{\partial\psi}{\partial x}\tp$$

It follows that \( \nabla\v = \psi_{yx} - \psi_{xy}=0 \), so the stream function
can only be used for incompressible flows.
Since

$$\nabla\times\v = \left(\frac{\partial v}{\partial y} - \frac{\partial u}{\partial x}\right)\kk \equiv \omega\kk,$$

we can derive the relation

$$
\begin{equation}
\nabla^2\psi = -\omega,
\tag{128}
\end{equation}
$$

which is a governing equation for the stream function \( \psi(x,y) \)
if the vorticity \( \omega \) is known.

<h2 id="___sec119">The potential of an electric field </h2>

<p>
Under the assumption of time independence, Maxwell's equations
for the electric field \( \boldsymbol{E} \) become

$$
\begin{align*}
\nabla\cdot\boldsymbol{E} &= \frac{\rho}{\epsilon_0},\\ 
\nabla\times\boldsymbol{E} &= 0,
\end{align*}
$$

where \( \rho \) is the electric charge density and \( \epsilon_0 \) is
the electric permittivity of free space (i.e., vacuum).
Since \( \nabla\times\boldsymbol{E}=0 \), \( \boldsymbol{E} \) can be derived from a potential
\( \varphi \), \( \boldsymbol{E} = -\nabla\varphi \). The electric field potential is
therefore governed by the Poisson equation

$$
\begin{equation}
\nabla^2\varphi = -\frac{\rho}{\epsilon_0}\tp
\tag{129}
\end{equation}
$$

<p>
If the medium is heterogeneous, \( \rho \) will depend on the spatial location \( \boldsymbol{r} \).
Also, \( \epsilon_0 \) must be exchanged with an electric permittivity function
\( \epsilon(\boldsymbol{r}) \).

<p>
Each point of the boundary must be accompanied by, either a Dirichlet condition
\( \varphi(\boldsymbol{r}) = \varphi_D(\boldsymbol{r}) \), or a Neumann condition
\( \frac{\partial\varphi(\boldsymbol{r})}{\partial n} = \varphi_N(\boldsymbol{r}) \).

<h2 id="diffu:app:Couette">Development of flow between two flat plates</h2>

<p>
Diffusion equations may also arise as simplified versions of other
mathematical models, especially in fluid flow. Consider a fluid
flowing between two flat, parallel plates. The velocity is
uni-directional, say along the \( z \) axis, and depends only on the
distance \( x \) from the plates; \( \u = u(x,t)\kk \).  The flow is governed
by the Navier-Stokes equations,

$$
\begin{align*}
\varrho\frac{\partial\u}{\partial t} + \varrho\u\cdot\nabla\u &= -\nabla p
+ \mu\nabla^2\u + \varrho\f,\\ 
\nabla\cdot\u &= 0,
\end{align*}
$$

where \( p \) is the pressure field, unknown along with the velocity \( \u \),
\( \varrho \) is the fluid density, \( \mu \) the dynamic viscosity, and \( \f \)
is some external body force. The geometric restrictions of flow between
two flat plates puts restrictions on the velocity, \( \u = u(x,t)\ii \),
and the \( z \) component of the Navier-Stokes equations collapses to
a diffusion equation:

$$
\varrho\frac{\partial u}{\partial t} = - \frac{\partial p}{\partial z} +
\mu\frac{\partial^2 u}{\partial z^2}
+ \varrho f_z,
$$

if \( f_z \) is the component of \( \f \) in the \( z \) direction.

<p>
The boundary conditions are derived from the fact that the fluid sticks to
the plates, which means \( \u=0 \) at the plates. Say the location of the
plates are \( z=0 \) and \( z=L \). We then have

$$ u(0,t)=u(L,t)=0\tp$$

<p>
One can easily show that \( \partial p/\partial z \) must be a constant or
just a function of time \( t \). We set \( \partial p/\partial z = -\beta(t) \).
The body force could be a component of gravity, if desired, set as
\( f_z = \gamma g \). Switching from \( z \) to \( x \) as independent variable gives
a very standard one-dimensional diffusion equation:

$$
\varrho\frac{\partial u}{\partial t} =
\mu\frac{\partial^2 u}{\partial x^2} + \beta(t) + \varrho\gamma g,\quad
x\in [0,L],\ t\in (0,T]\tp
$$

The boundary conditions are

$$ u(0,t)=u(L,t)=0,$$

while some initial condition

$$ u(x,0) = I(x)$$

must also be prescribed.

<p>
The flow is driven by either the pressure gradient \( \beta \) or gravity, or
a combination of both. One may also consider one moving plate that
drives the fluid. If the plate at \( x=L \) moves with velocity \( U_L(t) \), we have
the adjusted boundary condition

$$ u(L,t) = U_L(t)\tp$$

<h2 id="diffu:app:pipeflow">Flow in a straight tube</h2>

<p>
Now we consider viscous fluid flow in a straight tube with radius \( R \)
and rigid walls.
The governing equations are the Navier-Stokes equations, but as
in the section <a href="#diffu:app:Couette">Development of flow between two flat plates</a>, it is natural to assume that the
velocity is directed along the tube, and that it is axi-symmetric.
These assumptions reduced the velocity field to \( \u = u(r,x,t)\ii \), if the
\( x \) axis is directed along the tube. From the equation of continuity,
\( \nabla\cdot\u = 0 \), we see that \( u \) must be independent of \( x \).
Inserting \( \u = u(r,t)\ii \) in the Navier-Stokes equations, expressed
in axi-symmetric cylindrical coordinates, results in

$$
\begin{equation}
\varrho\frac{\partial u}{\partial t} =
\mu\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) + \beta(t) + \varrho\gamma g,\quad
r\in [0,R],\ t\in (0,T]\tp
\tag{130}
\end{equation}
$$

Here, \( \beta(t) = -\partial p/\partial x \) is the pressure gradient along
the tube. The associated boundary condition is \( u(R,t)=0 \).

<h2 id="___sec122">Tribology: thin film fluid flow </h2>

<p>
Thin fluid films are extremely important inside machinery to reduce friction
between gliding surfaces. The mathematical model for the fluid motion takes
the form of a diffusion problem and is quickly derived here.
We consider two solid surfaces whose distance is described by a
gap function \( h(x,y) \). The space between these surfaces is filled with
a fluid with dynamic viscosity \( \mu \). The fluid may move partially
because of pressure gradients and partially because the surfaces
move. Let \( U\ii + V\jj \) be the relative velocity of the two surfaces and
\( p \) the pressure in the fluid. The mathematical model builds on two
principles: 1) conservation of mass, 2) assumption of locally quasi-static
flow between flat plates.

<p>
The conservation of mass equation reads \( \nabla\cdot\u \), where \( \u \) is
the local fluid velocity. For thin films the detailed variation between
the surfaces is not of interest, so \( \nabla\cdot\u = 0 \) is integrated
(average) in the direction perpendicular to the surfaces. This gives
rise to the alternative mass conservation equation

$$ \nabla\cdot\q = 0,\quad \q = \int\limits_0^{h(x,y)}\u dz,$$

where \( z \) is the coordinate perpendicular to the surfaces, and \( \q \)
is then the volume flux in the fluid gap.

<p>
Locally, we may assume that we have steady flow between two flat
surfaces, with a pressure gradient and where the lower surface is at rest
and the upper moves with velocity \( U\ii + V\jj \).
The corresponding mathematical problem is actually the limit problem
in the section <a href="#diffu:app:Couette">Development of flow between two flat plates</a> as \( t\rightarrow\infty \). The limit
problem can be solved analytically, and the local volume flux becomes

$$ \q(x,y,z) = \int\limits_0^{h}\u(x,y,z) dz
= -\frac{h^3}{12\mu}\nabla p + \half Uh\ii + \half Vh\jj\tp$$

The idea is to use this expression locally
also when the surfaces are not flat,
but slowly varying, and if \( U \), \( V \), or \( p \) varies in time, provided the
time variation is sufficiently slow. This is a common quasi-static
approximation, much used in mathematical modeling.

<p>
Inserting the expression for \( \q \) via \( p \), \( U \), and \( V \) in the
equation \( \nabla\q = 0 \) gives a diffusion PDE for \( p \):

$$
\begin{equation}
\nabla\cdot\left(\frac{h^3}{12\mu}\nabla p\right) =
\half\frac{\partial}{\partial x}(hU)
+ \half\frac{\partial}{\partial x}(hV)\tp
\tag{131}
\end{equation}
$$

The boundary conditions must involve \( p \) or \( \q \) at the boundary.

<h2 id="___sec123">Propagation of electrical signals in the brain </h2>

<p>
<!-- <a href="http://icwww.epfl.ch/~gerstner/SPNM/node17.html" target="_self"><tt>http://icwww.epfl.ch/~gerstner/SPNM/node17.html</tt></a> -->
<!-- <a href="http://www.uio.no/studier/emner/matnat/ifi/INF5610/h09/Lecture04.pdf" target="_self"><tt>http://www.uio.no/studier/emner/matnat/ifi/INF5610/h09/Lecture04.pdf</tt></a> -->
<!-- <a href="http://people.mbi.ohio-state.edu/schwemmer.2/Publications/Schwemmer_Dissertation_Final.pdf" target="_self"><tt>http://people.mbi.ohio-state.edu/schwemmer.2/Publications/Schwemmer_Dissertation_Final.pdf</tt></a> -->
<!-- The book by Peskin & ... -->

<p>
One can make a model of how electrical signals are propagated along the
neuronal fibers that receive synaptic inputs in the brain. The signal
propagation is one-dimensional and can, in the simplest cases, be
governed by the <a href="http://en.wikipedia.org/wiki/Cable_equation" target="_self">Cable equation</a>:

$$
\begin{equation}
c_m \frac{\partial V}{\partial t} =
\frac{1}{r_l}\frac{\partial^2 V}{\partial x^2} - \frac{1}{r_m}V
\label{}
\end{equation}
$$

where \( V(x,t) \) is the voltage to be determined,
\( c_m \) is capacitance of the neuronal fiber, while
\( r_l \) and \( r_m \) are measures of the resistance.
The boundary conditions are often taken as \( V=0 \) at a short circuit or open end,
\( \partial V/\partial x=0 \) at a sealed end, or \( \partial V/\partial x \propto
V \) where there is an injection of current.

<h1 id="___sec124">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:CN:Rannacher">Exercise 6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</h2>

<p>
It is well known that the Crank-Nicolson method may give rise to
non-physical oscillations in the solution of diffusion equations
if the initial data exhibit jumps (see the section <a href="#diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</a>).
Rannacher <a href="._diffu-sol002.html#Rannacher_1984">[11]</a> suggested a stabilizing technique
consisting of using the Backward Euler scheme for the first two
time steps with step length \( \half\Delta t \). One can generalize
this idea to taking \( 2m \) time steps of size \( \half\Delta t \) with
the Backward Euler method and then continuing with the
Crank-Nicolson method, which is of second-order in time.
The idea is that the high frequencies of the initial solution are
quickly damped out, and the Backward Euler scheme treats these
high frequencies correctly. Thereafter, the high frequency content of
the solution is gone and the Crank-Nicolson method will do well.

<p>
Test this idea for \( m=1,2,3 \) on a diffusion problem with a
discontinuous initial condition. Measure the convergence rate using
the solution <a href="#mjx-eqn-45">(45)</a> with the boundary
conditions
<a href="#mjx-eqn-46">(46)</a>-<a href="#mjx-eqn-47">(47)</a>
for \( t \) values such that the conditions are in the vicinity of \( \pm 1 \).
For example, \( t < 5a 1.6\cdot 10^{-2} \) makes the solution diffusion from
a step to almost a straight line. The
program <code>diffu_erf_sol.py</code> shows how to compute the analytical
solution.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:energy:estimates">Project 7: Energy estimates for diffusion problems</h2>

<p>
This project concerns so-called <em>energy estimates</em> for diffusion problems
that can be used for qualitative analytical insight and for
verification of implementations.

<p>
<b>a)</b>
We start with a 1D homogeneous diffusion equation with zero Dirichlet
conditions:

$$
\begin{alignat}{2}
u_t &= \alpha u_xx, & x\in \Omega =(0,L),\ t\in (0,T],
\tag{132} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{133}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{134}
\tp
\end{alignat}
$$

The energy estimate for this problem reads

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2},
\tag{135}
\end{equation}
$$

where the \( ||\cdot ||_{L^2} \) norm is defined by

$$
\begin{equation}
||g||_{L^2} = \sqrt{\int_0^L g^2dx}\tp
\tag{136}
\end{equation}
$$

The quantify  \( ||u||_{L^2} \) or \( \half ||u||_{L^2} \) is known
as the <em>energy</em> of the solution, although it is not the physical
energy of the system. A mathematical tradition has introduced the
notion <em>energy</em> in this context.

<p>
The estimate <a href="#mjx-eqn-135">(135)</a> says that the
&quot;size of $u$&quot; never exceeds that of the initial condition,
or more precisely, it says that the area under the \( u \) curve decreases
with time.

<p>
To show <a href="#mjx-eqn-135">(135)</a>, multiply the PDE
by \( u \) and integrate from \( 0 \) to \( L \). Use that \( uu_t \) can be
expressed as the time derivative of \( u^2 \) and that \( u_xxu \) can
integrated by parts to form an integrand \( u_x^2 \). Show that
the time derivative of \( ||u||_{L^2}^2 \) must be less than or equal
to zero. Integrate this expression and derive
<a href="#mjx-eqn-135">(135)</a>.

<p>
<!-- <a href="http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf" target="_self"><tt>http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf</tt></a> -->

<p>
<b>b)</b>
Now we address a slightly different problem,

$$
\begin{alignat}{2}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{137} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{138}\\ 
u(x,0) &= 0, & x\in [0,L]
\tag{139}
\tp
\end{alignat}
$$

The associated energy estimate is

$$
\begin{equation}
||u||_{L^2} \leq ||f||_{L^2}\tp
\tag{140}
\end{equation}
$$

(This result is more difficult to derive.)

<p>
Now consider the compound problem with an initial condition \( I(x) \) and
a right-hand side \( f(x,t) \):

$$
\begin{alignat}{2}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{141} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{142}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{143}
\tp
\end{alignat}
$$

Show that if \( w_1 \) fulfills
<a href="#mjx-eqn-132">(132)</a>-<a href="#mjx-eqn-134">(134)</a>
and \( w_2 \) fulfills
<a href="#mjx-eqn-137">(137)</a>-<a href="#mjx-eqn-139">(139)</a>,
then \( u=w_1 + w_2 \) is the solution of
<a href="#mjx-eqn-141">(141)</a>-<a href="#mjx-eqn-143">(143)</a>.
Using the triangle inequality for norms,

$$ ||a + b|| \leq ||a|| + ||b||,$$

show that the energy estimate for
<a href="#mjx-eqn-141">(141)</a>-<a href="#mjx-eqn-143">(143)</a>
becomes

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2} + ||f||_{L^2}\tp
\tag{144}
\end{equation}
$$

<p>
<b>c)</b>
One application of <a href="#mjx-eqn-144">(144)</a> is to prove uniqueness
of the solution.
Suppose \( u_1 \) and \( u_2 \) both fulfill
<a href="#mjx-eqn-141">(141)</a>-<a href="#mjx-eqn-143">(143)</a>.
Show that \( u=u_1 - u_2 \) then fulfills
<a href="#mjx-eqn-141">(141)</a>-<a href="#mjx-eqn-143">(143)</a>
with \( f=0 \) and \( I=0 \). Use <a href="#mjx-eqn-144">(144)</a>
to deduce that the energy must be zero for all times and therefore
that \( u_1=u_2 \), which proves that the solution is unique.

<p>
<b>d)</b>
Generalize <a href="#mjx-eqn-144">(144)</a> to a 2D/3D
diffusion equation \( u_t = \nabla\cdot (\alpha \nabla u) \) for \( x\in\Omega \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_7_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_7_1">

<p>
Use integration by parts in multi dimensions:

$$ \int_\Omega u \nabla\cdot (\alpha\nabla u)\dx =
- \int_\Omega \alpha \nabla u\cdot\nabla u\dx
+ \int_{\partial\Omega} u \alpha\frac{\partial u}{\partial n},$$

where \( \frac{\partial u}{\partial n} = \boldsymbol{n}\cdot\nabla u \),
\( \boldsymbol{n} \) being the outward unit normal to the boundary \( \partial\Omega \)
of the domain \( \Omega \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Now we also consider the multi-dimensional PDE \( u_t =
\nabla\cdot (\alpha \nabla u) \). Integrate both sides over \( \Omega \)
and use Gauss' divergence theorem, \( \int_\Omega \nabla\cdot\boldsymbol{q}\dx
= \int_{\partial\Omega}\boldsymbol{q}\cdot\boldsymbol{n}\ds \) for a vector field
\( \boldsymbol{q} \). Show that if we have homogeneous Neumann conditions
on the boundary, \( \partial u/\partial n=0 \), area under the
\( u \) surface remains constant in time and

$$
\begin{equation}
\int_{\Omega} u\dx = \int_{\Omega} I\dx
\tp
\tag{145}
\end{equation}
$$

<p>
<b>f)</b>
Establish a code in 1D, 2D, or 3D that can solve a diffusion equation with a
source term \( f \), initial condition \( I \), and zero Dirichlet or
Neumann conditions on the whole boundary.

<p>
We can use <a href="#mjx-eqn-144">(144)</a>
and <a href="#mjx-eqn-145">(145)</a> as a partial verification
of the code. Choose some functions \( f \) and \( I \) and
check that <a href="#mjx-eqn-144">(144)</a> is obeyed at any
time when zero Dirichlet conditions are used.
Iterate over the same \( I \) functions and check that
<a href="#mjx-eqn-145">(145)</a> is fulfilled
when using zero Neumann conditions.

<p>
<b>g)</b>
Make a list of some possible bugs in the code, such as indexing errors
in arrays, failure to set the correct boundary conditions,
evaluation of a term at a wrong time level, and similar.
For each of the bugs, see if the verification tests from the previous
subexercise pass or fail. This investigation shows how strong
the energy estimates and the estimate <a href="#mjx-eqn-145">(145)</a>
are for pointing out errors in the implementation.

<p>
Filename: <code>diffu_energy</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:splitting_prec">Exercise 8: Splitting methods and preconditioning</h2>

<p>
In the section <a href="#diffu:2D:direct_vs_iter">Direct versus iterative methods</a>, we outlined a class of
iterative methods for \( Au=b \) based on splitting \( A \) into \( A=M-N \)
and introducing the iteration

$$ Mu^{k} = Nu^k + b\tp$$

The very simplest splitting is \( M=I \), where \( I \) is the identity
matrix. Show that this choice corresponds to the iteration

$$
\begin{equation}
u^k = u^{k-1} + r^{k-1},\quad r^{k-1} = b - Au^{k-1},
\tag{146}
\end{equation}
$$

where \( r^{k-1} \) is the residual in the linear system in iteration
\( k-1 \). The formula <a href="#mjx-eqn-146">(146)</a> is known
as Richardson's iteration.
Show that if we apply the simple iteration method
<a href="#mjx-eqn-146">(146)</a> to the <em>preconditioned</em>
system \( M^{-1}Au=M^{-1}b \), we arrive at the Jacobi method by choosing
\( M=D \) (the diagonal of \( A \)) as preconditioner and the SOR method by
choosing \( M=\omega^{-1}D + L \) (\( L \) being the lower triangular part of
\( A \)).  This equivalence shows that we can apply one iteration of the
Jacobi or SOR method as preconditioner.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_8_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_8_1">

<p>
Inserting \( M=I \) and \( N=I-A \) in the iterative method leads to

$$ u^{k} = (I-A)u^{k-1} + b = u^{k-1} + (b  - Au^{k-1}),$$

which is <a href="#mjx-eqn-146">(146)</a>.
Replacing \( A \) by \( M^{-1}A \) and \( b \) by \( M^{-1}b \) in this equation
gives

$$ u^k = u^{k-1} + M^{-1}r^{k-1},\quad r^{k-1}=b-Au^{k-1},$$

which we after multiplication by \( M \) and reordering can write
as

$$ Mu^k = (M-A)u^{k-1} + b = Nu^{k-1} + b,$$

which is the standard form for the Jacobi and SOR methods. Choosing \( M=D \)
gives Jacobi and \( M=\omega^{-1}D+L \) gives SOR. We have shown that we may
view \( M \) as a preconditioner of a simplest possible iteration method.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:earthosc">Problem 9: Oscillating surface temperature of the earth</h2>

<p>
Consider a day-and-night or seasonal variation in temperature at
the surface of the earth. How deep down in the ground will the
surface oscillations reach? For simplicity, we model only the
vertical variation along a coordinate \( x \), where \( x=0 \) at the
surface, and \( x \) increases as we go down in the ground.
The temperature is governed by the heat equation

$$ \varrho c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T),$$

in some spatial domain \( x\in [0,L] \), where \( L \) is chosen large enough such
that we can assume that \( T \) is approximately constant, independent of the surface
oscillations, for \( x>L \). The parameters \( \varrho \), \( c_v \), and \( k \) are the
density, the specific heat capacity at constant volume, and the
heat conduction coefficient, respectively.

<p>
<b>a)</b>
Derive the mathematical model for computing \( T(x,t) \).
Assume the surface oscillations to be sinusoidal around some mean
temperature \( T_m \). Let \( T=T_m \) initially. At \( x=L \), assume \( T\approx T_m \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_9_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_9_1">

<p>
The surface temperature is set as

$$ T(0,t) = T_m + A\sin(\omega t)\tp$$

With only one &quot;active&quot; spatial coordinate we get the initial-boundary
value problem

$$
\begin{alignat*}{2}
\varrho c_v \frac{\partial T}{\partial t} &= \frac{\partial}{\partial x}
\left(k(x)\frac{\partial T}{\partial x}\right), & x\in (0,L),\ t\in (0,T],\\ 
T(x,0)&= T_m, & x\in [0,L],\\ 
T(0,t)&= T_m + A\sin(\omega t), & t\in (0,T],\\ 
T(L,t) &= T_m, & t\in (0,T].
\end{alignat*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Scale the model in a) assuming \( k \) is constant. Use a time scale
\( t_c = \omega^{-1} \) and a length scale \( x_c = \sqrt{2\dfc/\omega} \),
where \( \dfc = k/(\varrho c_v) \). The primary unknown can be scaled
as \( \frac{T-T_m}{2A} \).

<p>
Show that the scaled PDE is

$$
\frac{\partial u}{\partial \bar t} =
\frac{1}{2}\frac{\partial^2 u}{\partial x^2},$$

with initial condition \( u(\bar x,0) = 0 \),
left boundary condition
\( u(0,\bar t)  = \sin(\bar t) \),
and right boundary condition
\( u(\bar L,\bar t)  = 0 \). The bar indicates a dimensionless quantity.

<p>
Show that \( u(\bar x, \bar t)=e^{-\bar x}\sin (\bar x - \bar t) \) is a
solution that fulfills the PDE and the boundary condition at \( \bar x
=0 \) (this is the solution we will experience as \( \bar
t\rightarrow\infty \) and \( L\rightarrow\infty \)).  Conclude that an
appropriate domain for \( x \) is \( [0,4] \) if a damping \( e^{-4}\approx
0.18 \) is appropriate for implementing \( \bar u\approx\hbox{const} \);
increasing to \( [0,6] \) damps \( \bar u \) to 0.0025.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_9_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_9_2">

<p>
Chapter 3.2.4 in the book <a href="._diffu-sol002.html#Langtangen_scaling">[4]</a> describes the
scaling of this problem in detail.
Inserting dimensionless variables \( \bar t = \omega t \), \( \bar x =
\sqrt{\omega/(2\dfc)} x \), and

$$ u = \frac{T-T_m}{2A},$$

leads to

$$
\begin{alignat*}{2}
\frac{\partial u}{\partial \bar t} &=
\frac{1}{2}\frac{\partial^2 u}{\partial x^2},
\quad & \bar x\in (0,\bar L),\ \bar t\in (0,\bar T],
\\ 
u(\bar x,0) &= 0,
\quad &\bar x\in [0,1],
\\ 
u(0,\bar t) & = \sin(\bar t),
\quad  &\bar t\in (0,\bar T],
\\ 
u(\bar L,\bar t) & = 0,
\quad &\bar t\in (0,\bar T].
\end{alignat*}
$$

The domain lengths \( \bar L \) and \( \bar T \) follows from straightforward
scaling of \( L \) and \( T \).

<p>
Inserting \( u(\bar x, \bar t)=e^{-\bar x}\sin (\bar t - \bar x) \) in the
PDE shows that this is a solution. It also obeys
the boundary condition \( \bar u(0,\bar t)=sin(\bar t) \). As
\( \bar t\rightarrow\infty \), the initial condition has no longer impact
on the solution and is &quot;forgotten&quot; and of no interest.
The boundary condition at \( \bar x=\bar L \) is never compatible with the
given solution unless \( \bar u \) is damped to zero, which happens
mathematically as \( \bar L\rightarrow\infty \). For a numerical solution,
however, we may use a small finite value such as \( \bar L=4 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Compute the scaled temperature and make animations comparing two solutions
with \( \bar L=4 \) and \( \bar L=8 \), respectively (keep \( \Delta x \) the same).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_9_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_9_3">

<p>
We can use the <code>viz</code> function in <code>diff1D_vc.py</code> to do the number
crunching. Appropriate calls and visualization go here:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(os<span style="color: #666666">.</span>pardir, <span style="color: #BA2121">&#39;src-diffu&#39;</span>))
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">diffu1D_vc</span> <span style="color: #008000; font-weight: bold">import</span> viz

sol <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># store solutions</span>
<span style="color: #008000; font-weight: bold">for</span> Nx, L <span style="color: #AA22FF; font-weight: bold">in</span> [[<span style="color: #666666">20</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">40</span>, <span style="color: #666666">8</span>]]:
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    dx <span style="color: #666666">=</span> <span style="color: #008000">float</span>(L)<span style="color: #666666">/</span>Nx
    D <span style="color: #666666">=</span> dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    T <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">*6</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros
    a <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>
    cpu, u_ <span style="color: #666666">=</span> viz(
        I<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">0</span>, a<span style="color: #666666">=</span>a, L<span style="color: #666666">=</span>L, Nx<span style="color: #666666">=</span>Nx, D<span style="color: #666666">=</span>D, T<span style="color: #666666">=</span>T,
        umin<span style="color: #666666">=-1.1</span>, umax<span style="color: #666666">=1.1</span>, theta<span style="color: #666666">=0.5</span>,
        u_L<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: sin(t),
        u_R<span style="color: #666666">=0</span>,
        animate<span style="color: #666666">=</span><span style="color: #008000">False</span>, store_u<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    sol<span style="color: #666666">.</span>append(u_)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;computed solution for Nx=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> in [0,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">]&#39;</span> <span style="color: #666666">%</span> (Nx, L)

<span style="color: #008000; font-weight: bold">print</span> sol[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>shape
<span style="color: #008000; font-weight: bold">print</span> sol[<span style="color: #666666">1</span>]<span style="color: #666666">.</span>shape
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> u0, u1 <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(sol[<span style="color: #666666">0</span>][<span style="color: #666666">2</span>:], sol[<span style="color: #666666">1</span>][<span style="color: #666666">2</span>:]):
    x0 <span style="color: #666666">=</span> sol[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]
    x1 <span style="color: #666666">=</span> sol[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]
    plt<span style="color: #666666">.</span>plot(x0, u0, <span style="color: #BA2121">&#39;r-&#39;</span>, x1, u1, <span style="color: #BA2121">&#39;b-&#39;</span>,
             legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;short&#39;</span>, <span style="color: #BA2121">&#39;long&#39;</span>],
             savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> counter,
             axis<span style="color: #666666">=</span>[x1[<span style="color: #666666">0</span>], x1[<span style="color: #666666">-1</span>], <span style="color: #666666">-1.1</span>, <span style="color: #666666">1.1</span>])
    counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
</pre></div>
<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:bloodflow">Problem 10: Oscillating and pulsating flow in tubes</h2>

<p>
We consider flow in a straight tube with radius \( R \) and straight walls.
The flow is driven by a pressure gradient \( \beta(t) \). The effect of
gravity can be neglected. The mathematical problem reads

$$
\begin{alignat}{2}
\varrho\frac{\partial u}{\partial t} &=
\mu\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) + \beta(t),\quad
& r\in [0,R],\ t\in (0,T],\\ 
u(r,0) &= I(r),\quad & r\in [0,R],\\ 
u(R,t) &= 0,\quad & t\in (0,T],\\ 
\frac{\partial u}{\partial r}(0,t) &= 0,\quad & t\in (0,T].
\end{alignat}
$$

We consider two models for \( \beta(t) \). One plain, sinusoidal oscillation:

$$
\begin{equation}
\beta = A\sin(\omega t),
\tag{147}
\end{equation}
$$

and one with periodic pulses,

$$
\begin{equation}
\beta = A\sin^{16}(\omega t),
\tag{148}
\end{equation}
$$

Note that both models can be written as \( \beta = A\sin^m(\omega t) \), with
\( m=1 \) and \( m=16 \), respectively.

<p>
<b>a)</b>
Scale the mathematical model, using the viscous time scale \( \varrho R^2/\mu \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_2">

<p>
We can introduce

$$ \bar r = \frac{r}{R}, \quad \bar t = \frac{t}{\varrho R^2/\mu},\quad u = \frac{u}{u_c}\tp$$

Inserted in the PDE, we get

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{1}{\bar r}\frac{\partial}{\partial\bar r}\left(
\bar r\frac{\partial\bar u}{\partial\bar r}\right) +
\frac{R^2 A}{u_c \mu}\sin^m (\alpha\bar t)
$$

where \( \alpha \) is a dimensionless number

$$  \alpha = \frac{\omega\varrho R^2}{\mu} = \frac{\varrho R^2/\mu}{1/\omega},
$$

reflecting the ratio of the viscous diffusion time scale and the
time scale of the oscillating pressure gradient.
We may choose \( u_c \) such that the coefficient in the pressure gradient
term equals unity:

$$ u_c = \frac{R^2 A}{\mu}\tp$$

The governing PDE, dropping the bars, then reads

$$ \frac{\partial u}{\partial t} =
\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) +
\sin^m (\alpha\bar t),\quad r\in (0,1),\ t\in (0,T]\tp
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Implement the scaled model from a), using the unifying \( \theta \) scheme
in time and centered differences in space.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_3">

<p>
We need to take into account extensions below: a coefficient in front of
the viscous term, and an extra source term.

<p>
A preliminary and unfinished code:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">Solve the diffusion equation for axi-symmetric case:</span>

<span style="color: #BA2121; font-style: italic">    u_t = 1/r * (r*a(r)*u_r)_r + f(r,t)</span>

<span style="color: #BA2121; font-style: italic">on (0,R) with boundary conditions u(0,t)_r = 0 and u(R,t) = 0,</span>
<span style="color: #BA2121; font-style: italic">for t in (0,T]. Initial condition: u(r,0) = I(r). </span>
<span style="color: #BA2121; font-style: italic">Pressure gradient f.</span>

<span style="color: #BA2121; font-style: italic">The following naming convention of variables are used.</span>

<span style="color: #BA2121; font-style: italic">===== ==========================================================</span>
<span style="color: #BA2121; font-style: italic">Name  Description</span>
<span style="color: #BA2121; font-style: italic">===== ==========================================================</span>
<span style="color: #BA2121; font-style: italic">Nx    The total number of mesh cells; mesh points are numbered</span>
<span style="color: #BA2121; font-style: italic">      from 0 to Nx.</span>
<span style="color: #BA2121; font-style: italic">T     The stop time for the simulation.</span>
<span style="color: #BA2121; font-style: italic">I     Initial condition (Python function of x).</span>
<span style="color: #BA2121; font-style: italic">a     Variable coefficient (constant).</span>
<span style="color: #BA2121; font-style: italic">R     Length of the domain ([0,R]).</span>
<span style="color: #BA2121; font-style: italic">r     Mesh points in space.</span>
<span style="color: #BA2121; font-style: italic">t     Mesh points in time.</span>
<span style="color: #BA2121; font-style: italic">n     Index counter in time.</span>
<span style="color: #BA2121; font-style: italic">u     Unknown at current/new time level.</span>
<span style="color: #BA2121; font-style: italic">u_1   u at the previous time level.</span>
<span style="color: #BA2121; font-style: italic">dr    Constant mesh spacing in r.</span>
<span style="color: #BA2121; font-style: italic">dt    Constant mesh spacing in t.</span>
<span style="color: #BA2121; font-style: italic">===== ==========================================================</span>

<span style="color: #BA2121; font-style: italic">``user_action`` is a function of ``(u, r, t, n)``, ``u[i]`` is the</span>
<span style="color: #BA2121; font-style: italic">solution at spatial mesh point ``r[i]`` at time ``t[n]``, where the</span>
<span style="color: #BA2121; font-style: italic">calling code can add visualization, error computations, data analysis,</span>
<span style="color: #BA2121; font-style: italic">store solutions, etc.</span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, zeros, random, array, ones, <span style="color: #008000">sum</span>, log, sqrt
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">sys</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>    


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_theta</span>(I, a, R, Nr, D, T, theta<span style="color: #666666">=0.5</span>, u_L<span style="color: #666666">=</span><span style="color: #008000">None</span>, u_R<span style="color: #666666">=0</span>,
                 user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, f<span style="color: #666666">=0</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    The array a has length Nr+1 and holds the values of</span>
<span style="color: #BA2121; font-style: italic">    a(x) at the mesh points.</span>

<span style="color: #BA2121; font-style: italic">    Method: (implicit) theta-rule in time.</span>

<span style="color: #BA2121; font-style: italic">    Nr is the total number of mesh cells; mesh points are numbered</span>
<span style="color: #BA2121; font-style: italic">    from 0 to Nr.</span>
<span style="color: #BA2121; font-style: italic">    D = dt/dr**2 and implicitly specifies the time step.</span>
<span style="color: #BA2121; font-style: italic">    T is the stop time for the simulation.</span>
<span style="color: #BA2121; font-style: italic">    I is a function of r.</span>
<span style="color: #BA2121; font-style: italic">    u_L = None implies du/dr = 0, i.e. a symmetry condition </span>
<span style="color: #BA2121; font-style: italic">    f(r,t) is pressure gradient with radius.</span>

<span style="color: #BA2121; font-style: italic">    user_action is a function of (u, x, t, n) where the calling code</span>
<span style="color: #BA2121; font-style: italic">    can add visualization, error computations, data analysis,</span>
<span style="color: #BA2121; font-style: italic">    store solutions, etc.</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">    r*alpha is needed midway between spatial mesh points, - use</span>
<span style="color: #BA2121; font-style: italic">    arithmetic mean of successive mesh values (i.e. of r_i*alpha_i)</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()

    r <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, R, Nr<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
    dr <span style="color: #666666">=</span> r[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> r[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> D<span style="color: #666666">*</span>dr<span style="color: #666666">**2</span>   
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>

    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(u_L, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
        u_L_ <span style="color: #666666">=</span> <span style="color: #008000">float</span>(u_L)  <span style="color: #408080; font-style: italic"># must take copy of u_L number</span>
        u_L <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: u_L_
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(u_R, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
        u_R_ <span style="color: #666666">=</span> <span style="color: #008000">float</span>(u_R)  <span style="color: #408080; font-style: italic"># must take copy of u_R number</span>
        u_R <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: u_R_
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(f, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
        f_ <span style="color: #666666">=</span> <span style="color: #008000">float</span>(f)  <span style="color: #408080; font-style: italic"># must take copy of f number</span>
        f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> r, t: f_

    ra <span style="color: #666666">=</span> r<span style="color: #666666">*</span>a    <span style="color: #408080; font-style: italic"># help array in scheme</span>

    inv_r <span style="color: #666666">=</span> zeros(<span style="color: #008000">len</span>(r)<span style="color: #666666">-2</span>)    <span style="color: #408080; font-style: italic"># needed for inner mesh points</span>
    inv_r <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>r[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]

    u   <span style="color: #666666">=</span> zeros(Nr<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array at t[n+1]</span>
    u_1 <span style="color: #666666">=</span> zeros(Nr<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t[n]</span>

    Dl <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>theta
    Dr <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)

    <span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
    diagonal <span style="color: #666666">=</span> zeros(Nr<span style="color: #666666">+1</span>)
    lower    <span style="color: #666666">=</span> zeros(Nr)
    upper    <span style="color: #666666">=</span> zeros(Nr)
    b        <span style="color: #666666">=</span> zeros(Nr<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Precompute sparse matrix (scipy format)</span>
    diagonal[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> Dl<span style="color: #666666">*</span>(ra[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>ra[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> ra[:<span style="color: #666666">-2</span>])<span style="color: #666666">*</span>inv_r
    lower[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(ra[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> ra[:<span style="color: #666666">-2</span>])<span style="color: #666666">*</span>inv_r
    upper[<span style="color: #666666">1</span>:]  <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(ra[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> ra[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">*</span>inv_r
    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    <span style="color: #008000; font-weight: bold">if</span> u_L <span style="color: #666666">==</span> <span style="color: #008000">None</span>:     <span style="color: #408080; font-style: italic"># symmetry axis, du/dr = 0</span>
        diagonal[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">8*</span>a[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>Dl
        upper[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">-8*</span>a[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>Dl
    <span style="color: #008000; font-weight: bold">else</span>:
        diagonal[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        upper[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    diagonal[Nr] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    lower[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
        diagonals<span style="color: #666666">=</span>[diagonal, lower, upper],
        offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>],
        shape<span style="color: #666666">=</span>(Nr<span style="color: #666666">+1</span>, Nr<span style="color: #666666">+1</span>),
        format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
    <span style="color: #408080; font-style: italic">#print A.todense()</span>

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nr<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(r[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_1, r, t, <span style="color: #666666">0</span>)

    <span style="color: #408080; font-style: italic"># Time loop</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        b[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> Dr<span style="color: #666666">*</span>(
            (ra[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> ra[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">*</span>(u_1[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">-</span>
            (ra[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> ra[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>])<span style="color: #666666">*</span>(u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> u_1[:<span style="color: #666666">-2</span>]))<span style="color: #666666">*</span>inv_r <span style="color: #666666">+</span> \
            dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>f(r[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>], t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \
            dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>f(r[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>], t[n])
            
        <span style="color: #408080; font-style: italic"># Boundary conditions</span>
        <span style="color: #008000; font-weight: bold">if</span> u_L <span style="color: #666666">==</span> <span style="color: #008000">None</span>:     <span style="color: #408080; font-style: italic"># symmetry axis, du/dr = 0</span>
            b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u_1[<span style="color: #666666">0</span>] <span style="color: #666666">+</span> <span style="color: #666666">8*</span>a[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>Dr<span style="color: #666666">*</span>(u_1[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> u_1[<span style="color: #666666">0</span>]) <span style="color: #666666">+</span> \
                   dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>f(<span style="color: #666666">0</span>, (n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \
                   dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>f(<span style="color: #666666">0</span>, n<span style="color: #666666">*</span>dt)
        <span style="color: #008000; font-weight: bold">else</span>:               
            b[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> u_L(t[n<span style="color: #666666">+1</span>])        
        b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_R(t[n<span style="color: #666666">+1</span>])
        <span style="color: #408080; font-style: italic">#print b        </span>
        
        <span style="color: #408080; font-style: italic"># Solve</span>
        u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
        
        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, r, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_1, u <span style="color: #666666">=</span> u, u_1

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #408080; font-style: italic"># return u_1, since u and u_1 are switched</span>
    <span style="color: #008000; font-weight: bold">return</span> u_1, t, t1<span style="color: #666666">-</span>t0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compute_rates</span>(h_values, E_values):
    m <span style="color: #666666">=</span> <span style="color: #008000">len</span>(h_values)
    q <span style="color: #666666">=</span> [log(E_values[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>E_values[i])<span style="color: #666666">/</span>
         log(h_values[i<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>h_values[i])
         <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, m<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)]
    q <span style="color: #666666">=</span> [<span style="color: #008000">round</span>(q_, <span style="color: #666666">2</span>) <span style="color: #008000; font-weight: bold">for</span> q_ <span style="color: #AA22FF; font-weight: bold">in</span> q]
    <span style="color: #008000; font-weight: bold">return</span> q

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">make_a</span>(alpha, r):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    alpha is a func, generally of r, - but may be constant.</span>
<span style="color: #BA2121; font-style: italic">    Note: when solution is to be axi-symmetric, alpha</span>
<span style="color: #BA2121; font-style: italic">    must be so too.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    a <span style="color: #666666">=</span> alpha(r)<span style="color: #666666">*</span>ones(<span style="color: #008000">len</span>(r))
    <span style="color: #008000; font-weight: bold">return</span> a

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tests_with_alpha_and_u_exact</span>():
    <span style="color: #BA2121; font-style: italic">&#39;&#39;&#39;</span>
<span style="color: #BA2121; font-style: italic">    Test solver performance when alpha is either const or </span>
<span style="color: #BA2121; font-style: italic">    a fu of r, combined with a manufactured sol u_exact </span>
<span style="color: #BA2121; font-style: italic">    that is either a fu of r only, or a fu of both r and t.</span>
<span style="color: #BA2121; font-style: italic">    Note: alpha and u_e are defined as symb expr here, since </span>
<span style="color: #BA2121; font-style: italic">    test_solver_symmetric needs to automatically generate </span>
<span style="color: #BA2121; font-style: italic">    the source term f. After that, test_solver_symmetric</span>
<span style="color: #BA2121; font-style: italic">    redefines alpha, u_e and f as num functions.</span>
<span style="color: #BA2121; font-style: italic">    &#39;&#39;&#39;</span>
    R, r, t <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;R r t&#39;</span>)

    <span style="color: #408080; font-style: italic"># alpha const ...</span>
    
    <span style="color: #408080; font-style: italic"># ue = const</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Testing with alpha = 1.5 and u_e = R**2 - r**2...&#39;</span>
    test_solver_symmetric(alpha<span style="color: #666666">=1.5</span>, u_exact<span style="color: #666666">=</span>R<span style="color: #666666">**2</span> <span style="color: #666666">-</span> r<span style="color: #666666">**2</span>)
    
    <span style="color: #408080; font-style: italic"># ue = ue(t)</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Testing with alpha = 1.5 and u_e = 5*t*(R**2 - r**2)...&#39;</span>
    test_solver_symmetric(alpha<span style="color: #666666">=1.5</span>, u_exact<span style="color: #666666">=5*</span>t<span style="color: #666666">*</span>(R<span style="color: #666666">**2</span> <span style="color: #666666">-</span> r<span style="color: #666666">**2</span>))
    
    <span style="color: #408080; font-style: italic"># alpha function of r ...</span>
    
    <span style="color: #408080; font-style: italic"># ue = const </span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Testing with alpha = 1 + r**2 and u_e = R**2 - r**2...&#39;</span>
    test_solver_symmetric(alpha<span style="color: #666666">=1+</span>r<span style="color: #666666">**2</span>, u_exact<span style="color: #666666">=</span>R<span style="color: #666666">**2</span> <span style="color: #666666">-</span> r<span style="color: #666666">**2</span>)
    
    <span style="color: #408080; font-style: italic"># ue = ue(t)</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Testing with alpha = 1+r**2 and u_e = 5*t*(R**2 - r**2)...&#39;</span>
    test_solver_symmetric(alpha<span style="color: #666666">=1+</span>r<span style="color: #666666">**2</span>, u_exact<span style="color: #666666">=5*</span>t<span style="color: #666666">*</span>(R<span style="color: #666666">**2</span> <span style="color: #666666">-</span> r<span style="color: #666666">**2</span>))



<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver_symmetric</span>(alpha, u_exact):
    <span style="color: #BA2121; font-style: italic">&#39;&#39;&#39;</span>
<span style="color: #BA2121; font-style: italic">    Test solver performance for manufactured solution</span>
<span style="color: #BA2121; font-style: italic">    given in the function u_exact. Parameter alpha is </span>
<span style="color: #BA2121; font-style: italic">    either a const or a function of r. In the latter </span>
<span style="color: #BA2121; font-style: italic">    case, an &quot;exact&quot; sol can not be achieved, so then</span>
<span style="color: #BA2121; font-style: italic">    testing switches to conv. rates.</span>
<span style="color: #BA2121; font-style: italic">    R is tube radius and T is duration of simulation.</span>
<span style="color: #BA2121; font-style: italic">    alpha constant:</span>
<span style="color: #BA2121; font-style: italic">        Compares the manufactured solution with the </span>
<span style="color: #BA2121; font-style: italic">        solution from the solver at each time step. </span>
<span style="color: #BA2121; font-style: italic">    alpha function of r:</span>
<span style="color: #BA2121; font-style: italic">        convergence rates are tested (using the sol</span>
<span style="color: #BA2121; font-style: italic">        at the final point in time only).</span>
<span style="color: #BA2121; font-style: italic">    &#39;&#39;&#39;</span>   
    
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compare</span>(u, r, t, n):      <span style="color: #408080; font-style: italic"># user_action function</span>
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compare exact and computed solution.&quot;&quot;&quot;</span>
        u_e <span style="color: #666666">=</span> u_exact(r, t[n])
        diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
        <span style="color: #408080; font-style: italic">#print diff</span>
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-12</span>
        <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">pde_source_term</span>(a, u):
        <span style="color: #BA2121; font-style: italic">&#39;&#39;&#39;Return the terms in the PDE that the source term</span>
<span style="color: #BA2121; font-style: italic">        must balance, here du/dt - (1/r) * d/dr(r*a*du/dr).</span>
<span style="color: #BA2121; font-style: italic">        a, i.e. alpha, is either const or a fu of r.</span>
<span style="color: #BA2121; font-style: italic">        u is a symbolic Python function of r and t.&#39;&#39;&#39;</span>
        
        <span style="color: #008000; font-weight: bold">return</span> sym<span style="color: #666666">.</span>diff(u, t) <span style="color: #666666">-</span> \
               (<span style="color: #666666">1.0/</span>r)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(r<span style="color: #666666">*</span>a<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, r), r)
               
    R, r, t <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;R r t&#39;</span>)

    <span style="color: #408080; font-style: italic"># fit source term</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(pde_source_term(alpha, u_exact))  

    R <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>     <span style="color: #408080; font-style: italic"># radius of tube</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>     <span style="color: #408080; font-style: italic"># duration of simulation </span>
   
    <span style="color: #008000; font-weight: bold">if</span> sym<span style="color: #666666">.</span>diff(alpha, r) <span style="color: #666666">==</span> <span style="color: #666666">0</span>:  
        alpha_is_const <span style="color: #666666">=</span> <span style="color: #008000">True</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        alpha_is_const <span style="color: #666666">=</span> <span style="color: #008000">False</span>        

    <span style="color: #408080; font-style: italic"># make alpha, f and u_exact numerical functions</span>
    alpha <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([r], alpha, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)             
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([r, t], f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;R&#39;</span>, R), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)             
    u_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
        [r, t], u_exact<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;R&#39;</span>, R), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)             

    I <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> r: u_exact(r, <span style="color: #666666">0</span>)

    <span style="color: #408080; font-style: italic"># some help variables</span>
    FE <span style="color: #666666">=</span> <span style="color: #666666">0</span>      <span style="color: #408080; font-style: italic"># Forward Euler method</span>
    BE <span style="color: #666666">=</span> <span style="color: #666666">1</span>      <span style="color: #408080; font-style: italic"># Backward Euler method</span>
    CN <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>    <span style="color: #408080; font-style: italic"># Crank-Nicolson method</span>

    <span style="color: #408080; font-style: italic"># test all three schemes </span>
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> (FE, BE, CN):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;theta: &#39;</span>, theta
        E_values <span style="color: #666666">=</span> []
        dt_values <span style="color: #666666">=</span> []
        <span style="color: #008000; font-weight: bold">for</span> Nr <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">8</span>, <span style="color: #666666">16</span>, <span style="color: #666666">32</span>, <span style="color: #666666">64</span>):
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Nr:&#39;</span>, Nr
            r <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, R, Nr<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
            dr <span style="color: #666666">=</span> r[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> r[<span style="color: #666666">0</span>]
            a_values <span style="color: #666666">=</span> make_a(alpha, r)   
            <span style="color: #008000; font-weight: bold">if</span> theta <span style="color: #666666">==</span> CN:
                dt <span style="color: #666666">=</span> dr
            <span style="color: #008000; font-weight: bold">else</span>:   <span style="color: #408080; font-style: italic"># either FE or BE</span>
                <span style="color: #408080; font-style: italic"># use most conservative dt as decided by FE</span>
                K <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">4*</span>a_values<span style="color: #666666">.</span>max())              
                dt <span style="color: #666666">=</span> K<span style="color: #666666">*</span>dr<span style="color: #666666">**2</span>                 
            D <span style="color: #666666">=</span> dt<span style="color: #666666">/</span>dr<span style="color: #666666">**2</span>

            <span style="color: #008000; font-weight: bold">if</span> alpha_is_const:  
                u, t, cpu <span style="color: #666666">=</span> solver_theta(
                        I, a_values, R, Nr, D, T, 
                        theta, u_L<span style="color: #666666">=</span><span style="color: #008000">None</span>, u_R<span style="color: #666666">=0</span>,
                        user_action<span style="color: #666666">=</span>compare, f<span style="color: #666666">=</span>f)   
            <span style="color: #008000; font-weight: bold">else</span>:   <span style="color: #408080; font-style: italic"># alpha depends on r</span>
                u, t, cpu <span style="color: #666666">=</span> solver_theta(
                        I, a_values, R, Nr, D, T, 
                        theta, u_L<span style="color: #666666">=</span><span style="color: #008000">None</span>, u_R<span style="color: #666666">=0</span>,
                        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, f<span style="color: #666666">=</span>f)   
                        
                <span style="color: #408080; font-style: italic"># compute L2 error at t = T</span>
                u_e <span style="color: #666666">=</span> u_exact(r, t[<span style="color: #666666">-1</span>])
                e <span style="color: #666666">=</span> u_e <span style="color: #666666">-</span> u
                E <span style="color: #666666">=</span> sqrt(dr<span style="color: #666666">*</span><span style="color: #008000">sum</span>(e<span style="color: #666666">**2</span>))
                E_values<span style="color: #666666">.</span>append(E)
                dt_values<span style="color: #666666">.</span>append(dt)
            
        <span style="color: #008000; font-weight: bold">if</span> alpha_is_const <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #008000">False</span>:  
            q <span style="color: #666666">=</span> compute_rates(dt_values, E_values)        
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, q: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (theta, q)
            expected_rate <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #008000; font-weight: bold">if</span> theta <span style="color: #666666">==</span> CN <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
            tol <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
            diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected_rate <span style="color: #666666">-</span> q[<span style="color: #666666">-1</span>])
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;diff:&#39;</span>, diff
            <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol
    
    
<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    tests_with_alpha_and_u_exact()        
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;This is just a start. More remaining for this Exerc.&#39;</span>
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Verify the implementation in b) using a manufactured solution that is
quadratic in \( r \) and linear in \( t \). Make a corresponding test function.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_1">

<p>
You need to include an extra source term
in the equation to allow for such tests. Let the spatial variation be
\( 1-r^2 \) such that the boundary condition is fulfilled.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Make animations for \( m=1,16 \) and \( \alpha=1,0.1 \). Choose \( T \) such that
the motion has reached a steady state (non-visible changes from period to
period in \( u \)).

<p>
<b>e)</b>
For \( \alpha\gg 1 \), the scaling in a) is not good, because the
characteristic time for changes (due to the pressure) is much smaller
than the viscous diffusion time scale (\( \alpha \) becomes large).
We should in this case base
the short time scale on \( 1/\omega \). Scale the model again, and
make an animation for \( m=1,16 \) and \( \alpha = 10 \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_10_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_10_4">

<p>
Now the governing PDE becomes

$$ \frac{\partial u}{\partial t} =
\alpha^{-1}\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) +
\sin^m t,\quad r\in (0,1),\ t\in (0,T]\tp
$$

In this case,

$$ u_c = \frac{A}{\varrho\omega}\tp$$

We see that for \( \alpha\gg 1 \), we can neglect the viscous term, and we
basically have a balance between the acceleration and the driving pressure
gradient:

$$\frac{\partial u}{\partial t} = \sin^m t\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>axisymm_flow</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:welding">Problem 11: Scaling a welding problem</h2>

<p>
Welding equipment makes a very localized heat source that moves in
time. We shall investigate the heating due to welding and choose, for
maximum simplicity, a one-dimensional heat equation with a fixed
temperature at the ends, and we neglect melting.  We shall scale the
problem, and besides solving such a problem numerically, the aim is to
investigate the appropriateness of alternative scalings.

<p>
The governing PDE problem reads

$$
\begin{alignat*}{2}
\varrho c\frac{\partial u}{\partial t} &= k\frac{\partial^2 u}{\partial x^2}
+ f, & x\in (0,L),\ t\in (0,T),\\ 
u(x,0) &= U_s, & x\in [0,L],\\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T].
\end{alignat*}
$$

Here, \( u \) is the temperature, \( \varrho \) the density of the material,
\( c \) a heat capacity, \( k \) the heat conduction coefficient, \( f \) is
the heat source from the welding equipment, and \( U_s \) is the
initial constant (room) temperature in the material.

<p>
A possible model for the heat source is a moving Gaussian function:

$$ f = A\exp{\left(-\frac{1}{2}\left(\frac{x-vt}{\sigma}\right)^2\right)},$$

where \( A \) is the strength, \( \sigma \) is a parameter governing how
peak-shaped (or localized in space) the heat source is, and
\( v \) is the velocity (in positive \( x \) direction) of the source.

<p>
<b>a)</b>
Let \( x_c \), \( t_c \), \( u_c \), and \( f_c \) be scales, i.e., characteristic
sizes, of \( x \), \( t \), \( u \), and \( f \), respectively. The natural choice of
\( x_c \) and \( f_c \) is \( L \) and \( A \), since these make the scaled \( x \) and
\( f \) in the interval \( [0,1] \).  If each of the three terms in the PDE
are equally important, we can find \( t_c \) and \( u_c \) by demanding that
the coefficients in the scaled PDE are all equal to unity.  Perform
this scaling. Use scaled quantities in the arguments for the
exponential function in \( f \) too and show that

$$ \bar f= e^{-\frac{1}{2}\beta^2(\bar x -\gamma \bar t)^2},$$

where \( \beta \) and \( \gamma \) are dimensionless numbers. Give an
interpretation of \( \beta \) and \( \gamma \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_2">

<p>
We introduce

$$ \bar x=\frac{x}{L},\quad \bar t = \frac{t}{t_c},\quad \bar u = \frac{u-U_s}{u_c},
\quad \bar f=\frac{f}{A}\tp$$

Inserted in the PDE and dividing by \( \varrho c u_c/t_c \) such that the
coefficient in front of \( \partial\bar u/\partial\bar t \) becomes unity,
and thereby all terms become dimensionless, we get

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{k t_c}{\varrho c L^2}\frac{\partial^2\bar u}{\partial\bar x^2}
+ \frac{A t_c}{\varrho c u_c}\bar f\tp
$$

Demanding that all three terms are equally important, it follows that

$$ \frac{k t_c}{\varrho c L^2} = 1,\quad \frac{A t_c}{\varrho c u_c}=1\tp$$

These constraints imply the <em>diffusion time scale</em>

$$ t_c = \frac{\varrho cL^2}{k},$$

and a scale for \( u_c \),

$$ u_c = \frac{AL^2}{k}\tp$$

The scaled PDE reads

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{\partial^2\bar u}{\partial\bar x^2}
+ \bar f\tp$$

<p>
Scaling \( f \) results in

$$
\begin{align*}
\bar f &= \exp{\left(-\frac{1}{2}\left(\frac{x-vt}{\sigma}\right)^2\right)}\\ 
&= \exp{\left(-\frac{1}{2}\frac{L^2}{\sigma^2}
\left(\bar x- \frac{vt_c}{L}t\right)^2\right)}\\ 
&= \exp{\left(-\frac{1}{2}\beta^2\left(\bar x-\gamma \bar t\right)^2\right)},
\end{align*}
$$

where \( \beta \) and \( \gamma \) are dimensionless numbers:

$$ \beta = \frac{L}{\sigma},\quad
\gamma = \frac{vt_c}{L} = \frac{v\varrho cL}{k}\tp$$

The \( \sigma \) parameter measures the width of the Gaussian peak, so
\( \beta \) is the ratio of the domain and the width of the heat source (large
\( \beta \) implies a very peak-formed heat source).  The \( \gamma \)
parameter arises from \( t_c/(L/v) \), which is the ratio of the diffusion
time scale and the time it takes for the heat source to travel through
the domain. Equivalently, we can multiply by \( t_c/t_c \) to get \( \gamma
= v/(t_cL) \) as the ratio between the velocity of the heat source and
the diffusion velocity.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Argue that for large \( \gamma \) we should base the time scale on the
movement of the heat source. Show that this gives rise to the scaled
PDE

$$ \frac{\partial\bar u}{\partial\bar t} =
\gamma^{-1}\frac{\partial^2\bar u}{\partial\bar x^2}
+ \bar f,
$$

and

$$ \bar f = \exp{(-\frac{1}{2}\beta^2(\bar x - \bar t)^2)}\tp$$

Discuss when the scalings in a) and b) are appropriate.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_3">

<p>
We perform the scaling as in a), but this time we determine \( t_c \) such
that the heat source moves with unit velocity. This means that

$$ \frac{vt_c}{L} = 1\quad\Rightarrow\quad t_c = \frac{L}{v}\tp$$

Scaling of the PDE gives, as before,

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{k t_c}{\varrho c L^2}\frac{\partial^2\bar u}{\partial\bar x^2}
+ \frac{A t_c}{\varrho c u_c}\bar f\tp
$$

Inserting the expression for \( t_c \), we have

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{k L}{\varrho c L^2v}\frac{\partial^2\bar u}{\partial\bar x^2}
+ \frac{A L}{v\varrho c u_c}\bar f\tp
$$

We recognize the first coefficient as \( \gamma^{-1} \), while \( u_c \) can
be determined from demanding the second coefficient to be unity:

$$ u_c = \frac{AL}{v\varrho c}\tp$$

The scaled PDE is therefore

$$ \frac{\partial\bar u}{\partial\bar t} =
\gamma^{-1}\frac{\partial^2\bar u}{\partial\bar x^2}
+ \bar f\tp$$

If the heat source moves very fast, there is little time for the
diffusion to transport the heat away from the source, and the heat
conduction term becomes insignificant. This is reflected in the
coefficient \( \gamma^{-1} \), which is small when \( \gamma \), the ratio of
the heat source velocity and the diffusion velocity, is large.

<p>
The scaling in a) is therefore appropriate if diffusion is a
significant process, i.e., the welding equipment moves at a slow speed
so heat can efficiently spread out by diffusion. For large \( \gamma \),
the scaling in b) is appropriate, and \( t=1 \) corresponds to having the
heat source traveled through the domain (with the scaling in a), the
heat source will leave the domain in short time).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
One aim with scaling is to get a solution that lies in the interval
\( [-1,1] \). This is not always the case when \( u_c \) is based on a scale
involving a source term, as we do in a) and b).  However, from the
scaled PDE we realize that if we replace \( \bar f \) with \( \delta\bar f \),
where \( \delta \) is a dimensionless factor, this corresponds to
replacing \( u_c \) by \( u_c/\delta \). So, if we observe that \( \bar
u\sim1/\delta \) in simulations, we can just replace \( \bar f \) by \( \delta
\bar f \) in the scaled PDE.

<p>
Use this trick and implement the two scaled models. Reuse software for
the diffusion equation (e.g., the <code>solver</code> function in
<code>diffu1D_vc.py</code>).  Make a function <code>run(gamma, beta=10, delta=40,
scaling=1, animate=False)</code> that runs the model with the given
\( \gamma \), \( \beta \), and \( \delta \) parameters as well as an indicator
<code>scaling</code> that is 1 for the scaling in a) and 2 for the scaling in
b). The last argument can be used to turn screen animations on or off.

<p>
Experiments show that with \( \gamma=1 \) and \( \beta=10 \), \( \delta =20 \)
is appropriate. Then \( \max |\bar u| \) will be larger than 4 for \( \gamma
=40 \), but that is acceptable.

<p>
Equip the <code>run</code> function with visualization, both animation of \( \bar u \)
and \( \bar f \), and plots with \( \bar u \) and \( \bar f \) for \( t=0.2 \) and \( t=0.5 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_1">

<p>
Since the amplitudes of \( \bar u \) and \( \bar f \) differs by a factor \( \delta \),
it is attractive to plot \( \bar f/\delta \) together with \( \bar u \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_4">

<p>
Here is a possible <code>run</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">diffu1D_vc</span> <span style="color: #008000; font-weight: bold">import</span> solver
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">run</span>(gamma, beta<span style="color: #666666">=10</span>, delta<span style="color: #666666">=40</span>, scaling<span style="color: #666666">=1</span>, animate<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Run the scaled model for welding.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">if</span> scaling <span style="color: #666666">==</span> <span style="color: #666666">1</span>:
        v <span style="color: #666666">=</span> gamma
        a <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">elif</span> scaling <span style="color: #666666">==</span> <span style="color: #666666">2</span>:
        v <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        a <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>gamma

    b <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>beta<span style="color: #666666">**2</span>
    L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
    ymin <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #408080; font-style: italic"># Need gloal to be able change ymax in closure process_u</span>
    <span style="color: #008000; font-weight: bold">global</span> ymax
    ymax <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>

    I <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">0</span>
    f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x, t: delta<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>b<span style="color: #666666">*</span>(x <span style="color: #666666">-</span> v<span style="color: #666666">*</span>t)<span style="color: #666666">**2</span>)

    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    plot_arrays <span style="color: #666666">=</span> []

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">process_u</span>(u, x, t, n):
        <span style="color: #008000; font-weight: bold">global</span> ymax
        <span style="color: #008000; font-weight: bold">if</span> animate:
            plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;r-&#39;</span>,
                     x, f(x, t[n])<span style="color: #666666">/</span>delta, <span style="color: #BA2121">&#39;b-&#39;</span>,
                     axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, L, ymin, ymax], title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n],
                     xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;x&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u and f/</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> delta)
        <span style="color: #008000; font-weight: bold">if</span> t[n] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">1</span>)
            plot_arrays<span style="color: #666666">.</span>append(x)
        dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
        tol <span style="color: #666666">=</span> dt<span style="color: #666666">/10.0</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(t[n] <span style="color: #666666">-</span> <span style="color: #666666">0.2</span>) <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> <span style="color: #008000">abs</span>(t[n] <span style="color: #666666">-</span> <span style="color: #666666">0.5</span>) <span style="color: #666666">&lt;</span> tol:
            plot_arrays<span style="color: #666666">.</span>append((u<span style="color: #666666">.</span>copy(), f(x, t[n])<span style="color: #666666">/</span>delta))
            <span style="color: #008000; font-weight: bold">if</span> u<span style="color: #666666">.</span>max() <span style="color: #666666">&gt;</span> ymax:
                ymax <span style="color: #666666">=</span> u<span style="color: #666666">.</span>max()

    Nx <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    D <span style="color: #666666">=</span> <span style="color: #666666">10</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    u_L <span style="color: #666666">=</span> u_R <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    theta <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
    cpu <span style="color: #666666">=</span> solver(
        I, a, f, L, Nx, D, T, theta, u_L, u_R, user_action<span style="color: #666666">=</span>process_u)
    x <span style="color: #666666">=</span> plot_arrays[<span style="color: #666666">0</span>]
    plt<span style="color: #666666">.</span>figure()
    <span style="color: #008000; font-weight: bold">for</span> u, f <span style="color: #AA22FF; font-weight: bold">in</span> plot_arrays[<span style="color: #666666">1</span>:]:
        plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;r-&#39;</span>, x, f, <span style="color: #BA2121">&#39;b--&#39;</span>, axis<span style="color: #666666">=</span>[x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], <span style="color: #666666">0</span>, ymax],
                 xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;$x$&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">r&#39;$u, \ f/</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">$&#39;</span> <span style="color: #666666">%</span> delta)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;$u,</span><span style="color: #BB6622; font-weight: bold">\\</span><span style="color: #BA2121"> t=0.2$&#39;</span>, <span style="color: #BA2121">&#39;$f/</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6622; font-weight: bold">\\</span><span style="color: #BA2121"> t=0.2$&#39;</span> <span style="color: #666666">%</span> delta,
                <span style="color: #BA2121">&#39;$u,</span><span style="color: #BB6622; font-weight: bold">\\</span><span style="color: #BA2121"> t=0.5$&#39;</span>, <span style="color: #BA2121">&#39;$f/</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,</span><span style="color: #BB6622; font-weight: bold">\\</span><span style="color: #BA2121"> t=0.5$&#39;</span> <span style="color: #666666">%</span> delta])
    filename <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;tmp1_gamma</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">_s</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (gamma, scaling)
    s <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;diffusion&#39;</span> <span style="color: #008000; font-weight: bold">if</span> scaling <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #BA2121">&#39;source&#39;</span>
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">r&#39;$\beta = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,\ \gamma = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">,\ $&#39;</span> <span style="color: #666666">%</span> (beta, gamma)
              <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;scaling=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> s)
    plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.pdf&#39;</span>);  plt<span style="color: #666666">.</span>savefig(filename <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.png&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> cpu
</pre></div>
<p>
Note that we have dropped the bar notation in the plots. It is common
to drop the bars as soon as the scaled problem is established.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
Use the software in c) to investigate \( \gamma=0.2,1,5,40 \) for the
two scalings. Discuss the results.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_5" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_5">

<p>
For these investigations, we compare the two scalings for each of
the different \( \gamma \) values. An appropriate function for automating
the tasks is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">investigate</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Do scienfic experiments with the run function above.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Clean up old files</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">glob</span>
    <span style="color: #008000; font-weight: bold">for</span> filename <span style="color: #AA22FF; font-weight: bold">in</span> glob<span style="color: #666666">.</span>glob(<span style="color: #BA2121">&#39;tmp1_gamma*&#39;</span>) <span style="color: #666666">+</span> \ 
            glob<span style="color: #666666">.</span>glob(<span style="color: #BA2121">&#39;welding_gamma*&#39;</span>):
        os<span style="color: #666666">.</span>remove(filename)

    gamma_values <span style="color: #666666">=</span> <span style="color: #666666">1</span>, <span style="color: #666666">40</span>, <span style="color: #666666">5</span>, <span style="color: #666666">0.2</span>, <span style="color: #666666">0.025</span>
    <span style="color: #008000; font-weight: bold">for</span> gamma <span style="color: #AA22FF; font-weight: bold">in</span> gamma_values:
        <span style="color: #008000; font-weight: bold">for</span> scaling <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">2</span>:
            run(gamma<span style="color: #666666">=</span>gamma, beta<span style="color: #666666">=10</span>, delta<span style="color: #666666">=20</span>, scaling<span style="color: #666666">=</span>scaling)

    <span style="color: #408080; font-style: italic"># Combine images</span>
    <span style="color: #008000; font-weight: bold">for</span> gamma <span style="color: #AA22FF; font-weight: bold">in</span> gamma_values:
        <span style="color: #008000; font-weight: bold">for</span> ext <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;pdf&#39;</span>, <span style="color: #BA2121">&#39;png&#39;</span>:
            cmd <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;doconce combine_images -2 &#39;</span>\ 
                  <span style="color: #BA2121">&#39;tmp1_gamma</span><span style="color: #BB6688; font-weight: bold">%(gamma)g</span><span style="color: #BA2121">_s1.</span><span style="color: #BB6688; font-weight: bold">%(ext)s</span><span style="color: #BA2121"> &#39;</span>\ 
                  <span style="color: #BA2121">&#39;tmp1_gamma</span><span style="color: #BB6688; font-weight: bold">%(gamma)g</span><span style="color: #BA2121">_s2.</span><span style="color: #BB6688; font-weight: bold">%(ext)s</span><span style="color: #BA2121"> &#39;</span>\ 
                  <span style="color: #BA2121">&#39;welding_gamma</span><span style="color: #BB6688; font-weight: bold">%(gamma)g</span><span style="color: #BA2121">.</span><span style="color: #BB6688; font-weight: bold">%(ext)s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">vars</span>()
            os<span style="color: #666666">.</span>system(cmd)
            <span style="color: #408080; font-style: italic"># pdflatex doesn&#39;t like 0.2 in filenames...</span>
            <span style="color: #008000; font-weight: bold">if</span> <span style="color: #BA2121">&#39;.&#39;</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">str</span>(gamma):
                os<span style="color: #666666">.</span>rename(
                    <span style="color: #BA2121">&#39;welding_gamma</span><span style="color: #BB6688; font-weight: bold">%(gamma)g</span><span style="color: #BA2121">.</span><span style="color: #BB6688; font-weight: bold">%(ext)s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">vars</span>(),
                    (<span style="color: #BA2121">&#39;welding_gamma</span><span style="color: #BB6688; font-weight: bold">%(gamma)g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">vars</span>())<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;.&#39;</span>, <span style="color: #BA2121">&#39;_&#39;</span>)
                    <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;.&#39;</span> <span style="color: #666666">+</span> ext)
</pre></div>
<p>
We run here a Backward Euler scheme with \( N_x=100 \) and quite long
time steps.

<p>
Running the <code>investigate</code> function, we get the following plots:

<p>
<center><p><img src="fig-diffu/welding_gamma0_025.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-diffu/welding_gamma0_2.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-diffu/welding_gamma1.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-diffu/welding_gamma5.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-diffu/welding_gamma40.png" align="bottom" width=800></p></center>

<p>
For \( \gamma\ll 1 \) as in \( \gamma = 0.025 \), the heat source moves very
slowly on the diffusion time scale and has hardly entered the medium,
while the scaling in b) is not inappropriate, but a larger \( \delta \) is
needed to bring \( \bar u \) around unity.  We see that for \( \gamma=0.2 \),
each of the scalings work, but with the diffusion time scale, the heat
source has not moved much into the domain. For \( \gamma=1 \), the
mathematical problems are identical and hence the plots too. For
\( \gamma=5 \), the time scale based on the source is clearly the best
choice, and for \( \gamma=40 \), only this scale is appropriate.

<p>
A conclusion is that the scaling in b) works well for a range of \( \gamma \)
values, also in the case \( \gamma\ll 1 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- ===== Exercise: Radial heat conduction out of offshore pipelines ===== -->

<p>
<!-- Easy to make something out of the ideas/5620/apps/offshore... mekit -->
<!-- paper where one has a multi-walled radial heat conduction equation. -->
<!-- Can, as in the paper, use one cell per material. Coupling to soil -->
<!-- outside with many parameters given. The discussion of the Fourier -->
<!-- number is interesting - I guess time changes here relates to -->
<!-- BCs on the inner wall because the gas suddenly has a different -->
<!-- temperature? Could be a good project perhaps; anyway, the theory -->
<!-- can be written up. -->

<p>
Filename: <code>welding</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:axisymm">Exercise 12: Implement a Forward Euler scheme for axi-symmetric diffusion</h2>

<p>
Based on the discussion in the section <a href="#diffu:fd2:radial">Axi-symmetric diffusion</a>, derive in detail
the discrete equations for a Forward Euler in time, centered in space,
finite difference method for axi-symmetric diffusion. The
diffusion coefficient may be a function of the radial coordinate.
At the outer boundary \( r=R \), we may have either a Dirichlet or Robin
condition.
Implement this scheme. Construct appropriate test problems.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_12_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_12_1">

<p>
We start with the equation at \( r=0 \). According to the section <a href="#diffu:fd2:radial">Axi-symmetric diffusion</a>,
we get

$$ \frac{u^{n+1}_0-u^n_0}{\Delta t} = 4\dfc(0)\frac{u_1^n - u^n_0}{\Delta r^2}
+ f_0^n\tp$$

For \( i>0 \), we have

$$
\begin{align*}
\frac{u^{n+1}_i-u^n_i}{\Delta t} &= \frac{1}{r_i\Delta r^2}(
\half(r_i + r_{i+1})\half(\dfc_i + \dfc_{i+1})(u^n_{i+1} - u^n_i) -\\ 
&\qquad\half(r_{i-1} + r_{i})\half(\dfc_{i-1} + \dfc_{i})(u^n_{i} - u^n_{i-1}))
+ f_i^n
\end{align*}
$$

Solving with respect to \( u^{n+1}_i \) and introducing \( D=\Delta t/\Delta r^2 \)
results in

$$
\begin{align*}
u^{n+1}_0 &= u^n_0 + 4D\dfc(0)(u_1^n - u^n_0)
+ f_0^n,\\ 
u^{n+1}_i &= u^n_i + D\frac{1}{r_i}(
\half(r_i + r_{i+1})\half(\dfc_i + \dfc_{i+1})(u^n_{i+1} - u^n_i) -\\ 
&\qquad\half(r_{i-1} + r_{i})\half(\dfc_{i-1} + \dfc_{i})(u^n_{i} - u^n_{i-1}))
+ \Delta t f_i^n,\\ 
&\qquad i = 1,\ldots,N_r-1,
\end{align*}
$$

and \( u^{n+1}_i \) at the end point \( i=N_r \) is assumed known in case of
a Dirichlet condition. A Robin condition

$$ -\dfc\frac{\partial u}{\partial n} = h_T(u-U_s),$$

can be discretized at \( i=N_r \) by

$$ -\alpha_i\frac{u_{i+1}^n-u_{i-1}^n}{2\Delta r} = h_T(u_i^n - U_s)\tp$$

Solving with respect to the value at the fictitious point \( i+1 \) gives

$$ u_{i+1}^n = u_{i-1}^n - 2\Delta r \frac{h_T}{\alpha_i}(u_i^n - U_s)\tp$$

This value is then inserted for \( u_{i+1}^n \) in the discrete PDE at \( i=N_r \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>FE_axisym</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._diffu-sol000.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._diffu-sol002.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

