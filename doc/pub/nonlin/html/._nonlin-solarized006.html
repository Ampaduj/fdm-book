<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving nonlinear ODE and PDE problems">
<meta name="keywords" content="linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,operator splitting,splitting ODEs,fractional step methods,Strang splitting,continuation method">

<title>Solving nonlinear ODE and PDE problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec1'),
              ('Algebraic equations', 3, None, '___sec2'),
              ('Differential equations', 3, None, '___sec3'),
              ('A simple model problem', 2, None, '___sec4'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec7'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec9'),
              ('A single Picard iteration', 3, None, '___sec10'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec16'),
              ('Backward Euler discretization', 3, None, '___sec17'),
              ('Crank-Nicolson discretization', 3, None, '___sec18'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec20'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec26'),
              ('A Picard iteration', 3, None, '___sec27'),
              ("Newton's method", 3, None, '___sec28'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec33'),
              ('Similarity with Picard iteration', 3, None, '___sec34'),
              ('Implementation', 3, None, '___sec35'),
              ('Derivation with alternative notation', 3, None, '___sec36'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('Discretization of 1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec40'),
              ('The structure of the equation system', 3, None, '___sec41'),
              ('Picard iteration', 3, None, '___sec42'),
              ('Mesh with two cells', 3, None, '___sec43'),
              ("Newton's method", 3, None, '___sec44'),
              ('Multi-dimensional PDE problems', 1, None, '___sec45'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec47'),
              ("Newton's method", 3, None, '___sec48'),
              ('Continuation methods', 2, None, '___sec49'),
              ('Operator splitting methods',
               1,
               'nonlin:splitting',
               'nonlin:splitting'),
              ('Ordinary operator splitting for ODEs',
               2,
               'nonlin:splitting:ODE',
               'nonlin:splitting:ODE'),
              ('Strang splitting for ODEs',
               2,
               'nonlin:splitting:ODE_Strang',
               'nonlin:splitting:ODE_Strang'),
              ('Example: Logistic growth', 2, None, '___sec53'),
              ('Reaction-diffusion equation', 2, None, '___sec54'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 1: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Problem 2: Derive and investigate a generalized logistic model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 3: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Exercise 4: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 5: Solve nonlinear equations arising from a vibration ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 6: Find the truncation error of arithmetic mean of products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 7: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Problem 8: Discretize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Problem 9: Linearize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 10: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Problem 11: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Problem 12: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 13: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Problem 14: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 15: Investigate a 1D problem with a continuation method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Bibliography', 1, None, '___sec71')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\baspsi}{\psi}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._nonlin-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._nonlin-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="nonlin:splitting">Operator splitting methods</h1>

<p>
Operator splitting is a natural and old idea. When a PDE or system of PDEs
contains different terms expressing different physics, it is natural to
use different numerical methods for different physical processes. This can
optimize and simplify the overall solution process. The idea was
especially popularized in the context of the Navier-Stokes equations
and reaction-diffusion PDEs. Common names for the technique are <em>operator
splitting</em>, <em>fractional step</em> methods, and <em>split-step</em> methods. We shall
stick to the former name.
In the context of nonlinear differential equations, operator splitting
can be used to isolate nonlinear terms and simplify the solution methods.

<p>
A related technique, often known as dimensional splitting or
alternating direction implicit (ADI) methods, is to split the spatial
dimensions and solve a 2D or 3D problem as two or three
consecutive 1D problems, but this type of splitting
is not to be further considered here.

<h2 id="nonlin:splitting:ODE">Ordinary operator splitting for ODEs</h2>

<p>
Consider first an ODE where the right-hand side is split into two
terms:

$$
\begin{equation}
u' = f_0(u) + f_1(u)\tp
\tag{71}
\end{equation}
$$

In case \( f_0 \) and \( f_1 \) are linear functions of \( u \), \( f_0=au \) and \( f_1=bu \),
we have \( u(t)=Ie^{(a+b)t} \), if \( u(0)=I \).
When going one time step of length \( \Delta t \) from \( t_n \) to \( t_{n+1} \), we have

$$ u(t_{n+1}) = u(t_n)e^{(a+b)\Delta t}\tp$$

This expression can be also be written as

$$ u(t_{n+1}) = u(t_n)e^{a\Delta t}e^{b\Delta t},$$

or

$$
\begin{align}
u^* &= u(t_n)e^{a\Delta t},
\tag{72}\\ 
u(t_{n+1}) &= u^*e^{b\Delta t}
\tag{73}
\end{align}
$$

The first step <a href="#mjx-eqn-72">(72)</a> means solving
\( u'=f_0 \) over a time interval \( \Delta t \) with \( u(t_n) \) as start value.
The second step <a href="#mjx-eqn-73">(73)</a> means solving
\( u'=f_1 \) over a time interval \( \Delta t \) with the value at the end
of the first step as start value.
That is, we progress the solution in two steps and solve
two ODEs \( u'=f_1 \) ad \( u'=f_2 \). The order of the equations is not
important. From the derivation above we see that solving \( u'=f_1 \)
prior to \( u'=f_0 \) can equally well be done.

<p>
The technique is exact if the ODEs are linear. For nonlinear ODEs it is
only an approximate method with error \( \Delta t \). The technique can
be extended to \( n+1 \) steps:

$$ u' = \sum_{i=0}^n f_i(u),$$

which is solved by \( n+1 \) steps over \( [t_n, t_{n+1}] \):

$$
\begin{align*}
\frac{du^{(0)}}{dt} &= f_0(u^{(0)}),\quad u^{(0)}(t_n)=u(t_n),\\ 
\frac{du^{(i)}}{dt} &= f_i(u^{(i)}),\quad u^{(i)}(t_n)=u^{(i-1)}(t_{n+1}),\\ 
\end{align*}
$$

for \( i=1,\ldots,n \). We take the final solution
\( u(t_{n+1}) \) as \( u^{(n)}(t_{n+1}) \).

<h2 id="nonlin:splitting:ODE_Strang">Strang splitting for ODEs</h2>

<p>
The accuracy of the splitting method in the section <a href="#nonlin:splitting:ODE">Ordinary operator splitting for ODEs</a>
can be improved from \( \Oof{\Delta t} \) to \( \Oof{\Delta t^2} \) using so-called
<em>Strang splitting</em>, where we take half a step with the \( f_1 \) operator,
a full step with the \( f_2 \) operator, and finally half another step with
the \( f_1 \) operator. During a time interval \( \Delta t \) the algorithm can
be written as follows.

$$
\begin{align*}
\frac{du^{(0)}}{dt} &= f_0(u^{(0)}),\quad u^{(0)}(t_n)=u(t_n),
\quad t\in [0,\half\Delta t],\\ 
\frac{du^{(\half)}}{dt} &= f_1(u^{(\half)}),\quad u^{(\half)}(t_n)=u^{(0)}(t_{n+\half}),
\quad t\in [0,\Delta t],\\ 
\frac{du^{(1)}}{dt} &= f_0(u^{(1)}),\quad u^{(1)}(t_n)=u^{(\half)}(t_{n+1})
\tp\\ 
\end{align*}
$$

<p>
There is no use in applying higher-order methods when performing
ordinary splitting since the error due to splitting is \( \Oof{\Delta
t} \), but for Strang splitting it makes sense to use schemes of order
\( \Oof{\Delta t^2} \).

<h2 id="___sec53">Example: Logistic growth </h2>

<p>
Let us split the (scaled) logistic equation

$$ u'=u(1-u),\quad u'(0)=0.1,$$

with solution \( u=(9e^{-t}+1)^{-1} \), into

$$ u'=u - u^2 = f_0(u) + f_1(u), \quad f_0(u)=u,\quad f_1(u)=-u^2\tp$$

We solve \( u'=f_0(u) \) and \( u'=f_2(u) \) by a Forward Euler step.
In addition, we add a method where we solve \( u'=f_0(u) \) analytically,
since the equation is actually \( u'=u \) with solution \( e^t \).

<p>
The following function computes four solutions arising from the Forward
Euler method, ordinary splitting, Strang splitting, as well as Strang splitting
with exact treatment of \( u'=f_0(u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(dt, T, f, f_0, f_1):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=f by the Forward Euler method and by ordinary and</span>
<span style="color: #CD5555">    Strang splitting: f(u) = f_1(u) + f_2(u).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    t = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)
    u_FE = np.zeros(<span style="color: #658b00">len</span>(t))
    u_split1 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 1st-order splitting</span>
    u_split2 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 2nd-order splitting</span>
    u_split3 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 2nd-order splitting w/exact f_0</span>

    <span style="color: #228B22"># Set initial values</span>
    u_FE[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split1[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split2[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split3[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>):
        <span style="color: #228B22"># Forward Euler method</span>
        u_FE[n+<span style="color: #B452CD">1</span>] = u_FE[n] + dt*f(u_FE[n])

        <span style="color: #228B22"># Ordinary splitting</span>
        u_0 = u_split1[n] + dt*f_0(u_split1[n])
        u_split1[n+<span style="color: #B452CD">1</span>] = u_0 + dt*f_1(u_0)

        <span style="color: #228B22"># Strang splitting</span>
        u_0 = u_split2[n] + dt/<span style="color: #B452CD">2.</span>*f_0(u_split2[n])
        u_1 = u_0 + dt*f_1(u_0)
        u_split2[n+<span style="color: #B452CD">1</span>] = u_1 + dt/<span style="color: #B452CD">2.</span>*f_0(u_1)

        <span style="color: #228B22"># Strang splitting using exact integrator for u&#39;=f_0</span>
        u_0 = u_split3[n]*np.exp(dt/<span style="color: #B452CD">2.</span>)  <span style="color: #228B22"># exact</span>
        u_1 = u_0 + dt*f_1(u_0)
        u_split3[n+<span style="color: #B452CD">1</span>] = u_1*np.exp(dt/<span style="color: #B452CD">2.</span>)

    <span style="color: #8B008B; font-weight: bold">return</span> u_FE, u_split1, u_split2, u_split3, t
</pre></div>
<p>
Figure <a href="#nonlin:splitting:ODE:logistic:fig">3</a> shows that the impact
of splitting is significant. The Forward Euler method is much more accurate
than any of the splitting schemes. We also see that Strang splitting is
definitely more accurate than ordinary splitting and that it helps a bit
to use an exact solution of \( u'=f_0(u) \). As technique for solving
nonlinear ODEs, we realize that the present example is not particularly
illustrating, as the Forward Euler method both linearizes the original
problem and provides a solution that is more accurate than the splitting.

<p>
<center> <!-- figure label: --> <div id="nonlin:splitting:ODE:logistic:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Effect of ordinary and Strang splitting for the logistic equation.  <!-- caption label: nonlin:splitting:ODE:logistic:fig --> </p></center>
<p><img src="fig-nonlin/split_logistic.png" align="bottom" width=800></p>
</center>

<h2 id="___sec54">Reaction-diffusion equation </h2>

<p>
Consider a diffusion equation coupled to chemical reactions modeled by
a nonlinear term \( f(u) \):

$$ \frac{\partial u}{\partial t} = \dfc\nabla^2 + f(u)\tp$$

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._nonlin-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._nonlin-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

