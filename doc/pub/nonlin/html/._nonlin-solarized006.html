<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving nonlinear ODE and PDE problems">
<meta name="keywords" content="iterative methods,linearization explicit time integration,Taylor series,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,geometric mean,arithmetic mean,quadratic convergence,relaxation (nonlinear equations),relaxation parameter,system of algebraic equations,coupled system,linear system,Jacobian,stopping criteria (nonlinear problems),continuation  method,continuation  parameter,ADI methods,split-step methods,dimensional splitting,operator splitting,splitting ODEs,fractional step methods,Strang splitting,logistic growth,verification  convergence rates,Adams-Bashforth,Odespy,continuation method">

<title>Solving nonlinear ODE and PDE problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec1'),
              ('Algebraic equations', 3, None, '___sec2'),
              ('Differential equations', 3, None, '___sec3'),
              ('A simple model problem', 2, None, '___sec4'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec7'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec9'),
              ('A single Picard iteration', 3, None, '___sec10'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec16'),
              ('Backward Euler discretization', 3, None, '___sec17'),
              ('Crank-Nicolson discretization', 3, None, '___sec18'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec20'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec26'),
              ('A Picard iteration', 3, None, '___sec27'),
              ("Newton's method", 3, None, '___sec28'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec33'),
              ('Similarity with Picard iteration', 3, None, '___sec34'),
              ('Implementation', 3, None, '___sec35'),
              ('Derivation with alternative notation', 3, None, '___sec36'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec40'),
              ('The structure of the equation system', 3, None, '___sec41'),
              ('Picard iteration', 3, None, '___sec42'),
              ('Mesh with two cells', 3, None, '___sec43'),
              ("Newton's method", 3, None, '___sec44'),
              ('Multi-dimensional nonlinear PDE problems',
               1,
               None,
               '___sec45'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec47'),
              ("Newton's method", 3, None, '___sec48'),
              ('Continuation methods', 2, None, '___sec49'),
              ('Operator splitting methods',
               1,
               'nonlin:splitting',
               'nonlin:splitting'),
              ('Ordinary operator splitting for ODEs',
               2,
               'nonlin:splitting:ODE',
               'nonlin:splitting:ODE'),
              ('Strang splitting for ODEs',
               2,
               'nonlin:splitting:ODE_Strang',
               'nonlin:splitting:ODE_Strang'),
              ('Example: Logistic growth',
               2,
               'nonlin:splitting:logistic',
               'nonlin:splitting:logistic'),
              ('Splitting techniques', 3, None, '___sec54'),
              ('Verbose implementation', 3, None, '___sec55'),
              ('Compact implementation', 3, None, '___sec56'),
              ('Results', 3, None, '___sec57'),
              ('Reaction-diffusion equation',
               2,
               'nonlin:splitting:RD',
               'nonlin:splitting:RD'),
              ('Example: Reaction-Diffusion with linear reaction term',
               2,
               'nonlin:splitting:RD_linearR',
               'nonlin:splitting:RD_linearR'),
              ('Analysis of the splitting method', 2, None, '___sec60'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 1: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Problem 2: Derive and investigate a generalized logistic model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 3: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Exercise 4: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 5: Solve nonlinear equations arising from a vibration ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 6: Find the truncation error of arithmetic mean of products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 7: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Problem 8: Discretize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Problem 9: Linearize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 10: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Problem 11: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Problem 12: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 13: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Problem 14: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 15: Investigate a 1D problem with a continuation method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Bibliography', 1, None, '___sec77')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\stepzero}{*}
\newcommand{\stephalf}{***}
\newcommand{\stepone}{**}
\newcommand{\baspsi}{\psi}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._nonlin-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._nonlin-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="nonlin:splitting">Operator splitting methods</h1>

<p>
Operator splitting is a natural and old idea. When a PDE or system of PDEs
contains different terms expressing different physics, it is natural to
use different numerical methods for different physical processes. This can
optimize and simplify the overall solution process. The idea was
especially popularized in the context of the Navier-Stokes equations
and reaction-diffusion PDEs. Common names for the technique are <em>operator
splitting</em>, <em>fractional step</em> methods, and <em>split-step</em> methods. We shall
stick to the former name.
In the context of nonlinear differential equations, operator splitting
can be used to isolate nonlinear terms and simplify the solution methods.

<p>
A related technique, often known as dimensional splitting or
alternating direction implicit (ADI) methods, is to split the spatial
dimensions and solve a 2D or 3D problem as two or three
consecutive 1D problems, but this type of splitting
is not to be further considered here.

<h2 id="nonlin:splitting:ODE">Ordinary operator splitting for ODEs</h2>

<p>
Consider first an ODE where the right-hand side is split into two
terms:

$$
\begin{equation}
u' = f_0(u) + f_1(u)\tp
\tag{71}
\end{equation}
$$

In case \( f_0 \) and \( f_1 \) are linear functions of \( u \), \( f_0=au \) and \( f_1=bu \),
we have \( u(t)=Ie^{(a+b)t} \), if \( u(0)=I \).
When going one time step of length \( \Delta t \) from \( t_n \) to \( t_{n+1} \), we have

$$ u(t_{n+1}) = u(t_n)e^{(a+b)\Delta t}\tp$$

This expression can be also be written as

$$ u(t_{n+1}) = u(t_n)e^{a\Delta t}e^{b\Delta t},$$

or

$$
\begin{align}
u^\stepzero &= u(t_n)e^{a\Delta t},
\tag{72}\\ 
u(t_{n+1}) &= u^\stepzero e^{b\Delta t}
\tag{73}
\end{align}
$$

The first step <a href="#mjx-eqn-72">(72)</a> means solving
\( u'=f_0 \) over a time interval \( \Delta t \) with \( u(t_n) \) as start value.
The second step <a href="#mjx-eqn-73">(73)</a> means solving
\( u'=f_1 \) over a time interval \( \Delta t \) with the value at the end
of the first step as start value.
That is, we progress the solution in two steps and solve
two ODEs \( u'=f_0 \) and \( u'=f_1 \). The order of the equations is not
important. From the derivation above we see that solving \( u'=f_1 \)
prior to \( u'=f_0 \) can equally well be done.

<p>
The technique is exact if the ODEs are linear. For nonlinear ODEs it is
only an approximate method with error \( \Delta t \). The technique can
be extended to an arbitrary number of steps; i.e., we may split the PDE
system into any number of subsystems. Examples will illuminate this principle.

<h2 id="nonlin:splitting:ODE_Strang">Strang splitting for ODEs</h2>

<p>
The accuracy of the splitting method in the section <a href="#nonlin:splitting:ODE">Ordinary operator splitting for ODEs</a>
can be improved from \( \Oof{\Delta t} \) to \( \Oof{\Delta t^2} \) using so-called
<em>Strang splitting</em>, where we take half a step with the \( f_0 \) operator,
a full step with the \( f_1 \) operator, and finally half another step with
the \( f_0 \) operator. During a time interval \( \Delta t \) the algorithm can
be written as follows.

$$
\begin{align*}
\frac{du^{\stepzero}}{dt} &= f_0(u^{\stepzero}),
\quad u^{\stepzero}(t_n)=u(t_n),
\quad t\in [t_n,t_n+\half\Delta t],\\ 
\frac{du^{\stephalf}}{dt} &= f_1(u^{\stephalf}),
\quad u^{\stephalf}(t_n)=u^{\stepzero}(t_{n+\half}),
\quad t\in [t_n,t_n+\Delta t],\\ 
\frac{du^{\stepone}}{dt}  &= f_0(u^{\stepone}),
\quad u^{\stepone}(t_{n+\half})=u^{\stephalf}(t_{n+1}),
\quad t\in [t_n+\half\Delta t, t_n+\Delta t]\tp
\end{align*}
$$

The global solution is set as \( u(t_{n+1}) = u^{\stepone}(t_{n+1}) \).

<p>
There is no use in combining higher-order methods with
ordinary splitting since the error due to splitting is \( \Oof{\Delta
t} \), but for Strang splitting it makes sense to use schemes of order
\( \Oof{\Delta t^2} \).

<p>
With the notation introduced for Strang splitting, we may express
ordinary first-order splitting as

$$
\begin{align*}
\frac{du^{\stepzero}}{dt} &= f_0(u^{\stepzero}),\quad u^{\stepzero}(t_n)=u(t_n),
\quad t\in [t_n,t_n+\Delta t],\\ 
\frac{du^{\stepone}}{dt} &= f_1(u^{\stepone}),\quad u^{\stepone}(t_n)=u^{\stepzero}(t_{n+1}),
\quad t\in [t_n,t_n+\Delta t],
\end{align*}
$$

with global solution set as \( u(t_{n+1}) = u^{\stepone}(t_{n+1}) \).

<h2 id="nonlin:splitting:logistic">Example: Logistic growth</h2>

<p>
Let us split the (scaled) logistic equation

$$ u'=u(1-u),\quad u(0)=0.1,$$

with solution \( u=(9e^{-t}+1)^{-1} \), into

$$ u'=u - u^2 = f_0(u) + f_1(u), \quad f_0(u)=u,\quad f_1(u)=-u^2\tp$$

We solve \( u'=f_0(u) \) and \( u'=f_1(u) \) by a Forward Euler step.
In addition, we add a method where we solve \( u'=f_0(u) \) analytically,
since the equation is actually \( u'=u \) with solution \( e^t \).
The software that accompanies the following methods is the file
<a href="http://tinyurl.com/nu656p2/nonlin/split_logistic.py" target="_self"><tt>split_logistic.py</tt></a>.

<h3 id="___sec54">Splitting techniques </h3>

<p>
Ordinary splitting takes a Forward Euler step for each of the ODEs
according to

$$
\begin{align}
\frac{u^{\stepzero,n+1} - u^{\stepzero,n}}{\Delta t} &=
f_0(u^{\stepzero,n}),\quad
u^{\stepzero,n} = u(t_n),\quad t\in [t_n,t_n+\Delta t],
\tag{74}\\ 
\frac{u^{\stepone,n+1} - u^{\stepone, n}}{\Delta t} &= f_1(u^{\stepone,n}),\quad
u^{\stepone,n} = u^{\stepzero,n+1},\quad t\in [t_n,t_n+\Delta t],
\tag{75}
\end{align}
$$

with \( u(t_{n+1}) = u^{\stepone,n+1} \).

<p>
Strang splitting takes the form

$$
\begin{align}
\frac{u^{\stepzero,n+\half} - u^{\stepzero,n}}{\half\Delta t} &=
f_0(u^{\stepzero,n}),\quad
u^{\stepzero,n} = u(t_n),\quad t\in [t_n,t_n+\half\Delta t],
\tag{76}\\ 
\frac{u^{\stephalf,n+1}-u^{\stephalf,n}}{\Delta t} &=
f_1(u^{\stephalf,n}),\quad
u^{\stephalf,n} = u^{\stepzero, n+\half},\quad t\in [t_n,t_n+\Delta t],
\tag{77}\\ 
\frac{u^{\stepone, n+1} - u^{\stepone, n+\half}}{\half\Delta t} &=
f_0(u^{\stepone,n+\half}),\quad
u^{\stepone,n+\half} = u^{\stephalf,n+1},\quad
t\in [t_n+\half\Delta t, t_n+\Delta t]\tp
\tag{78}
\end{align}
$$

<h3 id="___sec55">Verbose implementation </h3>

<p>
The following function computes four solutions arising from the Forward
Euler method, ordinary splitting, Strang splitting, as well as Strang splitting
with exact treatment of \( u'=f_0(u) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(dt, T, f, f_0, f_1):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=f by the Forward Euler method and by ordinary and</span>
<span style="color: #CD5555">    Strang splitting: f(u) = f_0(u) + f_1(u).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    t = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)
    u_FE = np.zeros(<span style="color: #658b00">len</span>(t))
    u_split1 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 1st-order splitting</span>
    u_split2 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 2nd-order splitting</span>
    u_split3 = np.zeros(<span style="color: #658b00">len</span>(t))  <span style="color: #228B22"># 2nd-order splitting w/exact f_0</span>

    <span style="color: #228B22"># Set initial values</span>
    u_FE[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split1[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split2[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>
    u_split3[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0.1</span>

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>):
        <span style="color: #228B22"># Forward Euler method</span>
        u_FE[n+<span style="color: #B452CD">1</span>] = u_FE[n] + dt*f(u_FE[n])

        <span style="color: #228B22"># --- Ordinary splitting ---</span>
        <span style="color: #228B22"># First step</span>
        u_s_n = u_split1[n]
        u_s = u_s_n + dt*f_0(u_s_n)
        <span style="color: #228B22"># Second step</span>
        u_ss_n = u_s
        u_ss = u_ss_n + dt*f_1(u_ss_n)
        u_split1[n+<span style="color: #B452CD">1</span>] = u_ss

        <span style="color: #228B22"># --- Strang splitting ---</span>
        <span style="color: #228B22"># First step</span>
        u_s_n = u_split2[n]
        u_s = u_s_n + dt/<span style="color: #B452CD">2.</span>*f_0(u_s_n)
        <span style="color: #228B22"># Second step</span>
        u_sss_n = u_s
        u_sss = u_sss_n + dt*f_1(u_sss_n)
        <span style="color: #228B22"># Third step</span>
        u_ss_n = u_sss
        u_ss = u_ss_n + dt/<span style="color: #B452CD">2.</span>*f_0(u_ss_n)
        u_split2[n+<span style="color: #B452CD">1</span>] = u_ss

        <span style="color: #228B22"># --- Strang splitting using exact integrator for u&#39;=f_0 ---</span>
        <span style="color: #228B22"># First step</span>
        u_s_n = u_split3[n]
        u_s = u_s_n*np.exp(dt/<span style="color: #B452CD">2.</span>)  <span style="color: #228B22"># exact</span>
        <span style="color: #228B22"># Second step</span>
        u_sss_n = u_s
        u_sss = u_sss_n + dt*f_1(u_sss_n)
        <span style="color: #228B22"># Third step</span>
        u_ss_n = u_sss
        u_ss = u_ss_n*np.exp(dt/<span style="color: #B452CD">2.</span>)  <span style="color: #228B22"># exact</span>
        u_split3[n+<span style="color: #B452CD">1</span>] = u_ss

    <span style="color: #8B008B; font-weight: bold">return</span> u_FE, u_split1, u_split2, u_split3, t
</pre></div>

<h3 id="___sec56">Compact implementation </h3>

<p>
We have used quite many lines for the steps in the splitting methods.
Many will prefer to condense the code a bit, as done here:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Ordinary splitting</span>
u_s = u_split1[n] + dt*f_0(u_split1[n])
u_split1[n+<span style="color: #B452CD">1</span>] = u_s + dt*f_1(u_s)
<span style="color: #228B22"># Strang splitting</span>
u_s = u_split2[n] + dt/<span style="color: #B452CD">2.</span>*f_0(u_split2[n])
u_sss = u_s + dt*f_1(u_s)
u_split2[n+<span style="color: #B452CD">1</span>] = u_sss + dt/<span style="color: #B452CD">2.</span>*f_0(u_sss)
<span style="color: #228B22"># Strang splitting using exact integrator for u&#39;=f_0</span>
u_s = u_split3[n]*np.exp(dt/<span style="color: #B452CD">2.</span>)  <span style="color: #228B22"># exact</span>
u_ss = u_s + dt*f_1(u_s)
u_split3[n+<span style="color: #B452CD">1</span>] = u_ss*np.exp(dt/<span style="color: #B452CD">2.</span>)
</pre></div>

<h3 id="___sec57">Results </h3>

<p>
Figure <a href="#nonlin:splitting:ODE:logistic:fig">3</a> shows that the impact of
splitting is significant. Interestingly, however,
the Forward Euler method applied to the entire problem directly is much more
accurate than any of the splitting schemes. We also see that Strang
splitting is definitely more accurate than ordinary splitting and that
it helps a bit to use an exact solution of \( u'=f_0(u) \).  With a large
time step (\( \Delta t = 0.2 \), left plot in Figure
<a href="#nonlin:splitting:ODE:logistic:fig">3</a>), the asymptotic values are off
by 20-30%.  A more reasonable time step (\( \Delta t = 0.05 \), right plot
in Figure <a href="#nonlin:splitting:ODE:logistic:fig">3</a>) gives better
results, but still the asymptotic values are up to 10% wrong.

<p>
As technique for solving nonlinear ODEs, we realize that the present
case study is not particularly promising, as the Forward Euler method
both linearizes the original problem and provides a solution that is
much more accurate than any of the splitting techniques.
In complicated multi-physics settings, on the other hand, splitting
may be the only feasible way to go, and sometimes you really need to apply
different numerics to different parts of a PDE problem.
But in very simple problems, like the logistic ODE, splitting is just an
inferior technique. Still, the logistic ODE is ideal for introducing all
the mathematical details and for investigating the behavior.

<p>
<center> <!-- figure label: --> <div id="nonlin:splitting:ODE:logistic:fig"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 3:  Effect of ordinary and Strang splitting for the logistic equation.  <!-- caption label: nonlin:splitting:ODE:logistic:fig --> </p></center>
<p><img src="fig-nonlin/split_logistic.png" align="bottom" width=800></p>
</center>

<p>
<!-- Cannot analyze logistic method because we have no exact solution -->
<!-- of the discrete equations. But in the next linear problem we can analyze. -->

<h2 id="nonlin:splitting:RD">Reaction-diffusion equation</h2>

<p>
Consider a diffusion equation coupled to chemical reactions modeled by
a nonlinear term \( f(u) \):

$$ \frac{\partial u}{\partial t} = \dfc\nabla^2u + f(u)\tp$$

This is a physical process composed of two individual processes:
\( u \) is the concentration of a substance that is locally generated by
a chemical reaction \( f(u) \), while \( u \) is spreading in space because
of diffusion. There are obviously two time scales: one for the chemical
reaction and one for diffusion. Typically, fast chemical reactions require
much finer time stepping than slower diffusion processes.
It could therefore be advantageous to split
the two physical effects in separate models and use different numerical methods
for the two.

<p>
A natural spitting in the present case is

$$
\begin{align}
\frac{\partial u^{\stepzero}}{\partial t} &= \dfc\nabla^2 u^{\stepzero},
\tag{79}\\ 
\frac{\partial u^{\stepone}}{\partial t} &= f(u^{\stepone})
\tag{80}\tp
\end{align}
$$

Looking at these familiar problems,
we may apply a \( \theta \) rule (implicit) scheme for
<a href="#mjx-eqn-79">(79)</a> over one time step
and avoid dealing with nonlinearities
by applying an explicit scheme for <a href="#mjx-eqn-80">(80)</a>
over the same time step.

<p>
Suppose we have some solution \( u \) at time level \( t_n \). For flexibility,
we define a \( \theta \) method for the diffusion part
<a href="#mjx-eqn-79">(79)</a> by

$$ [D_t u^\stepzero =
\dfc (D_xD_x u^\stepzero + D_y D_y u^\stepzero)]^{n+\theta}\tp$$

We use \( u^{n} \) as initial condition for \( u^\stepzero \).

<p>
The reaction part, which is defined at each mesh point (without coupling
values in different mesh points), can employ any scheme for an ODE.
Here we use an Adams-Bashforth method of order 2. Recall that the overall
accuracy of the splitting method
is maximum \( \Oof{\Delta t^2} \) for Strang splitting,
otherwise it is just \( \Oof{\Delta t} \). Higher-order methods for ODEs will
therefore be a waste of work. The 2nd-order Adams-Bashforth method reads

$$
\begin{equation}
u^{\stepone,n+1}_{i,j} = u^{\stepone,n}_{i,j} +
\half\Delta t\left( 3f(u^{\stepone, n}_{i,j}, t_n) -
f(u^{\stepone, n-1}_{i,j}, t_{n-1})
\right)
\tp
\tag{81}
\end{equation}
$$

We can use a Forward Euler step to start the method, i.e, compute
\( u^{\stepone,1}_{i,j} \).

<p>
The algorithm goes like this:

<ol>
<li> Solve the diffusion problem for one time step as usual.</li>
<li> Solve the reaction ODEs at each mesh point in \( [t_n,t_n+\Delta t] \),
   using the diffusion solution in 1. as initial condition.
   The solution of the ODEs constitutes the solution of the original problem
   at the end of each time step.</li>
</ol>

We may use a much smaller time step when solving the reaction part, adapted
to the dynamics of the problem \( u'=f(u) \). This gives great flexibility in
splitting methods.

<h2 id="nonlin:splitting:RD_linearR">Example: Reaction-Diffusion with linear reaction term</h2>

<p>
The methods above may be explored in detail through a specific
computational example in which we compute the convergence rates
associated with four different solution approaches for the
reaction-diffusion equation with a linear reaction term,
i.e. \( f(u)=-bu \).  The methods comprise solving without splitting (just
straight Forward Euler), ordinary splitting, first order Strang
splitting, and second order Strang splitting.  In all four methods, a
standard centered difference approximation is used for the spatial
second derivative. The methods share the error model \( E = C h^r \),
while differing in the step \( h \) (being either \( \Delta x^2 \) or \( \Delta
x \)) and the convergence rate \( r \) (being either 1 or 2).

<p>
All code commented below is found in the file
<a href="http://tinyurl.com/nu656p2/nonlin/split_diffu_react.py" target="_self"><tt>split_diffu_react.py</tt></a>. When executed,
a function <code>convergence_rates</code> is called, from which all convergence
rate computations are handled:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convergence_rates</span>(scheme=<span style="color: #CD5555">&#39;diffusion&#39;</span>):
    
    F = <span style="color: #B452CD">0.5</span>     <span style="color: #228B22"># Upper limit for FE (stability). For CN, this </span>
                <span style="color: #228B22"># limit does not apply, but for simplicity, we</span>
                <span style="color: #228B22"># choose F = 0.5 as the initial F value.</span>
    T = <span style="color: #B452CD">1.2</span>
    a = <span style="color: #B452CD">3.5</span>
    b = <span style="color: #B452CD">1</span>
    L = <span style="color: #B452CD">1.5</span>
    k = np.pi/L
    
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact</span>(x, t):
        <span style="color: #CD5555">&#39;&#39;&#39;exact sol. to: du/dt = a*d^2u/dx^2 - b*u&#39;&#39;&#39;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> np.exp(-(a*k**<span style="color: #B452CD">2</span> + b)*t) * np.sin(k*x)
        
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(u, t):
        <span style="color: #8B008B; font-weight: bold">return</span> -b*u  

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> exact(x, <span style="color: #B452CD">0</span>)
        
    <span style="color: #8B008B; font-weight: bold">global</span> error    <span style="color: #228B22"># error computed in the user action function</span>
    error = <span style="color: #B452CD">0</span>  

    <span style="color: #228B22"># Convergence study</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">action</span>(u, x, t, n):
        <span style="color: #8B008B; font-weight: bold">global</span> error            
        <span style="color: #8B008B; font-weight: bold">if</span> n == <span style="color: #B452CD">1</span>:      <span style="color: #228B22"># New simulation, - reset error</span>
            error = <span style="color: #B452CD">0</span>
        <span style="color: #8B008B; font-weight: bold">else</span>:
            error = <span style="color: #658b00">max</span>(error, np.abs(u - exact(x, t[n])).max())        

    E = []
    h = []
    Nx_values = [<span style="color: #B452CD">10</span>, <span style="color: #B452CD">20</span>, <span style="color: #B452CD">40</span>, <span style="color: #B452CD">80</span>]   <span style="color: #228B22"># i.e., dx halved each time</span>
    <span style="color: #8B008B; font-weight: bold">for</span> Nx <span style="color: #8B008B">in</span> Nx_values:        
        dx = L/Nx           
        <span style="color: #8B008B; font-weight: bold">if</span> scheme == <span style="color: #CD5555">&#39;Strang_splitting_2ndOrder&#39;</span>:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Strang splitting with 2nd order schemes...&#39;</span>
            <span style="color: #228B22"># In this case, E = C*h**r (with r = 2) and since </span>
            <span style="color: #228B22"># h = dx = K*dt, the ratio dt/dx must be constant.</span>
            <span style="color: #228B22"># To fulfill this demand, we must let F change</span>
            <span style="color: #228B22"># when dx changes. From F = a*dt/dx**2, it follows</span>
            <span style="color: #228B22"># that halving dx AND doubling F assures dt/dx const.</span>
            <span style="color: #228B22"># Initially, we simply choose F = 0.5.</span>

            dt = F/a*dx**<span style="color: #B452CD">2</span>
            <span style="color: #228B22">#print &#39;dt/dx:&#39;, dt/dx            </span>
            Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
            t = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># global time            </span>
            Strang_splitting_2ndOrder(I=I, a=a, b=b, f=f, L=L, dt=dt, 
                                      dt_Rfactor=<span style="color: #B452CD">1</span>, F=F, t=t, T=T,
                                      user_action=action)    
            h.append(dx)
            <span style="color: #228B22"># prepare for next iteration (make F match dx/2)</span>
            F = F*<span style="color: #B452CD">2</span>       <span style="color: #228B22"># assures dt/dx const. when dx = dx/2                                      </span>
        <span style="color: #8B008B; font-weight: bold">else</span>:   
            <span style="color: #228B22"># In these cases, E = C*h**r (with r = 1) and since </span>
            <span style="color: #228B22"># h = dx**2 = K*dt, the ratio dt/dx**2 must be constant.</span>
            <span style="color: #228B22"># This is fulfilled by choosing F = 0.5 (for FE stability)</span>
            <span style="color: #228B22"># and make sure that F, dx and dt comply to F = a*dt/dx**2.            </span>
            dt = F/a*dx**<span style="color: #B452CD">2</span>
            Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
            t = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># global time</span>
            <span style="color: #8B008B; font-weight: bold">if</span> scheme == <span style="color: #CD5555">&#39;diffusion&#39;</span>:
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;FE on whole eqn...&#39;</span>
                diffusion_theta(I, a, f, L, dt, F, t, T,
                                step_no=<span style="color: #B452CD">0</span>, theta=<span style="color: #B452CD">0</span>,
                                u_L=<span style="color: #B452CD">0</span>, u_R=<span style="color: #B452CD">0</span>, user_action=action)                         
                h.append(dx**<span style="color: #B452CD">2</span>)
            <span style="color: #8B008B; font-weight: bold">elif</span> scheme == <span style="color: #CD5555">&#39;ordinary_splitting&#39;</span>:
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Ordinary splitting...&#39;</span>
                ordinary_splitting(I=I, a=a, b=b, f=f, L=L, dt=dt, 
                                   dt_Rfactor=<span style="color: #B452CD">1</span>, F=F, t=t, T=T,
                                   user_action=action)        
                h.append(dx**<span style="color: #B452CD">2</span>)
            <span style="color: #8B008B; font-weight: bold">elif</span> scheme == <span style="color: #CD5555">&#39;Strang_splitting_1stOrder&#39;</span>:
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Strang splitting with 1st order schemes...&#39;</span>
                Strang_splitting_1stOrder(I=I, a=a, b=b, f=f, L=L, dt=dt, 
                                          dt_Rfactor=<span style="color: #B452CD">1</span>, F=F, t=t, T=T,
                                          user_action=action)       
                h.append(dx**<span style="color: #B452CD">2</span>)
            <span style="color: #8B008B; font-weight: bold">else</span>:
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Unknown scheme requested!&#39;</span>
                sys.exit(<span style="color: #B452CD">0</span>)
        
            <span style="color: #228B22">#print &#39;dt/dx**2:&#39;, dt/dx**2            </span>
        
        E.append(error)
        Nx *= <span style="color: #B452CD">2</span>         <span style="color: #228B22"># Nx doubled gives dx/2</span>

    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;E:&#39;</span>, E
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;h:&#39;</span>, h
        
    <span style="color: #228B22"># Convergence rates </span>
    r = [np.log(E[i]/E[i-<span style="color: #B452CD">1</span>])/np.log(h[i]/h[i-<span style="color: #B452CD">1</span>])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #658b00">len</span>(Nx_values))]
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Computed rates:&#39;</span>, r


<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    
    schemes = [<span style="color: #CD5555">&#39;diffusion&#39;</span>, 
               <span style="color: #CD5555">&#39;ordinary_splitting&#39;</span>, 
               <span style="color: #CD5555">&#39;Strang_splitting_1stOrder&#39;</span>,
               <span style="color: #CD5555">&#39;Strang_splitting_2ndOrder&#39;</span>]
               
    <span style="color: #8B008B; font-weight: bold">for</span> scheme <span style="color: #8B008B">in</span> schemes:
        convergence_rates(scheme=scheme)
</pre></div>
<p>
Now, with respect to the error (\( E = C h^r \)), the Forward Euler
scheme, the ordinary splitting scheme and first order Strang splitting
scheme are all first order (\( r = 1 \)), with a step \( h = \Delta x^2 =
K^{-1}\Delta t \), where \( K \) is some constant. This implies that the
<em>ratio</em> \( \frac{\Delta t}{\Delta x^2} \) must be held constant during
convergence rate calculations. Furthermore, the Fourier number \( F =
\frac{\alpha \Delta t}{\Delta x^2} \) is upwards limited to \( F = 0.5 \),
being the stability limit with explicit schemes. Thus, in these cases,
we use the fixed value of \( F \) and a given (but changing) spatial
resolution \( \Delta x \) to compute the corresponding value of \( \Delta t \)
according to the expression for \( F \).  This assures that \( \frac{\Delta
t}{\Delta x^2} \) is kept constant. The loop in <code>convergence_rates</code> runs
over a chosen set of grid points (<code>Nx_values</code>) which gives a doubling
of spatial resolution with each iteration (\( \Delta x \) is halved).

<p>
For the second order Strang splitting scheme, we have \( r = 2 \) and a
step \( h = \Delta x = K^{-1}\Delta t \), where \( K \) again is some
constant. In this case, it is thus the ratio \( \frac{\Delta t}{\Delta
x} \) that must be held constant during the convergence rate
calculations. From the expression for \( F \), it is clear then that \( F \)
must change with each halving of \( \Delta x \). In fact, if \( F \) is
doubled each time \( \Delta x \) is halved, the ratio \( \frac{\Delta
t}{\Delta x} \) will be constant (this follows, e.g., from the
expression for \( F \)). This is utilized in our code.

<p>
A solver <code>diffusion_theta</code> is used in each of the four solution approaches:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">diffusion_theta</span>(I, a, f, L, dt, F, t, T, step_no, theta=<span style="color: #B452CD">0.5</span>, 
                    u_L=<span style="color: #B452CD">0</span>, u_R=<span style="color: #B452CD">0</span>, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Full solver for the model problem using the theta-rule</span>
<span style="color: #CD5555">    difference approximation in time (no restriction on F,</span>
<span style="color: #CD5555">    i.e., the time step when theta &gt;= 0.5).     Vectorized </span>
<span style="color: #CD5555">    implementation and sparse (tridiagonal) coefficient matrix.</span>
<span style="color: #CD5555">    Note that t always covers the whole global time interval, whether</span>
<span style="color: #CD5555">    splitting is the case or not. T, on the other hand, is </span>
<span style="color: #CD5555">    the end of the global time interval if there is no split,</span>
<span style="color: #CD5555">    but if splitting, we use T=dt. When splitting, step_no </span>
<span style="color: #CD5555">    keeps track of the time step number (for lookup in t).    </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>

    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    dx = np.sqrt(a*dt/F)   
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)       <span style="color: #228B22"># Mesh points in space</span>
    <span style="color: #228B22"># Make sure dx and dt are compatible with x and t</span>
    dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
    dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]

    u   = np.zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># solution array at t[n+1]</span>
    u_1 = np.zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># solution at t[n]</span>

    <span style="color: #228B22"># Representation of sparse matrix and right-hand side</span>
    diagonal = np.zeros(Nx+<span style="color: #B452CD">1</span>)
    lower    = np.zeros(Nx)
    upper    = np.zeros(Nx)
    b        = np.zeros(Nx+<span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Precompute sparse matrix (scipy format)</span>
    Fl = F*theta
    Fr = F*(<span style="color: #B452CD">1</span>-theta)
    diagonal[:] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*Fl
    lower[:] = -Fl  <span style="color: #228B22">#1</span>
    upper[:] = -Fl  <span style="color: #228B22">#1</span>
    <span style="color: #228B22"># Insert boundary conditions</span>
    diagonal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1</span>
    upper[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
    diagonal[Nx] = <span style="color: #B452CD">1</span>
    lower[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0</span>

    diags = [<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>]
    A = scipy.sparse.diags(
        diagonals=[diagonal, lower, upper],
        offsets=[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>], shape=(Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>),
        format=<span style="color: #CD5555">&#39;csr&#39;</span>)
    <span style="color: #228B22">#print A.todense()</span>

    <span style="color: #228B22"># Allow f to be None or 0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> f <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> f == <span style="color: #B452CD">0</span>:
        f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: np.zeros((x.size)) \ 
            <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(x, np.ndarray) <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Set initial condition  </span>
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">isinstance</span>(I, np.ndarray):   <span style="color: #228B22"># I is an array</span>
        u_1 = np.copy(I)
    <span style="color: #8B008B; font-weight: bold">else</span>:                           <span style="color: #228B22"># I is a function</span>
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
            u_1[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u_1, x, t, step_no+<span style="color: #B452CD">0</span>)        

    <span style="color: #228B22"># Time loop</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
        b[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
                  Fr*(u_1[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:]) + \ 
                  dt*theta*f(u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>], t[step_no+n+<span style="color: #B452CD">1</span>]) + \ 
                  dt*(<span style="color: #B452CD">1</span>-theta)*f(u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>], t[step_no+n])
        b[<span style="color: #B452CD">0</span>] = u_L; b[-<span style="color: #B452CD">1</span>] = u_R  <span style="color: #228B22"># boundary conditions</span>
        u[:] = scipy.sparse.linalg.spsolve(A, b)

        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            user_action(u, x, t, step_no+(n+<span style="color: #B452CD">1</span>))

        <span style="color: #228B22"># Update u_1 before next step</span>
        u_1, u = u, u_1

    <span style="color: #228B22"># u is now contained in u_1 (swapping)</span>
    <span style="color: #8B008B; font-weight: bold">return</span> u_1
</pre></div>
<p>
For the no splitting approach with Forward Euler in time, this solver
handles both the diffusion and the reaction term. When splitting,
<code>diffusion_theta</code> takes care of the diffusion term only, while the
reaction term is handled either by a Forward Euler scheme in
<code>reaction_FE</code>, or by a second order Adams-Bashforth scheme from
Odespy. The <code>reaction_FE</code> function covers one complete time step <code>dt</code>
during ordinary splitting, while Strang splitting (both first and
second order) applies it with <code>dt/2</code> twice during each time step
<code>dt</code>. Since the reaction term typically represents a much faster
process than the diffusion term, a further refinement of the time step
is made possible in <code>reaction_FE</code>. It was implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">reaction_FE</span>(I, f, L, Nx, dt, dt_Rfactor, t, step_no, 
                user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Reaction solver, Forward Euler method.</span>
<span style="color: #CD5555">    Note the at t covers the whole global time interval. </span>
<span style="color: #CD5555">    dt is either one complete,or one half, of the step in the </span>
<span style="color: #CD5555">    diffusion part, i.e. there is a local time interval </span>
<span style="color: #CD5555">    [0, dt] or [0, dt/2] that the reaction_FE</span>
<span style="color: #CD5555">    deals with each time it is called. step_no keeps</span>
<span style="color: #CD5555">    track of the (global) time step number (required </span>
<span style="color: #CD5555">    for lookup in t).    </span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>

    u = np.copy(I)      
    dt_local = dt/<span style="color: #658b00">float</span>(dt_Rfactor)    
    Nt_local = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(dt/<span style="color: #658b00">float</span>(dt_local)))    
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)  
          
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nt_local):
        time = t[step_no] + n*dt_local
        u[<span style="color: #B452CD">1</span>:Nx] = u[<span style="color: #B452CD">1</span>:Nx] + dt_local*f(u[<span style="color: #B452CD">1</span>:Nx], time)  
        
    <span style="color: #228B22"># BC already inserted in diffusion step, i.e. no action here            </span>
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
<p>
With the ordinary splitting approach, each time step <code>dt</code> is covered
twice. First computing the impact of the reaction term, then the
contribution from the diffusion term:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">ordinary_splitting</span>(I, a, b, f, L, dt, 
                       dt_Rfactor, F, t, T, 
                       user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&#39;&#39;&#39;1st order scheme, i.e. Forward Euler is enough for both</span>
<span style="color: #CD5555">    the diffusion and the reaction part. The time step dt is </span>
<span style="color: #CD5555">    given for the diffusion step, while the time step for the </span>
<span style="color: #CD5555">    reaction part is found as dt/dt_Rfactor, where dt_Rfactor &gt;= 1.</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    dx = np.sqrt(a*dt/F)
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)       <span style="color: #228B22"># Mesh points in space</span>
    u = np.zeros(Nx+<span style="color: #B452CD">1</span>)
        
    <span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
        u[i] = I(x[i])

    <span style="color: #228B22"># In the following loop, each time step is &quot;covered twice&quot;, </span>
    <span style="color: #228B22"># first for reaction, then for diffusion</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    
        <span style="color: #228B22"># Reaction step (potentially many smaller steps within dt)</span>
        u_s = reaction_FE(I=u, f=f, L=L, Nx=Nx, 
                        dt=dt, dt_Rfactor=dt_Rfactor, 
                        t=t, step_no=n, 
                        user_action=<span style="color: #658b00">None</span>)        
        
        u = diffusion_theta(I=u_s, a=a, f=<span style="color: #B452CD">0</span>, L=L, dt=dt, F=F,
                              t=t, T=dt, step_no=n, theta=<span style="color: #B452CD">0</span>,
                              u_L=<span style="color: #B452CD">0</span>, u_R=<span style="color: #B452CD">0</span>, user_action=<span style="color: #658b00">None</span>)                         
                           
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            user_action(u, x, t, n+<span style="color: #B452CD">1</span>)

    <span style="color: #8B008B; font-weight: bold">return</span>
</pre></div>
<p>
For the two Strang splitting approaches, each time step <code>dt</code> is
handled by first computing the reaction step for (the first) <code>dt/2</code>,
followed by a diffusion step <code>dt</code>, before the reaction step is treated
once again for (the remaining) <code>dt/2</code>. Since first order Strang
splitting is no better than first order accurate, both the reaction
and diffusion steps are computed explicitly. The solver was
implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Strang_splitting_1stOrder</span>(I, a, b, f, L, dt, dt_Rfactor, 
                              F, t, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&#39;&#39;&#39;Strang splitting while still using FE for the reaction</span>
<span style="color: #CD5555">    step and for the diffusion step. Gives 1st order scheme.</span>
<span style="color: #CD5555">    The time step dt is given for the diffusion step, while </span>
<span style="color: #CD5555">    the time step for the reaction part is found as </span>
<span style="color: #CD5555">    0.5*dt/dt_Rfactor, where dt_Rfactor &gt;= 1. Introduce an </span>
<span style="color: #CD5555">    extra time mesh t2 for the reaction part, since it steps dt/2.</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    t2 = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, (Nt+<span style="color: #B452CD">1</span>)+Nt)   <span style="color: #228B22"># Mesh points in diff    </span>
    dx = np.sqrt(a*dt/F)
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)     
    u = np.zeros(Nx+<span style="color: #B452CD">1</span>)
        
    <span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
        u[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    
        <span style="color: #228B22"># Reaction step (1/2 dt: from t_n to t_n+1/2)</span>
        <span style="color: #228B22"># (potentially many smaller steps within dt/2)</span>
        u_s = reaction_FE(I=u, f=f, L=L, Nx=Nx, 
                        dt=dt/<span style="color: #B452CD">2.0</span>, dt_Rfactor=dt_Rfactor, 
                        t=t2, step_no=<span style="color: #B452CD">2</span>*n, 
                        user_action=<span style="color: #658b00">None</span>)
        <span style="color: #228B22"># Diffusion step (1 dt: from t_n to t_n+1)</span>
        u_sss = diffusion_theta(I=u_s, a=a, f=<span style="color: #B452CD">0</span>, L=L, dt=dt, F=F,
                              t=t, T=dt, step_no=n, theta=<span style="color: #B452CD">0</span>,
                              u_L=<span style="color: #B452CD">0</span>, u_R=<span style="color: #B452CD">0</span>, user_action=<span style="color: #658b00">None</span>)                         
        <span style="color: #228B22"># Reaction step (1/2 dt: from t_n+1/2 to t_n+1)</span>
        <span style="color: #228B22"># (potentially many smaller steps within dt/2)</span>
        u = reaction_FE(I=u_sss, f=f, L=L, Nx=Nx, 
                        dt=dt/<span style="color: #B452CD">2.0</span>, dt_Rfactor=dt_Rfactor, 
                        t=t2, step_no=<span style="color: #B452CD">2</span>*n+<span style="color: #B452CD">1</span>, 
                        user_action=<span style="color: #658b00">None</span>)
        
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            user_action(u, x, t, n+<span style="color: #B452CD">1</span>)

    <span style="color: #8B008B; font-weight: bold">return</span>
</pre></div>
<p>
The second order version of the Strang splitting approach utilizes a
second order Adams-Bashforth solver for the reaction part and a
Crank-Nicolson scheme for the diffusion part. The solver has the same
structure as the one for first order Strang splitting and was
implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Strang_splitting_2ndOrder</span>(I, a, b, f, L, dt, dt_Rfactor, 
                              F, t, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&#39;&#39;&#39;Strang splitting using Crank-Nicolson for the diffusion</span>
<span style="color: #CD5555">    step (theta-rule) and Adams-Bashforth 2 for the reaction step. </span>
<span style="color: #CD5555">    Gives 2nd order scheme. Introduce an extra time mesh t2 for </span>
<span style="color: #CD5555">    the reaction part, since it steps dt/2.</span>
<span style="color: #CD5555">    &#39;&#39;&#39;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">odespy</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
    t2 = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, (Nt+<span style="color: #B452CD">1</span>)+Nt)   <span style="color: #228B22"># Mesh points in diff    </span>
    dx = np.sqrt(a*dt/F)
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)     
    u = np.zeros(Nx+<span style="color: #B452CD">1</span>)
        
    <span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
        u[i] = I(x[i])

    reaction_solver = odespy.AdamsBashforth2(f)    

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    
        <span style="color: #228B22"># Reaction step (1/2 dt: from t_n to t_n+1/2)</span>
        <span style="color: #228B22"># (potentially many smaller steps within dt/2)</span>
        reaction_solver.set_initial_condition(u)
        t_points = np.linspace(<span style="color: #B452CD">0</span>, dt/<span style="color: #B452CD">2.0</span>, dt_Rfactor+<span style="color: #B452CD">1</span>)
        u_AB2, t_ = reaction_solver.solve(t_points) <span style="color: #228B22"># t_ not needed</span>
        u_s = u_AB2[-<span style="color: #B452CD">1</span>,:]  <span style="color: #228B22"># pick sol at last point in time</span>

        <span style="color: #228B22"># Diffusion step (1 dt: from t_n to t_n+1)</span>
        u_sss = diffusion_theta(I=u_s, a=a, f=<span style="color: #B452CD">0</span>, L=L, dt=dt, F=F,
                              t=t, T=dt, step_no=n, theta=<span style="color: #B452CD">0.5</span>,
                              u_L=<span style="color: #B452CD">0</span>, u_R=<span style="color: #B452CD">0</span>, user_action=<span style="color: #658b00">None</span>)                         
        <span style="color: #228B22"># Reaction step (1/2 dt: from t_n+1/2 to t_n+1)</span>
        <span style="color: #228B22"># (potentially many smaller steps within dt/2)</span>
        reaction_solver.set_initial_condition(u_sss)
        t_points = np.linspace(<span style="color: #B452CD">0</span>, dt/<span style="color: #B452CD">2.0</span>, dt_Rfactor+<span style="color: #B452CD">1</span>)
        u_AB2, t_ = reaction_solver.solve(t_points) <span style="color: #228B22"># t_ not needed</span>
        u = u_AB2[-<span style="color: #B452CD">1</span>,:]  <span style="color: #228B22"># pick sol at last point in time</span>
               
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            user_action(u, x, t, n+<span style="color: #B452CD">1</span>)

    <span style="color: #8B008B; font-weight: bold">return</span>
</pre></div>
<p>
When executing <code>split_diffu_react.py</code>, we find that the estimated
convergence rates are as expected. The second order Strang splitting
gives the least error (about \( 4e^{-5} \)) and has second order
convergence (\( r = 2 \)), while the remaining three approaches have first
order convergence (\( r = 1 \)).

<h2 id="___sec60">Analysis of the splitting method </h2>

<p>
Let us address a linear PDE problem for which we can develop analytical
solutions of the discrete equations, with and without splitting, and discuss
these. Choosing \( f(u)=-\beta u \) for a constant \( \beta \) gives a linear
problem. We use the Forward Euler method for both the PDE and ODE problems.

<p>
We seek a 1D Fourier wave component solution of the problem, assuming
homogeneous Dirichlet conditions at \( x=0 \) and \( x=L \):

$$ u = e^{-\dfc k^2 t - \beta t}\sin kx,\quad k = \frac{\pi}{L}\tp$$

This component fits the 1D PDE problem (\( f=0 \)). On complex form we can
write

$$ u = e^{-\dfc k^2 t - \beta t + ikx},$$

where \( i=\sqrt{-1} \) and the imaginary part is taken as the physical solution.

<p>
We refer to the section "Analysis of schemes for
the diffusion equation": "" in <a href="._nonlin-solarized007.html#Langtangen_Linge">[2]</a> and to
the book <a href="._nonlin-solarized007.html#Langtangen_decay">[3]</a> for a discussion of exact numerical
solutions to diffusion and decay problems, respectively.  The key idea
is to search for solutions \( A^ne^{ikx} \) and determine \( A \).  For the
diffusion problem solved by a Forward Euler method one has

$$ A = 1 - 4F\sin^p, $$

where \( F=\dfc\Delta t/\Delta x^2 \) is the mesh Fourier number and \( p=k\Delta x/2 \)
is a dimensionless number reflecting the spatial resolution (number of points
per wave length in space). For the decay problem \( u'=-\beta u \), we have
\( A=1 - q \), where \( q \) is a dimensionless parameter for the resolution
in the decay problem: \( q = \beta\Delta t \).

<p>
The original model problem can also be discretized by a Forward Euler scheme,

$$ [D^+_t u = \dfc D_xD_x u - \beta u]^n_i\tp$$

Assuming \( A^ne^{ikx} \) we find that

$$ u^n_i = (1 - 4F\sin^p -q)^n\sin kx\tp$$

We are particularly interested in what happens at one time step. That is,

$$ u^{n}_{i} = (1-4F\sin^2 p)u^{n-1}_i\tp$$

<p>
In the two stage algorithm, we first compute the diffusion step

$$ u^{\stepzero,n+1}_i = (1 - 4F\sin^2 p)u^{n-1}_i\tp$$

Then we use this as input to the decay algorithm and arrive at

$$ u^{\stepone,n+1} = (1-q)u^{\stepzero,n+1} = (1-q)(1-4F\sin^2 p) u^{n-1}_i\tp$$

The splitting approximation over one step is therefore

$$ E = 1 - 4F\sin^p -q - (1-q)(1-4F\sin^2 p) = -q(2 - F\sin^2 p))\tp $$

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._nonlin-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._nonlin-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

