<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite Difference Computing with Partial Differential Equations">
<meta name="keywords" content="vibration ODE,oscillations,mechanical vibrations,period (of oscillations),frequency (of oscillations),Hz (unit),mesh finite differences,mesh function,centered difference,finite differences centered,test function,pytest,nose,verification hand calculations,unit testing,verification polynomial solutions,verification convergence rates,making movies,animation,WebM (video format),Ogg (video format),MP4 (video format),Flash (video format),video formats,HTML5 video tag,error global,stability criterion,phase plane plot,mechanical energy,energy principle,forward-backward Euler-Cromer scheme,nonlinear restoring force,nonlinear spring,forced vibrations,geometric mean,averaging geometric,DOF (degree of freedom),resonance,waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,callback function,verification polynomial solution,nose,pytest,unit testing,test function,closure,vectorization,parallelism,scalar code,vectorization,array computing,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,boundary conditions Neumann,boundary conditions Dirichlet,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,radiation condition,open boundary condition,boundary condition open (radiation),periodic boundary conditions,boundary conditions periodic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,index set notation,diffusion equation, 1D,heat equation, 1D,stationary solution,explicit discretization methods,Forward Euler scheme,implicit discretization methods,amplification factor,sparse matrix,Jacobi method,Gauss-Seidel method,SOR method,red-black numbering,LU factorization,Cholesky factorization,preconditioning,random walk,vectorization,seed (random numbers),verification,diffusion limit of random walk,interrupt a program by Ctrl+c,stochastic difference equation,stochastic ODE,Fokker-Planck equation,Wiener process,energy estimates (diffusion),Richardson iteration,preconditioning,upwind difference,staggered mesh,staggered Euler-Cromer scheme,alternating mesh,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,truncation error general,finite differences backward,truncation error Backward Euler scheme,finite differences forward,truncation error Forward Euler scheme,finite differences centered,truncation error Crank-Nicolson scheme,truncation error table of formulas,decay ODE,correction terms,truncation error correction terms,verification,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage">

<title>Finite Difference Computing with Partial Differential Equations</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>



<!-- Tools for embedded Bokeh plots -->
<link rel="stylesheet"
      href="http://cdn.pydata.org/bokeh/release/bokeh-0.9.0.min.css"
      type="text/css" />
<script type="text/javascript"
	src="http://cdn.pydata.org/bokeh/release/bokeh-0.9.0.min.js">
</script>
<script type="text/javascript">
  Bokeh.set_log_level("info");
</script>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Simplify, understand, generalize', 3, None, '___sec1'),
              (u'Constructive mathematics', 3, None, '___sec2'),
              (u'All nuts and bolts', 3, None, '___sec3'),
              (u'Python as programming language', 3, None, '___sec4'),
              (u'Program verification', 3, None, '___sec5'),
              (u'Vectorized code', 3, None, '___sec6'),
              (u'Analysis via exact solutions of discrete equations',
               3,
               None,
               '___sec7'),
              (u'Code-inspired mathematical notation', 3, None, '___sec8'),
              (u'Limited scope', 3, None, '___sec9'),
              (u'Independent chapters', 3, None, '___sec10'),
              (u'Supplementary materials', 3, None, '___sec11'),
              (u'Acknowledgments', 3, None, '___sec12'),
              (u'Vibration ODEs', 0, u'ch:vib', u'ch:vib'),
              (u'Finite difference discretization',
               1,
               u'vib:model1',
               u'vib:model1'),
              (u'A basic model for vibrations', 2, None, '___sec15'),
              (u'A centered finite difference scheme',
               2,
               u'vib:ode1:fdm',
               u'vib:ode1:fdm'),
              (u'Step 1: Discretizing the domain', 3, None, '___sec17'),
              (u'Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec18'),
              (u'Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec19'),
              (u'Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec20'),
              (u'Computing the first step', 3, None, '___sec21'),
              (u'The computational algorithm', 3, None, '___sec22'),
              (u'Operator notation', 3, None, '___sec23'),
              (u'Implementation', 1, u'vib:impl1', u'vib:impl1'),
              (u'Making a solver function',
               2,
               u'vib:impl1:solver',
               u'vib:impl1:solver'),
              (u'Computing $u^{\\prime}$', 3, None, '___sec26'),
              (u'Verification', 2, u'vib:ode1:verify', u'vib:ode1:verify'),
              (u'Manual calculation', 3, None, '___sec28'),
              (u'Testing very simple polynomial solutions',
               3,
               None,
               '___sec29'),
              (u'Checking convergence rates', 3, None, '___sec30'),
              (u'Scaled model', 2, None, '___sec31'),
              (u'Long time simulations',
               1,
               u'vib:ode1:longseries',
               u'vib:ode1:longseries'),
              (u'Using a moving plot window', 2, None, '___sec33'),
              (u'Making animations', 2, u'vib:ode1:anim', u'vib:ode1:anim'),
              (u'Producing standard video formats', 3, None, '___sec35'),
              (u'Paying PNG files in a web browser', 3, None, '___sec36'),
              (u'Making animated GIF files', 3, None, '___sec37'),
              (u'Using Bokeh to compare graphs', 2, None, '___sec38'),
              (u'Using a line-by-line ascii plotter', 2, None, '___sec39'),
              (u'Empirical analysis of the solution',
               2,
               u'vib:ode1:empirical',
               u'vib:ode1:empirical'),
              (u'Analysis of the numerical scheme',
               1,
               u'vib:ode1:analysis',
               u'vib:ode1:analysis'),
              (u'Deriving a solution of the numerical scheme',
               2,
               None,
               '___sec42'),
              (u'Exact discrete solution',
               2,
               u'vib:ode1:analysis:sol',
               u'vib:ode1:analysis:sol'),
              (u'Convergence',
               2,
               u'vib:ode1:analysis:conv',
               u'vib:ode1:analysis:conv'),
              (u'The global error', 2, None, '___sec45'),
              (u'Stability', 2, None, '___sec46'),
              (u'About the accuracy at the stability limit',
               2,
               None,
               '___sec47'),
              (u'Alternative schemes based on 1st-order equations',
               1,
               u'vib:model2x2',
               u'vib:model2x2'),
              (u'The Forward Euler scheme', 2, None, '___sec49'),
              (u'The Backward Euler scheme', 2, None, '___sec50'),
              (u'The Crank-Nicolson scheme',
               2,
               u'vib:undamped:CN',
               u'vib:undamped:CN'),
              (u'Comparison of schemes',
               2,
               u'vib:model2x2:compare',
               u'vib:model2x2:compare'),
              (u'Runge-Kutta methods', 2, None, '___sec53'),
              (u'Analysis of the Forward Euler scheme', 2, None, '___sec54'),
              (u'Energy considerations',
               1,
               u'vib:model1:energy',
               u'vib:model1:energy'),
              (u'Derivation of the energy expression',
               2,
               u'vib:model1:energy:expr',
               u'vib:model1:energy:expr'),
              (u'Energy of the exact solution', 3, None, '___sec57'),
              (u'An error measure based on energy',
               2,
               u'vib:model1:energy:measure',
               u'vib:model1:energy:measure'),
              (u'The Euler-Cromer method',
               1,
               u'vib:model2x2:EulerCromer',
               u'vib:model2x2:EulerCromer'),
              (u'Forward-backward discretization', 2, None, '___sec60'),
              (u'Equivalence with the scheme for the second-order ODE',
               2,
               u'vib:model2x2:EulerCromer:equiv',
               u'vib:model2x2:EulerCromer:equiv'),
              (u'Implementation',
               2,
               u'vib:model2x2:EulerCromer:impl',
               u'vib:model2x2:EulerCromer:impl'),
              (u'The velocity Verlet algorithm', 2, None, '___sec63'),
              (u'Generalization: damping, nonlinear spring, and external excitation',
               1,
               u'vib:model2',
               u'vib:model2'),
              (u'A centered scheme for linear damping',
               2,
               u'vib:ode2:fdm:flin',
               u'vib:ode2:fdm:flin'),
              (u'A centered scheme for quadratic damping',
               2,
               u'vib:ode2:fdm:fquad',
               u'vib:ode2:fdm:fquad'),
              (u'A forward-backward discretization of the quadratic damping term',
               2,
               None,
               '___sec67'),
              (u'Implementation', 2, u'vib:ode2:solver', u'vib:ode2:solver'),
              (u'Verification', 2, u'vib:ode2:verify', u'vib:ode2:verify'),
              (u'Constant solution', 3, None, '___sec70'),
              (u'Linear solution', 3, None, '___sec71'),
              (u'Quadratic solution', 3, None, '___sec72'),
              (u'Visualization', 2, u'vib:ode2:viz', u'vib:ode2:viz'),
              (u'User interface', 2, u'vib:ode2:ui', u'vib:ode2:ui'),
              (u'The Euler-Cromer scheme for the generalized model',
               2,
               None,
               '___sec75'),
              (u'Exercises and Problems', 1, None, '___sec76'),
              (u'Problem 1.1: Use linear/quadratic functions for verification',
               2,
               u'vib:exer:undamped:verify:linquad',
               u'vib:exer:undamped:verify:linquad'),
              (u'Exercise 1.2: Show linear growth of the phase with time',
               2,
               u'vib:exer:phase:err:growth',
               u'vib:exer:phase:err:growth'),
              (u'Exercise 1.3: Improve the accuracy by adjusting the frequency',
               2,
               u'vib:exer:w:adjust',
               u'vib:exer:w:adjust'),
              (u'Exercise 1.4: See if adaptive methods improve the phase error',
               2,
               u'vib:exer:undamped:adaptive',
               u'vib:exer:undamped:adaptive'),
              (u'Exercise 1.5: Use a Taylor polynomial to compute $u^1$',
               2,
               u'vib:exer:step4b:alt',
               u'vib:exer:step4b:alt'),
              (u'Exercise 1.6: Find the minimal resolution of an oscillatory function',
               2,
               u'vib:exer:wdt:limit',
               u'vib:exer:wdt:limit'),
              (u'Exercise 1.7: Visualize the accuracy of finite differences for a cosine function',
               2,
               u'vib:exer:fd:exp:plot',
               u'vib:exer:fd:exp:plot'),
              (u'Exercise 1.8: Verify convergence rates of the error in energy',
               2,
               u'vib:exer:energy:convrate',
               u'vib:exer:energy:convrate'),
              (u'Exercise 1.9: Use linear/quadratic functions for verification',
               2,
               u'vib:exer:verify:gen:linear',
               u'vib:exer:verify:gen:linear'),
              (u'Exercise 1.10: Use an exact discrete solution for verification',
               2,
               u'vib:exer:discrete:omega',
               u'vib:exer:discrete:omega'),
              (u'Exercise 1.11: Use analytical solution for convergence rate tests',
               2,
               u'vib:exer:conv:rate',
               u'vib:exer:conv:rate'),
              (u'Exercise 1.12: Investigate the amplitude errors of many solvers',
               2,
               u'vib:exer:undamped:odespy',
               u'vib:exer:undamped:odespy'),
              (u'Exercise 1.13: Minimize memory usage of a vibration solver',
               2,
               u'vib:exer:memsave',
               u'vib:exer:memsave'),
              (u'Exercise 1.14: Implement the solver via classes',
               2,
               u'vib:exer:gen:class',
               u'vib:exer:gen:class'),
              (u'Exercise 1.15: Interpret $[D_tD_t u]^n$ as a forward-backward difference',
               2,
               u'vib:exer:DtDt:asDtpDtm',
               u'vib:exer:DtDt:asDtpDtm'),
              (u'Exercise 1.16: Use a backward difference for the damping term',
               2,
               u'vib:exer:quad:damping:bw',
               u'vib:exer:quad:damping:bw'),
              (u'Exercise 1.17: Analysis of the Euler-Cromer scheme',
               2,
               u'vib:exer:EulerCromer:analysis',
               u'vib:exer:EulerCromer:analysis'),
              (u'Applications of vibration models',
               1,
               u'vib:app',
               u'vib:app'),
              (u'Oscillating mass attached to a spring',
               2,
               u'vib:app:mass_spring',
               u'vib:app:mass_spring'),
              (u'Scaling', 3, None, '___sec96'),
              (u'The physics', 3, None, '___sec97'),
              (u'General mechanical vibrating system',
               2,
               u'vib:app:mass_gen',
               u'vib:app:mass_gen'),
              (u'Scaling', 3, None, '___sec99'),
              (u'A sliding mass attached to a spring',
               2,
               u'vib:app:mass_sliding',
               u'vib:app:mass_sliding'),
              (u'A jumping washing machine',
               2,
               u'vib:app:washmach',
               u'vib:app:washmach'),
              (u'Motion of a pendulum',
               2,
               u'vib:app:pendulum',
               u'vib:app:pendulum'),
              (u'Simple pendulum', 3, None, '___sec103'),
              (u'Physical pendulum', 3, None, '___sec104'),
              (u'Dynamic free body diagram during pendulum motion',
               2,
               u'vib:app:pendulum_bodydia',
               u'vib:app:pendulum_bodydia'),
              (u'Writing the solver', 3, None, '___sec106'),
              (u'Drawing the free body diagram', 3, None, '___sec107'),
              (u'Making the animated free body diagram',
               3,
               None,
               '___sec108'),
              (u'Motion of an elastic pendulum',
               2,
               u'vib:app:pendulum_elastic',
               u'vib:app:pendulum_elastic'),
              (u'Remarks about an elastic vs a non-elastic pendulum',
               3,
               None,
               '___sec110'),
              (u'Initial conditions', 3, None, '___sec111'),
              (u'The complete ODE problem', 3, None, '___sec112'),
              (u'Scaling', 3, None, '___sec113'),
              (u'Remark on the non-elastic limit', 3, None, '___sec114'),
              (u'Vehicle on a bumpy road',
               2,
               u'vib:app:bumpy',
               u'vib:app:bumpy'),
              (u'Bouncing ball',
               2,
               u'vib:app:bouncing_ball',
               u'vib:app:bouncing_ball'),
              (u'Electric circuits', 2, None, '___sec117'),
              (u'Exercises', 1, None, '___sec118'),
              (u'Exercise 1.18: Simulate resonance',
               2,
               u'vib:exer:resonance',
               u'vib:exer:resonance'),
              (u'Exercise 1.19: Simulate oscillations of a sliding box',
               2,
               u'vib:exer:sliding_box',
               u'vib:exer:sliding_box'),
              (u'Exercise 1.20: Simulate a bouncing ball',
               2,
               u'vib:exer:bouncing:ball',
               u'vib:exer:bouncing:ball'),
              (u'Exercise 1.21: Simulate a simple pendulum',
               2,
               u'vib:exer:pendulum_simple',
               u'vib:exer:pendulum_simple'),
              (u'Exercise 1.22: Simulate an elastic pendulum',
               2,
               u'vib:exer:pendulum_elastic',
               u'vib:exer:pendulum_elastic'),
              (u'Exercise 1.23: Simulate an elastic pendulum with air resistance',
               2,
               u'vib:exer:pendulum_elastic_drag',
               u'vib:exer:pendulum_elastic_drag'),
              (u'Remarks', 3, None, '___sec125'),
              (u'Wave equations', 0, u'ch:wave', u'ch:wave'),
              (u'Simulation of waves on a string',
               1,
               u'wave:string',
               u'wave:string'),
              (u'Discretizing the domain',
               2,
               u'wave:string:mesh',
               u'wave:string:mesh'),
              (u'Uniform meshes', 3, None, '___sec129'),
              (u'The discrete solution',
               2,
               u'wave:string:numerical:sol',
               u'wave:string:numerical:sol'),
              (u'Fulfilling the equation at the mesh points',
               2,
               u'wave:string:samplingPDE',
               u'wave:string:samplingPDE'),
              (u'Replacing derivatives by finite differences',
               2,
               u'wave:string:fd',
               u'wave:string:fd'),
              (u'Algebraic version of the PDE', 3, None, '___sec133'),
              (u'Interpretation of the equation as a stencil',
               3,
               None,
               '___sec134'),
              (u'Algebraic version of the initial conditions',
               3,
               None,
               '___sec135'),
              (u'Formulating a recursive algorithm',
               2,
               u'wave:string:alg',
               u'wave:string:alg'),
              (u'Sketch of an implementation',
               2,
               u'wave:string:impl',
               u'wave:string:impl'),
              (u'Verification', 1, None, '___sec138'),
              (u'A slightly generalized model problem',
               2,
               u'wave:pde2:fd',
               u'wave:pde2:fd'),
              (u'Using an analytical solution of physical significance',
               2,
               u'wave:pde2:fd:standing:waves',
               u'wave:pde2:fd:standing:waves'),
              (u'Manufactured solution',
               2,
               u'wave:pde2:fd:MMS',
               u'wave:pde2:fd:MMS'),
              (u'Constructing an exact solution of the discrete equations',
               2,
               u'wave:pde2:fd:verify:quadratic',
               u'wave:pde2:fd:verify:quadratic'),
              (u'Implementation', 1, u'wave:pde1:impl', u'wave:pde1:impl'),
              (u'Callback function for user-specific actions',
               2,
               None,
               '___sec144'),
              (u'The solver function',
               2,
               u'wave:pde1:impl:solver',
               u'wave:pde1:impl:solver'),
              (u'Verification: exact quadratic solution',
               2,
               u'wave:pde1:impl:verify:quadratic',
               u'wave:pde1:impl:verify:quadratic'),
              (u'Visualization: animating the solution',
               2,
               u'wave:pde1:impl:animate',
               u'wave:pde1:impl:animate'),
              (u'Function for administering the simulation',
               3,
               None,
               '___sec148'),
              (u'Dissection of the code', 3, None, '___sec149'),
              (u'Making movie files', 3, None, '___sec150'),
              (u'Skipping frames for animation speed', 3, None, '___sec151'),
              (u'Running a case',
               2,
               u'wave:pde1:guitar:data',
               u'wave:pde1:guitar:data'),
              (u'Working with a scaled PDE model', 2, None, '___sec153'),
              (u'Vectorization',
               1,
               u'wave:pde1:impl:vec',
               u'wave:pde1:impl:vec'),
              (u'Operations on slices of arrays',
               2,
               u'wave:pde1:impl:vec:slices:basics',
               u'wave:pde1:impl:vec:slices:basics'),
              (u'Finite difference schemes expressed as slices',
               2,
               u'wave:pde1:impl:vec:slices:fdm',
               u'wave:pde1:impl:vec:slices:fdm'),
              (u'Verification',
               2,
               u'wave:pde1:impl:vec:verify:quadratic',
               u'wave:pde1:impl:vec:verify:quadratic'),
              (u'Efficiency measurements', 2, None, '___sec158'),
              (u'Solution 1', 3, None, '___sec159'),
              (u'Solution 2', 3, None, '___sec160'),
              (u'Efficiency experiments', 3, None, '___sec161'),
              (u'Remark on the updating of arrays',
               2,
               u'wave:pde1:impl:ref:switch',
               u'wave:pde1:impl:ref:switch'),
              (u'Exercises', 1, None, '___sec163'),
              (u'Exercise 2.1: Simulate a standing wave',
               2,
               u'wave:exer:standingwave',
               u'wave:exer:standingwave'),
              (u'Remarks', 3, None, '___sec165'),
              (u'Exercise 2.2: Add storage of solution in a user action function',
               2,
               u'wave:exer:store:list',
               u'wave:exer:store:list'),
              (u'Exercise 2.3: Use a class for the user action function',
               2,
               u'wave:exer:store:list:class',
               u'wave:exer:store:list:class'),
              (u'Exercise 2.4: Compare several Courant numbers in one movie',
               2,
               u'wave:exer:multiple:C',
               u'wave:exer:multiple:C'),
              (u'Project 2.5: Calculus with 1D mesh functions',
               2,
               u'wave:exer:mesh1D:calculus',
               u'wave:exer:mesh1D:calculus'),
              (u'Generalization: reflecting boundaries',
               1,
               u'wave:pde2:Neumann',
               u'wave:pde2:Neumann'),
              (u'Neumann boundary condition',
               2,
               u'wave:pde2:Neumann:bc',
               u'wave:pde2:Neumann:bc'),
              (u'Discretization of derivatives at the boundary',
               2,
               u'wave:pde2:Neumann:discr',
               u'wave:pde2:Neumann:discr'),
              (u'Implementation of Neumann conditions',
               2,
               u'wave:pde2:Neumann:impl',
               u'wave:pde2:Neumann:impl'),
              (u'Index set notation', 2, u'wave:indexset', u'wave:indexset'),
              (u'Verifying the implementation of Neumann conditions',
               2,
               u'wave:pde1:verify',
               u'wave:pde1:verify'),
              (u'Alternative implementation via ghost cells',
               2,
               u'wave:pde1:Neumann:ghost',
               u'wave:pde1:Neumann:ghost'),
              (u'Idea', 3, None, '___sec177'),
              (u'Implementation', 3, None, '___sec178'),
              (u'Generalization: variable wave velocity',
               1,
               u'wave:pde2:var:c',
               u'wave:pde2:var:c'),
              (u'The model PDE with a variable coefficient',
               2,
               None,
               '___sec180'),
              (u'Discretizing the variable coefficient',
               2,
               u'wave:pde2:var:c:ideas',
               u'wave:pde2:var:c:ideas'),
              (u'Computing the coefficient between mesh points',
               2,
               u'wave:pde2:var:c:means',
               u'wave:pde2:var:c:means'),
              (u'How a variable coefficient affects the stability',
               2,
               u'wave:pde2:var:c:stability',
               u'wave:pde2:var:c:stability'),
              (u'Neumann condition and a variable coefficient',
               2,
               u'wave:pde2:var:c:Neumann',
               u'wave:pde2:var:c:Neumann'),
              (u'Implementation of variable coefficients',
               2,
               u'wave:pde2:var:c:impl',
               u'wave:pde2:var:c:impl'),
              (u'A more general PDE model with variable coefficients',
               2,
               None,
               '___sec186'),
              (u'Generalization: damping', 2, None, '___sec187'),
              (u'Building a general 1D wave equation solver',
               1,
               u'wave:pde2:software',
               u'wave:pde2:software'),
              (u'User action function as a class', 2, None, '___sec189'),
              (u'The code', 3, None, '___sec190'),
              (u'Dissection', 3, None, '___sec191'),
              (u'Pulse propagation in two media', 2, None, '___sec192'),
              (u'Exercises', 1, None, '___sec193'),
              (u'Exercise 2.6: Find the analytical solution to a damped wave equation',
               2,
               u'wave:exer:standingwave:damped:uex',
               u'wave:exer:standingwave:damped:uex'),
              (u'Problem 2.7: Explore symmetry boundary conditions',
               2,
               u'wave:exer:symmetry:bc',
               u'wave:exer:symmetry:bc'),
              (u'Exercise 2.8: Send pulse waves through a layered medium',
               2,
               u'wave:app:exer:pulse1D',
               u'wave:app:exer:pulse1D'),
              (u'Exercise 2.9: Explain why numerical noise occurs',
               2,
               u'wave:app:exer:pulse1D:analysis',
               u'wave:app:exer:pulse1D:analysis'),
              (u'Exercise 2.10: Investigate harmonic averaging in a 1D model',
               2,
               u'wave:app:exer:pulse1D:harmonic',
               u'wave:app:exer:pulse1D:harmonic'),
              (u'Problem 2.11: Implement open boundary conditions',
               2,
               u'wave:app:exer:radiationBC',
               u'wave:app:exer:radiationBC'),
              (u'Remarks', 3, None, '___sec200'),
              (u'Exercise 2.12: Implement periodic boundary conditions',
               2,
               u'wave:exer:periodic',
               u'wave:exer:periodic'),
              (u'Exercise 2.13: Compare discretizations of a Neumann condition',
               2,
               None,
               '___sec202'),
              (u'Exercise 2.14: Verification by a cubic polynomial in space',
               2,
               u'wave:fd2:exer:verify:cubic',
               u'wave:fd2:exer:verify:cubic'),
              (u'Analysis of the difference equations',
               1,
               u'wave:pde1:analysis',
               u'wave:pde1:analysis'),
              (u'Properties of the solution of the wave equation',
               2,
               u'wave:pde1:properties',
               u'wave:pde1:properties'),
              (u'More precise definition of Fourier representations',
               2,
               u'wave:pde1:Fourier',
               u'wave:pde1:Fourier'),
              (u'Stability',
               2,
               u'wave:pde1:stability',
               u'wave:pde1:stability'),
              (u'Preliminary results', 3, None, '___sec208'),
              (u'Numerical wave propagation', 3, None, '___sec209'),
              (u'Numerical dispersion relation',
               2,
               u'wave:pde1:num:dispersion',
               u'wave:pde1:num:dispersion'),
              (u'Extending the analysis to 2D and 3D',
               2,
               u'wave:pde1:analysis:2D3D',
               u'wave:pde1:analysis:2D3D'),
              (u'Finite difference methods for 2D and 3D wave equations',
               1,
               u'wave:2D3D',
               u'wave:2D3D'),
              (u'Multi-dimensional wave equations',
               2,
               u'wave:2D3D:models',
               u'wave:2D3D:models'),
              (u'Mesh', 2, u'wave:2D3D:mesh', u'wave:2D3D:mesh'),
              (u'Discretization',
               2,
               u'wave:2D3D:discretization',
               u'wave:2D3D:discretization'),
              (u'Discretizing the PDEs', 3, None, '___sec216'),
              (u'Handling boundary conditions where $u$ is known',
               3,
               None,
               '___sec217'),
              (u'Discretizing the Neumann condition', 3, None, '___sec218'),
              (u'Implementation', 1, u'wave:2D3D:impl', u'wave:2D3D:impl'),
              (u'Scalar computations',
               2,
               u'wave2D3D:impl:scalar',
               u'wave2D3D:impl:scalar'),
              (u'Domain and mesh', 3, None, '___sec221'),
              (u'Solution arrays', 3, None, '___sec222'),
              (u'Index sets', 3, None, '___sec223'),
              (u'Computing the solution', 3, None, '___sec224'),
              (u'Vectorized computations',
               2,
               u'wave2D3D:impl:vectorized',
               u'wave2D3D:impl:vectorized'),
              (u'Verification',
               2,
               u'wave2D3D:impl:verify',
               u'wave2D3D:impl:verify'),
              (u'Testing a quadratic solution', 3, None, '___sec227'),
              (u'Exercises', 1, None, '___sec228'),
              (u'Exercise 2.15: Check that a solution fulfills the discrete model',
               2,
               u'wave:exer:quadratic:2D',
               u'wave:exer:quadratic:2D'),
              (u'Project 2.16: Calculus with 2D mesh functions',
               2,
               u'wave:exer:mesh3D:calculus',
               u'wave:exer:mesh3D:calculus'),
              (u'Exercise 2.17: Implement Neumann conditions in 2D',
               2,
               u'wave:app:exer:wave2D:Neumann',
               u'wave:app:exer:wave2D:Neumann'),
              (u'Exercise 2.18: Test the efficiency of compiled loops in 3D',
               2,
               u'wave:exer:3D:f77:cy:efficiency',
               u'wave:exer:3D:f77:cy:efficiency'),
              (u'Applications of wave equations',
               1,
               u'wave:app',
               u'wave:app'),
              (u'Waves on a string',
               2,
               u'wave:app:string',
               u'wave:app:string'),
              (u'Damping', 3, None, '___sec235'),
              (u'External forcing', 3, None, '___sec236'),
              (u'Modeling the tension via springs', 3, None, '___sec237'),
              (u'Waves on a membrane',
               2,
               u'wave:app:membrane',
               u'wave:app:membrane'),
              (u'Elastic waves in a rod',
               2,
               u'wave:app:elastic:rod',
               u'wave:app:elastic:rod'),
              (u'The acoustic model for seismic waves',
               2,
               u'wave:app:acoustic:seismic',
               u'wave:app:acoustic:seismic'),
              (u'Anisotropy', 3, None, '___sec241'),
              (u'Sound waves in liquids and gases',
               2,
               u'wave:app:sound',
               u'wave:app:sound'),
              (u'Spherical waves',
               2,
               u'wave:app:spherical',
               u'wave:app:spherical'),
              (u'The linear shallow water equations',
               2,
               u'wave:app:sw:2D',
               u'wave:app:sw:2D'),
              (u'Wind drag on the surface', 3, None, '___sec245'),
              (u'Bottom drag', 3, None, '___sec246'),
              (u"Effect of the Earth's rotation", 3, None, '___sec247'),
              (u'Waves in blood vessels',
               2,
               u'wave:app:blood',
               u'wave:app:blood'),
              (u'Electromagnetic waves',
               2,
               u'wave:app:light',
               u'wave:app:light'),
              (u'Exercises', 1, u'wave:app:exer', u'wave:app:exer'),
              (u'Exercise 2.19: Simulate waves on a non-homogeneous string',
               2,
               u'wave:app:exer:string:discont',
               u'wave:app:exer:string:discont'),
              (u'Exercise 2.20: Simulate damped waves on a string',
               2,
               u'wave:app:exer:string:damping',
               u'wave:app:exer:string:damping'),
              (u'Exercise 2.21: Simulate elastic waves in a rod',
               2,
               u'wave:app:exer:rod',
               u'wave:app:exer:rod'),
              (u'Exercise 2.22: Simulate spherical waves',
               2,
               u'wave:app:exer:spherical',
               u'wave:app:exer:spherical'),
              (u'Problem 2.23: Earthquake-generated tsunami over a subsea hill',
               2,
               u'wave:app:exer:tsunami1D:hill',
               u'wave:app:exer:tsunami1D:hill'),
              (u'Problem 2.24: Earthquake-generated tsunami over a 3D hill',
               2,
               u'wave:app:exer:tsunami2D:hill',
               u'wave:app:exer:tsunami2D:hill'),
              (u'Problem 2.25: Investigate Matplotlib for visualization',
               2,
               u'wave:app:exer:tsunami:hill:viz:matplotlib',
               u'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (u'Problem 2.26: Investigate visualization packages',
               2,
               u'wave:app:exer:tsunami:hill:viz:packages',
               u'wave:app:exer:tsunami:hill:viz:packages'),
              (u'Problem 2.27: Implement loops in compiled languages',
               2,
               u'wave:app:exer:tsunami2D:hill:compiled',
               u'wave:app:exer:tsunami2D:hill:compiled'),
              (u'Exercise 2.28: Simulate seismic waves in 2D',
               2,
               u'wave:app:exer:seismic2D',
               u'wave:app:exer:seismic2D'),
              (u'Project 2.29: Model 3D acoustic waves in a room',
               2,
               u'wave:app:exer:acoustics',
               u'wave:app:exer:acoustics'),
              (u'Project 2.30: Solve a 1D transport equation',
               2,
               u'wave:app:exer:advec1D',
               u'wave:app:exer:advec1D'),
              (u'Problem 2.31: General analytical solution of a 1D damped wave equation',
               2,
               u'wave:app:exer:anal:damped:wave1D',
               u'wave:app:exer:anal:damped:wave1D'),
              (u'Problem 2.32: General analytical solution of a 2D damped wave equation',
               2,
               u'wave:app:exer:anal:damped:wave2D',
               u'wave:app:exer:anal:damped:wave2D'),
              (u'Diffusion equations', 0, u'ch:diffu', u'ch:diffu'),
              (u'An explicit method for the 1D diffusion equation',
               1,
               u'diffu:pde1:FEsec',
               u'diffu:pde1:FEsec'),
              (u'The initial-boundary value problem for 1D diffusion',
               2,
               None,
               '___sec267'),
              (u'Forward Euler scheme',
               2,
               u'diffu:pde1:FE',
               u'diffu:pde1:FE'),
              (u'Implementation',
               2,
               u'diffu:pde1:FE:code',
               u'diffu:pde1:FE:code'),
              (u'Verification',
               2,
               u'diffu:pde1:FE:verify',
               u'diffu:pde1:FE:verify'),
              (u'Numerical experiments',
               2,
               u'diffu:pde1:FE:experiments',
               u'diffu:pde1:FE:experiments'),
              (u'Implicit methods for the 1D diffusion equation',
               1,
               u'diffu:pde1:implicit',
               u'diffu:pde1:implicit'),
              (u'Backward Euler scheme',
               2,
               u'diffu:pde1:BE',
               u'diffu:pde1:BE'),
              (u'Sparse matrix implementation',
               2,
               u'diffu:pde1:impl:sparse',
               u'diffu:pde1:impl:sparse'),
              (u'Crank-Nicolson scheme',
               2,
               u'diffu:pde1:CN',
               u'diffu:pde1:CN'),
              (u'The unifying $\\theta$ rule',
               2,
               u'diffu:pde1:theta',
               u'diffu:pde1:theta'),
              (u'Experiments',
               2,
               u'diffu:pde1:theta:experiments',
               u'diffu:pde1:theta:experiments'),
              (u'The Laplace and Poisson equation', 2, None, '___sec278'),
              (u'Analysis of schemes for the diffusion equation',
               1,
               u'diffu:pde1:analysis',
               u'diffu:pde1:analysis'),
              (u'Properties of the solution',
               2,
               u'diffu:pde1:analysis:uex',
               u'diffu:pde1:analysis:uex'),
              (u'Similarity solution', 3, None, '___sec281'),
              (u'Solution for a Gaussian pulse', 3, None, '___sec282'),
              (u'Solution for a sine component', 3, None, '___sec283'),
              (u'Analysis of discrete equations', 2, None, '___sec284'),
              (u'Analysis of the finite difference schemes',
               2,
               u'diffu:pde1:analysis:details',
               u'diffu:pde1:analysis:details'),
              (u'Stability', 3, None, '___sec286'),
              (u'Accuracy', 3, None, '___sec287'),
              (u'Analysis of the Forward Euler scheme',
               2,
               u'diffu:pde1:analysis:FE',
               u'diffu:pde1:analysis:FE'),
              (u'Stability', 3, None, '___sec289'),
              (u'Accuracy', 3, None, '___sec290'),
              (u'Analysis of the Backward Euler scheme',
               2,
               u'diffu:pde1:analysis:BE',
               u'diffu:pde1:analysis:BE'),
              (u'Stability', 3, None, '___sec292'),
              (u'Analysis of the Crank-Nicolson scheme',
               2,
               u'diffu:pde1:analysis:CN',
               u'diffu:pde1:analysis:CN'),
              (u'Stability', 3, None, '___sec294'),
              (u'Summary of accuracy of amplification factors',
               2,
               None,
               '___sec295'),
              (u'Analysis of the 2D diffusion equation',
               2,
               u'diffu:2D:analysis',
               u'diffu:2D:analysis'),
              (u'The Forward Euler scheme', 3, None, '___sec297'),
              (u'The Backward Euler scheme', 3, None, '___sec298'),
              (u'The Crank-Nicolson scheme', 3, None, '___sec299'),
              (u'Explanation of numerical artifacts', 2, None, '___sec300'),
              (u'Exercises', 1, None, '___sec301'),
              (u'Exercise 3.1: Explore symmetry in a 1D problem',
               2,
               u'diffu:exer:1D:gaussian:symmetric',
               u'diffu:exer:1D:gaussian:symmetric'),
              (u'Exercise 3.2: Investigate approximation errors from a $u_x=0$ boundary condition',
               2,
               u'diffu:exer:1D:ux:onesided',
               u'diffu:exer:1D:ux:onesided'),
              (u'Exercise 3.3: Experiment with open boundary conditions in 1D',
               2,
               u'diffu:exer:1D:openBC',
               u'diffu:exer:1D:openBC'),
              (u'Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D',
               2,
               None,
               '___sec305'),
              (u'Exercise 3.5: Examine stability of a diffusion model with a source term',
               2,
               u'diffu:exer:uterm',
               u'diffu:exer:uterm'),
              (u'Diffusion in heterogeneous media',
               1,
               u'diffu:varcoeff',
               u'diffu:varcoeff'),
              (u'Discretization',
               2,
               u'diffu:varcoeff:discr',
               u'diffu:varcoeff:discr'),
              (u'Implementation',
               2,
               u'diffu:varcoeff:impl',
               u'diffu:varcoeff:impl'),
              (u'Stationary solution',
               2,
               u'diffu:varcoeff:stationary',
               u'diffu:varcoeff:stationary'),
              (u'Piecewise constant medium',
               2,
               u'diffu:varcoeff:piecewise',
               u'diffu:varcoeff:piecewise'),
              (u'Implementation of diffusion in a piecewise constant medium',
               2,
               u'diffu:varcoeff:impl:piecewise',
               u'diffu:varcoeff:impl:piecewise'),
              (u'Diffusion equation in axi-symmetric geometries',
               2,
               u'diffu:fd2:radial',
               u'diffu:fd2:radial'),
              (u'Diffusion equation in spherically-symmetric geometries',
               2,
               u'diffu:fd2:spherical',
               u'diffu:fd2:spherical'),
              (u'Discretization in spherical coordinates',
               3,
               None,
               '___sec315'),
              (u'Discretization in Cartesian coordinates',
               3,
               None,
               '___sec316'),
              (u'Diffusion in 2D', 1, u'diffu:2D', u'diffu:2D'),
              (u'Discretization', 2, u'diffu:2D:discr', u'diffu:2D:discr'),
              (u'Numbering of mesh points versus equations and unknowns',
               2,
               u'diffu:2D:numbering',
               u'diffu:2D:numbering'),
              (u'Algorithm for setting up the coefficient matrix',
               2,
               u'diffu:2D:alg',
               u'diffu:2D:alg'),
              (u'Implementation with a dense coefficient matrix',
               2,
               u'diffu:2D:impl:dense',
               u'diffu:2D:impl:dense'),
              (u'Verification: exact numerical solution',
               2,
               u'diffu:2D:verify',
               u'diffu:2D:verify'),
              (u'Verification: convergence rates',
               2,
               u'diffu:2D:convrate',
               u'diffu:2D:convrate'),
              (u'Implementation with a sparse coefficient matrix',
               2,
               u'diffu:2D:impl:sparse',
               u'diffu:2D:impl:sparse'),
              (u'Understanding the diagonals', 3, None, '___sec325'),
              (u'Filling the diagonals', 3, None, '___sec326'),
              (u'Filling the right-hand side; scalar version',
               3,
               None,
               '___sec327'),
              (u'Filling the right-hand side; vectorized version',
               3,
               None,
               '___sec328'),
              (u'Verification', 3, None, '___sec329'),
              (u'The Jacobi iterative method', 2, None, '___sec330'),
              (u'Numerical scheme and linear system', 3, None, '___sec331'),
              (u'Iterations', 3, None, '___sec332'),
              (u'Initial guess', 3, None, '___sec333'),
              (u'Relaxation', 3, None, '___sec334'),
              (u'Stopping criteria', 3, None, '___sec335'),
              (u'Code-friendly notation', 3, None, '___sec336'),
              (u'Generalization of the scheme', 3, None, '___sec337'),
              (u'Implementation of the Jacobi method',
               2,
               u'diffu:2D:Jacobi:impl',
               u'diffu:2D:Jacobi:impl'),
              (u'Test problem: diffusion of a sine hill',
               2,
               u'diffu:2D:Jacobi:impl:hill',
               u'diffu:2D:Jacobi:impl:hill'),
              (u'The relaxed Jacobi method and its relation to the Forward Euler method',
               2,
               u'diffu:2D:Jacobi_vs_FE',
               u'diffu:2D:Jacobi_vs_FE'),
              (u'The Gauss-Seidel and SOR methods',
               2,
               u'diffu:2D:SOR',
               u'diffu:2D:SOR'),
              (u'Scalar implementation of the SOR method',
               2,
               u'diffu:2D:SOR:impl:scalar',
               u'diffu:2D:SOR:impl:scalar'),
              (u'Vectorized implementation of the SOR method',
               2,
               u'diffu:2D:SOR:impl:vectorized',
               u'diffu:2D:SOR:impl:vectorized'),
              (u'Direct versus iterative methods',
               2,
               u'diffu:2D:direct_vs_iter',
               u'diffu:2D:direct_vs_iter'),
              (u'Direct methods', 3, None, '___sec345'),
              (u'Iterative methods', 3, None, '___sec346'),
              (u'The Conjugate gradient method',
               2,
               u'diffu:2D:CG',
               u'diffu:2D:CG'),
              (u'Random walk', 1, u'diffu:randomwalk', u'diffu:randomwalk'),
              (u'Random walk in 1D',
               2,
               u'diffu:randomwalk:1D',
               u'diffu:randomwalk:1D'),
              (u'Statistical considerations',
               2,
               u'diffu:randomwalk:1D:EVar',
               u'diffu:randomwalk:1D:EVar'),
              (u'Playing around with some code',
               2,
               u'diffu:randomwalk:1D:code1',
               u'diffu:randomwalk:1D:code1'),
              (u'Scalar code', 3, None, '___sec352'),
              (u'Vectorized code', 3, None, '___sec353'),
              (u'Fixing the random sequence', 3, None, '___sec354'),
              (u'Verification', 3, None, '___sec355'),
              (u'Equivalence with diffusion',
               2,
               u'diffu:randomwalk:1D:pde',
               u'diffu:randomwalk:1D:pde'),
              (u'Implementation of multiple walks', 2, None, '___sec357'),
              (u'Scalar version', 3, None, '___sec358'),
              (u'Vectorized version', 3, None, '___sec359'),
              (u'Improved vectorized version', 3, None, '___sec360'),
              (u'Remark on vectorized code and parallelization',
               3,
               None,
               '___sec361'),
              (u'Test function', 3, None, '___sec362'),
              (u'Demonstration of multiple walks', 2, None, '___sec363'),
              (u'Ascii visualization of 1D random walk',
               2,
               u'diffu:randomwalk:1D:avplotter',
               u'diffu:randomwalk:1D:avplotter'),
              (u'Random walk as a stochastic equation',
               2,
               u'diffu:randomwalk:1D:ode',
               u'diffu:randomwalk:1D:ode'),
              (u'Random walk in 2D', 2, None, '___sec366'),
              (u'Random walk in any number of space dimensions',
               2,
               None,
               '___sec367'),
              (u'Multiple random walks in any number of space dimensions',
               2,
               None,
               '___sec368'),
              (u'Scalar code', 3, None, '___sec369'),
              (u'Vectorized code', 3, None, '___sec370'),
              (u'Applications', 1, u'diffu:app', u'diffu:app'),
              (u'Diffusion of a substance',
               2,
               u'diffu:app:substance',
               u'diffu:app:substance'),
              (u'Heat conduction', 2, u'diffu:app:heat', u'diffu:app:heat'),
              (u'Development of flow between two flat plates',
               2,
               u'diffu:app:Couette',
               u'diffu:app:Couette'),
              (u'Flow in a straight tube',
               2,
               u'diffu:app:pipeflow',
               u'diffu:app:pipeflow'),
              (u'Tribology: thin film fluid flow', 2, None, '___sec376'),
              (u'Propagation of electrical signals in the brain',
               2,
               None,
               '___sec377'),
              (u'Exercises', 1, None, '___sec378'),
              (u'Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping',
               2,
               u'diffu:exer:CN:Rannacher',
               u'diffu:exer:CN:Rannacher'),
              (u'Project 3.7: Energy estimates for diffusion problems',
               2,
               u'diffu:exer:energy:estimates',
               u'diffu:exer:energy:estimates'),
              (u'Exercise 3.8: Splitting methods and preconditioning',
               2,
               u'diffu:exer:splitting_prec',
               u'diffu:exer:splitting_prec'),
              (u'Exercise 3.9: Oscillating surface temperature of the earth',
               2,
               u'diffu:exer:earthosc',
               u'diffu:exer:earthosc'),
              (u'Exercise 3.10: Oscillating and pulsating flow in tubes',
               2,
               u'diffu:exer:bloodflow',
               u'diffu:exer:bloodflow'),
              (u'Advection-dominated equations',
               0,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'One-dimensional time-dependent advection equations',
               1,
               u'advec:1D',
               u'advec:1D'),
              (u'Simplest scheme: forward in time, centered in space',
               2,
               None,
               '___sec386'),
              (u'Method', 3, None, '___sec387'),
              (u'Implementation', 3, None, '___sec388'),
              (u'Test cases', 3, None, '___sec389'),
              (u'Bug?', 3, None, '___sec390'),
              (u'Analysis of the scheme', 2, None, '___sec391'),
              (u'Leapfrog in time, centered differences in space',
               2,
               None,
               '___sec392'),
              (u'Method', 3, None, '___sec393'),
              (u'Implementation', 3, None, '___sec394'),
              (u'Running the test case', 3, None, '___sec395'),
              (u'Analysis', 3, None, '___sec396'),
              (u'Upwind differences in space', 2, None, '___sec397'),
              (u'A Crank-Nicolson discretization in time and centered differences in space',
               2,
               None,
               '___sec398'),
              (u'The Lax-Wendroff method', 2, None, '___sec399'),
              (u'Analysis of dispersion relations',
               2,
               u'advec:1D:disprel',
               u'advec:1D:disprel'),
              (u'One-dimensional stationary advection-diffusion equation',
               1,
               None,
               '___sec401'),
              (u'Two-dimensional advection-diffusion equations',
               1,
               None,
               '___sec402'),
              (u'Applications of advection equations', 1, None, '___sec403'),
              (u'Staggered mesh discretization',
               0,
               u'ch:staggered',
               u'ch:staggered'),
              (u'Ordinary differential equations', 1, None, '___sec405'),
              (u'The Euler-Cromer scheme on a standard mesh',
               2,
               None,
               '___sec406'),
              (u'The Euler-Cromer scheme on a staggered mesh',
               2,
               u'vib:model2x2:staggered',
               u'vib:model2x2:staggered'),
              (u'Implementation of the scheme on a staggered mesh',
               2,
               None,
               '___sec408'),
              (u'Implementation with integer indices', 3, None, '___sec409'),
              (u'Implementation with half-integer indices',
               3,
               None,
               '___sec410'),
              (u'A staggered Euler-Cromer scheme for a generalized model',
               2,
               u'vib:ode2:staggered',
               u'vib:ode2:staggered'),
              (u'Exercises', 1, None, '___sec412'),
              (u'Exercise 5.1: Use the forward-backward scheme with quadratic damping',
               2,
               u'vib:exer:quad:damping:fwbw',
               u'vib:exer:quad:damping:fwbw'),
              (u'Partial differential equations', 1, None, '___sec414'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec417'),
              (u'Algebraic equations', 3, None, '___sec418'),
              (u'Differential equations', 3, None, '___sec419'),
              (u'A simple model problem', 2, None, '___sec420'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec423'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec425'),
              (u'A single Picard iteration', 3, None, '___sec426'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec432'),
              (u'Backward Euler discretization', 3, None, '___sec433'),
              (u'Crank-Nicolson discretization', 3, None, '___sec434'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec436'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec442'),
              (u'A Picard iteration', 3, None, '___sec443'),
              (u"Newton's method", 3, None, '___sec444'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec449'),
              (u'Similarity with Picard iteration', 3, None, '___sec450'),
              (u'Implementation', 3, None, '___sec451'),
              (u'Derivation with alternative notation', 3, None, '___sec452'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'Discretization of 1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec456'),
              (u'The structure of the equation system', 3, None, '___sec457'),
              (u'Picard iteration', 3, None, '___sec458'),
              (u'Mesh with two cells', 3, None, '___sec459'),
              (u"Newton's method", 3, None, '___sec460'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec461'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec463'),
              (u"Newton's method", 3, None, '___sec464'),
              (u'Continuation methods', 2, None, '___sec465'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 6.1: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 6.2: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 6.3: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 6.4: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 6.5: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 6.6: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 6.7: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 6.8: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 6.9: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 6.10: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 6.11: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 6.12: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 6.13: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 6.14: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 6.15: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec486'),
              (u'Real exponentials', 3, None, '___sec487'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec489'),
              (u'Appendix: Truncation error analysis',
               0,
               u'ch:trunc',
               u'ch:trunc'),
              (u'Overview of truncation error analysis',
               1,
               None,
               '___sec491'),
              (u'Abstract problem setting', 2, None, '___sec492'),
              (u'Error measures', 2, None, '___sec493'),
              (u'Truncation errors in finite difference formulas',
               1,
               u'trunc:finite:differences',
               u'trunc:finite:differences'),
              (u"Example: The backward difference for $u'(t)$",
               2,
               u'trunc:fd:backward',
               u'trunc:fd:backward'),
              (u"Example: The forward difference for $u'(t)$",
               2,
               u'trunc:fd:forward',
               u'trunc:fd:forward'),
              (u"Example: The central difference for $u'(t)$",
               2,
               u'trunc:fd:central',
               u'trunc:fd:central'),
              (u'Overview of leading-order error terms in finite difference formulas',
               2,
               u'trunc:table',
               u'trunc:table'),
              (u'Software for computing truncation errors',
               2,
               u'trunc:sympy',
               u'trunc:sympy'),
              (u'Truncation errors in exponential decay ODE',
               1,
               u'trunc:decay',
               u'trunc:decay'),
              (u'Truncation error of the Forward Euler scheme',
               2,
               u'trunc:decay:FE',
               u'trunc:decay:FE'),
              (u'Truncation error of the Crank-Nicolson scheme',
               2,
               u'trunc:decay:CN',
               u'trunc:decay:CN'),
              (u'Truncation error of the $\\theta$-rule',
               2,
               u'trunc:decay:theta',
               u'trunc:decay:theta'),
              (u'Using symbolic software',
               2,
               u'trunc:decay:software',
               u'trunc:decay:software'),
              (u'Empirical verification of the truncation error',
               2,
               u'trunc:decay:estimate:R',
               u'trunc:decay:estimate:R'),
              (u'Increasing the accuracy by adding correction terms',
               2,
               u'trunc:decay:corr',
               u'trunc:decay:corr'),
              (u'Extension to variable coefficients', 2, None, '___sec507'),
              (u'Exact solutions of the finite difference equations',
               2,
               None,
               '___sec508'),
              (u'Computing truncation errors in nonlinear problems',
               2,
               u'trunc:decay:gen',
               u'trunc:decay:gen'),
              (u'Truncation errors in vibration ODEs',
               1,
               u'trunc:vib',
               u'trunc:vib'),
              (u'Linear model without damping',
               2,
               u'trunc:vib:undamped',
               u'trunc:vib:undamped'),
              (u'The truncation error of a centered finite difference scheme',
               3,
               None,
               '___sec512'),
              (u"The truncation error of approximating $u'(0)$",
               3,
               None,
               '___sec513'),
              (u'Truncation error of the equation for the first step',
               3,
               None,
               '___sec514'),
              (u'Computing correction terms', 3, None, '___sec515'),
              (u'Model with damping and nonlinearity',
               2,
               u'trunc:vib:gen',
               u'trunc:vib:gen'),
              (u'Extension to quadratic damping', 2, None, '___sec517'),
              (u'The general model formulated as first-order ODEs',
               2,
               u'trunc:vib:gen:staggered',
               u'trunc:vib:gen:staggered'),
              (u'The forward-backward scheme', 3, None, '___sec519'),
              (u'A centered scheme on a staggered mesh',
               3,
               None,
               '___sec520'),
              (u'Truncation errors in wave equations', 1, None, '___sec521'),
              (u'Linear wave equation in 1D',
               2,
               u'trunc:wave:1D',
               u'trunc:wave:1D'),
              (u'Finding correction terms',
               2,
               u'trunc:wave:1D:corr',
               u'trunc:wave:1D:corr'),
              (u'Extension to variable coefficients',
               2,
               u'trunc:wave:1D:varcoeff',
               u'trunc:wave:1D:varcoeff'),
              (u'1D wave equation on a staggered mesh', 2, None, '___sec525'),
              (u'Linear wave equation in 2D/3D',
               2,
               u'trunc:wave:2D',
               u'trunc:wave:2D'),
              (u'Truncation errors in diffusion equations',
               1,
               u'trunc:diffu',
               u'trunc:diffu'),
              (u'Linear diffusion equation in 1D',
               2,
               u'trunc:diffu:1D',
               u'trunc:diffu:1D'),
              (u'The Forward Euler scheme in time', 3, None, '___sec529'),
              (u'The Crank-Nicolson scheme in time', 3, None, '___sec530'),
              (u'Linear diffusion equation in 2D/3D', 2, None, '___sec531'),
              (u'A nonlinear diffusion equation in 2D', 2, None, '___sec532'),
              (u'Exercises', 1, None, '___sec533'),
              (u'Exercise B.1: Truncation error of a weighted mean',
               2,
               u'trunc:exer:theta:avg',
               u'trunc:exer:theta:avg'),
              (u'Exercise B.2: Simulate the error of a weighted mean',
               2,
               u'trunc:exer:theta:avg2',
               u'trunc:exer:theta:avg2'),
              (u'Exercise B.3: Verify a truncation error formula',
               2,
               u'trunc:exer:decay:bw2',
               u'trunc:exer:decay:bw2'),
              (u'Exercise B.4: Truncation error of the Backward Euler scheme',
               2,
               u'trunc:exer:decay:BE',
               u'trunc:exer:decay:BE'),
              (u'Exercise B.5: Empirical estimation of truncation errors',
               2,
               u'trunc:exer:decay:estimate',
               u'trunc:exer:decay:estimate'),
              (u'Exercise B.6: Correction term for a Backward Euler scheme',
               2,
               u'trunc:exer:decay:corr:BE',
               u'trunc:exer:decay:corr:BE'),
              (u'Exercise B.7: Verify the effect of correction terms',
               2,
               u'trunc:exer:decay:corr:verify',
               u'trunc:exer:decay:corr:verify'),
              (u'Exercise B.8: Truncation error of the Crank-Nicolson scheme',
               2,
               u'trunc:exer:decay:varcoeff:CN',
               u'trunc:exer:decay:varcoeff:CN'),
              (u"Exercise B.9: Truncation error of $u'=f(u,t)$",
               2,
               u'trunc:exer:decay:nonlin:BEFE',
               u'trunc:exer:decay:nonlin:BEFE'),
              (u'Exercise B.10: Truncation error of $[D_t D_tu]^n$',
               2,
               u'trunc:exer:DtDtu',
               u'trunc:exer:DtDtu'),
              (u"Exercise B.11: Investigate the impact of approximating $u'(0)$",
               2,
               u'trunc:exer:vib:ic:fw',
               u'trunc:exer:vib:ic:fw'),
              (u'Exercise B.12: Investigate the accuracy of a simplified scheme',
               2,
               u'trunc:exer:vib:fbw',
               u'trunc:exer:vib:fbw'),
              (u'Appendix: Software engineering; wave equation model',
               0,
               u'ch:softeng2',
               u'ch:softeng2'),
              (u'A 1D wave equation simulator', 1, None, '___sec547'),
              (u'Mathematical model', 2, None, '___sec548'),
              (u'Numerical discretization', 2, None, '___sec549'),
              (u'A solver function', 2, None, '___sec550'),
              (u'Saving large arrays in files',
               1,
               u'softeng2:wave1D:filestorage',
               u'softeng2:wave1D:filestorage'),
              (u'Using `savez` to store arrays in files',
               2,
               u'softeng2:wave1D:filestorage:savez',
               u'softeng2:wave1D:filestorage:savez'),
              (u'Storing individual arrays', 3, None, '___sec553'),
              (u'Merging zip archives', 3, None, '___sec554'),
              (u'Reading arrays from zip archives', 3, None, '___sec555'),
              (u'Using `joblib` to store arrays in files',
               2,
               u'softeng2:wave1D:filestorage:joblib',
               u'softeng2:wave1D:filestorage:joblib'),
              (u'Using a hash to create a file or directory name',
               2,
               u'softeng2:wave1D:filestorage:hash',
               u'softeng2:wave1D:filestorage:hash'),
              (u'Software for the 1D wave equation', 1, None, '___sec558'),
              (u'Making hash strings from input data',
               2,
               u'softeng2:wave1D:filestorage:hashlib',
               u'softeng2:wave1D:filestorage:hashlib'),
              (u'Avoiding rerunning previously run cases',
               2,
               u'softeng2:wave1D:filestorage:norerun',
               u'softeng2:wave1D:filestorage:norerun'),
              (u'Verification', 2, None, '___sec561'),
              (u'Programming the solver with classes', 1, None, '___sec562'),
              (u'Class Problem', 2, None, '___sec563'),
              (u'Class Mesh', 2, None, '___sec564'),
              (u'Class Function', 2, None, '___sec565'),
              (u'Class Solver', 2, None, '___sec566'),
              (u'Migrating loops to Cython',
               1,
               u'wave2D3D:impl:Cython',
               u'wave2D3D:impl:Cython'),
              (u'Declaring variables and annotating the code',
               2,
               None,
               '___sec568'),
              (u'Visual inspection of the C translation',
               2,
               None,
               '___sec569'),
              (u'Building the extension module', 2, None, '___sec570'),
              (u'Calling the Cython function from Python',
               2,
               None,
               '___sec571'),
              (u'Efficiency', 3, None, '___sec572'),
              (u'Migrating loops to Fortran', 1, None, '___sec573'),
              (u'The Fortran subroutine', 2, None, '___sec574'),
              (u'Building the Fortran module with f2py',
               2,
               None,
               '___sec575'),
              (u'How to avoid array copying', 2, None, '___sec576'),
              (u'Efficiency', 3, None, '___sec577'),
              (u'Migrating loops to C via Cython', 1, None, '___sec578'),
              (u'Translating index pairs to single indices',
               2,
               None,
               '___sec579'),
              (u'The complete C code', 2, None, '___sec580'),
              (u'The Cython interface file', 2, None, '___sec581'),
              (u'Building the extension module', 2, None, '___sec582'),
              (u'Efficiency', 3, None, '___sec583'),
              (u'Migrating loops to C via f2py', 1, None, '___sec584'),
              (u'Migrating loops to C++ via f2py', 2, None, '___sec585'),
              (u'Exercises', 1, None, '___sec586'),
              (u'Exercise C.1: Make an improved `numpy.savez` function',
               2,
               u'softeng2:exer:savez',
               u'softeng2:exer:savez'),
              (u'References', 1, None, '___sec588')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\acc}{\boldsymbol{a}}
\newcommand{\rpos}{\boldsymbol{r}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}
\newcommand{\q}{\boldsymbol{q}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\baspsi}{\psi}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0015"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fdm-book-solarized014.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fdm-book-solarized016.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<center><h1 id="ch:nonlin">Nonlinear problems</h1></center> <hr>

<h1 id="nonlin:timediscrete:logistic">Introduction of basic concepts</h1>

<h2 id="___sec417">Linear versus nonlinear equations </h2>

<h3 id="___sec418">Algebraic equations </h3>

<p>
A linear, scalar, algebraic equation in \( x \) has the form

$$ ax + b = 0,$$

for arbitrary real constants \( a \) and \( b \). The unknown is a number \( x \).
All other algebraic equations, e.g., \( x^2 + ax + b = 0 \), are nonlinear.
The typical feature in a nonlinear algebraic equation is that the unknown
appears in products with itself, like \( x^2 \) or \( e^x = 1 + x +\half x^2 +
\frac{1}{3!}x^3 + \cdots \).

<p>
We know how to solve a linear algebraic equation, \( x=-b/a \), but there are
no general methods for finding the exact solutions of
nonlinear algebraic equations, except for very special cases (quadratic
equations are a primary example). A nonlinear algebraic equation
may have no solution, one solution, or many solutions. The tools for
solving nonlinear algebraic equations are <em>iterative methods</em>, where
we construct a series of linear equations, which we know how to solve,
and hope that the solutions of the linear equations converge to a
solution of the nonlinear equation we want to solve.
Typical methods for nonlinear algebraic equation equations are
Newton's method, the Bisection method, and the Secant method.

<h3 id="___sec419">Differential equations </h3>

<p>
The unknown in a differential equation is a function and not a number.
In a linear differential equation, all terms involving the unknown function
are linear in the unknown function or its derivatives. Linear here means that
the unknown function, or a derivative of it, is multiplied by a number or
a known function. All other differential equations are non-linear.

<p>
The easiest way to see if an equation is nonlinear, is to spot nonlinear terms
where the unknown function or its derivatives are multiplied by
each other. For example, in

$$ u^{\prime}(t) = -a(t)u(t) + b(t),$$

the terms involving the unknown function \( u \) are linear: \( u^{\prime} \) contains
the derivative of the unknown function multiplied by unity, and \( au \) contains
the unknown function multiplied by a known function.
However,
$$ u^{\prime}(t) = u(t)(1 - u(t)),$$

is nonlinear because of the term \( -u^2 \) where the unknown function is
multiplied by itself. Also

$$ \frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0,$$

is nonlinear because of the term \( uu_x \) where the unknown
function appears in a product with itself or one if its derivatives.
(Note here that we use different notations for derivatives: \( u^{\prime} \)
or \( du/dt \) for a function \( u(t) \) of one variable,
\( \frac{\partial u}{\partial t} \) or \( u_t \) for a function of more than one
variable.)

<p>
Another example of a nonlinear equation is

$$ u^{\prime\prime} + \sin(u) =0,$$

because \( \sin(u) \) contains products of \( u \) if we expand the function in
a Taylor series:

$$ \sin(u) = u - \frac{1}{3} u^3 + \ldots$$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Mathematical proof of linearity.</b>
<p>
To really prove mathematically that some differential equation
in an unknown \( u \) is linear,
show for each term \( T(u) \) that with \( u = au_1 + bu_2 \) for
constants \( a \) and \( b \),

$$ T(au_1 + bu_2) = aT(u_1) + bT(u_2)\tp $$

<p>
For example, the term \( T(u) = (\sin^2 t)u'(t) \) is linear because

$$
\begin{align*}
T(au_1 + bu_2) &= (\sin^2 t)(au_1(t) + b u_2(t))\\ 
& = a(\sin^2 t)u_1(t) + b(\sin^2 t)u_2(t)\\ 
& =aT(u_1) + bT(u_2)\tp
\end{align*}
$$

However, \( T(u)=\sin u \) is nonlinear because

$$ T(au_1 + bu_2) = \sin (au_1 + bu_2) \neq a\sin u_1 + b\sin u_2\tp$$
</div>


<h2 id="___sec420">A simple model problem </h2>

<p>
A series of forthcoming examples will explain how to tackle
nonlinear differential equations with various techniques.
We start with the (scaled) logistic equation as model problem:

$$
\begin{equation}
u^{\prime}(t) = u(t)(1 - u(t)) \tp
\tag{493}
\end{equation}
$$

This is a nonlinear ordinary differential equation (ODE)
which will be solved by
different strategies in the following.
Depending on the chosen
time discretization of <a href="#mjx-eqn-493">(493)</a>,
the mathematical problem to be solved at every time level will
either be a linear algebraic equation or a nonlinear
algebraic equation.
In the former case, the time discretization method transforms
the nonlinear ODE into linear subproblems at each time level, and
the solution is straightforward to find since linear algebraic equations
are easy to solve. However,
when the time discretization leads to nonlinear algebraic equations, we
cannot (except in very rare cases) solve these without turning to
approximate, iterative solution methods.

<p>
The next subsections introduce various methods
for solving nonlinear differential equations,
using <a href="#mjx-eqn-493">(493)</a> as model. We shall go through
the following set cases:

<ul>
 <li> explicit time discretization methods (with no need to
   solve nonlinear algebraic equations)</li>
 <li> implicit Backward Euler discretization, leading to nonlinear
   algebraic equations solved by</li>

<ul>
  <li> an exact analytical technique</li>
  <li> Picard iteration based on manual linearization</li>
  <li> a single Picard step</li>
  <li> Newton's method</li>
</ul>

 <li> Implicit Crank-Nicolson discretization and linearization
   via a geometric mean formula</li>
</ul>

Thereafter, we compare the performance of the various approaches. Despite
the simplicity of <a href="#mjx-eqn-493">(493)</a>, the conclusions
reveal typical features of the various methods in much more complicated
nonlinear PDE problems.

<h2 id="nonlin:timediscrete:logistic:FE">Linearization by explicit time discretization</h2>

<p>
Time discretization methods are divided into explicit and implicit
methods. Explicit methods lead to a closed-form formula for
finding new values of the unknowns, while implicit methods give
a linear or nonlinear system of equations that couples (all) the
unknowns at a new time level. Here we shall demonstrate that
explicit methods constitute an efficient way to deal with nonlinear
differential equations.

<p>
The Forward Euler
method is an explicit method. When applied to
<a href="#mjx-eqn-493">(493)</a>, sampled at \( t=t_n \), it results in

$$ \frac{u^{n+1} - u^n}{\Delta t} = u^n(1 - u^n),$$

which is a <em>linear</em> algebraic
equation for the unknown value \( u^{n+1} \) that we can easily solve:

$$ u^{n+1} = u^n + \Delta t\,u^n(1 - u^n)\tp$$

The nonlinearity in the original equation poses in this case no difficulty
in the discrete algebraic equation.
Any other explicit scheme in time will also give only linear
algebraic equations
to solve. For example, a typical 2nd-order Runge-Kutta method
for <a href="#mjx-eqn-493">(493)</a> leads to the following
formulas:

$$
\begin{align*}
u^* &= u^n + \Delta t u^n(1 - u^n),\\ 
u^{n+1} &= u^n + \Delta t \half \left(
u^n(1 - u^n) + u^*(1 - u^*))
\right)\tp
\end{align*}
$$

The first step is linear in the unknown \( u^* \). Then \( u^* \) is
known in the next step, which is linear in the unknown \( u^{n+1} \) .

<h2 id="nonlin:timediscrete:logistic:roots">Exact solution of nonlinear algebraic equations</h2>

<p>
Switching to a Backward Euler scheme for
<a href="#mjx-eqn-493">(493)</a>,

$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^n),
\tag{494}
\end{equation}
$$

results in a nonlinear algebraic equation for the unknown value \( u^n \).
The equation is of quadratic type:

$$ \Delta t (u^n)^2 + (1-\Delta t)u^n - u^{n-1} = 0, $$

and may be solved exactly by the well-known formula for such equations.
Before we do so, however, we will
introduce a shorter, and often cleaner, notation for
nonlinear algebraic equations at a given time level. The notation is
inspired by the natural notation (i.e., variable names) used in a
program, especially in more advanced partial differential equation
problems. The unknown in the algebraic equation is denoted by \( u \),
while \( u^{(1)} \) is the value of the unknown at the previous time level
(in general, \( u^{(\ell)} \) is the value of the unknown \( \ell \) levels
back in time). The notation will be frequently used in later
sections. What is meant by \( u \) should be evident from the context: \( u \)
may be 1) the exact solution of the ODE/PDE problem,
2) the numerical approximation to the exact solution, or 3) the unknown
solution at a certain time level.

<p>
The quadratic equation for the unknown \( u^n \) in
<a href="#mjx-eqn-494">(494)</a> can, with the new
notation, be written

$$
\begin{equation}
F(u) = \Delta t u^2 + (1-\Delta t)u - u^{(1)} = 0\tp
\tag{495}
\end{equation}
$$

The solution is readily found to be

$$
\begin{equation}
u = \frac{1}{2\Delta t}
\left(-1+\Delta t \pm \sqrt{(1-\Delta t)^2 - 4\Delta t u^{(1)}}\right)
\tp
\tag{496}
\end{equation}
$$

<p>
Now we encounter a fundamental challenge with nonlinear
algebraic equations:
the equation may have more than one solution. How do we pick the right
solution? This is in general a hard problem.
In the present simple case, however, we can analyze the roots mathematically
and provide an answer. The idea is to expand the roots
in a series in \( \Delta t \) and truncate after the linear term since
the Backward Euler scheme will introduce an error proportional to
\( \Delta t \) anyway. Using <code>sympy</code> we find the following Taylor series
expansions of the roots:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; import sympy as sym
&gt;&gt;&gt; dt, u_1, u = sym.symbols('dt u_1 u')
&gt;&gt;&gt; r1, r2 = sym.solve(dt*u**2 + (1-dt)*u - u_1, u)  # find roots
&gt;&gt;&gt; r1
(dt - sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)
&gt;&gt;&gt; r2
(dt + sqrt(dt**2 + 4*dt*u_1 - 2*dt + 1) - 1)/(2*dt)
&gt;&gt;&gt; print r1.series(dt, 0, 2)    # 2 terms in dt, around dt=0
-1/dt + 1 - u_1 + dt*(u_1**2 - u_1) + O(dt**2)
&gt;&gt;&gt; print r2.series(dt, 0, 2)
u_1 + dt*(-u_1**2 + u_1) + O(dt**2)
</code></pre>
<!-- end verbatim block -->
We see that the <code>r1</code> root, corresponding to
a minus sign in front of the square root in
<a href="#mjx-eqn-496">(496)</a>,
behaves as \( 1/\Delta t \) and will therefore
blow up as \( \Delta t\rightarrow 0 \)! Since we know that \( u \) takes on
finite values, actually it is less than or equal to 1,
only the <code>r2</code> root is of relevance in this case: as \( \Delta t\rightarrow 0 \),
\( u\rightarrow u^{(1)} \), which is the expected result.

<p>
For those who are not well experienced with approximating mathematical
formulas by series expansion, an alternative method of investigation
is simply to compute the limits of the two roots as \( \Delta t\rightarrow 0 \)
and see if a limit unreasonable:

<p>
<!-- begin verbatim block  pyshell-->
<pre><code>&gt;&gt;&gt; print r1.limit(dt, 0)
-oo
&gt;&gt;&gt; print r2.limit(dt, 0)
u_1
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec423">Linearization </h2>

<p>
When the time integration of an ODE results in a nonlinear algebraic
equation, we must normally find its solution by defining a sequence
of linear equations and hope that the solutions of these linear equations
converge to the desired solution of the nonlinear algebraic equation.
Usually, this means solving the linear equation repeatedly in an
iterative fashion.
Alternatively, the nonlinear equation can sometimes be approximated by one
linear equation, and consequently there is no need for iteration.

<p>
Constructing a linear equation from a nonlinear one requires
<em>linearization</em> of each nonlinear term. This can be done manually
as in Picard iteration, or fully algorithmically as in Newton's method.
Examples will best illustrate how to linearize nonlinear problems.

<h2 id="nonlin:timediscrete:logistic:Picard">Picard iteration</h2>

<p>
Let us write <a href="#mjx-eqn-495">(495)</a> in a
more compact form

$$ F(u) = au^2 + bu + c = 0,$$

with \( a=\Delta t \), \( b=1-\Delta t \), and \( c=-u^{(1)} \).
Let \( u^{-} \) be an available approximation of the unknown \( u \).
Then we can linearize the term \( u^2 \) simply by writing
\( u^{-}u \). The resulting equation, \( \hat F(u)=0 \), is now linear
and hence easy to solve:

$$ F(u)\approx\hat F(u) = au^{-}u + bu + c = 0\tp$$

Since the equation \( \hat F=0 \) is only approximate, the solution \( u \)
does not equal the exact solution \( \uex \) of the exact
equation \( F(\uex)=0 \), but we can hope that \( u \) is closer to
\( \uex \) than \( u^{-} \) is, and hence it makes sense to repeat the
procedure, i.e., set \( u^{-}=u \) and solve \( \hat F(u)=0 \) again.
There is no guarantee that \( u \) is closer to \( \uex \) than \( u^{-} \),
but this approach has proven to be effective in a wide range of
applications.

<p>
The idea of turning a nonlinear equation into a linear one by
using an approximation \( u^{-} \) of \( u \) in nonlinear terms is
a widely used approach that goes under many names:
<em>fixed-point iteration</em>, the method of <em>successive substitutions</em>,
<em>nonlinear Richardson iteration</em>, and <em>Picard iteration</em>.
We will stick to the latter name.

<p>
Picard iteration for solving the nonlinear equation
arising from the Backward Euler discretization of the logistic
equation can be written as

$$ u = -\frac{c}{au^{-} + b},\quad u^{-}\ \leftarrow\ u\tp$$

The \( \leftarrow \) symbols means assignment (we set \( u^{-} \) equal to
the value of \( u \)).
The iteration is started with the value of the unknown at the
previous time level: \( u^{-}=u^{(1)} \).

<p>
Some prefer an explicit iteration counter as superscript
in the mathematical notation. Let \( u^k \) be the computed approximation
to the solution in iteration \( k \). In iteration \( k+1 \) we want
to solve

$$ au^k u^{k+1} + bu^{k+1} + c = 0\quad\Rightarrow\quad u^{k+1}
= -\frac{c}{au^k + b},\quad k=0,1,\ldots$$

Since we need to perform the iteration at every time level, the
time level counter is often also included:

$$ au^{n,k} u^{n,k+1} + bu^{n,k+1} - u^{n-1} = 0\quad\Rightarrow\quad u^{n,k+1}
= \frac{u^n}{au^{n,k} + b},\quad k=0,1,\ldots,$$

with the start value \( u^{n,0}=u^{n-1} \) and the final converged value
\( u^{n}=u^{n,k} \) for sufficiently large \( k \).

<p>
However, we will normally apply a mathematical notation in our
final formulas that is as close as possible to what we aim to write
in a computer code and then it becomes natural to use \( u \) and \( u^{-} \)
instead of \( u^{k+1} \) and \( u^k \) or \( u^{n,k+1} \) and \( u^{n,k} \).

<h3 id="___sec425">Stopping criteria </h3>

<p>
The iteration method can typically be terminated when the change
in the solution is smaller than a tolerance \( \epsilon_u \):

$$ |u - u^{-}| \leq\epsilon_u,$$

or when the residual in the equation is sufficiently small (\( < \epsilon_r \)),
$$ |F(u)|= |au^2+bu + c| < \epsilon_r\tp$$

<h3 id="___sec426">A single Picard iteration </h3>

<p>
Instead of iterating until a stopping criterion is fulfilled, one may
iterate a specific number of times. Just one Picard iteration is
popular as this corresponds to the intuitive idea of approximating
a nonlinear term like \( (u^n)^2 \) by \( u^{n-1}u^n \). This follows
from the linearization \( u^{-}u^n \) and the initial choice of
\( u^{-}=u^{n-1} \) at time level \( t_n \). In other words, a single
Picard iteration corresponds to using the solution at
the previous time level to linearize
nonlinear terms. The resulting discretization
becomes (using proper values for \( a \), \( b \), and \( c \))

$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = u^n(1 - u^{n-1}),
\tag{497}
\end{equation}
$$

which is a linear algebraic equation in the unknown \( u^n \), and
therefore we can easily solve for \( u^n \), and there is no need
for any alternative notation.

<p>
We shall later refer to the strategy of taking one Picard step, or
equivalently, linearizing terms with use of the solution at the
previous time step, as the <em>Picard1</em> method. It is a widely used
approach in science and technology, but with some limitations if
\( \Delta t \) is not sufficiently small (as will be illustrated later).

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>

<p>
Equation <a href="#mjx-eqn-497">(497)</a> does not
correspond to a &quot;pure&quot; finite difference method where the equation
is sampled at a point and derivatives replaced by differences (because
the \( u^{n-1} \) term on the right-hand side must then be \( u^n \)). The
best interpretation of the scheme
<a href="#mjx-eqn-497">(497)</a> is a Backward Euler
difference combined with a single (perhaps insufficient) Picard
iteration at each time level, with the value at the previous time
level as start for the Picard iteration.


</div>


<h2 id="nonlin:timediscrete:logistic:geometric:mean">Linearization by a geometric mean</h2>

<p>
We consider now a Crank-Nicolson discretization of
<a href="#mjx-eqn-493">(493)</a>. This means that the
time derivative is approximated by a centered
difference,

$$ [D_t u = u(1-u)]^{n+\half},$$

written out as

$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = u^{n+\half} -
(u^{n+\half})^2\tp
\tag{498}
\end{equation}
$$

The term \( u^{n+\half} \) is normally approximated by an arithmetic
mean,

$$ u^{n+\half}\approx \half(u^n + u^{n+1}),$$

such that the scheme involves the unknown function only at the time levels
where we actually compute it.
The same arithmetic mean applied to the nonlinear term gives

$$ (u^{n+\half})^2\approx \frac{1}{4}(u^n + u^{n+1})^2,$$

which is nonlinear in the unknown \( u^{n+1} \).
However, using a <em>geometric mean</em> for \( (u^{n+\half})^2 \)
is a way of linearizing the nonlinear term in
<a href="#mjx-eqn-498">(498)</a>:

$$ (u^{n+\half})^2\approx u^nu^{n+1}\tp$$

Using an arithmetic mean on the linear \( u^{n+\frac{1}{2}} \) term in
<a href="#mjx-eqn-498">(498)</a> and a geometric
mean for the second term, results in a linearized equation for the
unknown \( u^{n+1} \):

$$ \frac{u^{n+1}-u^n}{\Delta t} =
\half(u^n + u^{n+1}) + u^nu^{n+1},$$

which can readily be solved:

$$
u^{n+1} = \frac{1 + \half\Delta t}{1+\Delta t u^n - \half\Delta t}
u^n\tp$$

This scheme can be coded directly, and since
there is no nonlinear algebraic equation to iterate over,
we skip the simplified notation with \( u \) for \( u^{n+1} \)
and \( u^{(1)} \) for \( u^n \). The technique with using
a geometric average is an example of transforming a nonlinear
algebraic equation to a linear one, without any need for iterations.

<p>
The geometric mean approximation is often very effective for
linearizing quadratic nonlinearities. Both the arithmetic and geometric mean
approximations have truncation errors of order \( \Delta t^2 \) and are
therefore compatible with the truncation error \( \Oof{\Delta t^2} \)
of the centered difference approximation for \( u^\prime \) in the Crank-Nicolson
method.

<p>
Applying the operator notation for the means and finite differences,
the linearized Crank-Nicolson scheme for the logistic equation can be
compactly expressed as

$$ [D_t u = \overline{u}^{t} + \overline{u^2}^{t,g}]^{n+\half}\tp$$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Remark.</b>
<p>
If we use an arithmetic instead of a geometric mean
for the nonlinear term in
<a href="#mjx-eqn-498">(498)</a>,
we end up with a nonlinear term \( (u^{n+1})^2 \).
This term can be linearized as \( u^{-}u^{n+1} \) in a Picard iteration
approach and in particular as
\( u^nu^{n+1} \) in a Picard1 iteration approach.
The latter gives a scheme almost identical to the one arising from
a geometric mean (the difference in \( u^{n+1} \)
being \( \frac{1}{4}\Delta t u^n(u^{n+1}-u^n)\approx \frac{1}{4}\Delta t^2
u^\prime u \), i.e., a difference of \( \Oof{\Delta t^2} \)).
</div>


<h2 id="nonlin:timediscrete:logistic:Newton">Newton's method</h2>

<p>
The Backward Euler scheme <a href="#mjx-eqn-494">(494)</a>
for the logistic equation leads to a nonlinear algebraic equation
<a href="#mjx-eqn-495">(495)</a>. Now we write any nonlinear
algebraic equation in the general and compact form

$$ F(u) = 0\tp$$

Newton's method linearizes this equation by approximating \( F(u) \) by
its Taylor series expansion around a computed value \( u^{-} \)
and keeping only the linear part:

$$
\begin{align*}
F(u) &= F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) + {\half}F^{\prime\prime}(u^{-})(u-u^{-})^2
+\cdots\\ 
& \approx F(u^{-}) + F^{\prime}(u^{-})(u - u^{-}) = \hat F(u)\tp
\end{align*}
$$

The linear equation \( \hat F(u)=0 \) has the solution

$$ u = u^{-} - \frac{F(u^{-})}{F^{\prime}(u^{-})}\tp$$

Expressed with an iteration index in the unknown, Newton's method takes
on the more familiar mathematical form

$$ u^{k+1} = u^k - \frac{F(u^k)}{F^{\prime}(u^k)},\quad k=0,1,\ldots$$

<p>
It can be shown that the error in iteration \( k+1 \) of Newton's method is
proportional to
the square of the error in iteration \( k \), a result referred to as
<em>quadratic convergence</em>. This means that for
small errors the method converges very fast, and in particular much
faster than Picard iteration and other iteration methods.
(The proof of this result is found in most textbooks on numerical analysis.)
However, the quadratic convergence appears only if \( u^k \) is sufficiently
close to the solution. Further away from the solution the method can
easily converge very slowly or diverge. The reader is encouraged to do
<a href="._fdm-book-solarized020.html#nonlin:exer:Newton:problems1">Problem 6.3: Experience the behavior of Newton's method</a> to get a better understanding
for the behavior of the method.

<p>
Application of Newton's method to the logistic equation discretized
by the Backward Euler method is straightforward
as we have

$$ F(u) = au^2 + bu + c,\quad a=\Delta t,\ b = 1-\Delta t,\ c=-u^{(1)},$$

and then

$$ F^{\prime}(u) = 2au + b\tp$$

The iteration method becomes

$$
\begin{equation}
u = u^{-} + \frac{a(u^{-})^2 + bu^{-} + c}{2au^{-} + b},\quad
u^{-}\ \leftarrow u\tp
\tag{499}
\end{equation}
$$

At each time level, we start the iteration by setting \( u^{-}=u^{(1)} \).
Stopping criteria as listed for the Picard iteration can be used also
for Newton's method.

<p>
An alternative mathematical form, where we write out \( a \), \( b \), and \( c \),
and use a time level counter \( n \) and an iteration counter \( k \), takes
the form

$$
\begin{equation}
u^{n,k+1} = u^{n,k} +
\frac{\Delta t (u^{n,k})^2 + (1-\Delta t)u^{n,k} - u^{n-1}}
{2\Delta t u^{n,k} + 1 - \Delta t},\quad u^{n,0}=u^{n-1},\quad k=0,1,\ldots
\tag{500}
\end{equation}
$$

A program implementation is much closer to <a href="#mjx-eqn-499">(499)</a> than to <a href="#mjx-eqn-500">(500)</a>, but
the latter is better aligned with the established mathematical
notation used in the literature.

<h2 id="nonlin:timediscrete:logistic:relaxation">Relaxation</h2>

<p>
One iteration in Newton's method or
Picard iteration consists of solving a linear problem \( \hat F(u)=0 \).
Sometimes convergence problems arise because the new solution \( u \)
of \( \hat F(u)=0 \) is &quot;too far away&quot; from the previously computed
solution \( u^{-} \). A remedy is to introduce a relaxation, meaning that
we first solve \( \hat F(u^*)=0 \) for a suggested value \( u^* \) and
then we take \( u \) as a weighted mean of what we had, \( u^{-} \), and
what our linearized equation \( \hat F=0 \) suggests, \( u^* \):

$$ u = \omega u^* + (1-\omega) u^{-}\tp$$

The parameter \( \omega \)
is known as a <em>relaxation parameter</em>, and a choice \( \omega < 1 \)
may prevent divergent iterations.

<p>
Relaxation in Newton's method can be directly incorporated
in the basic iteration formula:

$$
\begin{equation}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}\tp
\tag{501}
\end{equation}
$$

<h2 id="nonlin:timediscrete:logistic:impl">Implementation and experiments</h2>

<p>
The program <a href="http://tinyurl.com/nm5587k/nonlin/logistic.py" target="_self"><tt>logistic.py</tt></a> contains
implementations of all the methods described above.
Below is an extract of the file showing how the Picard and Newton
methods are implemented for a Backward Euler discretization of
the logistic equation.

<p>
<!-- @@@CODE src-nonlin/logistic.py fromto: def BE_logistic@def CN_logistic -->

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def BE_logistic(u0, dt, Nt, choice='Picard',
                eps_r=1E-3, omega=1, max_iter=1000):
    if choice == 'Picard1':
        choice = 'Picard'
        max_iter = 1

    u = np.zeros(Nt+1)
    iterations = []
    u[0] = u0
    for n in range(1, Nt+1):
        a = dt
        b = 1 - dt
        c = -u[n-1]

        if choice == 'Picard':

            def F(u):
                return a*u**2 + b*u + c

            u_ = u[n-1]
            k = 0
            while abs(F(u_)) &gt; eps_r and k &lt; max_iter:
                u_ = omega*(-c/(a*u_ + b)) + (1-omega)*u_
                k += 1
            u[n] = u_
            iterations.append(k)

        elif choice == 'Newton':

            def F(u):
                return a*u**2 + b*u + c

            def dF(u):
                return 2*a*u + b

            u_ = u[n-1]
            k = 0
            while abs(F(u_)) &gt; eps_r and k &lt; max_iter:
                u_ = u_ - F(u_)/dF(u_)
                k += 1
            u[n] = u_
            iterations.append(k)
    return u, iterations
</code></pre>
<!-- end verbatim block -->

<p>
The Crank-Nicolson method utilizing a linearization based on the
geometric mean gives a simpler algorithm:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def CN_logistic(u0, dt, Nt):
    u = np.zeros(Nt+1)
    u[0] = u0
    for n in range(0, Nt):
        u[n+1] = (1 + 0.5*dt)/(1 + dt*u[n] - 0.5*dt)*u[n]
    return u
</code></pre>
<!-- end verbatim block -->

<p>
We may run experiments with the model problem
<a href="#mjx-eqn-493">(493)</a> and the different strategies for
dealing with nonlinearities as described above. For a quite coarse
time resolution, \( \Delta t=0.9 \), use of a tolerance \( \epsilon_r=0.1 \)
in the stopping criterion introduces an iteration error, especially in
the Picard iterations, that is visibly much larger than the
time discretization error due to a large \( \Delta t \). This is illustrated
by comparing the upper two plots in
Figure <a href="#nonlin:timediscrete:logistic:impl:fig:u">66</a>. The one to
the right has a stricter tolerance \( \epsilon = 10^{-3} \), which leads
to all the curves corresponding to Picard and Newton iteration to be
on top of each other (and no changes can be visually observed by
reducing \( \epsilon_r \) further). The reason why Newton's method does
much better than Picard iteration in the upper left plot is that
Newton's method with one step comes far below the \( \epsilon_r \) tolerance,
while the Picard iteration needs on average 7 iterations to bring the
residual down to \( \epsilon_r=10^{-1} \), which gives insufficient
accuracy in the solution of the nonlinear equation. It is obvious
that the Picard1 method gives significant errors in addition to
the time discretization unless the time step is as small as in
the lower right plot.

<p>
The <em>BE exact</em> curve corresponds to using the exact solution of the
quadratic equation at each time level, so this curve is only affected
by the Backward Euler time discretization.  The <em>CN gm</em> curve
corresponds to the theoretically more accurate Crank-Nicolson
discretization, combined with a geometric mean for linearization.
This curve appears more accurate, especially if we take the plot in
the lower right with a small \( \Delta t \) and an appropriately small
\( \epsilon_r \) value as the exact curve.

<p>
When it comes to the need for iterations, Figure
<a href="#nonlin:timediscrete:logistic:impl:fig:iter">67</a> displays the number of
iterations required at each time level for Newton's method and
Picard iteration. The smaller \( \Delta t \) is, the better starting value
we have for the iteration, and the faster the convergence is.
With \( \Delta t = 0.9 \) Picard iteration requires on average 32 iterations
per time step, but this number is dramatically reduced as \( \Delta t \)
is reduced.

<p>
However, introducing relaxation and a parameter \( \omega=0.8 \)
immediately reduces the average of 32 to 7, indicating that for the large
\( \Delta t=0.9 \), Picard iteration takes too long steps. An approximately optimal
value for \( \omega \) in this case is 0.5, which results in an average of only
2 iterations! An even more dramatic impact of \( \omega \) appears when
\( \Delta t = 1 \): Picard iteration does not convergence in 1000 iterations,
but \( \omega=0.5 \) again brings the average number of iterations down to 2.

<p>
<center> <!-- figure label: --> <div id="nonlin:timediscrete:logistic:impl:fig:u"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 66:  Impact of solution strategy and time step length on the solution.  <!-- caption label: nonlin:timediscrete:logistic:impl:fig:u --> </p></center>
<p><img src="fig-nonlin/logistic_u.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="nonlin:timediscrete:logistic:impl:fig:iter"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 67:  Comparison of the number of iterations at various time levels for Picard and Newton iteration.  <!-- caption label: nonlin:timediscrete:logistic:impl:fig:iter --> </p></center>
<p><img src="fig-nonlin/logistic_iter.png" align="bottom" width=800></p>
</center>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 27</b>: Is this remark really relevant now? Compare with text.)</font>
<!-- end inline comment -->

<p>
<b>Remark.</b>
The simple Crank-Nicolson method with a geometric mean for the quadratic
nonlinearity gives visually more accurate solutions than the
Backward Euler discretization. Even with a tolerance of \( \epsilon_r=10^{-3} \),
all the methods for treating the nonlinearities in the Backward Euler
discretization give graphs that cannot be distinguished. So for
accuracy in this problem, the time discretization is much more crucial
than \( \epsilon_r \). Ideally, one should estimate the error in the
time discretization, as the solution progresses, and set \( \epsilon_r \)
accordingly.

<h2 id="nonlin:ode:generic">Generalization to a general nonlinear ODE</h2>

<p>
Let us see how the various methods in the previous sections
can be applied to the more generic model

$$
\begin{equation}
u^{\prime} = f(u, t),
\tag{502}
\end{equation}
$$

where \( f \) is a nonlinear function of \( u \).

<h3 id="___sec432">Explicit time discretization </h3>

<p>
Explicit ODE methods like the Forward Euler scheme, Runge-Kutta methods,
Adams-Bashforth methods all evaluate \( f \) at time levels where
\( u \) is already computed, so nonlinearities in \( f \) do not
pose any difficulties.

<h3 id="___sec433">Backward Euler discretization </h3>

<p>
Approximating \( u^{\prime} \) by a backward difference leads to a Backward Euler
scheme, which can be written as

$$ F(u^n) = u^{n} - \Delta t\, f(u^n, t_n) - u^{n-1}=0,$$

or alternatively

$$ F(u) = u - \Delta t\, f(u, t_n) - u^{(1)} = 0\tp$$

A simple Picard iteration, not knowing anything about the nonlinear
structure of \( f \), must approximate \( f(u,t_n) \) by \( f(u^{-},t_n) \):

$$ \hat F(u) = u - \Delta t\, f(u^{-},t_n) - u^{(1)}\tp$$

The iteration starts with \( u^{-}=u^{(1)} \) and proceeds with repeating

$$ u^* = \Delta t\, f(u^{-},t_n) + u^{(1)},\quad u = \omega u^* + (1-\omega)u^{-},
\quad u^{-}\ \leftarrow\ u,$$

until a stopping criterion is fulfilled.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Explicit vs implicit treatment of nonlinear terms.</b>
<p>
Evaluating \( f \) for a known \( u^{-} \) is referred to as <em>explicit</em> treatment of
\( f \), while if \( f(u,t) \) has some structure, say \( f(u,t) = u^3 \), parts of
\( f \) can involve the known \( u \), as in the manual linearization
like \( (u^{-})^2u \), and then the treatment of \( f \) is &quot;more implicit&quot;
and &quot;less explicit&quot;. This terminology is inspired by time discretization
of \( u^{\prime}=f(u,t) \), where evaluating \( f \) for known \( u \) values gives
explicit schemes, while treating \( f \) or parts of \( f \) implicitly,
makes \( f \) contribute to the unknown terms in the equation at the new
time level.

<p>
Explicit treatment of \( f \) usually means stricter conditions on
\( \Delta t \) to achieve stability of time discretization schemes. The same
applies to iteration techniques for nonlinear algebraic equations: the &quot;less&quot;
we linearize \( f \) (i.e., the more we keep of \( u \) in the original formula),
the faster the convergence may be.

<p>
We may say that \( f(u,t)=u^3 \) is treated explicitly if we evaluate \( f \)
as \( (u^{-})^3 \), partially implicit if we linearize as \( (u^{-})^2u \)
and fully implicit if we represent \( f \) by \( u^3 \). (Of course, the
fully implicit representation will require further linearization,
but with \( f(u,t)=u^2 \) a fully implicit treatment is possible if
the resulting quadratic equation is solved with a formula.)

<p>
For the ODE \( u^{\prime}=-u^3 \) with \( f(u,t)=-u^3 \) and coarse
time resolution \( \Delta t = 0.4 \), Picard iteration with \( (u^{-})^2u \)
requires 8 iterations with \( \epsilon_r = 10^{-3} \) for the first
time step, while \( (u^{-})^3 \) leads to 22 iterations. After about 10
time steps both approaches are down to about 2 iterations per time
step, but this example shows a potential of treating \( f \) more
implicitly.

<p>
A trick to treat \( f \) implicitly in Picard iteration is to
evaluate it as \( f(u^{-},t)u/u^{-} \). For a polynomial \( f \), \( f(u,t)=u^m \),
this corresponds to \( (u^{-})^{m}u/u^{-1}=(u^{-})^{m-1}u \). Sometimes this more implicit
treatment has no effect, as with \( f(u,t)=\exp(-u) \) and \( f(u,t)=\ln (1+u) \),
but with \( f(u,t)=\sin(2(u+1)) \), the \( f(u^{-},t)u/u^{-} \) trick
leads to 7, 9, and 11 iterations during the first three steps, while
\( f(u^{-},t) \) demands 17, 21, and 20 iterations.
(Experiments can be done with the code <a href="http://tinyurl.com/nm5587k/nonlin/ODE_Picard_tricks.py" target="_self"><tt>ODE_Picard_tricks.py</tt></a>.)
</div>


<p>
Newton's method applied to a Backward Euler discretization of
\( u^{\prime}=f(u,t) \)
requires the computation of the derivative

$$ F^{\prime}(u) = 1 - \Delta t\frac{\partial f}{\partial u}(u,t_n)\tp$$

Starting with the solution at the previous time level, \( u^{-}=u^{(1)} \),
we can just use the standard formula

$$
\begin{equation}
u = u^{-} - \omega \frac{F(u^{-})}{F^{\prime}(u^{-})}
= u^{-} - \omega \frac{u^{-} - \Delta t\, f(u^{-}, t_n) - u^{(1)}}{1 - \Delta t
\frac{\partial}{\partial u}f(u^{-},t_n)}
\tp
\tag{503}
\end{equation}
$$

<p>
<!-- The geometric mean trick cannot be used unless we know that \( f \) has -->
<!-- a special structure with quadratic expressions in \( u \). -->

<h3 id="___sec434">Crank-Nicolson discretization </h3>

<p>
The standard Crank-Nicolson scheme with arithmetic mean approximation of
\( f \) takes the form

$$ \frac{u^{n+1} - u^n}{\Delta t} = \half(f(u^{n+1}, t_{n+1})
+ f(u^n, t_n))\tp$$

We can write the scheme as a nonlinear algebraic equation

$$
\begin{equation}
F(u) = u - u^{(1)} - \Delta t{\half}f(u,t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}) = 0\tp
\tag{504}
\end{equation}
$$

A Picard iteration scheme must in general employ the linearization

$$ \hat F(u) = u - u^{(1)} - \Delta t{\half}f(u^{-},t_{n+1}) -
\Delta t{\half}f(u^{(1)},t_{n}),$$

while Newton's method can apply the general formula
<a href="#mjx-eqn-503">(503)</a> with \( F(u) \) given in
<a href="#mjx-eqn-504">(504)</a> and

$$ F^{\prime}(u)= 1 - \half\Delta t\frac{\partial f}{\partial u}(u,t_{n+1})\tp$$

<p>
<!-- What about pendulum sin(u) as u/u_ sin(u_)? Check in odespy if it -->
<!-- converges faster (should be able to store the no of Newton and -->
<!-- Picard iterations in the classes and poll afterwards). It the trick -->
<!-- pays off, describe it here. Can odespy be used here? That is, can we -->
<!-- provide the linearization? No...? -->

<h2 id="nonlin:ode:generic:sys:pendulum">Systems of ODEs</h2>

<p>
We may write a system of ODEs

$$
\begin{align*}
\frac{d}{dt}u_0(t) &= f_0(u_0(t),u_1(t),\ldots,u_N(t),t),\\ 
\frac{d}{dt}u_1(t) &= f_1(u_0(t),u_1(t),\ldots,u_N(t),t),\\ 
&\vdots\\ 
\frac{d}{dt}u_m(t) &= f_m(u_0(t),u_1(t),\ldots,u_N(t),t),
\end{align*}
$$

as

$$
\begin{equation}
u^{\prime} = f(u,t),\quad u(0)=U_0,
\tag{505}
\end{equation}
$$

if we interpret \( u \) as a vector \( u=(u_0(t),u_1(t),\ldots,u_N(t)) \)
and \( f \) as a vector function with components
\( (f_0(u,t),f_1(u,t),\ldots,f_N(u,t)) \).

<p>
Most solution methods for scalar ODEs, including
the Forward and Backward Euler schemes and the
Crank-Nicolson method, generalize in a
straightforward way to systems of ODEs simply by using vector
arithmetics instead of scalar arithmetics, which corresponds to
applying the scalar scheme to each component of the system.  For
example, here is a backward difference scheme applied to each
component,

$$
\begin{align*}
\frac{u_0^n- u_0^{n-1}}{\Delta t} &= f_0(u^n,t_n),\\ 
\frac{u_1^n- u_1^{n-1}}{\Delta t} &= f_1(u^n,t_n),\\ 
&\vdots\\ 
\frac{u_N^n- u_N^{n-1}}{\Delta t} &= f_N(u^n,t_n),
\end{align*}
$$

which can be written more compactly in vector form as

$$ \frac{u^n- u^{n-1}}{\Delta t} = f(u^n,t_n)\tp$$

This is a <em>system of algebraic equations</em>,

$$ u^n - \Delta t\,f(u^n,t_n) - u^{n-1}=0,$$

or written out

$$
\begin{align*}
u_0^n - \Delta t\, f_0(u^n,t_n) - u_0^{n-1} &= 0,\\ 
&\vdots\\ 
u_N^n - \Delta t\, f_N(u^n,t_n) - u_N^{n-1} &= 0\tp
\end{align*}
$$

<h3 id="___sec436">Example </h3>

<p>
We shall address the \( 2\times 2 \) ODE system for
oscillations of a pendulum
subject to gravity and air drag. The system can be written as

$$
\begin{align}
\dot\omega &= -\sin\theta -\beta \omega |\omega|,
\tag{506}\\ 
\dot\theta &= \omega,
\tag{507}
\end{align}
$$

where \( \beta \) is a dimensionless parameter (this is the scaled, dimensionless
version of the original, physical model). The unknown components of the
system are the
angle \( \theta(t) \) and the angular velocity \( \omega(t) \).
We introduce \( u_0=\omega \) and \( u_1=\theta \), which leads to

$$
\begin{align*}
u_0^{\prime} = f_0(u,t) &= -\sin u_1 - \beta u_0|u_0|,\\ 
u_1^{\prime} = f_1(u,t) &= u_0\tp
\end{align*}
$$

A Crank-Nicolson scheme reads

$$
\begin{align}
\frac{u_0^{n+1}-u_0^{n}}{\Delta t} &= -\sin u_1^{n+\frac{1}{2}}
- \beta u_0^{n+\frac{1}{2}}|u_0^{n+\frac{1}{2}}|\nonumber\\ 
& \approx -\sin\left(\frac{1}{2}(u_1^{n+1} + u_1n)\right)
- \beta\frac{1}{4} (u_0^{n+1} + u_0^n)|u_0^{n+1}+u_0^n|,
\tag{508}\\ 
\frac{u_1^{n+1}-u_1^n}{\Delta t} &= u_0^{n+\frac{1}{2}}\approx
\frac{1}{2} (u_0^{n+1}+u_0^n)\tp
\tag{509}
\end{align}
$$

This is a <em>coupled system</em> of two nonlinear algebraic equations
in two unknowns \( u_0^{n+1} \) and \( u_1^{n+1} \).

<p>
Using the notation \( u_0 \) and \( u_1 \) for the unknowns \( u_0^{n+1} \) and
\( u_1^{n+1} \) in this system, writing \( u_0^{(1)} \) and
\( u_1^{(1)} \) for the previous values \( u_0^n \) and \( u_1^n \), multiplying
by \( \Delta t \) and moving the terms to the left-hand sides, gives

$$
\begin{align}
u_0 - u_0^{(1)} + \Delta t\,\sin\left(\frac{1}{2}(u_1 + u_1^{(1)})\right)
+ \frac{1}{4}\Delta t\beta (u_0 + u_0^{(1)})|u_0 + u_0^{(1)}| &=0,
\tag{510}\\ 
u_1 - u_1^{(1)} -\frac{1}{2}\Delta t(u_0 + u_0^{(1)}) &=0\tp
\tag{511}
\end{align}
$$

Obviously, we have a need for solving systems of nonlinear algebraic
equations, which is the topic of the next section.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._fdm-book-solarized014.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._fdm-book-solarized016.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

