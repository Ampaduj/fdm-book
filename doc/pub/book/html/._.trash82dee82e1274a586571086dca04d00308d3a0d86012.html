<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite Difference Computing with Partial Differential Equations">
<meta name="keywords" content="vibration ODE,oscillations,mechanical vibrations,period (of oscillations),frequency (of oscillations),Hz (unit),mesh finite differences,mesh function,centered difference,finite differences centered,test function,pytest,nose,verification hand calculations,unit testing,verification polynomial solutions,verification convergence rates,making movies,animation,WebM (video format),Ogg (video format),MP4 (video format),Flash (video format),video formats,HTML5 video tag,error global,stability criterion,phase plane plot,mechanical energy,energy principle,forward-backward Euler-Cromer scheme,nonlinear restoring force,nonlinear spring,forced vibrations,geometric mean,averaging geometric,DOF (degree of freedom),resonance,waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,callback function,verification polynomial solution,nose,pytest,unit testing,test function,closure,vectorization,parallelism,scalar code,vectorization,array computing,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,boundary conditions Neumann,boundary conditions Dirichlet,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,radiation condition,open boundary condition,boundary condition open (radiation),periodic boundary conditions,boundary conditions periodic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,index set notation,diffusion equation, 1D,heat equation, 1D,stationary solution,explicit discretization methods,Forward Euler scheme,implicit discretization methods,amplification factor,sparse matrix,Jacobi method,Gauss-Seidel method,SOR method,red-black numbering,LU factorization,Cholesky factorization,preconditioning,random walk,vectorization,seed (random numbers),verification,diffusion limit of random walk,interrupt a program by Ctrl+c,stochastic difference equation,stochastic ODE,Fokker-Planck equation,Wiener process,energy estimates (diffusion),Richardson iteration,preconditioning,upwind difference,staggered mesh,staggered Euler-Cromer scheme,alternating mesh,linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,continuation method,truncation error general,finite differences backward,truncation error Backward Euler scheme,finite differences forward,truncation error Forward Euler scheme,finite differences centered,truncation error Crank-Nicolson scheme,truncation error table of formulas,decay ODE,correction terms,truncation error correction terms,verification,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage">

<title>Finite Difference Computing with Partial Differential Equations</title>

<!-- Bootstrap style: bootswatch_readable -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/readable/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>



<!-- Tools for embedded Bokeh plots -->
<link rel="stylesheet"
      href="http://cdn.pydata.org/bokeh/release/bokeh-0.9.0.min.css"
      type="text/css" />
<script type="text/javascript"
	src="http://cdn.pydata.org/bokeh/release/bokeh-0.9.0.min.js">
</script>
<script type="text/javascript">
  Bokeh.set_log_level("info");
</script>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, u'ch:preface', u'ch:preface'),
              (u'Simplify, understand, generalize', 3, None, '___sec1'),
              (u'Constructive mathematics', 3, None, '___sec2'),
              (u'All nuts and bolts', 3, None, '___sec3'),
              (u'Python as programming language', 3, None, '___sec4'),
              (u'Program verification', 3, None, '___sec5'),
              (u'Vectorized code', 3, None, '___sec6'),
              (u'Analysis via exact solutions of discrete equations',
               3,
               None,
               '___sec7'),
              (u'Code-inspired mathematical notation', 3, None, '___sec8'),
              (u'Limited scope', 3, None, '___sec9'),
              (u'Independent chapters', 3, None, '___sec10'),
              (u'Supplementary materials', 3, None, '___sec11'),
              (u'Acknowledgments', 3, None, '___sec12'),
              (u'Vibration ODEs', 0, u'ch:vib', u'ch:vib'),
              (u'Finite difference discretization',
               1,
               u'vib:model1',
               u'vib:model1'),
              (u'A basic model for vibrations', 2, None, '___sec15'),
              (u'A centered finite difference scheme',
               2,
               u'vib:ode1:fdm',
               u'vib:ode1:fdm'),
              (u'Step 1: Discretizing the domain', 3, None, '___sec17'),
              (u'Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec18'),
              (u'Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec19'),
              (u'Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec20'),
              (u'Computing the first step', 3, None, '___sec21'),
              (u'The computational algorithm', 3, None, '___sec22'),
              (u'Operator notation', 3, None, '___sec23'),
              (u'Implementation', 1, u'vib:impl1', u'vib:impl1'),
              (u'Making a solver function',
               2,
               u'vib:impl1:solver',
               u'vib:impl1:solver'),
              (u'Computing $u^{\\prime}$', 3, None, '___sec26'),
              (u'Verification', 2, u'vib:ode1:verify', u'vib:ode1:verify'),
              (u'Manual calculation', 3, None, '___sec28'),
              (u'Testing very simple polynomial solutions',
               3,
               None,
               '___sec29'),
              (u'Checking convergence rates', 3, None, '___sec30'),
              (u'Scaled model', 2, None, '___sec31'),
              (u'Long time simulations',
               1,
               u'vib:ode1:longseries',
               u'vib:ode1:longseries'),
              (u'Using a moving plot window', 2, None, '___sec33'),
              (u'Making animations', 2, u'vib:ode1:anim', u'vib:ode1:anim'),
              (u'Producing standard video formats', 3, None, '___sec35'),
              (u'Paying PNG files in a web browser', 3, None, '___sec36'),
              (u'Making animated GIF files', 3, None, '___sec37'),
              (u'Using Bokeh to compare graphs', 2, None, '___sec38'),
              (u'Using a line-by-line ascii plotter', 2, None, '___sec39'),
              (u'Empirical analysis of the solution',
               2,
               u'vib:ode1:empirical',
               u'vib:ode1:empirical'),
              (u'Analysis of the numerical scheme',
               1,
               u'vib:ode1:analysis',
               u'vib:ode1:analysis'),
              (u'Deriving a solution of the numerical scheme',
               2,
               None,
               '___sec42'),
              (u'Exact discrete solution',
               2,
               u'vib:ode1:analysis:sol',
               u'vib:ode1:analysis:sol'),
              (u'Convergence',
               2,
               u'vib:ode1:analysis:conv',
               u'vib:ode1:analysis:conv'),
              (u'The global error', 2, None, '___sec45'),
              (u'Stability', 2, None, '___sec46'),
              (u'About the accuracy at the stability limit',
               2,
               None,
               '___sec47'),
              (u'Alternative schemes based on 1st-order equations',
               1,
               u'vib:model2x2',
               u'vib:model2x2'),
              (u'The Forward Euler scheme', 2, None, '___sec49'),
              (u'The Backward Euler scheme', 2, None, '___sec50'),
              (u'The Crank-Nicolson scheme',
               2,
               u'vib:undamped:CN',
               u'vib:undamped:CN'),
              (u'Comparison of schemes',
               2,
               u'vib:model2x2:compare',
               u'vib:model2x2:compare'),
              (u'Runge-Kutta methods', 2, None, '___sec53'),
              (u'Analysis of the Forward Euler scheme', 2, None, '___sec54'),
              (u'Energy considerations',
               1,
               u'vib:model1:energy',
               u'vib:model1:energy'),
              (u'Derivation of the energy expression',
               2,
               u'vib:model1:energy:expr',
               u'vib:model1:energy:expr'),
              (u'Energy of the exact solution', 3, None, '___sec57'),
              (u'An error measure based on energy',
               2,
               u'vib:model1:energy:measure',
               u'vib:model1:energy:measure'),
              (u'The Euler-Cromer method',
               1,
               u'vib:model2x2:EulerCromer',
               u'vib:model2x2:EulerCromer'),
              (u'Forward-backward discretization', 2, None, '___sec60'),
              (u'Equivalence with the scheme for the second-order ODE',
               2,
               u'vib:model2x2:EulerCromer:equiv',
               u'vib:model2x2:EulerCromer:equiv'),
              (u'Implementation',
               2,
               u'vib:model2x2:EulerCromer:impl',
               u'vib:model2x2:EulerCromer:impl'),
              (u'The velocity Verlet algorithm', 2, None, '___sec63'),
              (u'Generalization: damping, nonlinear spring, and external excitation',
               1,
               u'vib:model2',
               u'vib:model2'),
              (u'A centered scheme for linear damping',
               2,
               u'vib:ode2:fdm:flin',
               u'vib:ode2:fdm:flin'),
              (u'A centered scheme for quadratic damping',
               2,
               u'vib:ode2:fdm:fquad',
               u'vib:ode2:fdm:fquad'),
              (u'A forward-backward discretization of the quadratic damping term',
               2,
               None,
               '___sec67'),
              (u'Implementation', 2, u'vib:ode2:solver', u'vib:ode2:solver'),
              (u'Verification', 2, u'vib:ode2:verify', u'vib:ode2:verify'),
              (u'Constant solution', 3, None, '___sec70'),
              (u'Linear solution', 3, None, '___sec71'),
              (u'Quadratic solution', 3, None, '___sec72'),
              (u'Visualization', 2, u'vib:ode2:viz', u'vib:ode2:viz'),
              (u'User interface', 2, u'vib:ode2:ui', u'vib:ode2:ui'),
              (u'The Euler-Cromer scheme for the generalized model',
               2,
               None,
               '___sec75'),
              (u'Exercises and Problems', 1, None, '___sec76'),
              (u'Problem 1.1: Use linear/quadratic functions for verification',
               2,
               u'vib:exer:undamped:verify:linquad',
               u'vib:exer:undamped:verify:linquad'),
              (u'Exercise 1.2: Show linear growth of the phase with time',
               2,
               u'vib:exer:phase:err:growth',
               u'vib:exer:phase:err:growth'),
              (u'Exercise 1.3: Improve the accuracy by adjusting the frequency',
               2,
               u'vib:exer:w:adjust',
               u'vib:exer:w:adjust'),
              (u'Exercise 1.4: See if adaptive methods improve the phase error',
               2,
               u'vib:exer:undamped:adaptive',
               u'vib:exer:undamped:adaptive'),
              (u'Exercise 1.5: Use a Taylor polynomial to compute $u^1$',
               2,
               u'vib:exer:step4b:alt',
               u'vib:exer:step4b:alt'),
              (u'Exercise 1.6: Find the minimal resolution of an oscillatory function',
               2,
               u'vib:exer:wdt:limit',
               u'vib:exer:wdt:limit'),
              (u'Exercise 1.7: Visualize the accuracy of finite differences for a cosine function',
               2,
               u'vib:exer:fd:exp:plot',
               u'vib:exer:fd:exp:plot'),
              (u'Exercise 1.8: Verify convergence rates of the error in energy',
               2,
               u'vib:exer:energy:convrate',
               u'vib:exer:energy:convrate'),
              (u'Exercise 1.9: Use linear/quadratic functions for verification',
               2,
               u'vib:exer:verify:gen:linear',
               u'vib:exer:verify:gen:linear'),
              (u'Exercise 1.10: Use an exact discrete solution for verification',
               2,
               u'vib:exer:discrete:omega',
               u'vib:exer:discrete:omega'),
              (u'Exercise 1.11: Use analytical solution for convergence rate tests',
               2,
               u'vib:exer:conv:rate',
               u'vib:exer:conv:rate'),
              (u'Exercise 1.12: Investigate the amplitude errors of many solvers',
               2,
               u'vib:exer:undamped:odespy',
               u'vib:exer:undamped:odespy'),
              (u'Exercise 1.13: Minimize memory usage of a vibration solver',
               2,
               u'vib:exer:memsave',
               u'vib:exer:memsave'),
              (u'Exercise 1.14: Implement the solver via classes',
               2,
               u'vib:exer:gen:class',
               u'vib:exer:gen:class'),
              (u'Exercise 1.15: Interpret $[D_tD_t u]^n$ as a forward-backward difference',
               2,
               u'vib:exer:DtDt:asDtpDtm',
               u'vib:exer:DtDt:asDtpDtm'),
              (u'Exercise 1.16: Use a backward difference for the damping term',
               2,
               u'vib:exer:quad:damping:bw',
               u'vib:exer:quad:damping:bw'),
              (u'Exercise 1.17: Analysis of the Euler-Cromer scheme',
               2,
               u'vib:exer:EulerCromer:analysis',
               u'vib:exer:EulerCromer:analysis'),
              (u'Applications of vibration models',
               1,
               u'vib:app',
               u'vib:app'),
              (u'Oscillating mass attached to a spring',
               2,
               u'vib:app:mass_spring',
               u'vib:app:mass_spring'),
              (u'Scaling', 3, None, '___sec96'),
              (u'The physics', 3, None, '___sec97'),
              (u'General mechanical vibrating system',
               2,
               u'vib:app:mass_gen',
               u'vib:app:mass_gen'),
              (u'Scaling', 3, None, '___sec99'),
              (u'A sliding mass attached to a spring',
               2,
               u'vib:app:mass_sliding',
               u'vib:app:mass_sliding'),
              (u'A jumping washing machine',
               2,
               u'vib:app:washmach',
               u'vib:app:washmach'),
              (u'Motion of a pendulum',
               2,
               u'vib:app:pendulum',
               u'vib:app:pendulum'),
              (u'Simple pendulum', 3, None, '___sec103'),
              (u'Physical pendulum', 3, None, '___sec104'),
              (u'Dynamic free body diagram during pendulum motion',
               2,
               u'vib:app:pendulum_bodydia',
               u'vib:app:pendulum_bodydia'),
              (u'Writing the solver', 3, None, '___sec106'),
              (u'Drawing the free body diagram', 3, None, '___sec107'),
              (u'Making the animated free body diagram',
               3,
               None,
               '___sec108'),
              (u'Motion of an elastic pendulum',
               2,
               u'vib:app:pendulum_elastic',
               u'vib:app:pendulum_elastic'),
              (u'Remarks about an elastic vs a non-elastic pendulum',
               3,
               None,
               '___sec110'),
              (u'Initial conditions', 3, None, '___sec111'),
              (u'The complete ODE problem', 3, None, '___sec112'),
              (u'Scaling', 3, None, '___sec113'),
              (u'Remark on the non-elastic limit', 3, None, '___sec114'),
              (u'Vehicle on a bumpy road',
               2,
               u'vib:app:bumpy',
               u'vib:app:bumpy'),
              (u'Bouncing ball',
               2,
               u'vib:app:bouncing_ball',
               u'vib:app:bouncing_ball'),
              (u'Electric circuits', 2, None, '___sec117'),
              (u'Exercises', 1, None, '___sec118'),
              (u'Exercise 1.18: Simulate resonance',
               2,
               u'vib:exer:resonance',
               u'vib:exer:resonance'),
              (u'Exercise 1.19: Simulate oscillations of a sliding box',
               2,
               u'vib:exer:sliding_box',
               u'vib:exer:sliding_box'),
              (u'Exercise 1.20: Simulate a bouncing ball',
               2,
               u'vib:exer:bouncing:ball',
               u'vib:exer:bouncing:ball'),
              (u'Exercise 1.21: Simulate a simple pendulum',
               2,
               u'vib:exer:pendulum_simple',
               u'vib:exer:pendulum_simple'),
              (u'Exercise 1.22: Simulate an elastic pendulum',
               2,
               u'vib:exer:pendulum_elastic',
               u'vib:exer:pendulum_elastic'),
              (u'Exercise 1.23: Simulate an elastic pendulum with air resistance',
               2,
               u'vib:exer:pendulum_elastic_drag',
               u'vib:exer:pendulum_elastic_drag'),
              (u'Remarks', 3, None, '___sec125'),
              (u'Wave equations', 0, u'ch:wave', u'ch:wave'),
              (u'Simulation of waves on a string',
               1,
               u'wave:string',
               u'wave:string'),
              (u'Discretizing the domain',
               2,
               u'wave:string:mesh',
               u'wave:string:mesh'),
              (u'Uniform meshes', 3, None, '___sec129'),
              (u'The discrete solution',
               2,
               u'wave:string:numerical:sol',
               u'wave:string:numerical:sol'),
              (u'Fulfilling the equation at the mesh points',
               2,
               u'wave:string:samplingPDE',
               u'wave:string:samplingPDE'),
              (u'Replacing derivatives by finite differences',
               2,
               u'wave:string:fd',
               u'wave:string:fd'),
              (u'Algebraic version of the PDE', 3, None, '___sec133'),
              (u'Interpretation of the equation as a stencil',
               3,
               None,
               '___sec134'),
              (u'Algebraic version of the initial conditions',
               3,
               None,
               '___sec135'),
              (u'Formulating a recursive algorithm',
               2,
               u'wave:string:alg',
               u'wave:string:alg'),
              (u'Sketch of an implementation',
               2,
               u'wave:string:impl',
               u'wave:string:impl'),
              (u'Verification', 1, None, '___sec138'),
              (u'A slightly generalized model problem',
               2,
               u'wave:pde2:fd',
               u'wave:pde2:fd'),
              (u'Using an analytical solution of physical significance',
               2,
               u'wave:pde2:fd:standing:waves',
               u'wave:pde2:fd:standing:waves'),
              (u'Manufactured solution',
               2,
               u'wave:pde2:fd:MMS',
               u'wave:pde2:fd:MMS'),
              (u'Constructing an exact solution of the discrete equations',
               2,
               u'wave:pde2:fd:verify:quadratic',
               u'wave:pde2:fd:verify:quadratic'),
              (u'Implementation', 1, u'wave:pde1:impl', u'wave:pde1:impl'),
              (u'Callback function for user-specific actions',
               2,
               None,
               '___sec144'),
              (u'The solver function',
               2,
               u'wave:pde1:impl:solver',
               u'wave:pde1:impl:solver'),
              (u'Verification: exact quadratic solution',
               2,
               u'wave:pde1:impl:verify:quadratic',
               u'wave:pde1:impl:verify:quadratic'),
              (u'Visualization: animating the solution',
               2,
               u'wave:pde1:impl:animate',
               u'wave:pde1:impl:animate'),
              (u'Function for administering the simulation',
               3,
               None,
               '___sec148'),
              (u'Dissection of the code', 3, None, '___sec149'),
              (u'Making movie files', 3, None, '___sec150'),
              (u'Skipping frames for animation speed', 3, None, '___sec151'),
              (u'Running a case',
               2,
               u'wave:pde1:guitar:data',
               u'wave:pde1:guitar:data'),
              (u'Working with a scaled PDE model', 2, None, '___sec153'),
              (u'Vectorization',
               1,
               u'wave:pde1:impl:vec',
               u'wave:pde1:impl:vec'),
              (u'Operations on slices of arrays',
               2,
               u'wave:pde1:impl:vec:slices:basics',
               u'wave:pde1:impl:vec:slices:basics'),
              (u'Finite difference schemes expressed as slices',
               2,
               u'wave:pde1:impl:vec:slices:fdm',
               u'wave:pde1:impl:vec:slices:fdm'),
              (u'Verification',
               2,
               u'wave:pde1:impl:vec:verify:quadratic',
               u'wave:pde1:impl:vec:verify:quadratic'),
              (u'Efficiency measurements', 2, None, '___sec158'),
              (u'Solution 1', 3, None, '___sec159'),
              (u'Solution 2', 3, None, '___sec160'),
              (u'Efficiency experiments', 3, None, '___sec161'),
              (u'Remark on the updating of arrays',
               2,
               u'wave:pde1:impl:ref:switch',
               u'wave:pde1:impl:ref:switch'),
              (u'Exercises', 1, None, '___sec163'),
              (u'Exercise 2.1: Simulate a standing wave',
               2,
               u'wave:exer:standingwave',
               u'wave:exer:standingwave'),
              (u'Remarks', 3, None, '___sec165'),
              (u'Exercise 2.2: Add storage of solution in a user action function',
               2,
               u'wave:exer:store:list',
               u'wave:exer:store:list'),
              (u'Exercise 2.3: Use a class for the user action function',
               2,
               u'wave:exer:store:list:class',
               u'wave:exer:store:list:class'),
              (u'Exercise 2.4: Compare several Courant numbers in one movie',
               2,
               u'wave:exer:multiple:C',
               u'wave:exer:multiple:C'),
              (u'Project 2.5: Calculus with 1D mesh functions',
               2,
               u'wave:exer:mesh1D:calculus',
               u'wave:exer:mesh1D:calculus'),
              (u'Generalization: reflecting boundaries',
               1,
               u'wave:pde2:Neumann',
               u'wave:pde2:Neumann'),
              (u'Neumann boundary condition',
               2,
               u'wave:pde2:Neumann:bc',
               u'wave:pde2:Neumann:bc'),
              (u'Discretization of derivatives at the boundary',
               2,
               u'wave:pde2:Neumann:discr',
               u'wave:pde2:Neumann:discr'),
              (u'Implementation of Neumann conditions',
               2,
               u'wave:pde2:Neumann:impl',
               u'wave:pde2:Neumann:impl'),
              (u'Index set notation', 2, u'wave:indexset', u'wave:indexset'),
              (u'Verifying the implementation of Neumann conditions',
               2,
               u'wave:pde1:verify',
               u'wave:pde1:verify'),
              (u'Alternative implementation via ghost cells',
               2,
               u'wave:pde1:Neumann:ghost',
               u'wave:pde1:Neumann:ghost'),
              (u'Idea', 3, None, '___sec177'),
              (u'Implementation', 3, None, '___sec178'),
              (u'Generalization: variable wave velocity',
               1,
               u'wave:pde2:var:c',
               u'wave:pde2:var:c'),
              (u'The model PDE with a variable coefficient',
               2,
               None,
               '___sec180'),
              (u'Discretizing the variable coefficient',
               2,
               u'wave:pde2:var:c:ideas',
               u'wave:pde2:var:c:ideas'),
              (u'Computing the coefficient between mesh points',
               2,
               u'wave:pde2:var:c:means',
               u'wave:pde2:var:c:means'),
              (u'How a variable coefficient affects the stability',
               2,
               u'wave:pde2:var:c:stability',
               u'wave:pde2:var:c:stability'),
              (u'Neumann condition and a variable coefficient',
               2,
               u'wave:pde2:var:c:Neumann',
               u'wave:pde2:var:c:Neumann'),
              (u'Implementation of variable coefficients',
               2,
               u'wave:pde2:var:c:impl',
               u'wave:pde2:var:c:impl'),
              (u'A more general PDE model with variable coefficients',
               2,
               None,
               '___sec186'),
              (u'Generalization: damping', 2, None, '___sec187'),
              (u'Building a general 1D wave equation solver',
               1,
               u'wave:pde2:software',
               u'wave:pde2:software'),
              (u'User action function as a class', 2, None, '___sec189'),
              (u'The code', 3, None, '___sec190'),
              (u'Dissection', 3, None, '___sec191'),
              (u'Pulse propagation in two media', 2, None, '___sec192'),
              (u'Exercises', 1, None, '___sec193'),
              (u'Exercise 2.6: Find the analytical solution to a damped wave equation',
               2,
               u'wave:exer:standingwave:damped:uex',
               u'wave:exer:standingwave:damped:uex'),
              (u'Problem 2.7: Explore symmetry boundary conditions',
               2,
               u'wave:exer:symmetry:bc',
               u'wave:exer:symmetry:bc'),
              (u'Exercise 2.8: Send pulse waves through a layered medium',
               2,
               u'wave:app:exer:pulse1D',
               u'wave:app:exer:pulse1D'),
              (u'Exercise 2.9: Explain why numerical noise occurs',
               2,
               u'wave:app:exer:pulse1D:analysis',
               u'wave:app:exer:pulse1D:analysis'),
              (u'Exercise 2.10: Investigate harmonic averaging in a 1D model',
               2,
               u'wave:app:exer:pulse1D:harmonic',
               u'wave:app:exer:pulse1D:harmonic'),
              (u'Problem 2.11: Implement open boundary conditions',
               2,
               u'wave:app:exer:radiationBC',
               u'wave:app:exer:radiationBC'),
              (u'Remarks', 3, None, '___sec200'),
              (u'Exercise 2.12: Implement periodic boundary conditions',
               2,
               u'wave:exer:periodic',
               u'wave:exer:periodic'),
              (u'Exercise 2.13: Compare discretizations of a Neumann condition',
               2,
               None,
               '___sec202'),
              (u'Exercise 2.14: Verification by a cubic polynomial in space',
               2,
               u'wave:fd2:exer:verify:cubic',
               u'wave:fd2:exer:verify:cubic'),
              (u'Analysis of the difference equations',
               1,
               u'wave:pde1:analysis',
               u'wave:pde1:analysis'),
              (u'Properties of the solution of the wave equation',
               2,
               u'wave:pde1:properties',
               u'wave:pde1:properties'),
              (u'More precise definition of Fourier representations',
               2,
               u'wave:pde1:Fourier',
               u'wave:pde1:Fourier'),
              (u'Stability',
               2,
               u'wave:pde1:stability',
               u'wave:pde1:stability'),
              (u'Preliminary results', 3, None, '___sec208'),
              (u'Numerical wave propagation', 3, None, '___sec209'),
              (u'Numerical dispersion relation',
               2,
               u'wave:pde1:num:dispersion',
               u'wave:pde1:num:dispersion'),
              (u'Extending the analysis to 2D and 3D',
               2,
               u'wave:pde1:analysis:2D3D',
               u'wave:pde1:analysis:2D3D'),
              (u'Finite difference methods for 2D and 3D wave equations',
               1,
               u'wave:2D3D',
               u'wave:2D3D'),
              (u'Multi-dimensional wave equations',
               2,
               u'wave:2D3D:models',
               u'wave:2D3D:models'),
              (u'Mesh', 2, u'wave:2D3D:mesh', u'wave:2D3D:mesh'),
              (u'Discretization',
               2,
               u'wave:2D3D:discretization',
               u'wave:2D3D:discretization'),
              (u'Discretizing the PDEs', 3, None, '___sec216'),
              (u'Handling boundary conditions where $u$ is known',
               3,
               None,
               '___sec217'),
              (u'Discretizing the Neumann condition', 3, None, '___sec218'),
              (u'Implementation', 1, u'wave:2D3D:impl', u'wave:2D3D:impl'),
              (u'Scalar computations',
               2,
               u'wave2D3D:impl:scalar',
               u'wave2D3D:impl:scalar'),
              (u'Domain and mesh', 3, None, '___sec221'),
              (u'Solution arrays', 3, None, '___sec222'),
              (u'Index sets', 3, None, '___sec223'),
              (u'Computing the solution', 3, None, '___sec224'),
              (u'Vectorized computations',
               2,
               u'wave2D3D:impl:vectorized',
               u'wave2D3D:impl:vectorized'),
              (u'Verification',
               2,
               u'wave2D3D:impl:verify',
               u'wave2D3D:impl:verify'),
              (u'Testing a quadratic solution', 3, None, '___sec227'),
              (u'Exercises', 1, None, '___sec228'),
              (u'Exercise 2.15: Check that a solution fulfills the discrete model',
               2,
               u'wave:exer:quadratic:2D',
               u'wave:exer:quadratic:2D'),
              (u'Project 2.16: Calculus with 2D mesh functions',
               2,
               u'wave:exer:mesh3D:calculus',
               u'wave:exer:mesh3D:calculus'),
              (u'Exercise 2.17: Implement Neumann conditions in 2D',
               2,
               u'wave:app:exer:wave2D:Neumann',
               u'wave:app:exer:wave2D:Neumann'),
              (u'Exercise 2.18: Test the efficiency of compiled loops in 3D',
               2,
               u'wave:exer:3D:f77:cy:efficiency',
               u'wave:exer:3D:f77:cy:efficiency'),
              (u'Applications of wave equations',
               1,
               u'wave:app',
               u'wave:app'),
              (u'Waves on a string',
               2,
               u'wave:app:string',
               u'wave:app:string'),
              (u'Damping', 3, None, '___sec235'),
              (u'External forcing', 3, None, '___sec236'),
              (u'Modeling the tension via springs', 3, None, '___sec237'),
              (u'Waves on a membrane',
               2,
               u'wave:app:membrane',
               u'wave:app:membrane'),
              (u'Elastic waves in a rod',
               2,
               u'wave:app:elastic:rod',
               u'wave:app:elastic:rod'),
              (u'The acoustic model for seismic waves',
               2,
               u'wave:app:acoustic:seismic',
               u'wave:app:acoustic:seismic'),
              (u'Anisotropy', 3, None, '___sec241'),
              (u'Sound waves in liquids and gases',
               2,
               u'wave:app:sound',
               u'wave:app:sound'),
              (u'Spherical waves',
               2,
               u'wave:app:spherical',
               u'wave:app:spherical'),
              (u'The linear shallow water equations',
               2,
               u'wave:app:sw:2D',
               u'wave:app:sw:2D'),
              (u'Wind drag on the surface', 3, None, '___sec245'),
              (u'Bottom drag', 3, None, '___sec246'),
              (u"Effect of the Earth's rotation", 3, None, '___sec247'),
              (u'Waves in blood vessels',
               2,
               u'wave:app:blood',
               u'wave:app:blood'),
              (u'Electromagnetic waves',
               2,
               u'wave:app:light',
               u'wave:app:light'),
              (u'Exercises', 1, u'wave:app:exer', u'wave:app:exer'),
              (u'Exercise 2.19: Simulate waves on a non-homogeneous string',
               2,
               u'wave:app:exer:string:discont',
               u'wave:app:exer:string:discont'),
              (u'Exercise 2.20: Simulate damped waves on a string',
               2,
               u'wave:app:exer:string:damping',
               u'wave:app:exer:string:damping'),
              (u'Exercise 2.21: Simulate elastic waves in a rod',
               2,
               u'wave:app:exer:rod',
               u'wave:app:exer:rod'),
              (u'Exercise 2.22: Simulate spherical waves',
               2,
               u'wave:app:exer:spherical',
               u'wave:app:exer:spherical'),
              (u'Problem 2.23: Earthquake-generated tsunami over a subsea hill',
               2,
               u'wave:app:exer:tsunami1D:hill',
               u'wave:app:exer:tsunami1D:hill'),
              (u'Problem 2.24: Earthquake-generated tsunami over a 3D hill',
               2,
               u'wave:app:exer:tsunami2D:hill',
               u'wave:app:exer:tsunami2D:hill'),
              (u'Problem 2.25: Investigate Matplotlib for visualization',
               2,
               u'wave:app:exer:tsunami:hill:viz:matplotlib',
               u'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (u'Problem 2.26: Investigate visualization packages',
               2,
               u'wave:app:exer:tsunami:hill:viz:packages',
               u'wave:app:exer:tsunami:hill:viz:packages'),
              (u'Problem 2.27: Implement loops in compiled languages',
               2,
               u'wave:app:exer:tsunami2D:hill:compiled',
               u'wave:app:exer:tsunami2D:hill:compiled'),
              (u'Exercise 2.28: Simulate seismic waves in 2D',
               2,
               u'wave:app:exer:seismic2D',
               u'wave:app:exer:seismic2D'),
              (u'Project 2.29: Model 3D acoustic waves in a room',
               2,
               u'wave:app:exer:acoustics',
               u'wave:app:exer:acoustics'),
              (u'Project 2.30: Solve a 1D transport equation',
               2,
               u'wave:app:exer:advec1D',
               u'wave:app:exer:advec1D'),
              (u'Problem 2.31: General analytical solution of a 1D damped wave equation',
               2,
               u'wave:app:exer:anal:damped:wave1D',
               u'wave:app:exer:anal:damped:wave1D'),
              (u'Problem 2.32: General analytical solution of a 2D damped wave equation',
               2,
               u'wave:app:exer:anal:damped:wave2D',
               u'wave:app:exer:anal:damped:wave2D'),
              (u'Diffusion equations', 0, u'ch:diffu', u'ch:diffu'),
              (u'An explicit method for the 1D diffusion equation',
               1,
               u'diffu:pde1:FEsec',
               u'diffu:pde1:FEsec'),
              (u'The initial-boundary value problem for 1D diffusion',
               2,
               None,
               '___sec267'),
              (u'Forward Euler scheme',
               2,
               u'diffu:pde1:FE',
               u'diffu:pde1:FE'),
              (u'Implementation',
               2,
               u'diffu:pde1:FE:code',
               u'diffu:pde1:FE:code'),
              (u'Verification',
               2,
               u'diffu:pde1:FE:verify',
               u'diffu:pde1:FE:verify'),
              (u'Numerical experiments',
               2,
               u'diffu:pde1:FE:experiments',
               u'diffu:pde1:FE:experiments'),
              (u'Implicit methods for the 1D diffusion equation',
               1,
               u'diffu:pde1:implicit',
               u'diffu:pde1:implicit'),
              (u'Backward Euler scheme',
               2,
               u'diffu:pde1:BE',
               u'diffu:pde1:BE'),
              (u'Sparse matrix implementation',
               2,
               u'diffu:pde1:impl:sparse',
               u'diffu:pde1:impl:sparse'),
              (u'Crank-Nicolson scheme',
               2,
               u'diffu:pde1:CN',
               u'diffu:pde1:CN'),
              (u'The unifying $\\theta$ rule',
               2,
               u'diffu:pde1:theta',
               u'diffu:pde1:theta'),
              (u'Experiments',
               2,
               u'diffu:pde1:theta:experiments',
               u'diffu:pde1:theta:experiments'),
              (u'The Laplace and Poisson equation', 2, None, '___sec278'),
              (u'Analysis of schemes for the diffusion equation',
               1,
               u'diffu:pde1:analysis',
               u'diffu:pde1:analysis'),
              (u'Properties of the solution',
               2,
               u'diffu:pde1:analysis:uex',
               u'diffu:pde1:analysis:uex'),
              (u'Similarity solution', 3, None, '___sec281'),
              (u'Solution for a Gaussian pulse', 3, None, '___sec282'),
              (u'Solution for a sine component', 3, None, '___sec283'),
              (u'Analysis of discrete equations', 2, None, '___sec284'),
              (u'Analysis of the finite difference schemes',
               2,
               u'diffu:pde1:analysis:details',
               u'diffu:pde1:analysis:details'),
              (u'Stability', 3, None, '___sec286'),
              (u'Accuracy', 3, None, '___sec287'),
              (u'Analysis of the Forward Euler scheme',
               2,
               u'diffu:pde1:analysis:FE',
               u'diffu:pde1:analysis:FE'),
              (u'Stability', 3, None, '___sec289'),
              (u'Accuracy', 3, None, '___sec290'),
              (u'Analysis of the Backward Euler scheme',
               2,
               u'diffu:pde1:analysis:BE',
               u'diffu:pde1:analysis:BE'),
              (u'Stability', 3, None, '___sec292'),
              (u'Analysis of the Crank-Nicolson scheme',
               2,
               u'diffu:pde1:analysis:CN',
               u'diffu:pde1:analysis:CN'),
              (u'Stability', 3, None, '___sec294'),
              (u'Summary of accuracy of amplification factors',
               2,
               None,
               '___sec295'),
              (u'Analysis of the 2D diffusion equation',
               2,
               u'diffu:2D:analysis',
               u'diffu:2D:analysis'),
              (u'The Forward Euler scheme', 3, None, '___sec297'),
              (u'The Backward Euler scheme', 3, None, '___sec298'),
              (u'The Crank-Nicolson scheme', 3, None, '___sec299'),
              (u'Explanation of numerical artifacts', 2, None, '___sec300'),
              (u'Exercises', 1, None, '___sec301'),
              (u'Exercise 3.1: Explore symmetry in a 1D problem',
               2,
               u'diffu:exer:1D:gaussian:symmetric',
               u'diffu:exer:1D:gaussian:symmetric'),
              (u'Exercise 3.2: Investigate approximation errors from a $u_x=0$ boundary condition',
               2,
               u'diffu:exer:1D:ux:onesided',
               u'diffu:exer:1D:ux:onesided'),
              (u'Exercise 3.3: Experiment with open boundary conditions in 1D',
               2,
               u'diffu:exer:1D:openBC',
               u'diffu:exer:1D:openBC'),
              (u'Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D',
               2,
               None,
               '___sec305'),
              (u'Exercise 3.5: Examine stability of a diffusion model with a source term',
               2,
               u'diffu:exer:uterm',
               u'diffu:exer:uterm'),
              (u'Diffusion in heterogeneous media',
               1,
               u'diffu:varcoeff',
               u'diffu:varcoeff'),
              (u'Discretization',
               2,
               u'diffu:varcoeff:discr',
               u'diffu:varcoeff:discr'),
              (u'Implementation',
               2,
               u'diffu:varcoeff:impl',
               u'diffu:varcoeff:impl'),
              (u'Stationary solution',
               2,
               u'diffu:varcoeff:stationary',
               u'diffu:varcoeff:stationary'),
              (u'Piecewise constant medium',
               2,
               u'diffu:varcoeff:piecewise',
               u'diffu:varcoeff:piecewise'),
              (u'Implementation of diffusion in a piecewise constant medium',
               2,
               u'diffu:varcoeff:impl:piecewise',
               u'diffu:varcoeff:impl:piecewise'),
              (u'Diffusion equation in axi-symmetric geometries',
               2,
               u'diffu:fd2:radial',
               u'diffu:fd2:radial'),
              (u'Diffusion equation in spherically-symmetric geometries',
               2,
               u'diffu:fd2:spherical',
               u'diffu:fd2:spherical'),
              (u'Discretization in spherical coordinates',
               3,
               None,
               '___sec315'),
              (u'Discretization in Cartesian coordinates',
               3,
               None,
               '___sec316'),
              (u'Diffusion in 2D', 1, u'diffu:2D', u'diffu:2D'),
              (u'Discretization', 2, u'diffu:2D:discr', u'diffu:2D:discr'),
              (u'Numbering of mesh points versus equations and unknowns',
               2,
               u'diffu:2D:numbering',
               u'diffu:2D:numbering'),
              (u'Algorithm for setting up the coefficient matrix',
               2,
               u'diffu:2D:alg',
               u'diffu:2D:alg'),
              (u'Implementation with a dense coefficient matrix',
               2,
               u'diffu:2D:impl:dense',
               u'diffu:2D:impl:dense'),
              (u'Verification: exact numerical solution',
               2,
               u'diffu:2D:verify',
               u'diffu:2D:verify'),
              (u'Verification: convergence rates',
               2,
               u'diffu:2D:convrate',
               u'diffu:2D:convrate'),
              (u'Implementation with a sparse coefficient matrix',
               2,
               u'diffu:2D:impl:sparse',
               u'diffu:2D:impl:sparse'),
              (u'Understanding the diagonals', 3, None, '___sec325'),
              (u'Filling the diagonals', 3, None, '___sec326'),
              (u'Filling the right-hand side; scalar version',
               3,
               None,
               '___sec327'),
              (u'Filling the right-hand side; vectorized version',
               3,
               None,
               '___sec328'),
              (u'Verification', 3, None, '___sec329'),
              (u'The Jacobi iterative method', 2, None, '___sec330'),
              (u'Numerical scheme and linear system', 3, None, '___sec331'),
              (u'Iterations', 3, None, '___sec332'),
              (u'Initial guess', 3, None, '___sec333'),
              (u'Relaxation', 3, None, '___sec334'),
              (u'Stopping criteria', 3, None, '___sec335'),
              (u'Code-friendly notation', 3, None, '___sec336'),
              (u'Generalization of the scheme', 3, None, '___sec337'),
              (u'Implementation of the Jacobi method',
               2,
               u'diffu:2D:Jacobi:impl',
               u'diffu:2D:Jacobi:impl'),
              (u'Test problem: diffusion of a sine hill',
               2,
               u'diffu:2D:Jacobi:impl:hill',
               u'diffu:2D:Jacobi:impl:hill'),
              (u'The relaxed Jacobi method and its relation to the Forward Euler method',
               2,
               u'diffu:2D:Jacobi_vs_FE',
               u'diffu:2D:Jacobi_vs_FE'),
              (u'The Gauss-Seidel and SOR methods',
               2,
               u'diffu:2D:SOR',
               u'diffu:2D:SOR'),
              (u'Scalar implementation of the SOR method',
               2,
               u'diffu:2D:SOR:impl:scalar',
               u'diffu:2D:SOR:impl:scalar'),
              (u'Vectorized implementation of the SOR method',
               2,
               u'diffu:2D:SOR:impl:vectorized',
               u'diffu:2D:SOR:impl:vectorized'),
              (u'Direct versus iterative methods',
               2,
               u'diffu:2D:direct_vs_iter',
               u'diffu:2D:direct_vs_iter'),
              (u'Direct methods', 3, None, '___sec345'),
              (u'Iterative methods', 3, None, '___sec346'),
              (u'The Conjugate gradient method',
               2,
               u'diffu:2D:CG',
               u'diffu:2D:CG'),
              (u'Random walk', 1, u'diffu:randomwalk', u'diffu:randomwalk'),
              (u'Random walk in 1D',
               2,
               u'diffu:randomwalk:1D',
               u'diffu:randomwalk:1D'),
              (u'Statistical considerations',
               2,
               u'diffu:randomwalk:1D:EVar',
               u'diffu:randomwalk:1D:EVar'),
              (u'Playing around with some code',
               2,
               u'diffu:randomwalk:1D:code1',
               u'diffu:randomwalk:1D:code1'),
              (u'Scalar code', 3, None, '___sec352'),
              (u'Vectorized code', 3, None, '___sec353'),
              (u'Fixing the random sequence', 3, None, '___sec354'),
              (u'Verification', 3, None, '___sec355'),
              (u'Equivalence with diffusion',
               2,
               u'diffu:randomwalk:1D:pde',
               u'diffu:randomwalk:1D:pde'),
              (u'Implementation of multiple walks', 2, None, '___sec357'),
              (u'Scalar version', 3, None, '___sec358'),
              (u'Vectorized version', 3, None, '___sec359'),
              (u'Improved vectorized version', 3, None, '___sec360'),
              (u'Remark on vectorized code and parallelization',
               3,
               None,
               '___sec361'),
              (u'Test function', 3, None, '___sec362'),
              (u'Demonstration of multiple walks', 2, None, '___sec363'),
              (u'Ascii visualization of 1D random walk',
               2,
               u'diffu:randomwalk:1D:avplotter',
               u'diffu:randomwalk:1D:avplotter'),
              (u'Random walk as a stochastic equation',
               2,
               u'diffu:randomwalk:1D:ode',
               u'diffu:randomwalk:1D:ode'),
              (u'Random walk in 2D', 2, None, '___sec366'),
              (u'Random walk in any number of space dimensions',
               2,
               None,
               '___sec367'),
              (u'Multiple random walks in any number of space dimensions',
               2,
               None,
               '___sec368'),
              (u'Scalar code', 3, None, '___sec369'),
              (u'Vectorized code', 3, None, '___sec370'),
              (u'Applications', 1, u'diffu:app', u'diffu:app'),
              (u'Diffusion of a substance',
               2,
               u'diffu:app:substance',
               u'diffu:app:substance'),
              (u'Heat conduction', 2, u'diffu:app:heat', u'diffu:app:heat'),
              (u'Development of flow between two flat plates',
               2,
               u'diffu:app:Couette',
               u'diffu:app:Couette'),
              (u'Flow in a straight tube',
               2,
               u'diffu:app:pipeflow',
               u'diffu:app:pipeflow'),
              (u'Tribology: thin film fluid flow', 2, None, '___sec376'),
              (u'Propagation of electrical signals in the brain',
               2,
               None,
               '___sec377'),
              (u'Exercises', 1, None, '___sec378'),
              (u'Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping',
               2,
               u'diffu:exer:CN:Rannacher',
               u'diffu:exer:CN:Rannacher'),
              (u'Project 3.7: Energy estimates for diffusion problems',
               2,
               u'diffu:exer:energy:estimates',
               u'diffu:exer:energy:estimates'),
              (u'Exercise 3.8: Splitting methods and preconditioning',
               2,
               u'diffu:exer:splitting_prec',
               u'diffu:exer:splitting_prec'),
              (u'Exercise 3.9: Oscillating surface temperature of the earth',
               2,
               u'diffu:exer:earthosc',
               u'diffu:exer:earthosc'),
              (u'Exercise 3.10: Oscillating and pulsating flow in tubes',
               2,
               u'diffu:exer:bloodflow',
               u'diffu:exer:bloodflow'),
              (u'Advection-dominated equations',
               0,
               u'ch:convdiff',
               u'ch:convdiff'),
              (u'One-dimensional time-dependent advection equations',
               1,
               u'advec:1D',
               u'advec:1D'),
              (u'Simplest scheme: forward in time, centered in space',
               2,
               None,
               '___sec386'),
              (u'Method', 3, None, '___sec387'),
              (u'Implementation', 3, None, '___sec388'),
              (u'Test cases', 3, None, '___sec389'),
              (u'Bug?', 3, None, '___sec390'),
              (u'Analysis of the scheme', 2, None, '___sec391'),
              (u'Leapfrog in time, centered differences in space',
               2,
               None,
               '___sec392'),
              (u'Method', 3, None, '___sec393'),
              (u'Implementation', 3, None, '___sec394'),
              (u'Running the test case', 3, None, '___sec395'),
              (u'Analysis', 3, None, '___sec396'),
              (u'Upwind differences in space', 2, None, '___sec397'),
              (u'A Crank-Nicolson discretization in time and centered differences in space',
               2,
               None,
               '___sec398'),
              (u'The Lax-Wendroff method', 2, None, '___sec399'),
              (u'Analysis of dispersion relations',
               2,
               u'advec:1D:disprel',
               u'advec:1D:disprel'),
              (u'One-dimensional stationary advection-diffusion equation',
               1,
               None,
               '___sec401'),
              (u'Two-dimensional advection-diffusion equations',
               1,
               None,
               '___sec402'),
              (u'Applications of advection equations', 1, None, '___sec403'),
              (u'Staggered mesh discretization',
               0,
               u'ch:staggered',
               u'ch:staggered'),
              (u'Ordinary differential equations', 1, None, '___sec405'),
              (u'The Euler-Cromer scheme on a standard mesh',
               2,
               None,
               '___sec406'),
              (u'The Euler-Cromer scheme on a staggered mesh',
               2,
               u'vib:model2x2:staggered',
               u'vib:model2x2:staggered'),
              (u'Implementation of the scheme on a staggered mesh',
               2,
               None,
               '___sec408'),
              (u'Implementation with integer indices', 3, None, '___sec409'),
              (u'Implementation with half-integer indices',
               3,
               None,
               '___sec410'),
              (u'A staggered Euler-Cromer scheme for a generalized model',
               2,
               u'vib:ode2:staggered',
               u'vib:ode2:staggered'),
              (u'Exercises', 1, None, '___sec412'),
              (u'Exercise 5.1: Use the forward-backward scheme with quadratic damping',
               2,
               u'vib:exer:quad:damping:fwbw',
               u'vib:exer:quad:damping:fwbw'),
              (u'Partial differential equations', 1, None, '___sec414'),
              (u'Nonlinear problems', 0, u'ch:nonlin', u'ch:nonlin'),
              (u'Introduction of basic concepts',
               1,
               u'nonlin:timediscrete:logistic',
               u'nonlin:timediscrete:logistic'),
              (u'Linear versus nonlinear equations', 2, None, '___sec417'),
              (u'Algebraic equations', 3, None, '___sec418'),
              (u'Differential equations', 3, None, '___sec419'),
              (u'A simple model problem', 2, None, '___sec420'),
              (u'Linearization by explicit time discretization',
               2,
               u'nonlin:timediscrete:logistic:FE',
               u'nonlin:timediscrete:logistic:FE'),
              (u'Exact solution of nonlinear algebraic equations',
               2,
               u'nonlin:timediscrete:logistic:roots',
               u'nonlin:timediscrete:logistic:roots'),
              (u'Linearization', 2, None, '___sec423'),
              (u'Picard iteration',
               2,
               u'nonlin:timediscrete:logistic:Picard',
               u'nonlin:timediscrete:logistic:Picard'),
              (u'Stopping criteria', 3, None, '___sec425'),
              (u'A single Picard iteration', 3, None, '___sec426'),
              (u'Linearization by a geometric mean',
               2,
               u'nonlin:timediscrete:logistic:geometric:mean',
               u'nonlin:timediscrete:logistic:geometric:mean'),
              (u"Newton's method",
               2,
               u'nonlin:timediscrete:logistic:Newton',
               u'nonlin:timediscrete:logistic:Newton'),
              (u'Relaxation',
               2,
               u'nonlin:timediscrete:logistic:relaxation',
               u'nonlin:timediscrete:logistic:relaxation'),
              (u'Implementation and experiments',
               2,
               u'nonlin:timediscrete:logistic:impl',
               u'nonlin:timediscrete:logistic:impl'),
              (u'Generalization to a general nonlinear ODE',
               2,
               u'nonlin:ode:generic',
               u'nonlin:ode:generic'),
              (u'Explicit time discretization', 3, None, '___sec432'),
              (u'Backward Euler discretization', 3, None, '___sec433'),
              (u'Crank-Nicolson discretization', 3, None, '___sec434'),
              (u'Systems of ODEs',
               2,
               u'nonlin:ode:generic:sys:pendulum',
               u'nonlin:ode:generic:sys:pendulum'),
              (u'Example', 3, None, '___sec436'),
              (u'Systems of nonlinear algebraic equations',
               1,
               u'nonlin:systems:alg',
               u'nonlin:systems:alg'),
              (u'Picard iteration',
               2,
               u'nonlin:systems:alg:Picard',
               u'nonlin:systems:alg:Picard'),
              (u"Newton's method",
               2,
               u'nonlin:systems:alg:Newton',
               u'nonlin:systems:alg:Newton'),
              (u'Stopping criteria',
               2,
               u'nonlin:systems:alg:terminate',
               u'nonlin:systems:alg:terminate'),
              (u'Example: A nonlinear ODE model from epidemiology',
               2,
               u'nonlin:systems:alg:SI',
               u'nonlin:systems:alg:SI'),
              (u'Implicit time discretization', 3, None, '___sec442'),
              (u'A Picard iteration', 3, None, '___sec443'),
              (u"Newton's method", 3, None, '___sec444'),
              (u'Linearization at the differential equation level',
               1,
               u'nonlin:pdelevel',
               u'nonlin:pdelevel'),
              (u'Explicit time integration',
               2,
               u'nonlin:pdelevel:explicit',
               u'nonlin:pdelevel:explicit'),
              (u'Backward Euler scheme and Picard iteration',
               2,
               u'nonlin:pdelevel:Picard',
               u'nonlin:pdelevel:Picard'),
              (u"Backward Euler scheme and Newton's method",
               2,
               u'nonlin:pdelevel:Newton',
               u'nonlin:pdelevel:Newton'),
              (u'Linearization via Taylor expansions', 3, None, '___sec449'),
              (u'Similarity with Picard iteration', 3, None, '___sec450'),
              (u'Implementation', 3, None, '___sec451'),
              (u'Derivation with alternative notation', 3, None, '___sec452'),
              (u'Crank-Nicolson discretization',
               2,
               u'nonlin:pdelevel:Picard:CN',
               u'nonlin:pdelevel:Picard:CN'),
              (u'Discretization of 1D stationary nonlinear differential equations',
               1,
               u'nonlin:alglevel:1D',
               u'nonlin:alglevel:1D'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:1D:fd',
               u'nonlin:alglevel:1D:fd'),
              (u'Solution of algebraic equations', 2, None, '___sec456'),
              (u'The structure of the equation system', 3, None, '___sec457'),
              (u'Picard iteration', 3, None, '___sec458'),
              (u'Mesh with two cells', 3, None, '___sec459'),
              (u"Newton's method", 3, None, '___sec460'),
              (u'Multi-dimensional PDE problems', 1, None, '___sec461'),
              (u'Finite difference discretization',
               2,
               u'nonlin:alglevel:dD:fd',
               u'nonlin:alglevel:dD:fd'),
              (u'Picard iteration', 3, None, '___sec463'),
              (u"Newton's method", 3, None, '___sec464'),
              (u'Continuation methods', 2, None, '___sec465'),
              (u'Exercises', 1, u'nonlin:exer', u'nonlin:exer'),
              (u'Problem 6.1: Determine if equations are nonlinear or not',
               2,
               u'nonlin:exer:lin:vs:nonlin',
               u'nonlin:exer:lin:vs:nonlin'),
              (u'Exercise 6.2: Derive and investigate a generalized logistic model',
               2,
               u'nonlin:exer:logistic:gen',
               u'nonlin:exer:logistic:gen'),
              (u"Problem 6.3: Experience the behavior of Newton's method",
               2,
               u'nonlin:exer:Newton:problems1',
               u'nonlin:exer:Newton:problems1'),
              (u'Problem 6.4: Compute the Jacobian of a $2\\times 2$ system',
               2,
               u'nonlin:exer:vib:Jacobian',
               u'nonlin:exer:vib:Jacobian'),
              (u'Problem 6.5: Solve nonlinear equations arising from a vibration ODE',
               2,
               u'nonlin:exer:vib:geometric:mean',
               u'nonlin:exer:vib:geometric:mean'),
              (u'Exercise 6.6: Find the truncation error of arithmetic mean of products',
               2,
               u'nonlin:exer:products:arith:mean',
               u'nonlin:exer:products:arith:mean'),
              (u"Problem 6.7: Newton's method for linear problems",
               2,
               u'nonlin:exer:Newton:linear',
               u'nonlin:exer:Newton:linear'),
              (u'Exercise 6.8: Discretize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:fem',
               u'nonlin:exer:1D:1pu2:fem'),
              (u'Exercise 6.9: Linearize a 1D problem with a nonlinear coefficient',
               2,
               u'nonlin:exer:1D:1pu2:PicardNewton',
               u'nonlin:exer:1D:1pu2:PicardNewton'),
              (u'Problem 6.10: Finite differences for the 1D Bratu problem',
               2,
               u'nonlin:exer:1D:fu:discretize:fd',
               u'nonlin:exer:1D:fu:discretize:fd'),
              (u'Exercise 6.11: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               u'nonlin:exer:1D:heat:nonlinear:fdm',
               u'nonlin:exer:1D:heat:nonlinear:fdm'),
              (u'Exercise 6.12: Differentiate a highly nonlinear term',
               2,
               u'nonlin:exer:grad:pow:term',
               u'nonlin:exer:grad:pow:term'),
              (u'Exercise 6.13: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               u'nonlin:exer:2D:heat:nonlinear:fd',
               u'nonlin:exer:2D:heat:nonlinear:fd'),
              (u'Exercise 6.14: Find the sparsity of the Jacobian',
               2,
               u'nonlin:exer:sparsity:Jacobian',
               u'nonlin:exer:sparsity:Jacobian'),
              (u'Problem 6.15: Investigate a 1D problem with a continuation method',
               2,
               u'nonlin:exer:continuation:1DnNflow',
               u'nonlin:exer:continuation:1DnNflow'),
              (u'Appendix: Useful formulas',
               0,
               u'ch:formulas',
               u'ch:formulas'),
              (u'Finite difference operator notation',
               1,
               u'sec:form:fdop',
               u'sec:form:fdop'),
              (u'Truncation errors of finite difference approximations',
               1,
               u'sec:form:truncerr',
               u'sec:form:truncerr'),
              (u'Finite differences of exponential functions',
               1,
               u'sec:form:fdexp',
               u'sec:form:fdexp'),
              (u'Complex exponentials', 3, None, '___sec486'),
              (u'Real exponentials', 3, None, '___sec487'),
              (u'Finite differences of $t^n$',
               1,
               u'sec:form:fdtn',
               u'sec:form:fdtn'),
              (u'Software', 2, None, '___sec489'),
              (u'Appendix: Truncation error analysis',
               0,
               u'ch:trunc',
               u'ch:trunc'),
              (u'Overview of truncation error analysis',
               1,
               None,
               '___sec491'),
              (u'Abstract problem setting', 2, None, '___sec492'),
              (u'Error measures', 2, None, '___sec493'),
              (u'Truncation errors in finite difference formulas',
               1,
               u'trunc:finite:differences',
               u'trunc:finite:differences'),
              (u"Example: The backward difference for $u'(t)$",
               2,
               u'trunc:fd:backward',
               u'trunc:fd:backward'),
              (u"Example: The forward difference for $u'(t)$",
               2,
               u'trunc:fd:forward',
               u'trunc:fd:forward'),
              (u"Example: The central difference for $u'(t)$",
               2,
               u'trunc:fd:central',
               u'trunc:fd:central'),
              (u'Overview of leading-order error terms in finite difference formulas',
               2,
               u'trunc:table',
               u'trunc:table'),
              (u'Software for computing truncation errors',
               2,
               u'trunc:sympy',
               u'trunc:sympy'),
              (u'Truncation errors in exponential decay ODE',
               1,
               u'trunc:decay',
               u'trunc:decay'),
              (u'Truncation error of the Forward Euler scheme',
               2,
               u'trunc:decay:FE',
               u'trunc:decay:FE'),
              (u'Truncation error of the Crank-Nicolson scheme',
               2,
               u'trunc:decay:CN',
               u'trunc:decay:CN'),
              (u'Truncation error of the $\\theta$-rule',
               2,
               u'trunc:decay:theta',
               u'trunc:decay:theta'),
              (u'Using symbolic software',
               2,
               u'trunc:decay:software',
               u'trunc:decay:software'),
              (u'Empirical verification of the truncation error',
               2,
               u'trunc:decay:estimate:R',
               u'trunc:decay:estimate:R'),
              (u'Increasing the accuracy by adding correction terms',
               2,
               u'trunc:decay:corr',
               u'trunc:decay:corr'),
              (u'Extension to variable coefficients', 2, None, '___sec507'),
              (u'Exact solutions of the finite difference equations',
               2,
               None,
               '___sec508'),
              (u'Computing truncation errors in nonlinear problems',
               2,
               u'trunc:decay:gen',
               u'trunc:decay:gen'),
              (u'Truncation errors in vibration ODEs',
               1,
               u'trunc:vib',
               u'trunc:vib'),
              (u'Linear model without damping',
               2,
               u'trunc:vib:undamped',
               u'trunc:vib:undamped'),
              (u'The truncation error of a centered finite difference scheme',
               3,
               None,
               '___sec512'),
              (u"The truncation error of approximating $u'(0)$",
               3,
               None,
               '___sec513'),
              (u'Truncation error of the equation for the first step',
               3,
               None,
               '___sec514'),
              (u'Computing correction terms', 3, None, '___sec515'),
              (u'Model with damping and nonlinearity',
               2,
               u'trunc:vib:gen',
               u'trunc:vib:gen'),
              (u'Extension to quadratic damping', 2, None, '___sec517'),
              (u'The general model formulated as first-order ODEs',
               2,
               u'trunc:vib:gen:staggered',
               u'trunc:vib:gen:staggered'),
              (u'The forward-backward scheme', 3, None, '___sec519'),
              (u'A centered scheme on a staggered mesh',
               3,
               None,
               '___sec520'),
              (u'Truncation errors in wave equations', 1, None, '___sec521'),
              (u'Linear wave equation in 1D',
               2,
               u'trunc:wave:1D',
               u'trunc:wave:1D'),
              (u'Finding correction terms',
               2,
               u'trunc:wave:1D:corr',
               u'trunc:wave:1D:corr'),
              (u'Extension to variable coefficients',
               2,
               u'trunc:wave:1D:varcoeff',
               u'trunc:wave:1D:varcoeff'),
              (u'1D wave equation on a staggered mesh', 2, None, '___sec525'),
              (u'Linear wave equation in 2D/3D',
               2,
               u'trunc:wave:2D',
               u'trunc:wave:2D'),
              (u'Truncation errors in diffusion equations',
               1,
               u'trunc:diffu',
               u'trunc:diffu'),
              (u'Linear diffusion equation in 1D',
               2,
               u'trunc:diffu:1D',
               u'trunc:diffu:1D'),
              (u'The Forward Euler scheme in time', 3, None, '___sec529'),
              (u'The Crank-Nicolson scheme in time', 3, None, '___sec530'),
              (u'Linear diffusion equation in 2D/3D', 2, None, '___sec531'),
              (u'A nonlinear diffusion equation in 2D', 2, None, '___sec532'),
              (u'Exercises', 1, None, '___sec533'),
              (u'Exercise B.1: Truncation error of a weighted mean',
               2,
               u'trunc:exer:theta:avg',
               u'trunc:exer:theta:avg'),
              (u'Exercise B.2: Simulate the error of a weighted mean',
               2,
               u'trunc:exer:theta:avg2',
               u'trunc:exer:theta:avg2'),
              (u'Exercise B.3: Verify a truncation error formula',
               2,
               u'trunc:exer:decay:bw2',
               u'trunc:exer:decay:bw2'),
              (u'Exercise B.4: Truncation error of the Backward Euler scheme',
               2,
               u'trunc:exer:decay:BE',
               u'trunc:exer:decay:BE'),
              (u'Exercise B.5: Empirical estimation of truncation errors',
               2,
               u'trunc:exer:decay:estimate',
               u'trunc:exer:decay:estimate'),
              (u'Exercise B.6: Correction term for a Backward Euler scheme',
               2,
               u'trunc:exer:decay:corr:BE',
               u'trunc:exer:decay:corr:BE'),
              (u'Exercise B.7: Verify the effect of correction terms',
               2,
               u'trunc:exer:decay:corr:verify',
               u'trunc:exer:decay:corr:verify'),
              (u'Exercise B.8: Truncation error of the Crank-Nicolson scheme',
               2,
               u'trunc:exer:decay:varcoeff:CN',
               u'trunc:exer:decay:varcoeff:CN'),
              (u"Exercise B.9: Truncation error of $u'=f(u,t)$",
               2,
               u'trunc:exer:decay:nonlin:BEFE',
               u'trunc:exer:decay:nonlin:BEFE'),
              (u'Exercise B.10: Truncation error of $[D_t D_tu]^n$',
               2,
               u'trunc:exer:DtDtu',
               u'trunc:exer:DtDtu'),
              (u"Exercise B.11: Investigate the impact of approximating $u'(0)$",
               2,
               u'trunc:exer:vib:ic:fw',
               u'trunc:exer:vib:ic:fw'),
              (u'Exercise B.12: Investigate the accuracy of a simplified scheme',
               2,
               u'trunc:exer:vib:fbw',
               u'trunc:exer:vib:fbw'),
              (u'Appendix: Software engineering; wave equation model',
               0,
               u'ch:softeng2',
               u'ch:softeng2'),
              (u'A 1D wave equation simulator', 1, None, '___sec547'),
              (u'Mathematical model', 2, None, '___sec548'),
              (u'Numerical discretization', 2, None, '___sec549'),
              (u'A solver function', 2, None, '___sec550'),
              (u'Saving large arrays in files',
               1,
               u'softeng2:wave1D:filestorage',
               u'softeng2:wave1D:filestorage'),
              (u'Using `savez` to store arrays in files',
               2,
               u'softeng2:wave1D:filestorage:savez',
               u'softeng2:wave1D:filestorage:savez'),
              (u'Storing individual arrays', 3, None, '___sec553'),
              (u'Merging zip archives', 3, None, '___sec554'),
              (u'Reading arrays from zip archives', 3, None, '___sec555'),
              (u'Using `joblib` to store arrays in files',
               2,
               u'softeng2:wave1D:filestorage:joblib',
               u'softeng2:wave1D:filestorage:joblib'),
              (u'Using a hash to create a file or directory name',
               2,
               u'softeng2:wave1D:filestorage:hash',
               u'softeng2:wave1D:filestorage:hash'),
              (u'Software for the 1D wave equation', 1, None, '___sec558'),
              (u'Making hash strings from input data',
               2,
               u'softeng2:wave1D:filestorage:hashlib',
               u'softeng2:wave1D:filestorage:hashlib'),
              (u'Avoiding rerunning previously run cases',
               2,
               u'softeng2:wave1D:filestorage:norerun',
               u'softeng2:wave1D:filestorage:norerun'),
              (u'Verification', 2, None, '___sec561'),
              (u'Programming the solver with classes', 1, None, '___sec562'),
              (u'Class Problem', 2, None, '___sec563'),
              (u'Class Mesh', 2, None, '___sec564'),
              (u'Class Function', 2, None, '___sec565'),
              (u'Class Solver', 2, None, '___sec566'),
              (u'Migrating loops to Cython',
               1,
               u'wave2D3D:impl:Cython',
               u'wave2D3D:impl:Cython'),
              (u'Declaring variables and annotating the code',
               2,
               None,
               '___sec568'),
              (u'Visual inspection of the C translation',
               2,
               None,
               '___sec569'),
              (u'Building the extension module', 2, None, '___sec570'),
              (u'Calling the Cython function from Python',
               2,
               None,
               '___sec571'),
              (u'Efficiency', 3, None, '___sec572'),
              (u'Migrating loops to Fortran', 1, None, '___sec573'),
              (u'The Fortran subroutine', 2, None, '___sec574'),
              (u'Building the Fortran module with f2py',
               2,
               None,
               '___sec575'),
              (u'How to avoid array copying', 2, None, '___sec576'),
              (u'Efficiency', 3, None, '___sec577'),
              (u'Migrating loops to C via Cython', 1, None, '___sec578'),
              (u'Translating index pairs to single indices',
               2,
               None,
               '___sec579'),
              (u'The complete C code', 2, None, '___sec580'),
              (u'The Cython interface file', 2, None, '___sec581'),
              (u'Building the extension module', 2, None, '___sec582'),
              (u'Efficiency', 3, None, '___sec583'),
              (u'Migrating loops to C via f2py', 1, None, '___sec584'),
              (u'Migrating loops to C++ via f2py', 2, None, '___sec585'),
              (u'Exercises', 1, None, '___sec586'),
              (u'Exercise C.1: Make an improved `numpy.savez` function',
               2,
               u'softeng2:exer:savez',
               u'softeng2:exer:savez'),
              (u'References', 1, None, '___sec588')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\acc}{\boldsymbol{a}}
\newcommand{\rpos}{\boldsymbol{r}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}
\newcommand{\q}{\boldsymbol{q}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\ir}{\boldsymbol{i}_r}
\newcommand{\ith}{\boldsymbol{i}_{\theta}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\baspsi}{\psi}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href=".trash82dee82e1274a586571086dca04d00308d3a0d86.html">Finite Difference Computing with Partial Differential Equations</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#ch:preface" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplify, understand, generalize</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructive mathematics</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All nuts and bolts</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python as programming language</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Program verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized code</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis via exact solutions of discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code-inspired mathematical notation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Limited scope</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Independent chapters</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplementary materials</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86001.html#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#ch:vib" style="font-size: 80%;"><b>Vibration ODEs</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A basic model for vibrations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A centered finite difference scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 1: Discretizing the domain</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 2: Fulfilling the equation at discrete time points</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 3: Replacing derivatives by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4: Formulating a recursive algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the first step</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The computational algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operator notation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:impl1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:impl1:solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making a solver function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing \( u^{\prime} \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manual calculation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing very simple polynomial solutions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checking convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaled model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:longseries" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Long time simulations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a moving plot window</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:anim" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making animations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Producing standard video formats</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Paying PNG files in a web browser</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec37" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making animated GIF files</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec38" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using Bokeh to compare graphs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec39" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a line-by-line ascii plotter</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:empirical" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empirical analysis of the solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the numerical scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving a solution of the numerical scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:analysis:sol" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:ode1:analysis:conv" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convergence</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec45" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The global error</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec46" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec47" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;About the accuracy at the stability limit</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model2x2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Alternative schemes based on 1st-order equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec50" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:undamped:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model2x2:compare" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparison of schemes</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec53" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runge-Kutta methods</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model1:energy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Energy considerations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model1:energy:expr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation of the energy expression</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec57" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Energy of the exact solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model1:energy:measure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An error measure based on energy</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model2x2:EulerCromer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The Euler-Cromer method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec60" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward-backward discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model2x2:EulerCromer:equiv" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalence with the scheme for the second-order ODE</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#vib:model2x2:EulerCromer:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86003.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The velocity Verlet algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:model2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generalization: damping, nonlinear spring, and external excitation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:fdm:flin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A centered scheme for linear damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:fdm:fquad" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A centered scheme for quadratic damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec67" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A forward-backward discretization of the quadratic damping term</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec71" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quadratic solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:viz" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:ode2:ui" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User interface</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Euler-Cromer scheme for the generalized model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#___sec76" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises and Problems</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:undamped:verify:linquad" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 1.1: Use linear/quadratic functions for verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:phase:err:growth" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.2: Show linear growth of the phase with time</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:w:adjust" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.3: Improve the accuracy by adjusting the frequency</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:undamped:adaptive" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.4: See if adaptive methods improve the phase error</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:step4b:alt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.5: Use a Taylor polynomial to compute \( u^1 \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:wdt:limit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.6: Find the minimal resolution of an oscillatory function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:fd:exp:plot" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.7: Visualize the accuracy of finite differences for a cosine function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:energy:convrate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.8: Verify convergence rates of the error in energy</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:verify:gen:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.9: Use linear/quadratic functions for verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:discrete:omega" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.10: Use an exact discrete solution for verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:conv:rate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.11: Use analytical solution for convergence rate tests</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:undamped:odespy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.12: Investigate the amplitude errors of many solvers</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:memsave" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.13: Minimize memory usage of a vibration solver</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:gen:class" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.14: Implement the solver via classes</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:DtDt:asDtpDtm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.15: Interpret \( [D_tD_t u]^n \) as a forward-backward difference</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:quad:damping:bw" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.16: Use a backward difference for the damping term</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86004.html#vib:exer:EulerCromer:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.17: Analysis of the Euler-Cromer scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Applications of vibration models</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:mass_spring" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oscillating mass attached to a spring</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec96" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec97" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The physics</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:mass_gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General mechanical vibrating system</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:mass_sliding" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A sliding mass attached to a spring</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:washmach" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A jumping washing machine</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motion of a pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simple pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physical pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:pendulum_bodydia" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dynamic free body diagram during pendulum motion</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec106" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writing the solver</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Drawing the free body diagram</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making the animated free body diagram</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:pendulum_elastic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motion of an elastic pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks about an elastic vs a non-elastic pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete ODE problem</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scaling</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark on the non-elastic limit</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:bumpy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vehicle on a bumpy road</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:app:bouncing_ball" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bouncing ball</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Electric circuits</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:resonance" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.18: Simulate resonance</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:sliding_box" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.19: Simulate oscillations of a sliding box</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:bouncing:ball" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.20: Simulate a bouncing ball</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:pendulum_simple" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.21: Simulate a simple pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:pendulum_elastic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.22: Simulate an elastic pendulum</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#vib:exer:pendulum_elastic_drag" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1.23: Simulate an elastic pendulum with air resistance</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86005.html#___sec125" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#ch:wave" style="font-size: 80%;"><b>Wave equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Simulation of waves on a string</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:mesh" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretizing the domain</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uniform meshes</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:numerical:sol" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:samplingPDE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fulfilling the equation at the mesh points</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replacing derivatives by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec133" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic version of the PDE</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec134" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interpretation of the equation as a stencil</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec135" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic version of the initial conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formulating a recursive algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:string:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sketch of an implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec138" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde2:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A slightly generalized model problem</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde2:fd:standing:waves" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using an analytical solution of physical significance</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde2:fd:MMS" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manufactured solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde2:fd:verify:quadratic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing an exact solution of the discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec144" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Callback function for user-specific actions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:solver" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solver function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:verify:quadratic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification: exact quadratic solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:animate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visualization: animating the solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec148" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function for administering the simulation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec149" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the code</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec150" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making movie files</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skipping frames for animation speed</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:guitar:data" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running a case</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec153" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Working with a scaled PDE model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:vec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Vectorization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:vec:slices:basics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operations on slices of arrays</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:vec:slices:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference schemes expressed as slices</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:vec:verify:quadratic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Efficiency measurements</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec159" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution 1</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec160" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution 2</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec161" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Efficiency experiments</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde1:impl:ref:switch" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark on the updating of arrays</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec163" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:exer:standingwave" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.1: Simulate a standing wave</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#___sec165" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:exer:store:list" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.2: Add storage of solution in a user action function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:exer:store:list:class" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.3: Use a class for the user action function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:exer:multiple:C" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.4: Compare several Courant numbers in one movie</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:exer:mesh1D:calculus" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project 2.5: Calculus with 1D mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:Neumann" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generalization: reflecting boundaries</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:Neumann:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Neumann boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:Neumann:discr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization of derivatives at the boundary</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:Neumann:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:indexset" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index set notation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde1:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifying the implementation of Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde1:Neumann:ghost" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative implementation via ghost cells</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec177" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Idea</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec178" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generalization: variable wave velocity</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec180" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The model PDE with a variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c:ideas" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretizing the variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c:means" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the coefficient between mesh points</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c:stability" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How a variable coefficient affects the stability</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c:Neumann" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Neumann condition and a variable coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:var:c:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of variable coefficients</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec186" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A more general PDE model with variable coefficients</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec187" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization: damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:pde2:software" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Building a general 1D wave equation solver</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec189" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User action function as a class</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec190" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The code</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec191" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pulse propagation in two media</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec193" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:exer:standingwave:damped:uex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.6: Find the analytical solution to a damped wave equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:exer:symmetry:bc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.7: Explore symmetry boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:app:exer:pulse1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.8: Send pulse waves through a layered medium</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:app:exer:pulse1D:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.9: Explain why numerical noise occurs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:app:exer:pulse1D:harmonic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.10: Investigate harmonic averaging in a 1D model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:app:exer:radiationBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.11: Implement open boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec200" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:exer:periodic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.12: Implement periodic boundary conditions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#___sec202" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.13: Compare discretizations of a Neumann condition</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86007.html#wave:fd2:exer:verify:cubic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.14: Verification by a cubic polynomial in space</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of the difference equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:properties" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of the solution of the wave equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:Fourier" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More precise definition of Fourier representations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:stability" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#___sec208" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Preliminary results</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#___sec209" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical wave propagation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:num:dispersion" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical dispersion relation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86008.html#wave:pde1:analysis:2D3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extending the analysis to 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:2D3D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference methods for 2D and 3D wave equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:2D3D:models" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multi-dimensional wave equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:2D3D:mesh" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:2D3D:discretization" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec216" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretizing the PDEs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec217" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handling boundary conditions where \( u \) is known</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec218" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretizing the Neumann condition</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:2D3D:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave2D3D:impl:scalar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar computations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec221" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Domain and mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec222" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution arrays</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec223" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index sets</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec224" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing the solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave2D3D:impl:vectorized" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized computations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave2D3D:impl:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec227" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Testing a quadratic solution</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#___sec228" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:exer:quadratic:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.15: Check that a solution fulfills the discrete model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:exer:mesh3D:calculus" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project 2.16: Calculus with 2D mesh functions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:app:exer:wave2D:Neumann" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.17: Implement Neumann conditions in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86009.html#wave:exer:3D:f77:cy:efficiency" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.18: Test the efficiency of compiled loops in 3D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Applications of wave equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:string" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waves on a string</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec235" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec236" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;External forcing</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec237" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modeling the tension via springs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:membrane" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waves on a membrane</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:elastic:rod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elastic waves in a rod</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:acoustic:seismic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The acoustic model for seismic waves</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec241" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Anisotropy</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:sound" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sound waves in liquids and gases</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:spherical" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spherical waves</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:sw:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The linear shallow water equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec245" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wind drag on the surface</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec246" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bottom drag</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#___sec247" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Effect of the Earth's rotation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:blood" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waves in blood vessels</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86010.html#wave:app:light" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Electromagnetic waves</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:string:discont" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.19: Simulate waves on a non-homogeneous string</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:string:damping" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.20: Simulate damped waves on a string</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:rod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.21: Simulate elastic waves in a rod</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:spherical" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.22: Simulate spherical waves</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:tsunami1D:hill" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.23: Earthquake-generated tsunami over a subsea hill</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:tsunami2D:hill" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.24: Earthquake-generated tsunami over a 3D hill</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:tsunami:hill:viz:matplotlib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.25: Investigate Matplotlib for visualization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:tsunami:hill:viz:packages" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.26: Investigate visualization packages</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:tsunami2D:hill:compiled" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.27: Implement loops in compiled languages</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:seismic2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2.28: Simulate seismic waves in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:acoustics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project 2.29: Model 3D acoustic waves in a room</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:advec1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project 2.30: Solve a 1D transport equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:anal:damped:wave1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.31: General analytical solution of a 1D damped wave equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html#wave:app:exer:anal:damped:wave2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 2.32: General analytical solution of a 2D damped wave equation</a></li>
     <!-- navigation toc: --> <li><a href="#ch:diffu" style="font-size: 80%;"><b>Diffusion equations</b></a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FEsec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;An explicit method for the 1D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec267" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The initial-boundary value problem for 1D diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:FE:experiments" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical experiments</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:implicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implicit methods for the 1D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sparse matrix implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:theta" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The unifying \( \theta \) rule</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:theta:experiments" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experiments</a></li>
     <!-- navigation toc: --> <li><a href="#___sec278" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Laplace and Poisson equation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Analysis of schemes for the diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:uex" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec281" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity solution</a></li>
     <!-- navigation toc: --> <li><a href="#___sec282" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution for a Gaussian pulse</a></li>
     <!-- navigation toc: --> <li><a href="#___sec283" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution for a sine component</a></li>
     <!-- navigation toc: --> <li><a href="#___sec284" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:details" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the finite difference schemes</a></li>
     <!-- navigation toc: --> <li><a href="#___sec286" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec287" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accuracy</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec289" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec290" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accuracy</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec292" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:pde1:analysis:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec294" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stability</a></li>
     <!-- navigation toc: --> <li><a href="#___sec295" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Summary of accuracy of amplification factors</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:analysis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the 2D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec297" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec298" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec299" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="#___sec300" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explanation of numerical artifacts</a></li>
     <!-- navigation toc: --> <li><a href="#___sec301" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:gaussian:symmetric" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.1: Explore symmetry in a 1D problem</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:ux:onesided" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.2: Investigate approximation errors from a \( u_x=0 \) boundary condition</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:1D:openBC" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.3: Experiment with open boundary conditions in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec305" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:uterm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.5: Examine stability of a diffusion model with a source term</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Diffusion in heterogeneous media</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:discr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:stationary" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stationary solution</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:piecewise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Piecewise constant medium</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:varcoeff:impl:piecewise" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of diffusion in a piecewise constant medium</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:fd2:radial" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion equation in axi-symmetric geometries</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:fd2:spherical" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion equation in spherically-symmetric geometries</a></li>
     <!-- navigation toc: --> <li><a href="#___sec315" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization in spherical coordinates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec316" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization in Cartesian coordinates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Diffusion in 2D</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:discr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discretization</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:numbering" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numbering of mesh points versus equations and unknowns</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algorithm for setting up the coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:impl:dense" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation with a dense coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification: exact numerical solution</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:convrate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification: convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:impl:sparse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation with a sparse coefficient matrix</a></li>
     <!-- navigation toc: --> <li><a href="#___sec325" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Understanding the diagonals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec326" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the diagonals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec327" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the right-hand side; scalar version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec328" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filling the right-hand side; vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec329" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec330" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Jacobi iterative method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec331" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical scheme and linear system</a></li>
     <!-- navigation toc: --> <li><a href="#___sec332" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec333" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial guess</a></li>
     <!-- navigation toc: --> <li><a href="#___sec334" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec335" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="#___sec336" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Code-friendly notation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec337" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization of the scheme</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the Jacobi method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi:impl:hill" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test problem: diffusion of a sine hill</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:Jacobi_vs_FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The relaxed Jacobi method and its relation to the Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Gauss-Seidel and SOR methods</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR:impl:scalar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar implementation of the SOR method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:SOR:impl:vectorized" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized implementation of the SOR method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:direct_vs_iter" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct versus iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec345" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec346" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterative methods</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:2D:CG" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Conjugate gradient method</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Random walk</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random walk in 1D</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:EVar" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Statistical considerations</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:code1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Playing around with some code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec352" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec353" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec354" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixing the random sequence</a></li>
     <!-- navigation toc: --> <li><a href="#___sec355" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:pde" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalence with diffusion</a></li>
     <!-- navigation toc: --> <li><a href="#___sec357" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of multiple walks</a></li>
     <!-- navigation toc: --> <li><a href="#___sec358" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec359" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec360" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Improved vectorized version</a></li>
     <!-- navigation toc: --> <li><a href="#___sec361" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remark on vectorized code and parallelization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec362" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec363" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Demonstration of multiple walks</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:avplotter" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ascii visualization of 1D random walk</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:randomwalk:1D:ode" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random walk as a stochastic equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec366" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random walk in 2D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec367" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random walk in any number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec368" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiple random walks in any number of space dimensions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec369" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar code</a></li>
     <!-- navigation toc: --> <li><a href="#___sec370" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorized code</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Applications</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:substance" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diffusion of a substance</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:heat" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heat conduction</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:Couette" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Development of flow between two flat plates</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:app:pipeflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flow in a straight tube</a></li>
     <!-- navigation toc: --> <li><a href="#___sec376" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tribology: thin film fluid flow</a></li>
     <!-- navigation toc: --> <li><a href="#___sec377" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Propagation of electrical signals in the brain</a></li>
     <!-- navigation toc: --> <li><a href="#___sec378" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:CN:Rannacher" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:energy:estimates" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Project 3.7: Energy estimates for diffusion problems</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:splitting_prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.8: Splitting methods and preconditioning</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:earthosc" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.9: Oscillating surface temperature of the earth</a></li>
     <!-- navigation toc: --> <li><a href="#diffu:exer:bloodflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3.10: Oscillating and pulsating flow in tubes</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#ch:convdiff" style="font-size: 80%;"><b>Advection-dominated equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#advec:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;One-dimensional time-dependent advection equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec386" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplest scheme: forward in time, centered in space</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec387" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec388" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec389" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test cases</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec390" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bug?</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec391" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of the scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec392" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Leapfrog in time, centered differences in space</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec393" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec394" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec395" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running the test case</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec396" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec397" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Upwind differences in space</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec398" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Crank-Nicolson discretization in time and centered differences in space</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec399" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Lax-Wendroff method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#advec:1D:disprel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Analysis of dispersion relations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec401" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;One-dimensional stationary advection-diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec402" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Two-dimensional advection-diffusion equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html#___sec403" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Applications of advection equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#ch:staggered" style="font-size: 80%;"><b>Staggered mesh discretization</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec405" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Ordinary differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec406" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Euler-Cromer scheme on a standard mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#vib:model2x2:staggered" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Euler-Cromer scheme on a staggered mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec408" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the scheme on a staggered mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec409" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation with integer indices</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec410" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation with half-integer indices</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#vib:ode2:staggered" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A staggered Euler-Cromer scheme for a generalized model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec412" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#vib:exer:quad:damping:fwbw" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5.1: Use the forward-backward scheme with quadratic damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86014.html#___sec414" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Partial differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#ch:nonlin" style="font-size: 80%;"><b>Nonlinear problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction of basic concepts</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec417" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear versus nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec418" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec419" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec420" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple model problem</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:roots" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solution of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec423" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec425" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec426" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A single Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization by a geometric mean</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:relaxation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:timediscrete:logistic:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation and experiments</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:ode:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generalization to a general nonlinear ODE</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec432" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec433" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec434" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#nonlin:ode:generic:sys:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Systems of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86015.html#___sec436" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#nonlin:systems:alg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Systems of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#nonlin:systems:alg:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#nonlin:systems:alg:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#nonlin:systems:alg:terminate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#nonlin:systems:alg:SI" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: A nonlinear ODE model from epidemiology</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#___sec442" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#___sec443" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86016.html#___sec444" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#nonlin:pdelevel" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization at the differential equation level</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#nonlin:pdelevel:explicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time integration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#nonlin:pdelevel:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#nonlin:pdelevel:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler scheme and Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#___sec449" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization via Taylor expansions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#___sec450" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity with Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#___sec451" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#___sec452" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation with alternative notation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86017.html#nonlin:pdelevel:Picard:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#nonlin:alglevel:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Discretization of 1D stationary nonlinear differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#nonlin:alglevel:1D:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#___sec456" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution of algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#___sec457" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the equation system</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#___sec458" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#___sec459" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mesh with two cells</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86018.html#___sec460" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86019.html#___sec461" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Multi-dimensional PDE problems</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86019.html#nonlin:alglevel:dD:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86019.html#___sec463" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86019.html#___sec464" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86019.html#___sec465" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continuation methods</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:lin:vs:nonlin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.1: Determine if equations are nonlinear or not</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:logistic:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.2: Derive and investigate a generalized logistic model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:Newton:problems1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.3: Experience the behavior of Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:vib:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.4: Compute the Jacobian of a \( 2\times 2 \) system</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:vib:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.5: Solve nonlinear equations arising from a vibration ODE</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:products:arith:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.6: Find the truncation error of arithmetic mean of products</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:Newton:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.7: Newton's method for linear problems</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:1D:1pu2:fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.8: Discretize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:1D:1pu2:PicardNewton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.9: Linearize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:1D:fu:discretize:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.10: Finite differences for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:1D:heat:nonlinear:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.11: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:grad:pow:term" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.12: Differentiate a highly nonlinear term</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:2D:heat:nonlinear:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.13: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:sparsity:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6.14: Find the sparsity of the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86020.html#nonlin:exer:continuation:1DnNflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problem 6.15: Investigate a 1D problem with a continuation method</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#ch:formulas" style="font-size: 80%;"><b>Appendix: Useful formulas</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#sec:form:fdop" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference operator notation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#sec:form:truncerr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors of finite difference approximations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#sec:form:fdexp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of exponential functions</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#___sec486" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complex exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#___sec487" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Real exponentials</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#sec:form:fdtn" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite differences of \( t^n \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#___sec489" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#ch:trunc" style="font-size: 80%;"><b>Appendix: Truncation error analysis</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#___sec491" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Overview of truncation error analysis</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#___sec492" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract problem setting</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#___sec493" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error measures</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:finite:differences" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors in finite difference formulas</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:fd:backward" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: The backward difference for \( u'(t) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:fd:forward" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: The forward difference for \( u'(t) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:fd:central" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: The central difference for \( u'(t) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:table" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overview of leading-order error terms in finite difference formulas</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86022.html#trunc:sympy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software for computing truncation errors</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors in exponential decay ODE</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error of the Forward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error of the Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:theta" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error of the \( \theta \)-rule</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:software" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using symbolic software</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:estimate:R" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empirical verification of the truncation error</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:corr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increasing the accuracy by adding correction terms</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#___sec507" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to variable coefficients</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#___sec508" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exact solutions of the finite difference equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86023.html#trunc:decay:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing truncation errors in nonlinear problems</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#trunc:vib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors in vibration ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#trunc:vib:undamped" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear model without damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec512" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The truncation error of a centered finite difference scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec513" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The truncation error of approximating \( u'(0) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec514" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Truncation error of the equation for the first step</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec515" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computing correction terms</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#trunc:vib:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Model with damping and nonlinearity</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec517" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to quadratic damping</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#trunc:vib:gen:staggered" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general model formulated as first-order ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec519" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The forward-backward scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86024.html#___sec520" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A centered scheme on a staggered mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#___sec521" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors in wave equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#trunc:wave:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear wave equation in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#trunc:wave:1D:corr" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finding correction terms</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#trunc:wave:1D:varcoeff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extension to variable coefficients</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#___sec525" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1D wave equation on a staggered mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86025.html#trunc:wave:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear wave equation in 2D/3D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:diffu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Truncation errors in diffusion equations</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:diffu:1D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear diffusion equation in 1D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#___sec529" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Forward Euler scheme in time</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#___sec530" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Crank-Nicolson scheme in time</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#___sec531" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear diffusion equation in 2D/3D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#___sec532" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A nonlinear diffusion equation in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#___sec533" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:theta:avg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.1: Truncation error of a weighted mean</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:theta:avg2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.2: Simulate the error of a weighted mean</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:bw2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.3: Verify a truncation error formula</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.4: Truncation error of the Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:estimate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.5: Empirical estimation of truncation errors</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:corr:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.6: Correction term for a Backward Euler scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:corr:verify" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.7: Verify the effect of correction terms</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:varcoeff:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.8: Truncation error of the Crank-Nicolson scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:decay:nonlin:BEFE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.9: Truncation error of \( u'=f(u,t) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:DtDtu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.10: Truncation error of \( [D_t D_tu]^n \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:vib:ic:fw" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.11: Investigate the impact of approximating \( u'(0) \)</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86026.html#trunc:exer:vib:fbw" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise B.12: Investigate the accuracy of a simplified scheme</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#ch:softeng2" style="font-size: 80%;"><b>Appendix: Software engineering; wave equation model</b></a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec547" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A 1D wave equation simulator</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec548" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical model</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec549" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical discretization</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec550" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A solver function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Saving large arrays in files</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage:savez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using <code>savez</code> to store arrays in files</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec553" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Storing individual arrays</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec554" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merging zip archives</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec555" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reading arrays from zip archives</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage:joblib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using <code>joblib</code> to store arrays in files</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage:hash" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a hash to create a file or directory name</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec558" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Software for the 1D wave equation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage:hashlib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making hash strings from input data</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:wave1D:filestorage:norerun" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Avoiding rerunning previously run cases</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec561" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec562" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Programming the solver with classes</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec563" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class Problem</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec564" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class Mesh</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec565" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class Function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec566" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class Solver</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#wave2D3D:impl:Cython" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Migrating loops to Cython</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec568" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declaring variables and annotating the code</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec569" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visual inspection of the C translation</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec570" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Building the extension module</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec571" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calling the Cython function from Python</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec572" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Efficiency</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec573" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Migrating loops to Fortran</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec574" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Fortran subroutine</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec575" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Building the Fortran module with f2py</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec576" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to avoid array copying</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec577" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Efficiency</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec578" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Migrating loops to C via Cython</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec579" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translating index pairs to single indices</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec580" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The complete C code</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec581" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Cython interface file</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec582" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Building the extension module</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec583" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Efficiency</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec584" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Migrating loops to C via f2py</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec585" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Migrating loops to C++ via f2py</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#___sec586" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86027.html#softeng2:exer:savez" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise C.1: Make an improved <code>numpy.savez</code> function</a></li>
     <!-- navigation toc: --> <li><a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#___sec588" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0012"></a>
<!-- !split -->

<center><h1 id="ch:diffu">Diffusion equations</h1></center> <!-- chapter heading -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 10</b>: Here is a todo list.)</font>
<!-- end inline comment -->


<ul>
 <li> There are few index entries, see the &quot;wave equation&quot; index entries and
   how many sub-entries we have there...</li>
 <li> Check if the material on diffusion equation with radial symmetry is
   okay.</li>
 <li> Implement a diffusion equation with axi-symmetry such we can solve
   pulsating flow in a circular blood vessel, see <a href="#diffu:exer:bloodflow">Exercise 3.10: Oscillating and pulsating flow in tubes</a>.</li>
</ul>

The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2},
$$

where \( u(x,t) \) is the unknown function to be solved for, \( x \) is a coordinate
in space, and \( t \) is time. The coefficient \( \dfc \) is the <em>diffusion
coefficient</em> and determines how fast \( u \) changes in time. A quick
short form for the diffusion equation is \( u_t = \dfc u_{xx} \).

<p>
Compared to the wave equation, \( u_{tt}=c^2u_{xx} \), which looks very similar,
the diffusion equation features solutions that are very different from
those of the wave equation. Also, the diffusion equation
makes quite different demands to the numerical
methods.

<p>
Typical diffusion problems may experience rapid change in the very
beginning, but then the evolution of \( u \) becomes slower and slower.
The solution is usually very smooth, and after some time, one cannot
recognize the initial shape of \( u \). This is in sharp contrast to solutions
of the wave equation where the initial shape is preserved - the solution
is basically a moving initial condition. The standard wave equation
\( u_{tt}=c^2u_{xx} \) has solutions that propagates with speed \( c \) forever,
without  changing shape, while the diffusion equation converges to
a <em>stationary solution</em> \( \bar u(x) \) as \( t\rightarrow\infty \). In this
limit, \( u_t=0 \), and \( \bar u \) is governed by \( \bar u''(x)=0 \).
This stationary limit of the diffusion equation is called
the <em>Laplace</em> equation and arises in a very wide range of applications
throughout the sciences.

<p>
It is possible to solve for \( u(x,t) \) using an explicit scheme, as we do
in the section <a href="#diffu:pde1:FEsec">An explicit method for the 1D diffusion equation</a>, but the time step restrictions soon
become much less favorable than for an explicit scheme for the wave
equation. And of more importance, since the solution \( u \) of the
diffusion equation is very smooth and changes slowly, small time steps
are not convenient and not required by accuracy as the diffusion
process converges to a stationary state. Therefore, implicit schemes
as described in the section <a href="#diffu:pde1:implicit">Implicit methods for the 1D diffusion equation</a> are popular, but
these require solutions of systems of algebraic equations. We shall
use ready-made software for this purpose, but also program some simple
iterative methods.

<p>
The exposition below assumes that the reader is familiar with the
basic ideas of discretization and implementation of wave
equations from the chapter <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#ch:wave">Wave equations</a>. Readers not familiar with the
Forward Euler, Backward Euler, and Crank-Nicolson (or centered or
midpoint) discretization methods in time should consult, e.g.,
the
section <a href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book002.html#finite-difference-methods" target="_self">Finite difference methods</a> in <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Langtangen_decay">[3]</a>.

<h1 id="diffu:pde1:FEsec">An explicit method for the 1D diffusion equation</h1>

<h2 id="___sec267">The initial-boundary value problem for 1D diffusion </h2>

<p>
To obtain a unique solution of the diffusion equation, or equivalently,
to apply numerical methods, we need initial and boundary conditions.
The diffusion equation goes with one initial condition \( u(x,0)=I(x) \), where
\( I \) is a prescribed function. One boundary condition is required at
each point on the boundary, which in 1D means that \( u \) must be known,
\( u_x \) must be known, or some combination of them.

<p>
We shall start
with the simplest boundary condition: \( u=0 \). The complete
initial-boundary value diffusion problem in one
space dimension can then be specified as

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2} + f, \quad x\in (0,L),\ t\in (0,T]
\tag{3.1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\tag{3.2}\\ 
u(0,t) & = 0, \quad  t>0,
\tag{3.3}\\ 
u(L,t) & = 0, \quad  t>0\tp
\tag{3.4}
\end{align}
$$

With only a first-order derivative in time,
only one <em>initial condition</em> is needed, while the second-order
derivative in space leads to a demand for two <em>boundary conditions</em>.
We have added a source term \( f=f(x,t) \) for
convenience when testing implementations.

<p>
Diffusion equations like <a href="#mjx-eqn-3.1">(3.1)</a> have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
\( u(x,t) \) represents the temperature of some substance at point \( x \) and
time \( t \).

<h2 id="diffu:pde1:FE">Forward Euler scheme</h2>

<p>
The first step in the discretization procedure is to replace the
domain \( [0,L]\times [0,T] \) by a set of mesh points. Here we apply
equally spaced mesh points

$$
\begin{equation*} x_i=i\Delta x,\quad i=0,\ldots,N_x,\end{equation*}
$$

and

$$
\begin{equation*} t_n=n\Delta t,\quad n=0,\ldots,N_t \tp  \end{equation*}
$$

Moreover, \( u^n_i \) denotes the mesh function that
approximates \( u(x_i,t_n) \) for \( i=0,\ldots,N_x \) and \( n=0,\ldots,N_t \).
Requiring the PDE <a href="#mjx-eqn-3.1">(3.1)</a> to be fulfilled at a mesh point \( (x_i,t_n) \)
leads to the equation

$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n) + f(x_i,t_n),
\tag{3.5}
\end{equation}
$$

The next step is to replace the derivatives by finite difference approximations.
The computationally simplest method arises from
using a forward difference in time and a central difference in
space:

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u + f]^n_i \tp
\tag{3.6}
\end{equation}
$$

Written out,

$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{3.7}
\end{equation}
$$

We have turned the PDE into algebraic equations, also often called
discrete equations. The key property of the equations is that they
are algebraic, which makes them easy to solve.
As usual, we anticipate that \( u^n_i \) is already computed such that
\( u^{n+1}_i \) is the only unknown in <a href="#mjx-eqn-3.7">(3.7)</a>.
Solving with respect to this unknown is easy:

$$
\begin{equation}
u^{n+1}_i = u^n_i + F\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) + \Delta t f_i^n,
\tag{3.8}
\end{equation}
$$

where we have introduced the <em>mesh Fourier number</em>:

$$
\begin{equation}
F = \dfc\frac{\Delta t}{\Delta x^2}\tp
\tag{3.9}
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>\( F \) is the key parameter in the discrete diffusion equation.</b>
Note that \( F \) is a <em>dimensionless</em> number that lumps the key physical
parameter in the problem, \( \dfc \), and the discretization parameters
\( \Delta x \) and \( \Delta t \) into a single parameter. All the properties
of the numerical method are critically dependent upon the value of
\( F \) (see the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> for details).
</div>


<p>
The computational algorithm then becomes

<ol>
 <li> compute $u^0_i=I(x_i)$for \( i=0,\ldots,N_x \)</li>
 <li> for \( n=0,1,\ldots,N_t \):

<ol type="a"></li>
   <li> apply <a href="#mjx-eqn-3.8">(3.8)</a> for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>

</ol>

The algorithm is compactly and fully specified in Python:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]
F <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)           <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
	       f(x[i], t[n])

    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1[:]<span style="color: #666666">=</span> u
</pre></div>
<p>
Note that we use <code>a</code> for \( \dfc \) in the code, motivated by easy visual
mapping between the variable name and the mathematical symbol in formulas.

<p>
We need to state already now that the shown algorithm does not
produce meaningful results unless \( F\leq 1/2 \). Why is explained in
the section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a>.

<h2 id="diffu:pde1:FE:code">Implementation</h2>

<p>
The file <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a complete function <code>solver_FE_simple</code>
for solving the 1D diffusion equation with \( u=0 \) on the boundary
as specified in the algorithm above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE_simple</span>(I, a, f, L, dt, F, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Simplest expression of the computational algorithm</span>
<span style="color: #BA2121; font-style: italic">    using the Forward Euler method and explicit Python loops.</span>
<span style="color: #BA2121; font-style: italic">    For this method F &lt;= 0.5 for stability.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>;  t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()  <span style="color: #408080; font-style: italic"># For measuring the CPU time</span>

    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># Mesh points in space</span>
    <span style="color: #408080; font-style: italic"># Make sure dx and dt are compatible with x and t</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)
    u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Compute u at inner mesh points</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
            u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> \ 
                   dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        <span style="color: #408080; font-style: italic">#u_1[:] = u  # safe, but slow</span>
        u_1, u <span style="color: #666666">=</span> u, u_1

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> u_1, x, t, t1<span style="color: #666666">-</span>t0  <span style="color: #408080; font-style: italic"># u_1 holds latest u</span>
</pre></div>
<p>
A faster version, based on vectorization of the finite difference
scheme, is available in the function <code>solver_FE</code>.
The vectorized version replaces the explicit loop

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) \ 
           <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[i], t[n])
</pre></div>
<p>
by arithmetics on displaced slices of the <code>u</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
<span style="color: #408080; font-style: italic"># or</span>
u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:]) \ 
          <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>], t[n])
</pre></div>
<p>
For example,
the
vectorized version runs 70 times faster than the scalar version
in a case with 100 time steps and a spatial mesh of \( 10^5 \) cells.

<p>
The <code>solver_FE</code> function also features a callback function such that the
user can process the solution at each time level. The callback
function looks like <code>user_action(u, x, t, n)</code>, where <code>u</code> is the array
containing the solution at time level <code>n</code>, <code>x</code> holds all the
spatial mesh points, while <code>t</code> holds all the temporal mesh points.
Apart from the vectorized loop over the spatial mesh points, the
callback function, and a bit more complicated setting of the source
<code>f</code> it is not specified (<code>None</code>), the <code>solver_FE</code> is identical to
<code>solver_FE_simple</code> above:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_FE</span>(I, a, f, L, dt, F, T,
              user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Vectorized implementation of solver_FE_simple.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>;  t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()  <span style="color: #408080; font-style: italic"># for measuring the CPU time</span>

    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Mesh points in time</span>
    dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>F)
    Nx <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>dx))
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># Mesh points in space</span>
    <span style="color: #408080; font-style: italic"># Make sure dx and dt are compatible with x and t</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> t[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> t[<span style="color: #666666">0</span>]

    u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array</span>
    u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t-dt</span>

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_1, x, t, <span style="color: #666666">0</span>)

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        <span style="color: #408080; font-style: italic"># Update all inner points</span>
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
                u[i] <span style="color: #666666">=</span> u_1[i] <span style="color: #666666">+</span> F<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span>\ 
                       dt<span style="color: #666666">*</span>f(x[i], t[n])

        <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;vectorized&#39;</span>:
            u[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span>  \ 
                      F<span style="color: #666666">*</span>(u_1[<span style="color: #666666">0</span>:Nx<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:Nx] <span style="color: #666666">+</span> u_1[<span style="color: #666666">2</span>:Nx<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span>\ 
                      dt<span style="color: #666666">*</span>f(x[<span style="color: #666666">1</span>:Nx], t[n])
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">ValueError</span>(<span style="color: #BA2121">&#39;version=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> version)

        <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
        u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, x, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_1, u <span style="color: #666666">=</span> u, u_1

    t1 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
    <span style="color: #008000; font-weight: bold">return</span> t1<span style="color: #666666">-</span>t0
</pre></div>

<h2 id="diffu:pde1:FE:verify">Verification</h2>

<p>
Before thinking about running the functions in the previous section,
we need to construct a suitable test example for verification. It
appears that a manufactured solution that is linear in time and at
most quadratic in space fulfills the Forward Euler scheme
exactly. With the restriction that \( u=0 \) for \( x=0,L \), we can try the
solution

$$ u(x,t) = 5tx(L-x)\tp$$

Inserted in the PDE, it requires a source term

$$ f(x,t) = 10\dfc t + 5x(L-x)\tp$$

With the formulas from  <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86021.html#sec:form:fdtn">Finite differences of \( t^n \)</a> we can easily check
that the manufactured <code>u</code> fulfills the scheme:

$$
\begin{align*}
\lbrack D_t^+ u = \dfc D_x D_x u + f\rbrack^n_i &=
\lbrack 5x(L-x)D_t^+ t  = 5 t\dfc D_x D_x (xL-x^2) +\\ 
&\quad\quad 10\dfc t + 5x(L-x)\rbrack^n_i\\ 
&=
\lbrack 5x(L-x)  = 5 t\dfc (-2) + 10\dfc t + 5x(L-x) \rbrack^n_i\tp
\end{align*}
$$

<p>
The computation of the source term, given any \( u \),
is easily automated with <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
x, t, a, L <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x t a L&#39;</span>)
u <span style="color: #666666">=</span> x<span style="color: #666666">*</span>(L<span style="color: #666666">-</span>x)<span style="color: #666666">*5*</span>t

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">pde</span>(u):
    <span style="color: #008000; font-weight: bold">return</span> sym<span style="color: #666666">.</span>diff(u, t) <span style="color: #666666">-</span> a<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>diff(u, x, x)

f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(pde(u))
</pre></div>
<p>
Now we can choose any expression for <code>u</code> and automatically
get the suitable source term <code>f</code>. However, the manufactured solution
<code>u</code> will in general
not be exactly reproduced by the scheme: only constant and linear
functions are differentiated correctly by a forward difference, while only
constant, linear, and quadratic functions are differentiated exactly by
a \( [D_xD_x u]^n_i \) difference.

<p>
The numerical code will need to access the <code>u</code> and <code>f</code> above
as Python functions. The exact solution is wanted as a Python
function <code>u_exact(x, t)</code>, while the source term is wanted as
<code>f(x, t)</code>. The parameters <code>a</code> and <code>L</code> in <code>u</code> and <code>f</code> above
are symbols and must be replaced by <code>float</code> objects in a Python
function. This can be done by redefining <code>a</code> and <code>L</code> as
<code>float</code> objects and performing substitutions of symbols by
numbers in <code>u</code> and <code>f</code>. The appropriate code looks like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>
u_exact <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], u<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify(
    [x, t], f<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;L&#39;</span>, L)<span style="color: #666666">.</span>subs(<span style="color: #BA2121">&#39;a&#39;</span>, a), modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
I <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: u_exact(x, <span style="color: #666666">0</span>)
</pre></div>
<p>
Here we also make a function <code>I</code> for the initial condition.

<p>
The idea now is that our manufactured solution should be
exactly reproduced by the code (to machine precision).
For this purpose we make a test function for comparing
the exact and numerical solutions at the end of the
time interval:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_solver_FE</span>():
    <span style="color: #408080; font-style: italic"># Define u_exact, f, I as explained above</span>

    dx <span style="color: #666666">=</span> L<span style="color: #666666">/3</span>  <span style="color: #408080; font-style: italic"># 3 cells</span>
    F <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
    dt <span style="color: #666666">=</span> F<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE_simple(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE_simple: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;scalar&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, scalar: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff

    u, x, t, cpu <span style="color: #666666">=</span> solver_FE(
        I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, L<span style="color: #666666">=</span>L, dt<span style="color: #666666">=</span>dt, F<span style="color: #666666">=</span>F, T<span style="color: #666666">=2</span>,
        user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>, version<span style="color: #666666">=</span><span style="color: #BA2121">&#39;vectorized&#39;</span>)
    u_e <span style="color: #666666">=</span> u_exact(x, t[<span style="color: #666666">-1</span>])
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_e <span style="color: #666666">-</span> u)<span style="color: #666666">.</span>max()
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;max diff solver_FE, vectorized: </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff
</pre></div>
<p>
We emphasize that the value <code>F=0.5</code> is critical: the tests above
will fail if <code>F</code> has a larger value (this is because the Forward
Euler scheme is unstable for \( F>1/2 \)).

<h2 id="diffu:pde1:FE:experiments">Numerical experiments</h2>

<p>
When a test function like the one above runs silently without
errors, we have some evidence for a correct implementation of the
numerical method.
The next step is to do some experiments with more interesting solutions.

<p>
We target a scaled diffusion problem where \( x/L \) is a new spatial
coordinate and \( \dfc t/L^2 \) is a new time coordinate. The source term
\( f \) is omitted, and \( u \) is scaled by \( \max_{x\in [0,L]}|I(x)| \)
(see <a href="http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book008.html#sec:scale:diffu" target="_self">Scaling of the diffusion equation</a> in <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Langtangen_scaling">[4]</a> for details).
The governing PDE is then

$$ \frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2},$$

in the spatial domain \( [0,L] \), with boundary conditions \( u(0)=u(1)=0 \).
Two initial conditions will be tested: a discontinuous plug,

$$ I(x) = \left\lbrace\begin{array}{ll}
0, & |x-L/2| > 0.1\\ 
1, & \hbox{otherwise}
\end{array}\right.$$

and a smooth Gaussian function,

$$ I(x) = e^{-\frac{1}{2\sigma^2}(x-L/2)^2}\tp$$

The functions <code>plug</code> and <code>gaussian</code> in <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a> run the two cases,
respectively:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plug</span>(scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, F<span style="color: #666666">=0.5</span>, Nx<span style="color: #666666">=50</span>):
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    <span style="color: #408080; font-style: italic"># Compute dt from Nx and F</span>
    dx <span style="color: #666666">=</span> L<span style="color: #666666">/</span>Nx;  dt <span style="color: #666666">=</span> F<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plug profile as initial condition.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">abs</span>(x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>) <span style="color: #666666">&gt;</span> <span style="color: #666666">0.1</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span>

    cpu <span style="color: #666666">=</span> viz(I, a, L, dt, F, T,
              umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
              scheme<span style="color: #666666">=</span>scheme, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;CPU time:&#39;</span>, cpu

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">gaussian</span>(scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, F<span style="color: #666666">=0.5</span>, Nx<span style="color: #666666">=50</span>, sigma<span style="color: #666666">=0.05</span>):
    L <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1.</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    <span style="color: #408080; font-style: italic"># Compute dt from Nx and F</span>
    dx <span style="color: #666666">=</span> L<span style="color: #666666">/</span>Nx;  dt <span style="color: #666666">=</span> F<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">I</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Gaussian profile as initial condition.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-0.5*</span>((x<span style="color: #666666">-</span>L<span style="color: #666666">/2.0</span>)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>sigma<span style="color: #666666">**2</span>)

    u, cpu <span style="color: #666666">=</span> viz(I, a, L, dt, F, T,
                 umin<span style="color: #666666">=-0.1</span>, umax<span style="color: #666666">=1.1</span>,
                 scheme<span style="color: #666666">=</span>scheme, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;CPU time:&#39;</span>, cpu
</pre></div>
<p>
These functions make use of the function <code>viz</code> for running the
solver and visualizing the solution using a callback function
with plotting:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">viz</span>(I, a, L, dt, F, T, umin, umax,
        scheme<span style="color: #666666">=</span><span style="color: #BA2121">&#39;FE&#39;</span>, animate<span style="color: #666666">=</span><span style="color: #008000">True</span>, framefiles<span style="color: #666666">=</span><span style="color: #008000">True</span>):

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_u</span>(u, x, t, n):
        plt<span style="color: #666666">.</span>plot(x, u, <span style="color: #BA2121">&#39;r-&#39;</span>, axis<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, L, umin, umax],
                 title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t=</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> t[n])
        <span style="color: #008000; font-weight: bold">if</span> framefiles:
            plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp_frame</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> n)
        <span style="color: #008000; font-weight: bold">if</span> t[n] <span style="color: #666666">==</span> <span style="color: #666666">0</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">2</span>)
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #AA22FF; font-weight: bold">not</span> framefiles:
            <span style="color: #408080; font-style: italic"># It takes time to write files so pause is needed</span>
            <span style="color: #408080; font-style: italic"># for screen only animation</span>
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.2</span>)

    user_action <span style="color: #666666">=</span> plot_u <span style="color: #008000; font-weight: bold">if</span> animate <span style="color: #008000; font-weight: bold">else</span> <span style="color: #008000; font-weight: bold">lambda</span> u,x,t,n: <span style="color: #008000">None</span>

    cpu <span style="color: #666666">=</span> <span style="color: #008000">eval</span>(<span style="color: #BA2121">&#39;solver_&#39;</span><span style="color: #666666">+</span>scheme)(I, a, L, dt, F, T,
                                 user_action<span style="color: #666666">=</span>user_action)
    <span style="color: #008000; font-weight: bold">return</span> cpu
</pre></div>
<p>
Notice that this <code>viz</code> function stores all the solutions in a
list <code>solutions</code> in the callback function. Modern computers have
hardly any problem with storing a lot of such solutions for moderate
values of \( N_x \) in 1D problems, but for 2D and 3D problems, this
technique cannot be used and solutions must be stored in files.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 11</b>: Better to show the scalable file solution here?)</font>
<!-- end inline comment -->

<p>
Our experiments employ a time step \( \Delta t = 0.0002 \) and
simulate for \( t\in [0,0.1] \). First we try the highest value of
\( F \): \( F=0.5 \). This resolution corresponds to
\( N_x=50 \). A possible terminal command is

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python -c &#39;from diffu1D_u0 import gaussian
&gt; gaussian(&quot;solver_FE&quot;, F=0.5, dt=0.0002)&#39;
</pre></div>
<p>
The \( u(x,t) \) curve as a function of \( x \) is shown
in Figure <a href="#diffu:pde1:FE:fig:F=0.5">35</a> at four time
levels.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
We see that the curves have saw-tooth waves in the beginning of the
simulation. This non-physical noise is smoothed out with time, but
solutions of the diffusion equations are known to be smooth, and
this numerical solution is definitely not smooth.
Lowering \( F \) helps: \( F\leq 0.25 \) gives a smooth solution, see
Figure <a href="#diffu:pde1:FE:fig:F=0.25">36</a>.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_F025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
Increasing \( F \) slightly beyond the limit 0.5, to \( F=0.51 \),
gives growing, non-physical instabilities,
as seen in Figure <a href="#diffu:pde1:FE:fig:F=0.51">37</a>.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 35:  Forward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.5 --> </p></center>
<p><img src="fig-diffu/plug_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.25"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 36:  Forward Euler scheme for \( F=0.25 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.25 --> </p></center>
<p><img src="fig-diffu/plug_FE_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:F=0.51"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 37:  Forward Euler scheme for \( F=0.51 \).  <!-- caption label: diffu:pde1:FE:fig:F=0.51 --> </p></center>
<p><img src="fig-diffu/plug_FE_F051.png" align="bottom" width=800></p>
</center>

<p>
Instead of a discontinuous initial condition we now try the smooth
Gaussian function for \( I(x) \). A simulation for \( F=0.5 \)
is shown in Figure <a href="#diffu:pde1:FE:fig:gauss:F=0.5">38</a>. Now the numerical solution
is smooth for all times, and this is true for any \( F\leq 0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:FE:fig:gauss:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 38:  Forward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:FE:fig:gauss:F=0.5 --> </p></center>
<p><img src="fig-diffu/gaussian_FE_F05.png" align="bottom" width=800></p>
</center>

<p>
Experiments with these two choices of \( I(x) \) reveal some
important observations:

<ul>
 <li> The Forward Euler scheme leads to growing solutions if \( F>\half \).</li>
 <li> \( I(x) \) as a discontinuous plug leads to a saw tooth-like noise
   for \( F=\half \), which is absent for \( F\leq\frac{1}{4} \).</li>
 <li> The smooth Gaussian initial function leads to a smooth solution
   for all relevant \( F \) values (\( F\geq \half \)).</li>
</ul>

<h1 id="diffu:pde1:implicit">Implicit methods for the 1D diffusion equation</h1>

<p>
Simulations with the Forward Euler scheme shows that the time step
restriction, \( F\leq\half \), which means \( \Delta t \leq \Delta x^2/(2\dfc) \),
may be relevant in the beginning of the diffusion process, when the
solution changes quite fast, but as time increases, the process slows
down, and a small \( \Delta t \) may be inconvenient. By using
<em>implicit schemes</em>, which lead to a coupled system of linear equations
to be solved at each time level, any size of \( \Delta t \) is possible
(but the accuracy decreases with increasing \( \Delta t \)).
The Backward Euler scheme, derived and implemented below, is the
simplest implicit scheme for the diffusion equation.

<h2 id="diffu:pde1:BE">Backward Euler scheme</h2>

<p>
We now apply a backward difference in time in <a href="#mjx-eqn-3.5">(3.5)</a>,
but the same central difference in space:

$$
\begin{equation}
[D_t^- u = D_xD_x u + f]^n_i,
\tag{3.10}
\end{equation}
$$

which written out reads

$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n\tp
\tag{3.11}
\end{equation}
$$

Now we assume \( u^{n-1}_i \) is already computed, but all quantities at the &quot;new&quot;
time level \( n \) are unknown. This time it is not possible to solve
with respect to \( u_i^{n} \) because this value couples to its neighbors
in space, \( u^n_{i-1} \) and \( u^n_{i+1} \), which are also unknown.
Let us examine this fact for the case when \( N_x=3 \). Equation <a href="#mjx-eqn-3.11">(3.11)</a> written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2} + f_1^n
\tag{3.12}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2} + f_2^n
\tag{3.13}
\end{align}
$$

The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero. Collecting the
unknown new values \( u^n_1 \) and \( u^n_2 \) on the left-hand side and multiplying
by \( \Delta t \) gives

$$
\begin{align}
\left(1+  2F\right) u^{n}_1 - F u^{n}_{2}    &= u^{n-1}_1 + \Delta t f_1^n,
\tag{3.14}\\ 
- F u^{n}_{1} + \left(1+  2F\right) u^{n}_2  &= u^{n-1}_2 + \Delta t f_2^n\tp
\tag{3.15}
\end{align}
$$

This is a coupled \( 2\times 2 \) system of algebraic equations for
the unknowns \( u^n_1 \) and \( u^n_2 \). The equivalent matrix form is

$$ \left(\begin{array}{cc}
1+  2F &   - F\\ 
- F    & 1+  2F
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_2
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1 + \Delta t f_1^n\\ 
u^{n-1}_2 + \Delta t f_2^n
\end{array}\right)
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Implicit vs. explicit methods.</b>
Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
<em>implicit methods</em>.
The counterpart, <em>explicit methods</em>, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.
</div>


<p>
In the general case, <a href="#mjx-eqn-3.11">(3.11)</a> gives rise to
a coupled \( (Nx-1)\times (Nx-1) \) system of algebraic equations for
all the unknown \( u^n_i \) at the interior spatial points \( i=1,\ldots,Nx-1 \).
Collecting the unknowns on the left-hand side,
<a href="#mjx-eqn-3.11">(3.11)</a> can be written

$$
\begin{equation}
- F u^n_{i-1} + \left(1+  2F \right) u^{n}_i - F u^n_{i+1} =
u_{i-1}^{n-1},
\tag{3.16}
\end{equation}
$$

for \( i=1,\ldots,Nx-1 \).
One can either view these equations as a system for where the
\( u^{n}_i \) values at the internal mesh points, \( i=1,\ldots,N_x-1 \), are
unknown, or we may append the boundary values \( u^n_0 \) and \( u^n_{N_x} \)
to the system. In the latter case, all \( u^n_i \) for \( i=0,\ldots,N_x \)
are unknown and we must add the boundary equations to
the \( N_x-1 \) equations in <a href="#mjx-eqn-3.16">(3.16)</a>:

$$
\begin{align}
u_0^n &= 0,label{diffu:pde1:step4BE:BC:0}\\ 
u_{N_x}^n &= 0\tp
\tag{3.18}
\end{align}
$$

<p>
A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations <a href="#mjx-eqn-3.16">(3.16)</a>
and <a href="#mjx-eqn-3.17">(3.17)</a>--<a href="#mjx-eqn-3.18">(3.18)</a>
correspond to the matrix equation

$$
\begin{equation*} AU = b\end{equation*}
$$

where \( U=(u^n_0,\ldots,u^n_{N_x}) \), and
the matrix \( A \) has the following structure:

$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & A_{1,2} & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\tag{3.19}
\end{equation}
$$

The nonzero elements are given by

$$
\begin{align}
A_{i,i-1} &= -F
\tag{3.20}\\ 
A_{i,i} &= 1+ 2F
\tag{3.21}\\ 
A_{i,i+1} &= -F
\tag{3.22}
\end{align}
$$

for the equations for internal points, \( i=1,\ldots,N_x-1 \). The first and last
equation correspond to the boundary condition, where we know the solution,
and therefore we must have

$$
\begin{align}
A_{0,0} &= 1,
\tag{3.23}\\ 
A_{0,1} &= 0,
\tag{3.24}\\ 
A_{N_x,N_x-1} &= 0,
\tag{3.25}\\ 
A_{N_x,N_x} &= 1\tp
\tag{3.26}
\end{align}
$$

The right-hand side \( b \) is written as

$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\tag{3.27}
\end{equation}
$$

with

$$
\begin{align}
b_0 &= 0,
\tag{3.28}\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1,
\tag{3.29}\\ 
b_{N_x} &= 0 \tp   \tag{3.30}
\end{align}
$$

<p>
We observe that the matrix \( A \) contains quantities that do not change
in time. Therefore, \( A \) can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side \( b \), however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># mesh points in time</span>
u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)          <span style="color: #408080; font-style: italic"># u at the previous time level</span>

<span style="color: #408080; font-style: italic"># Data structures for the linear system</span>
A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>))
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
    A[i,i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
    A[i,i] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
A[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> A[Nx,Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    <span style="color: #408080; font-style: italic"># Compute b and solve linear system</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nx):
        b[i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>u_1[i]
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[Nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1[:] <span style="color: #666666">=</span> u
</pre></div>

<h2 id="diffu:pde1:impl:sparse">Sparse matrix implementation</h2>

<p>
We have seen from <a href="#mjx-eqn-3.19">(3.19)</a> that the matrix \( A \)
is tridiagonal. The code segment above used a full, dense matrix
representation of \( A \), which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these zeros.
With \( N_x+1 \) unknowns, the work by the solution algorithm is \( \frac{1}{3}
(N_x+1)^3 \) and the storage requirements \( (N_x+1)^2 \). By utilizing
the fact that \( A \) is tridiagonal and employing corresponding software
tools that work with the three diagonals,
the work and storage demands can be proportional to \( N_x \) only.
This leads to a dramatic improvement: with \( N_x=200 \), which is an often
needed resolution, the code runs about 40,000 times faster and reduces
the storage to just 1.5%! It is no doubt that we need to take advantage
of the fact that \( A \) is tridiagonal.

<p>
The key idea is to apply a data structure for a
tridiagonal or sparse matrix. The <code>scipy.sparse</code> package has
relevant utilities. For example, we can store the nonzero diagonals of
a matrix. The package also has linear system solvers that operate on
sparse matrix data structures. The code below illustrates how we
can store only the main diagonal and the upper and lower diagonals.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
main  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)
lower <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx)
upper <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx)
b     <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nx<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Precompute sparse matrix</span>
main[:] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>F
lower[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
upper[:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>F
<span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
main[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
main[Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
    diagonals<span style="color: #666666">=</span>[main, lower, upper],
    offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>], shape<span style="color: #666666">=</span>(Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>),
    format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
<span style="color: #008000; font-weight: bold">print</span> A<span style="color: #666666">.</span>todense()  <span style="color: #408080; font-style: italic"># Check that A is correct</span>

<span style="color: #408080; font-style: italic"># Set initial condition</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
    u_1[i] <span style="color: #666666">=</span> I(x[i])

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
    b <span style="color: #666666">=</span> u_1
    b[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>  <span style="color: #408080; font-style: italic"># boundary conditions</span>
    u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
    u_1[:] <span style="color: #666666">=</span> u
</pre></div>
<p>
The <code>scipy.sparse.linalg.spsolve</code> function utilizes the sparse storage
structure of <code>A</code> and performs in this case a very efficient Gaussian
elimination solve.

<p>
The program <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a>
contains a function <code>solver_BE</code>, which implements the Backward Euler scheme
sketched above.
As mentioned in the section <a href="#diffu:pde1:FE">Forward Euler scheme</a>,
the functions <code>plug</code> and <code>gaussian</code>
runs the case with \( I(x) \) as a discontinuous plug or a smooth
Gaussian function. All experiments point to two characteristic
features of the Backward Euler scheme: 1) it is always stable, and
2) it always gives a smooth, decaying solution.

<h2 id="diffu:pde1:CN">Crank-Nicolson scheme</h2>

<p>
The idea in the Crank-Nicolson scheme is to apply centered
differences in space and time, combined with an average in time.
We demand the PDE to be fulfilled at the spatial mesh points, but
midway between the points in the time mesh:

$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half}) + f(x_i,t_{n+\half}),
$$

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
With centered differences in space and time, we get

$$ [D_t u = \dfc D_xD_x u + f]^{n+\half}_i\tp$$

On the right-hand side we get an expression

$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right) + f_i^{n+\half}\tp$$

This expression is problematic since \( u^{n+\half}_i \) is not one of
the unknowns we compute. A possibility is to replace \( u^{n+\half}_i \)
by an arithmetic average:

$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)\tp
$$

In the compact notation, we can use the arithmetic average
notation \( \overline{u}^t \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + f]^{n+\half}_i\tp$$

We can also use an average for \( f_i^{n+\half} \):

$$ [D_t u = \dfc D_xD_x \overline{u}^t + \overline{f}^t]^{n+\half}_i\tp$$

<p>
After writing out the differences and average, multiplying by \( \Delta t \),
and collecting all unknown terms on the left-hand side, we get

$$
\begin{align}
u^{n+1}_i - \half F(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
&= u^{n}_i + \half F(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})\nonumber\\ 
&\qquad \half f_i^{n+1} + \half f_i^n\tp
\tag{3.31}
\end{align}
$$

<p>
Also here, as in the Backward Euler scheme, the new unknowns
\( u^{n+1}_{i-1} \), \( u^{n+1}_{i} \), and \( u^{n+1}_{i+1} \) are coupled
in a linear system \( AU=b \), where \( A \) has the same structure
as in <a href="#mjx-eqn-3.19">(3.19)</a>, but with slightly
different entries:

$$
\begin{align}
A_{i,i-1} &= -\half F
\tag{3.32}\\ 
A_{i,i} &= \half + F
\tag{3.33}\\ 
A_{i,i+1} &= -\half F
\tag{3.34}
\end{align}
$$

for the equations for internal points, \( i=1,\ldots,N_x-1 \). The equations
for the boundary points correspond to

$$
\begin{align}
A_{0,0} &= 1,
\tag{3.35}\\ 
A_{0,1} &= 0,
\tag{3.36}\\ 
A_{N_x,N_x-1} &= 0,
\tag{3.37}\\ 
A_{N_x,N_x} &= 1\tp
\tag{3.38}
\end{align}
$$

The right-hand side \( b \) has entries

$$
\begin{align}
b_0 &= 0,
\tag{3.39}\\ 
b_i &= u^{n-1}_i + \half(f_i^n + f_i^{n+1}),\quad i=1,\ldots,N_x-1,
\tag{3.40}\\ 
b_{N_x} &= 0 \tp   \tag{3.41}
\end{align}
$$

<h2 id="diffu:pde1:theta">The unifying \( \theta \) rule</h2>

<p>
For the equation

$$ \frac{\partial u}{\partial t} = G(u),$$

where \( G(u) \) is some
a spatial differential operator, the \( \theta \)-rule
looks like

$$ \frac{u^{n+1}_i - u^n_i}{\Delta t} =
\theta G(u^{n+1}_i) + (1-\theta) G(u^{n}_i)\tp$$

The important feature of this time discretization scheme is that
we can implement one formula and then generate a family of
well-known and widely used schemes:

<ul>
 <li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>

Applied to the 1D diffusion problem, the \( \theta \)-rule gives

$$
\begin{align*}
\frac{u^{n+1}_i-u^n_i}{\Delta t} &=
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)\\ 
&\qquad + \theta f_i^{n+1} + (1-\theta)f_i^n
\tp
\end{align*}
$$

This scheme also leads to a matrix system with entries

$$ A_{i,i-1} = -F\theta,\quad A_{i,i} = 1+2F\theta\quad,
A_{i,i+1} = -F\theta,$$

while right-hand side entry \( b_i \) is

$$ b_i = u^n_{i} + F(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} +
\Delta t\theta f_i^{n+1} + \Delta t(1-\theta)f_i^n\tp
$$

The corresponding entries for the boundary points are as in the Backward
Euler and Crank-Nicolson schemes listed earlier.

<h2 id="diffu:pde1:theta:experiments">Experiments</h2>

<p>
We can repeat the experiments from the section <a href="#diffu:pde1:FE:experiments">Numerical experiments</a>
to see if the Backward Euler or Crank-Nicolson schemes have problems
with sawtooth-like noise when starting with a discontinuous initial
condition. We can also verify that we can have \( F>\half \),
which allows larger time steps than in the Forward Euler method.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:BE:fig:F=0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 39:  Backward Euler scheme for \( F=0.5 \).  <!-- caption label: diffu:pde1:BE:fig:F=0.5 --> </p></center>
<p><img src="fig-diffu/plug_BE_F05.png" align="bottom" width=800></p>
</center>

<p>
The Backward Euler scheme always produces smooth solutions for any \( F \).
Figure <a href="#diffu:pde1:BE:fig:F=0.5">39</a> shows one example.
The Crank-Nicolson method produces smooth solutions for small \( F \),
\( F\leq\half \), but small noise is more and more evident as \( F \)
increases. Figures <a href="#diffu:pde1:CN:fig:F=3">40</a> and <a href="#diffu:pde1:CN:fig:F=10">41</a>
demonstrates the effect for \( F=3 \) and \( F=10 \), respectively.
The section <a href="#diffu:pde1:analysis">Analysis of schemes for the diffusion equation</a> explains why such noise occur.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:CN:fig:F=3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 40:  Crank-Nicolson scheme for \( F=3 \).  <!-- caption label: diffu:pde1:CN:fig:F=3 --> </p></center>
<p><img src="fig-diffu/plug_CN_F3.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:CN:fig:F=10"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 41:  Crank-Nicolson scheme for \( F=10 \).  <!-- caption label: diffu:pde1:CN:fig:F=10 --> </p></center>
<p><img src="fig-diffu/plug_CN_F10.png" align="bottom" width=800></p>
</center>

<h2 id="___sec278">The Laplace and Poisson equation </h2>

<p>
The Laplace equation, \( \nabla^2 u = 0 \), and the Poisson equation,
\( -\nabla^2 u = f \), occur in numerous applications throughout science and
engineering. In 1D these equations read
\( u''(x)=0 \) and \( -u''(x)=f(x) \), respectively.
We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret \( u_{xx}=0 \) as the limiting solution
of \( u_t = \dfc u_{xx} \) when \( u \) reaches a steady state limit where
\( u_t\rightarrow 0 \).
Similarly, Poisson's equation \( -u_{xx}=f \) arises from solving
\( u_t = u_{xx} + f \) and letting \( t\rightarrow\infty \) so \( u_t\rightarrow 0 \).

<p>
Technically in a program, we can simulate \( t\rightarrow\infty \)
by just taking one large time step:
\( \Delta t\rightarrow\infty \). In the limit, the Backward Euler
scheme gives

$$ -\frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = f^{n+1}_i,$$

which is nothing but the discretization \( [-D_xD_x u = f]^{n+1}_i=0 \) of
\( -u_{xx}=f \).

<p>
The result above means that
the Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since \( \Delta t >
\Delta x^2/\dfc \)
is illegal and leads to instability.
We may interpret this time stepping
as solving the equation system from \( -u_{xx}=f \) by iterating on a
pseudo time variable.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 12</b>: Better to say the last sentence when we treat iterative methods.)</font>
<!-- end inline comment -->

<h1 id="diffu:pde1:analysis">Analysis of schemes for the diffusion equation</h1>

<p>
The numerical experiments in the sections <a href="#diffu:pde1:FE:experiments">Numerical experiments</a> and <a href="#diffu:pde1:theta:experiments">Experiments</a>
reveal that there are some
numerical problems with the Forward Euler and Crank-Nicolson schemes:
sawtooth-like noise is sometimes present in solutions that are,
from a mathematical point of view, expected to be smooth.
This section presents a mathematical analysis that explains the
observed behavior and arrives at criteria for obtaining numerical
solutions that reproduce the qualitative properties of the exact
solutions. In short, we shall explain what is observed in
Figures
<a href="#diffu:pde1:FE:fig:F=0.5">35</a>,
<a href="#diffu:pde1:FE:fig:F=0.25">36</a>,
<a href="#diffu:pde1:FE:fig:F=0.51">37</a>,
<a href="#diffu:pde1:FE:fig:gauss:F=0.5">38</a>,
<a href="#diffu:pde1:BE:fig:F=0.5">39</a>,
<a href="#diffu:pde1:CN:fig:F=3">40</a>,
and
<a href="#diffu:pde1:CN:fig:F=10">41</a>.

<h2 id="diffu:pde1:analysis:uex">Properties of the solution</h2>

<p>
A particular characteristic of diffusive processes, governed
by an equation like

$$
\begin{equation}
u_t = \dfc u_{xx},
\tag{3.42}
\end{equation}
$$

is that the
initial shape \( u(x,0)=I(x) \) spreads out in space with time,
along with a decaying amplitude.
Three different examples will illustrate the spreading of \( u \) in
space and the decay in time.

<h3 id="___sec281">Similarity solution </h3>

<p>
The diffusion equation <a href="#mjx-eqn-3.42">(3.42)</a> admits solutions
that depend on \( \eta = (x-c)/\sqrt{4\dfc t} \) for a given value
of \( c \). One particular solution
is

$$
\begin{equation}
u(x,t) = a\,\mbox{erf}(\eta) + b,
\tag{3.43}
\end{equation}
$$

where

$$
\begin{equation}
\mbox{erf}(\eta) = \frac{2}{\sqrt{\pi}}\int_0^\eta e^{-\zeta^2}d\zeta,
\tag{3.44}
\end{equation}
$$

is the <em>error function</em>, and \( a \) and \( b \) are arbitrary constants.
The error function lies in \( (-1,1) \), is odd around \( \eta =0 \), and
goes relatively quickly to \( \pm 1 \):

$$
\begin{align*}
\lim_{\eta\rightarrow -\infty}\mbox{erf}(\eta) &=-1,\\ 
\lim_{\eta\rightarrow \infty}\mbox{erf}(\eta) &=1,\\ 
\mbox{erf}(\eta) &= -\mbox{erf}(-\eta),\\ 
\mbox{erf}(0) &=0,\\ 
\mbox{erf}(2) &=0.99532227,\\ 
\mbox{erf}(3) &=0.99997791
\tp
\end{align*}
$$

<p>
As \( t\rightarrow 0 \), the error function approaches a step function centered
at \( x=c \). For a diffusion problem posed on the unit interval \( [0,1] \),
we may choose the step at \( x=1/2 \) (meaning \( c=1/2 \)), \( a=-1/2 \), \( b=1/2 \).
Then

$$
\begin{equation}
u(x,t) = \half\left(1 -
\mbox{erf}\left(\frac{x-\half}{\sqrt{4\dfc t}}\right)\right) =
\half\mbox{erfc}\left(\frac{x-\half}{\sqrt{4\dfc t}}\right),
\tag{3.45}
\end{equation}
$$

where we have introduced the <em>complementary error function</em>
\( \mbox{erfc}(\eta) = 1-\mbox{erf}(\eta) \).
The solution <a href="#mjx-eqn-3.45">(3.45)</a>
implies the boundary conditions

$$
\begin{align}
u(0,t) &= \half\left(1 - \mbox{erf}\left(\frac{-1/2}{\sqrt{4\dfc t}}\right)\right),
\tag{3.46} \\ 
u(1,t) &= \half\left(1 - \mbox{erf}\left(\frac{1/2}{\sqrt{4\dfc t}}\right)\right)
\tag{3.47}
\tp
\end{align}
$$

For small enough \( t \), \( u(0,t)\approx 1 \) and \( u(1,t)\approx 1 \), but as
\( t\rightarrow\infty \), \( u(x,t)\rightarrow 1/2 \) on \( [0,1] \).

<h3 id="___sec282">Solution for a Gaussian pulse </h3>

<p>
The standard diffusion equation \( u_t = \dfc u_{xx} \) admits a
Gaussian function as solution:

$$
\begin{equation}
u(x,t) = \frac{1}{\sqrt{4\pi\dfc t}} \exp{\left({-\frac{(x-c)^2}{4\dfc t}}\right)}
\tag{3.48}
\tp
\end{equation}
$$

At \( t=0 \) this is a Dirac delta function, so for computational
purposes one must start to view the solution at some time \( t=t_\epsilon>0 \).
Replacing \( t \) by \( t_\epsilon +t \) in <a href="#mjx-eqn-3.48">(3.48)</a>
makes it easy to operate with a (new) \( t \) that starts at \( t=0 \)
with an initial condition with a finite width.
The important feature of <a href="#mjx-eqn-3.48">(3.48)</a> is that
the standard deviation \( \sigma \) of a sharp initial Gaussian pulse
increases in time according to \( \sigma = \sqrt{2\dfc t} \), making
the pulse diffuse and flatten out.

<p>
<!-- Mention combinations of such kernels to build up a general analytical sol? -->
<!-- Or maybe an exercise for verification. -->

<h3 id="___sec283">Solution for a sine component </h3>

<p>
For example, <a href="#mjx-eqn-3.42">(3.42)</a>
admits a solution of the form

$$
\begin{equation}
u(x,t) = Qe^{-at}\sin\left( kx\right)
\tag{3.49}
\tp
\end{equation}
$$

The parameters \( Q \) and \( k \) can be freely chosen, while
inserting <a href="#mjx-eqn-3.49">(3.49)</a> in <a href="#mjx-eqn-3.42">(3.42)</a> gives the constraint

$$
\begin{equation*} a = -\dfc k^2
\tp
\end{equation*}
$$

<p>
A very important feature is that the initial shape \( I(x)=Q\sin kx \)
undergoes a damping \( \exp{(-\dfc k^2t)} \), meaning that
rapid oscillations in space, corresponding to large \( k \), are very much
faster dampened than slow oscillations in space, corresponding to small
\( k \). This feature leads to a smoothing of the initial condition with time.

<p>
The following examples illustrates the damping properties of <a href="#mjx-eqn-3.49">(3.49)</a>. We consider the specific problem

$$
\begin{align*}
u_t &= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\ 
u(0,t) &= u(1,t) = 0,\quad t\in (0,T],\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\tp
\end{align*}
$$

The initial condition has been chosen such that adding
two solutions like <a href="#mjx-eqn-3.49">(3.49)</a> constructs
an analytical solution to the problem:

$$
\begin{equation}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
\tag{3.50}
\tp
\end{equation}
$$

Figure <a href="#diffu:pde1:fig:damping">42</a> illustrates the rapid damping of
rapid oscillations \( \sin (100\pi x) \) and the very much slower damping of the
slowly varying \( \sin (\pi x) \) term. After about \( t=0.5\cdot10^{-4} \) the rapid
oscillations do not have a visible amplitude, while we have to wait
until \( t\sim 0.5 \) before the amplitude of the long wave \( \sin (\pi x) \)
becomes very small.

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:damping"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 42:  Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right).  <!-- caption label: diffu:pde1:fig:damping --> </p></center>
<p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p>
</center>

<p>
<!-- x/sqrt(t) solution, kernel with integral -->

<h2 id="___sec284">Analysis of discrete equations </h2>

<p>
A counterpart to <a href="#mjx-eqn-3.49">(3.49)</a> is the complex representation
of the same function:

$$ u(x,t) = Qe^{-at}e^{ikx},$$

where \( i=\sqrt{-1} \) is the imaginary unit.
We can add such functions, often referred to as wave components,
to make a Fourier representation
of a general solution of the diffusion equation:

$$
\begin{equation}
u(x,t) \approx \sum_{k\in K} b_k e^{-\dfc k^2t}e^{ikx},
\tag{3.51}
\end{equation}
$$

where \( K \) is a set of an infinite number of \( k \) values needed to construct
the solution. In practice, however, the series is truncated and
\( K \) is a finite set of \( k \) values
needed to build a good approximate solution.
Note that <a href="#mjx-eqn-3.50">(3.50)</a> is a special case of
<a href="#mjx-eqn-3.51">(3.51)</a> where \( K=\{\pi, 100\pi\} \), \( b_{\pi}=1 \),
and \( b_{100\pi}=0.1 \).

<p>
The amplitudes \( b_k \) of the individual Fourier waves must be determined
from the initial condition. At \( t=0 \) we have \( u\approx\sum_kb_k\exp{(ikx)} \)
and find \( K \) and \( b_k \) such that

$$
\begin{equation}
I(x) \approx \sum_{k\in K} b_k e^{ikx}\tp
\tag{3.52}
\end{equation}
$$

(The relevant formulas for \( b_k \) come from Fourier analysis, or
equivalently, a least-squares method for approximating \( I(x) \)
in a function space with basis \( \exp{(ikx)} \).)

<p>
Much insight about the behavior of numerical methods can be obtained
by investigating how a wave component \( \exp{(-\dfc k^2
t)}\exp{(ikx)} \) is treated by the numerical scheme. It appears that
such wave components are also solutions of the schemes, but the
damping factor \( \exp{(-\dfc k^2 t)} \) varies among the schemes.  To
ease the forthcoming algebra, we write the damping factor as
\( A^n \). The exact amplification factor corresponding to \( A \) is \( \Aex =
\exp{(-\dfc k^2\Delta t)} \).

<h2 id="diffu:pde1:analysis:details">Analysis of the finite difference schemes</h2>

<p>
We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components

$$
\begin{equation*} e^{-\dfc k^2t}e^{ikx} \tp  \end{equation*}
$$

A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude \( \exp{(-\dfc k^2t)} \) might be modified (which also happens when
solving the ODE counterpart \( u'=-\dfc u \)).
We therefore look for numerical solutions of the form

$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},
\tag{3.53}
\end{equation}
$$

where the amplification factor \( A \)
must be determined by inserting the component into an actual scheme.

<h3 id="___sec286">Stability </h3>

<p>
The exact amplification factor is \( \Aex=\exp{(-\dfc^2 k^2\Delta t)} \).
We should therefore require \( |A| < 1 \) to have a decaying numerical
solution as well. If
\( -1\leq A < 0 \), \( A^n \) will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.

<h3 id="___sec287">Accuracy </h3>

<p>
To determine how accurately a finite difference scheme treats one
wave component <a href="#mjx-eqn-3.53">(3.53)</a>, we see that the basic
deviation from the exact solution is reflected in how well
\( A^n \) approximates \( \Aex^n \),
or how well \( A \) approximates \( \Aex \).
We can plot \( \Aex \) and the various expressions for \( A \), and we can
make Taylor expansions of \( A/\Aex \) to see the error more analytically.

<p>
<!-- We shall in particular investigate the error \( \Aex - A \) in the -->
<!-- amplification factor. -->

<h2 id="diffu:pde1:analysis:FE">Analysis of the Forward Euler scheme</h2>

<p>
<!-- 2DO: refer to vib and wave -->

<p>
The Forward Euler finite difference scheme for \( u_t = \dfc u_{xx} \) can
be written as

$$
\begin{equation*} [D_t^+ u = \dfc D_xD_x u]^n_q\tp  \end{equation*}
$$

Inserting a wave component <a href="#mjx-eqn-3.53">(3.53)</a>
in the scheme demands calculating the terms

$$ e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},$$

and

$$ A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)\right)
\tp  $$

Inserting these terms in the discrete equation and
dividing by \( A^n e^{ikq\Delta x} \) leads to

$$
\begin{equation*}
\frac{A-1}{\Delta t} = -\dfc \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and consequently

$$
\begin{equation}
A = 1 -4F\sin^2 p
\tag{3.54}
\end{equation}
$$

where

$$
\begin{equation}
F = \frac{\dfc\Delta t}{\Delta x^2}
\tag{3.55}
\end{equation}
$$

is the <em>numerical Fourier number</em>, and \( p=k\Delta x/2 \).
The complete numerical solution is then

$$
\begin{equation}
u^n_q = \left(1 -4F\sin^2 p\right)^ne^{ikq\Delta x}
\tp
\tag{3.56}
\end{equation}
$$

<h3 id="___sec289">Stability </h3>

<p>
We easily see that \( A\leq 1 \). However, the \( A \) can be less than \( -1 \),
which will lead
to growth of a numerical wave component. The criterion \( A\geq -1 \) implies

$$ 4F\sin^2 (p/2)\leq 2
\tp
$$

The worst case is when \( \sin^2 (p/2)=1 \), so a sufficient criterion for
stability is

$$
\begin{equation}
F\leq {\half},
\tag{3.57}
\end{equation}
$$

or expressed as a condition on \( \Delta t \):

$$
\begin{equation}
\Delta t\leq \frac{\Delta x^2}{2\dfc}\tp
\tag{3.58}
\end{equation}
$$

Note that halving the spatial mesh size, \( \Delta x \rightarrow {\half}
\Delta x \), requires \( \Delta t \) to be reduced by a factor of \( 1/4 \).
The method hence becomes very expensive for fine spatial meshes.

<p>
<!-- 2DO: verification based on exact solutions -->

<h3 id="___sec290">Accuracy </h3>

<p>
Since \( A \) is expressed in terms of \( F \) and the parameter we now call
\( p=k\Delta x/2 \), we should also express \( \Aex \) by \( F \) and \( p \). The exponent
in \( \Aex \) is \( -\dfc k^2\Delta t \), which equals \( -F k^2\Delta x^2=-F4p^2 \).
Consequently,

$$ \Aex = \exp{(-\dfc k^2\Delta t)} = \exp{(-4Fp^2)}
\tp $$

All our \( A \) expressions as well as \( \Aex \) are now functions of the two
dimensionless parameters \( F \) and \( p \).

<p>
Computing
the Taylor series expansion of \( A/\Aex \) in terms of \( F \)
can easily be done with aid of <code>sympy</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_exact</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-4*</span>F<span style="color: #666666">*</span>p<span style="color: #666666">**2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">A_FE</span>(F, p):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">1</span> <span style="color: #666666">-</span> <span style="color: #666666">4*</span>F<span style="color: #666666">*</span>sin(p)<span style="color: #666666">**2</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
F, p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;F p&#39;</span>)
A_err_FE <span style="color: #666666">=</span> A_FE(F, p)<span style="color: #666666">/</span>A_exact(F, p)
<span style="color: #008000; font-weight: bold">print</span> A_err_FE<span style="color: #666666">.</span>series(F, <span style="color: #666666">0</span>, <span style="color: #666666">6</span>)
</pre></div>
<p>
The result is

$$ \frac{A}{\Aex} = 1 - 4 F \sin^{2}p + 2F p^{2} - 16F^{2} p^{2} \sin^{2}p + 8 F^{2} p^{4} + \cdots
$$

Recalling that \( F=\dfc\Delta t/\Delta x \), \( p=k\Delta x/2 \), and that
\( \sin^2p\leq 1 \), we
realize that the dominating terms in \( A/\Aex \) are at most

$$ 1 - 4\dfc \frac{\Delta t}{\Delta x^2} +
\dfc\Delta t - 4\dfc^2\Delta t^2
+ \dfc^2 \Delta t^2\Delta x^2 + \cdots
\tp
$$

<h2 id="diffu:pde1:analysis:BE">Analysis of the Backward Euler scheme</h2>

<p>
Discretizing \( u_t = \dfc u_{xx} \) by a Backward Euler scheme,

$$
\begin{equation*} [D_t^- u = \dfc D_xD_x u]^n_q,\end{equation*}
$$

and inserting a wave component <a href="#mjx-eqn-3.53">(3.53)</a>,
leads to calculations similar to those arising from the Forward Euler scheme,
but since

$$ e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},$$

we get

$$
\begin{equation*}
\frac{1-A^{-1}}{\Delta t} = -\dfc \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),
\end{equation*}
$$

and then

$$
\begin{equation}
A = \left(1  + 4F\sin^2p\right)^{-1}
\tag{3.59}
\tp
\end{equation}
$$

The complete numerical solution can be written

$$
\begin{equation}
u^n_q = \left(1  + 4F\sin^2 p\right)^{-n}
e^{ikq\Delta x} \tp
\tag{3.60}
\end{equation}
$$

<h3 id="___sec292">Stability </h3>

<p>
We see from <a href="#mjx-eqn-3.59">(3.59)</a> that \( 0 < A < 1 \), which means
that all numerical wave components are stable and non-oscillatory
for any \( \Delta t >0 \).

<h2 id="diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</h2>

<p>
The Crank-Nicolson scheme can be written as

$$ [D_t u = \dfc D_xD_x \overline{u}^x]^{n+\half}_q, $$

or

$$ [D_t u]^{n+\half}_q = \half\dfc\left( [D_xD_x u]^{n}_q +
[D_xD_x u]^{n+1}_q\right)
\tp
$$

Inserting <a href="#mjx-eqn-3.53">(3.53)</a> in the time derivative approximation
leads to

$$ [D_t A^n e^{ikq\Delta x}]^{n+\half} = A^{n+\half} e^{ikq\Delta x}\frac{A^{\half}-A^{-\half}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
\tp $$

Inserting <a href="#mjx-eqn-3.53">(3.53)</a> in the other terms
and dividing by
\( A^ne^{ikq\Delta x} \) gives the relation

$$
\frac{A-1}{\Delta t} = -\half\dfc\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)
(1 + A),
$$

and after some more algebra,

$$
\begin{equation}
A = \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}
\tp
\tag{3.61}
\end{equation}
$$

The exact numerical solution is hence

$$
\begin{equation}
u^n_q = \left(\frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\right)^ne^{ikp\Delta x}
\tp
\tag{3.62}
\end{equation}
$$

<h3 id="___sec294">Stability </h3>

<p>
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \).
Therefore, the solution cannot grow, but it will oscillate if
\( 1-2F\sin^p < 0 \). To avoid such non-physical oscillations, we must demand
\( F\leq\half \).

<h2 id="___sec295">Summary of accuracy of amplification factors </h2>

<p>
We can plot the various amplification factors against \( p=k\Delta x/2 \)
for different choices of the \( F \) parameter. Figures
<a href="#diffu:pde1:fig:A:err:C20">43</a>, <a href="#diffu:pde1:fig:A:err:C0.5">44</a>, and
<a href="#diffu:pde1:fig:A:err:C0.1">45</a> show how long and small waves are
damped by the various schemes compared to the exact damping. As long
as all schemes are stable, the amplification factor is positive,
except for Crank-Nicolson when \( F>0.5 \).

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C20"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 43:  Amplification factors for large time steps.  <!-- caption label: diffu:pde1:fig:A:err:C20 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F20_F2.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C0.5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 44:  Amplification factors for time steps around the Forward Euler stability limit.  <!-- caption label: diffu:pde1:fig:A:err:C0.5 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F05_F025.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:pde1:fig:A:err:C0.1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 45:  Amplification factors for small time steps.  <!-- caption label: diffu:pde1:fig:A:err:C0.1 --> </p></center>
<p><img src="fig-diffu/diffusion_A_F01_F001.png" align="bottom" width=800></p>
</center>

<p>
The effect of negative amplification factors is that \( A^n \) changes
sign from one time level to the next, thereby giving rise to
oscillations in time in an animation of the solution. We see from
Figure <a href="#diffu:pde1:fig:A:err:C20">43</a> that for \( F=20 \), waves with
\( p\geq \pi/2 \) undergo a damping close to \( -1 \), which means that the
amplitude does not decay and that the wave component jumps up and down
(flips amplitude)
in time. For \( F=2 \) we have a damping of a factor of 0.5 from one time
level to the next, which is very much smaller than the exact
damping. Short waves will therefore fail to be effectively dampened.
These waves will manifest themselves as high frequency oscillatory
noise in the solution.

<p>
A value \( p=\pi/4 \) corresponds to four mesh points per wave length of
\( e^{ikx} \), while \( p=\pi/2 \) implies only two points per wave length,
which is the smallest number of points we can have to represent the
wave on the mesh.

<p>
To demonstrate the oscillatory behavior of the Crank-Nicolson scheme, we
choose an initial condition that leads to short waves with
significant amplitude. A discontinuous \( I(x) \) will in particular serve
this purpose.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 13</b>: Run example!!)</font>
<!-- end inline comment -->

<h2 id="diffu:2D:analysis">Analysis of the 2D diffusion equation</h2>

<p>
We first consider the 2D diffusion equation

$$ u_{t} = \dfc(u_{xx} + u_{yy}),$$

which has Fourier component solutions of the form

$$ u(x,y,t) = Ae^{-\dfc k^2t}e^{i(k_x x + k_yy)},$$

and the schemes have discrete versions of this Fourier component:

$$ u^{n}_{q,r} = A\xi^{n}e^{i(k_x q\Delta x + k_y r\Delta y)}\tp$$

<h3 id="___sec297">The Forward Euler scheme </h3>

<p>
For the Forward Euler discretization,

$$ [D_t^+u = \dfc(D_xD_x u + D_yD_y u)]_{i,j}^n,$$

we get

$$
\frac{\xi - 1}{\Delta t}
=
-\dfc\frac{4}{\Delta x^2}\sin^2\left(\frac{k_x\Delta x}{2}\right) -
\dfc\frac{4}{\Delta y^2}\sin^2\left(\frac{k_y\Delta y}{2}\right)\tp
$$

Introducing

$$ p_x = \frac{k_x\Delta x}{2},\quad p_y = \frac{k_y\Delta y}{2},$$

we can write the equation for \( \xi \) more compactly as

$$
\frac{\xi - 1}{\Delta t}
=
-\dfc\frac{4}{\Delta x^2}\sin^2 p_x -
\dfc\frac{4}{\Delta y^2}\sin^2 p_y,
$$

and solve for \( \xi \):

$$
\begin{equation}
\xi = 1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y\tp
\tag{3.63}
\end{equation}
$$

<p>
The complete numerical solution for a wave component is

$$
\begin{equation}
u^{n}_{q,r} = A(1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y)^n
e^{i(k_xp\Delta x + k_yq\Delta y)}\tp
\tag{3.64}
\end{equation}
$$

<p>
For stability we demand \( -1\leq\xi\leq 1 \), and \( -1\leq\xi \) is the
critical limit, since clearly \( \xi \leq 1 \), and the worst case
happens when the sines are at their maximum. The stability criterion
becomes

$$
\begin{equation}
F_x + F_y \leq \half\tp
\tag{3.65}
\end{equation}
$$

For the special, yet common, case \( \Delta x=\Delta y=h \), the
stability criterion can be written as

$$ \Delta t \leq \frac{h^2}{2d\dfc},$$

where \( d \) is the number of space dimensions: \( d=1,2,3 \).

<h3 id="___sec298">The Backward Euler scheme </h3>

<p>
The Backward Euler method,

$$ [D_t^-u = \dfc(D_xD_x u + D_yD_y u)]_{i,j}^n,$$

results in

$$ 1 - \xi^{-1} = - 4F_x \sin^2 p_x - 4F_y \sin^2 p_y, $$

and

$$ \xi = (1 + 4F_x \sin^2 p_x + 4F_y \sin^2 p_y)^{-1},$$

which is always in \( (0,1] \). The solution for a wave component becomes

$$
\begin{equation}
u^{n}_{q,r} = A(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n}
e^{i(k_xq\Delta x + k_yr\Delta y)}\tp
\tag{3.66}
\end{equation}
$$

<h3 id="___sec299">The Crank-Nicolson scheme </h3>

<p>
With a Crank-Nicolson discretization,

$$ [D_tu]^{n+\half}_{i,j} =
\half [\dfc(D_xD_x u + D_yD_y u)]_{i,j}^{n+1} +
\half [\dfc(D_xD_x u + D_yD_y u)]_{i,j}^n,$$

we have, after some algebra,

$$ \xi = \frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}\tp$$

The fraction on the right-hand side is always less than 1, so stability
in the sense of non-growing wave components is guaranteed for all
physical and numerical parameters. However,
the fraction can become negative and result in non-physical
oscillations. This phenomenon happens when

$$ F_x\sin^2 p_x + F_x\sin^2p_y > \half\tp$$

A criterion against non-physical oscillations is therefore

$$ F_x + F_y \leq \half, $$

which is the same limit as the stability criterion for the Forward Euler
scheme.

<p>
The exact discrete solution is

$$
\begin{equation}
u^{n}_{q,r} = A
\left(
\frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
\right)^n
e^{i(k_xq\Delta x + k_yr\Delta y)}\tp
\tag{3.67}
\end{equation}
$$

<h2 id="___sec300">Explanation of numerical artifacts </h2>

<p>
The behavior of the Forward Euler discretization in time (and centered
differences in space) is summarized at the end of
the section <a href="#diffu:pde1:FE:experiments">Numerical experiments</a>. Can we from the analysis
above explain the behavior?

<p>
We may start by looking at Figure <a href="#diffu:pde1:FE:fig:F=0.51">37</a>
where \( F=0.51 \). The figure shows that the solution is unstable and
grows in time. The stability limit for such growth is \( F=0.5 \) and
since the \( F \) in this simulation is slightly larger, growth is
unavoidable.

<p>
Figure <a href="#diffu:pde1:FE:fig:F=0.5">35</a> has unexpected features:
we would expect the solution of the diffusion equation to be
smooth, but the graphs in Figure <a href="#diffu:pde1:FE:fig:F=0.5">35</a>
contain non-smooth noise. Turning to Figure
<a href="#diffu:pde1:FE:fig:gauss:F=0.5">38</a>,  which has a quite similar
initial condition, we see that the curves are indeed smooth.
The problem with the results in Figure <a href="#diffu:pde1:FE:fig:F=0.5">35</a>
is that the initial condition is discontinuous. To represent it, we
need a significant amplitude on the shortest waves in the mesh.
However, for \( F=0.5 \), the shortest wave (\( p=\pi/2 \)) gives
the amplitude in the numerical solution as \( (1-4F)^n \), which oscillates
between negative and positive values at subsequent time levels
for \( F>\frac{1}{4} \). Since the shortest waves have visible amplitudes in
the solution profile, the oscillations becomes visible. The
smooth initial condition in Figure <a href="#diffu:pde1:FE:fig:gauss:F=0.5">38</a>,
on the other hand, lead to very small amplitudes of the shortest waves.
That these waves then oscillate in a non-physical way for
\( F=0.5 \) is not a visible effect. The oscillations
in time in the amplitude \( (1-4F)^n \) disappear for \( F\leq\frac{1}{4} \),
and that is why also the discontinuous initial condition leads to
always smooth solutions in Figure ref<a href="#diffu:pde1:FE:fig:F=0.25">36</a>, where
\( F=\frac{1}{4} \).

<p>
Turning the attention to the Backward Euler scheme and the experiments
in Figure <a href="#diffu:pde1:BE:fig:F=0.5">39</a>, we see that even the discontinuous
initial condition gives smooth solutions for \( F=0.5 \) (and in fact all other
\( F \) values). From the exact expression of the numerical amplitude,
\( (1  + 4F\sin^2p)^{-1} \), we realize that this factor can never flip between
positive and negative values, and no instabilities can occur. The conclusion
is that the Backward Euler scheme always produces smooth solutions.
Also, the Backward Euler scheme guarantees that the solution cannot grow
in time (unless we add a source term to the PDE, but that is meant to
represent a physically relevant growth).

<p>
Finally, we have some small, strange artifacts when simulating the
development of the initial plug profile with the Crank-Nicolson scheme,
see Figure <a href="#diffu:pde1:CN:fig:F=10">41</a>, where \( F=3 \).
The Crank-Nicolson scheme cannot give growing amplitudes, but it may
give oscillating amplitudes in time. The critical factor is
\( 1 - 2F\sin^2p \), which for the shortest waves (\( p=\pi/2 \)) indicates
a stability limit \( F=0.5 \). With the discontinuous initial condition, we have
enough amplitude on the shortest waves so their wrong behavior is visible,
and this is what we see as small instabilities in
Figure <a href="#diffu:pde1:CN:fig:F=10">41</a>. The only remedy is to lower the \( F \) value.

<h1 id="___sec301">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:gaussian:symmetric">Exercise 3.1: Explore symmetry in a 1D problem</h2>

<p>
This exercise simulates the exact solution <a href="#mjx-eqn-3.48">(3.48)</a>.
Suppose for simplicity that \( c=0 \).

<p>
<b>a)</b>
Formulate an initial-boundary value problem that has
<a href="#mjx-eqn-3.48">(3.48)</a> as solution in the domain \( [-L,L] \).
Use the exact solution <a href="#mjx-eqn-3.48">(3.48)</a> as Dirichlet
condition at the boundaries.
Simulate the diffusion of the Gaussian peak. Observe that the
solution is symmetric around \( x=0 \).

<p>
<b>b)</b>
Show from <a href="#mjx-eqn-3.48">(3.48)</a> that \( u_x(c,t)=0 \).
Since the solution is symmetric around \( x=c=0 \), we can solve the
numerical problem in half of the domain, using a <em>symmetry boundary condition</em>
\( u_x=0 \) at \( x=0 \). Set up the
initial-boundary value problem in this case. Simulate the
diffusion problem in \( [0,L] \) and compare with the solution in a).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_56_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_56_1">

$$
\begin{align*}
u_t &= \dfc u_xx,\\ 
u_x(0,t) &= 0,\\ 
u(L,t)& =\frac{1}{\sqrt{4\pi\dfc t}} \exp{\left({-\frac{x^2}{4\dfc t}}\right)}\tp
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>diffu_symmetric_gaussian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:ux:onesided">Exercise 3.2: Investigate approximation errors from a \( u_x=0 \) boundary condition</h2>

<p>
We consider the problem solved in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 3.1: Explore symmetry in a 1D problem</a>
part b). The boundary condition \( u_x(0,t)=0 \) can be implemented in
two ways: 1) by a standard symmetric finite difference \( [D_{2x}u]_i^n=0 \),
or 2) by a one-sided difference \( [D^+u=0]^n_i=0 \).
Investigate the effect of these two conditions on the
convergence rate in space.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_57_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_57_1">

<p>
If you use a Forward Euler scheme, choose a discretization parameter
\( h=\Delta t = \Delta x^2 \) and assume the error goes like \( E\sim h^r \).
The error in the scheme is \( \Oof{\Delta t,\Delta x^2} \) so one should
expect that the estimated \( r \) approaches 1. The question is if
a one-sided difference approximation to \( u_x(0,t)=0 \) destroys this
convergence rate.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>diffu_onesided_fd</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:1D:openBC">Exercise 3.3: Experiment with open boundary conditions in 1D</h2>

<p>
We address diffusion of a Gaussian function
as in <a href="#diffu:exer:1D:gaussian:symmetric">Exercise 3.1: Explore symmetry in a 1D problem</a>,
in the domain \( [0,L] \),
but now we shall explore different types of boundary
conditions on \( x=L \). In real-life problems we do not know
the exact solution on \( x=L \) and must use something simpler.

<p>
<b>a)</b>
Imagine that we want to solve the problem numerically on
\( [0,L] \), with a symmetry boundary condition \( u_x=0 \) at \( x=0 \),
but we do not know the exact solution and cannot of that
reason assign a correct Dirichlet condition at \( x=L \).
One idea is to simply set \( u(L,t)=0 \) since this will be an
accurate approximation before the diffused pulse reaches \( x=L \)
and even thereafter it might be a satisfactory condition if the exact \( u \) has
a small value.
Let \( \uex \) be the exact solution and let \( u \) be the solution
of \( u_t=\dfc u_{xx} \) with an initial Gaussian pulse and
the boundary conditions \( u_x(0,t)=u(L,t)=0 \). Derive a diffusion
problem for the error \( e=\uex - u \). Solve this problem
numerically using an exact Dirichlet condition at \( x=L \).
Animate the evolution of the error and make a curve plot of
the error measure

$$ E(t)=\sqrt{\frac{\int_0^L e^2dx}{\int_0^L udx}}\tp $$

Is this a suitable error measure for the present problem?

<p>
<b>b)</b>
Instead of using \( u(L,t)=0 \) as approximate boundary condition for
letting the diffused Gaussian pulse move out of our finite domain,
one may try \( u_x(L,t)=0 \) since the solution for large \( t \) is
quite flat. Argue that this condition gives a completely wrong
asymptotic solution as \( t\rightarrow 0 \). To do this,
integrate the diffusion equation from \( 0 \) to \( L \), integrate
\( u_{xx} \) by parts (or use Gauss' divergence theorem in 1D) to
arrive at the important property

$$ \frac{d}{dt}\int_{0}^L u(x,t)dx = 0,$$

implying that \( \int_0^Ludx \) must be constant in time, and therefore

$$ \int_{0}^L u(x,t)dx = \int_{0}^LI(x)dx\tp $$

The integral of the initial pulse is 1.

<p>
<b>c)</b>
Another idea for an artificial boundary condition at \( x=L \)
is to use a cooling law

$$
\begin{equation}
-\dfc u_x = q(u - u_S),
\tag{3.68}
\end{equation}
$$

where \( q \) is an unknown heat transfer coefficient and \( u_S \) is
the surrounding temperature in the medium outside of \( [0,L] \).
(Note that arguing that \( u_S \) is approximately \( u(L,t) \) gives
the \( u_x=0 \) condition from the previous subexercise that is
qualitatively wrong for large \( t \).)
Develop a diffusion problem for the error in the solution using
<a href="#mjx-eqn-3.68">(3.68)</a> as boundary condition.
Assume one can take \( u_S=0 \) &quot;outside the domain&quot; since
\( \uex\rightarrow 0 \) as \( x\rightarrow\infty \).
Find a function \( q=q(t) \) such that the exact solution
obeys the condition <a href="#mjx-eqn-3.68">(3.68)</a>.
Test some constant values of \( q \) and animate how the corresponding
error function behaves. Also compute \( E(t) \) curves as defined above.

<p>
Filename: <code>diffu_open_BC</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec305">Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D </h2>

<p>
<b>a)</b>
Generalize <a href="#mjx-eqn-3.48">(3.48)</a> to multi dimensions by
assuming that one-dimensional solutions can be multiplied to solve
\( u_t = \dfc\nabla^2 u \). Set \( c=0 \) such that the peak of
the Gaussian is at the origin.

<p>
<b>b)</b>
One can from the exact solution show
that \( u_x=0 \) on \( x=0 \), \( u_y=0 \) on \( y=0 \), and \( u_z=0 \) on \( z=0 \).
The approximately correct condition \( u=0 \) can be set
on the remaining boundaries (say \( x=L \), \( y=L \), \( z=L \)), cf. <a href="#diffu:exer:1D:openBC">Exercise 3.3: Experiment with open boundary conditions in 1D</a>.
Simulate a 2D case and make an animation of the diffused Gaussian peak.

<p>
<b>c)</b>
The formulation in b) makes use of symmetry of the solution such that we
can solve the problem in the first quadrant (2D) or octant (3D) only.
To check that the symmetry assumption is correct, formulate the problem
without symmetry in a domain \( [-L,L]\times [L,L] \) in 2D. Use \( u=0 \) as
approximately correct boundary condition. Simulate the same case as
in b), but in a four times as large domain. Make an animation and compare
it with the one in b).

<p>
Filename: <code>diffu_symmetric_gaussian_2D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:uterm">Exercise 3.5: Examine stability of a diffusion model with a source term</h2>

<p>
Consider a diffusion equation with a linear \( u \) term:

$$ u_t = \dfc u_{xx} + \beta u\tp$$

<p>
<b>a)</b>
Derive in detail a Forward Euler scheme, a Backward Euler scheme,
and a Crank-Nicolson for this type of diffusion model.
Thereafter, formulate a \( \theta \)-rule to summarize the three schemes.

<p>
<b>b)</b>
Assume a solution like <a href="#mjx-eqn-3.49">(3.49)</a> and find the relation
between \( a \), \( k \), \( \dfc \), and \( \beta \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_60_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_60_1">

<p>
Insert <a href="#mjx-eqn-3.49">(3.49)</a> in the PDE problem.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Calculate the stability of the Forward Euler scheme. Design
numerical experiments to confirm the results.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_60_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_60_2">

<p>
Insert the discrete counterpart to <a href="#mjx-eqn-3.49">(3.49)</a> in the
numerical scheme. Run experiments at the stability limit and slightly above.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat c) for the Backward Euler scheme.

<p>
<b>e)</b>
Repeat c) for the Crank-Nicolson scheme.

<p>
<b>f)</b>
How does the extra term \( bu \) impact the accuracy of the three schemes?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_60_3" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_60_3">

<p>
For analysis of the accuracy,
compare the numerical and exact amplification factors, in
graphs and/or by Taylor series expansion.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>diffu_stability_uterm</code>.

<p>
<!-- --- end exercise --- -->

<h1 id="diffu:varcoeff">Diffusion in heterogeneous media</h1>

<p>
Diffusion in heterogeneous media normally implies a non-constant
diffusion coefficient \( \alpha = \alpha (x) \).
A 1D diffusion model with such a variable diffusion coefficient reads

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\frac{\partial}{\partial x}\left( \alpha (x) \frac{\partial u}{\partial x^2}
\right) + f(x,t), \quad &x\in (0,L),\ t\in (0,T],
\tag{3.69}\\ 
u(x,0) &= I(x), \quad  &x\in [0,L],
\tag{3.70}\\ 
u(0,t) & = U_0, \quad  &t>0,
\tag{3.71}\\ 
u(L,t) & = U_L, \quad  &t>0.
\tag{3.72}
\end{align}
$$

A short form of the diffusion equation with variable coefficients is
\( u_t = (\alpha u_x)_x \).

<h2 id="diffu:varcoeff:discr">Discretization</h2>

<p>
We can discretize <a href="#mjx-eqn-3.69">(3.69)</a> by a \( \theta \)-rule in time
and centered differences in space:

$$ \lbrack D_t u\rbrack^{n+\half} = \theta\lbrack D_x\overline{\dfc}^x
D_x u + f\rbrack^{n+1} +
(1-\theta)\lbrack D_x\overline{\dfc}^x
D_x u + f\rbrack^{n}\tp$$

Written out, this becomes

$$
\begin{align*}
\frac{u^{n+1}-u^{n}}{\Delta t} &=
\theta\frac{1}{\Delta x^2}
(\dfc_{i+\half}(u^{n+1}_{i+1} - u^{n+1}_{i})
- \dfc_{i-\half}(u^{n+1}_i - u^{n+1}_{i+1})) +\\ 
&\quad (1-\theta)\frac{1}{\Delta x^2}
(\dfc_{i+\half}(u^{n}_{i+1} - u^{n}_{i})
- \dfc_{i-\half}(u^{n}_i - u^{n}_{i+1})) +\\ 
&\quad \theta f_i^{n+1} + (1-\theta)f_i^{n},
\end{align*}
$$

where, e.g., an arithmetic mean can to be used for \( \dfc_{i+\half} \):

$$ \dfc_{i+\half} = \half(\dfc_i + \dfc_{i+1})\tp$$

<h2 id="diffu:varcoeff:impl">Implementation</h2>

<p>
Suitable code for solving the discrete equations is very similar to
what we created for a constant \( \dfc \).
Since the Fourier number has no meaning for varying
\( \dfc \), we introduce a related parameter \( D=\Delta t /\Delta x^2 \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_theta</span>(I, a, L, Nx, D, T, theta<span style="color: #666666">=0.5</span>, u_L<span style="color: #666666">=1</span>, u_R<span style="color: #666666">=0</span>,
                 user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>):
    x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, L, Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in space</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dt <span style="color: #666666">=</span> D<span style="color: #666666">*</span>dx<span style="color: #666666">**2</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>

    u   <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution array at t[n+1]</span>
    u_1 <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># solution at t[n]</span>

    Dl <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>theta
    Dr <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>D<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>theta)

    <span style="color: #408080; font-style: italic"># Representation of sparse matrix and right-hand side</span>
    diagonal <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)
    lower    <span style="color: #666666">=</span> zeros(Nx)
    upper    <span style="color: #666666">=</span> zeros(Nx)
    b        <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Precompute sparse matrix (scipy format)</span>
    diagonal[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> <span style="color: #666666">2*</span>a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[:<span style="color: #666666">-2</span>])
    lower[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[:<span style="color: #666666">-2</span>])
    upper[<span style="color: #666666">1</span>:]  <span style="color: #666666">=</span> <span style="color: #666666">-</span>Dl<span style="color: #666666">*</span>(a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
    <span style="color: #408080; font-style: italic"># Insert boundary conditions</span>
    diagonal[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    upper[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    diagonal[Nx] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    lower[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
        diagonals<span style="color: #666666">=</span>[diagonal, lower, upper],
        offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>],
        shape<span style="color: #666666">=</span>(Nx<span style="color: #666666">+1</span>, Nx<span style="color: #666666">+1</span>),
        format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)

    <span style="color: #408080; font-style: italic"># Set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Nx<span style="color: #666666">+1</span>):
        u_1[i] <span style="color: #666666">=</span> I(x[i])

    <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
        user_action(u_1, x, t, <span style="color: #666666">0</span>)

    <span style="color: #408080; font-style: italic"># Time loop</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        b[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> Dr<span style="color: #666666">*</span>(
            (a[<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">*</span>(u_1[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">-</span>
            (a[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> a[<span style="color: #666666">0</span>:<span style="color: #666666">-2</span>])<span style="color: #666666">*</span>(u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> u_1[:<span style="color: #666666">-2</span>]))
        <span style="color: #408080; font-style: italic"># Boundary conditions</span>
        b[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> u_L(t[n<span style="color: #666666">+1</span>])
        b[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_R(t[n<span style="color: #666666">+1</span>])
        <span style="color: #408080; font-style: italic"># Solve</span>
        u[:] <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

        <span style="color: #008000; font-weight: bold">if</span> user_action <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">None</span>:
            user_action(u, x, t, n<span style="color: #666666">+1</span>)

        <span style="color: #408080; font-style: italic"># Switch variables before next step</span>
        u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>
<p>
The code is found in the file <a href="http://tinyurl.com/nm5587k/diffu/diffu1D_vc.py" target="_self"><tt>diffu1D_vc.py</tt></a>.

<h2 id="diffu:varcoeff:stationary">Stationary solution</h2>

<p>
As \( t\rightarrow\infty \), the solution of the
problem <a href="#mjx-eqn-3.69">(3.69)</a>-<a href="#mjx-eqn-3.72">(3.72)</a>
will approach
a stationary limit where \( \partial u/\partial t=0 \). The governing
equation is then

$$
\begin{equation}
\frac{d}{dx}\left(\alpha\frac{du}{dx}\right) =0,
\tag{3.73}
\end{equation}
$$

with boundary conditions \( u(0)=U_0 \) and \( u(L)=u_L \).
It is possible to obtain an exact solution of <a href="#mjx-eqn-3.73">(3.73)</a>
for any \( \alpha \). Integrating twice and applying the boundary conditions
to determine the integration constants gives

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)\frac{\int_0^x (\alpha(\xi))^{-1}d\xi}{\int_0^L (\alpha(\xi))^{-1}d\xi}
\tp
\tag{3.74}
\end{equation}
$$

<h2 id="diffu:varcoeff:piecewise">Piecewise constant medium</h2>

<p>
Consider a medium built of \( M \) layers. The boundaries between the
layers are denoted by \( b_0, \ldots, b_M \),
where \( b_0=0 \) and \( b_M=L \).
If the material in each layer potentially differs from the others, but
is otherwise constant, we can express \( \alpha \) as a
<em>piecewise constant function</em> according to

$$
\begin{equation}
\alpha (x) = \left\lbrace\begin{array}{ll}
\alpha_0,& b_0 \leq x < b_1,\\ 
\vdots &\\ 
\alpha_i,& b_i \leq x < b_{i+1},\\ 
\vdots &\\ 
\alpha_0,& b_{M-1} \leq x \leq b_M.
\end{array}\right.
\end{equation}
\tag{3.75}
$$

<p>
The exact solution <a href="#mjx-eqn-3.74">(3.74)</a> in case of such a
piecewise constant \( \alpha \) function is easy to derive. Assume that
\( x \) is in the \( m \)-th layer: \( x\in [b_m, b_{m+1}] \). In the integral
\( \int_0^x (a(\xi))^{-1}d\xi \) we must integrate through the first
\( m-1 \) layers and then add the contribution from the remaining part
\( x-b_m \) into the \( m \)-th layer:

$$
\begin{equation}
u(x) = U_0 + (U_L-U_0)
\frac{\sum_{j=0}^{m-1} (b_{j+1}-b_j)/\alpha(b_j) + (x-b_m)/\alpha(b_m)}{\sum_{j=0}^{M-1} (b_{j+1}-b_j)/\alpha(b_j)}
\tag{3.76}
\end{equation}
$$

<p>
<b>Remark.</b>
It may sound strange to have a discontinuous \( \alpha \) in a differential
equation where one is to differentiate, but a discontinuous \( \alpha \)
is compensated by a discontinuous \( u_x \) such that \( \alpha u_x \) is
continuous and therefore can be differentiated as \( (\alpha u_x)_x \).

<h2 id="diffu:varcoeff:impl:piecewise">Implementation of diffusion in a piecewise constant medium</h2>

<p>
Programming with piecewise function definition quickly becomes
cumbersome as the most naive approach is to test for which interval
\( x \) lies, and then start evaluating a formula like
<a href="#mjx-eqn-3.76">(3.76)</a>. In Python, vectorized expressions may
help to speed up the computations.
The convenience classes <code>PiecewiseConstant</code> and
<code>IntegratedPiecewiseConstant</code> in the <a href="http://tinyurl.com/nm5587k/diffu/Heaviside.py" target="_self"><tt>Heaviside</tt></a>
module were made to simplify programming with
functions like <a href="#mjx-eqn-3.75">(3.75)</a> and expressions like
<a href="#mjx-eqn-3.76">(3.76)</a>. These utilities not only represent
piecewise constant functions, but also <em>smoothed</em> versions of them
where the discontinuities can be smoothed out in a controlled fashion.
This is advantageous in many computational contexts (although seldom
for pure finite difference computations of the solution \( u \)).

<p>
The <code>PiecewiseConstant</code> class is created by sending in the domain as a
2-tuple or 2-list and a <code>data</code> object describing the boundaries
\( b_0,\ldots,b_M \) and the corresponding function values
\( \alpha_0,\ldots,\alpha_{M-1} \). More precisely, <code>data</code> is a nested
list, where <code>data[i][0]</code> holds \( b_i \) and <code>data[i][1]</code> holds the
corresponding value \( \alpha_i \), for \( i=0,\ldots,M-1 \). Given \( b_i \) and
\( \alpha_i \) in arrays <code>b</code> and <code>a</code>, it is easy to fill out the nested
list <code>data</code>.

<p>
In our application, we want to represent \( \alpha \) and \( 1/\alpha \)
as piecewise constant function, in addition to the \( u(x) \) function
which involves the integrals of \( 1/\alpha \). A class creating the
functions we need and a method for evaluating \( u \), can take the
form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    b: coordinates of boundaries of layers, b[0] is left boundary</span>
<span style="color: #BA2121; font-style: italic">    and b[-1] is right boundary of the domain [0,L].</span>
<span style="color: #BA2121; font-style: italic">    a: values of the functions in each layer (len(a) = len(b)-1).</span>
<span style="color: #BA2121; font-style: italic">    U_0: u(x) value at left boundary x=0=b[0].</span>
<span style="color: #BA2121; font-style: italic">    U_L: u(x) value at right boundary x=L=b[0].</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, a, b, U_0, U_L, eps<span style="color: #666666">=0</span>):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a, <span style="color: #008000">self</span><span style="color: #666666">.</span>b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(a), np<span style="color: #666666">.</span>asarray(b)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">=</span> eps  <span style="color: #408080; font-style: italic"># smoothing parameter for smoothed a</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0, <span style="color: #008000">self</span><span style="color: #666666">.</span>U_L <span style="color: #666666">=</span> U_0, U_L

        a_data <span style="color: #666666">=</span> [[bi, ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        domain <span style="color: #666666">=</span> [b[<span style="color: #666666">0</span>], b[<span style="color: #666666">-1</span>]]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func <span style="color: #666666">=</span> PiecewiseConstant(domain, a_data, eps)

        <span style="color: #408080; font-style: italic"># inv_a = 1/a is needed in formulas</span>
        inv_a_data <span style="color: #666666">=</span> [[bi, <span style="color: #666666">1./</span>ai] <span style="color: #008000; font-weight: bold">for</span> bi, ai <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(<span style="color: #008000">self</span><span style="color: #666666">.</span>b, <span style="color: #008000">self</span><span style="color: #666666">.</span>a)]
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_func <span style="color: #666666">=</span> \ 
             PiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func <span style="color: #666666">=</span> \ 
             IntegratedPiecewiseConstant(domain, inv_a_data, eps)
        <span style="color: #408080; font-style: italic"># Denominator in the exact formula is constant</span>
        <span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(b[<span style="color: #666666">-1</span>])

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, x):
        solution <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>U_0 <span style="color: #666666">+</span> (<span style="color: #008000">self</span><span style="color: #666666">.</span>U_L<span style="color: #666666">-</span><span style="color: #008000">self</span><span style="color: #666666">.</span>U_0)<span style="color: #666666">*</span>\ 
                   <span style="color: #008000">self</span><span style="color: #666666">.</span>integral_of_inv_a_func(x)<span style="color: #666666">/</span><span style="color: #008000">self</span><span style="color: #666666">.</span>inv_a_0L
        <span style="color: #008000; font-weight: bold">return</span> solution
</pre></div>
<p>
A visualization method is also convenient to have. Below we plot \( u(x) \)
along with \( \alpha (x) \) (which works well as long as \( \max \alpha(x) \)
is of the same size as \( \max u = \max(U_0,U_L) \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">SerialLayers</span>:
    <span style="color: #666666">...</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot</span>(<span style="color: #008000">self</span>):
        x, y_a <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>a_func<span style="color: #666666">.</span>plot()
        x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(x); y_a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(y_a)
        y_u <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>u_exact(x)
        <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
        plt<span style="color: #666666">.</span>figure()
        plt<span style="color: #666666">.</span>plot(x, y_u, <span style="color: #BA2121">&#39;b&#39;</span>)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)  <span style="color: #408080; font-style: italic"># Matlab style</span>
        plt<span style="color: #666666">.</span>plot(x, y_a, <span style="color: #BA2121">&#39;r&#39;</span>)
        ymin <span style="color: #666666">=</span> <span style="color: #666666">-0.1</span>
        ymax <span style="color: #666666">=</span> <span style="color: #666666">1.2*</span><span style="color: #008000">max</span>(y_u<span style="color: #666666">.</span>max(), y_a<span style="color: #666666">.</span>max())
        plt<span style="color: #666666">.</span>axis([x[<span style="color: #666666">0</span>], x[<span style="color: #666666">-1</span>], ymin, ymax])
        plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;solution $u$&#39;</span>, <span style="color: #BA2121">&#39;coefficient $a$&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper left&#39;</span>)
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
            plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Smoothing eps: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>eps)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>)
        plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
        plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Figure <a href="#diffu:fd2:pde:st:sol:pc:fig1">46</a> shows the case where

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">b <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>]   <span style="color: #408080; font-style: italic"># material boundaries</span>
a <span style="color: #666666">=</span> [<span style="color: #666666">0.2</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">4</span>]       <span style="color: #408080; font-style: italic"># material values</span>
U_0 <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>;  U_L <span style="color: #666666">=</span> <span style="color: #666666">5</span>     <span style="color: #408080; font-style: italic"># boundary conditions</span>
</pre></div>
<p>
<center> <!-- figure label: --> <div id="diffu:fd2:pde:st:sol:pc:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 46:  Solution of the stationary diffusion equation corresponding to a piecewise constant diffusion coefficient.  <!-- caption label: diffu:fd2:pde:st:sol:pc:fig1 --> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1.png" align="bottom" width=400></p>
</center>

<p>
By adding the <code>eps</code> parameter to the constructor of the <code>SerialLayers</code>
class, we can experiment with smoothed versions of \( \alpha \) and see
the (small) impact on \( u \). Figure <a href="#diffu:fd2:pde:st:sol:pc:fig2">47</a>
shows the result.

<p>
<center> <!-- figure label: --> <div id="diffu:fd2:pde:st:sol:pc:fig2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 47:  Solution of the stationary diffusion equation corresponding to a <em>smoothed</em> piecewise constant diffusion coefficient.  <!-- caption label: diffu:fd2:pde:st:sol:pc:fig2 --> </p></center>
<p><img src="fig-diffu/flow_in_layers_case1_eps.png" align="bottom" width=400></p>
</center>

<h2 id="diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</h2>

<p>
Suppose we have a diffusion process taking care in a straight tube
with radius \( R \). We assume axi-symmetry such that \( u \) is just a
function of \( r \) and \( t \). A model problem is

$$
\begin{align}
\frac{\partial u}{\partial t} &= \frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc(r)\frac{\partial u}{\partial r}\right) + f(t), & r\in (0,R),\ t\in (0,T],
\tag{3.77}\\ 
\frac{\partial u}{\partial r}(0,t) &= 0, & t\in (0,T],
\tag{3.78}\\ 
u(R,t) &= 0, & t\in (0,T],
\tag{3.79}\\ 
u(r,0) &= I(r), & r\in [0,R].
\tag{3.80}
\end{align}
$$

The condition <a href="#mjx-eqn-3.78">(3.78)</a> is a necessary symmetry condition
at \( r=0 \), while <a href="#mjx-eqn-3.79">(3.79)</a> could be any Dirichlet
or Neumann condition (or Robin condition in case of cooling or heating).

<p>
The finite difference approximation at \( r=0 \) of the spatial derivative term
is the only new challenge in this problem. Let us in case of
constant \( \dfc \) expand the derivative to

$$ \frac{\partial^2 u}{\partial r^2} + \frac{1}{r}\frac{\partial u}{\partial r}\tp$$

The last term faces a difficulty at \( r=0 \) since it becomes a \( 0/0 \) expression
because of the symmetry condition.
L'Hosptial's rule can be used:

$$ \lim_{r\rightarrow 0} \frac{1}{r}\frac{\partial u}{\partial r}
= \lim_{r\rightarrow 0} \frac{\partial^2 u}{\partial r^2}\tp$$

The PDE at \( r=0 \) therefore becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = 2\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{3.81}
\end{equation}
$$

For a variable coefficient \( \dfc(r) \) the expanded derivative reads

$$ \dfc(r)\frac{\partial^2 u}{\partial r^2} +
\frac{1}{r}(\dfc(r) + r\dfc'(r))\frac{\partial u}{\partial r}\tp$$

We have that the <a href="https://en.wikibooks.org/wiki/Calculus/Proofs_of_Some_Basic_Limit_Rules" target="_self">limit of a product</a> is

$$ \lim_{r\rightarrow 0}
\frac{1}{r}(\dfc(r) + r\dfc'(r))\frac{\partial u}{\partial r} =
\lim_{r\rightarrow 0} (\dfc(r) + r\dfc'(r))\ 
\lim_{x\rightarrow c}
\frac{1}{r}\frac{\partial u}{\partial r}\tp
$$

The second limit becomes as above, so the PDE at \( r=0 \),
assuming \( (\dfc(0) + r\dfc'(0))\neq 0 \),
looks like

$$
\begin{equation}
\frac{\partial u}{\partial t} = (2\dfc + r\dfc')
\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{3.82}
\end{equation}
$$

<p>
The second-order derivative is discretized in the usual way.
Consider first constant \( \dfc \):

$$ 2\dfc\frac{\partial^2}{\partial r^2}u(r_0,t_n) \approx
[2\dfc 2D_rD_r u]^n_0 =
2\dfc \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}\tp$$

The fictitious value \( u^n_{-1} \) can be eliminated using the discrete
symmetry condition

$$ [D_{2r} u =0]^n_0 \quad\Rightarrow\quad u^n_{-1} = u^n_1,$$

which then gives the modified approximation to the second-order derivative
of \( u \) in \( r \) at \( r=0 \):

$$
\begin{equation}
4\dfc \frac{u^{n}_{1} - u^{n}_0}{\Delta r^2}\tp
\tag{3.83}
\end{equation}
$$

With variable \( \dfc \) we simply get

$$(2\dfc + r\dfc')2D_rD_r u]^n_0 =
(2\dfc(0) + r\dfc'(0)) \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}\tp$$

<p>
The discretization of the second-order derivative in \( r \) at another
internal mesh point is straightforward:

$$
\left.\frac{1}{r}\frac{\partial}{\partial r}
\left(r\dfc\frac{\partial u}{\partial r}\right)\right\vert_{r=r_i}^{t=t_n}
\approx [r^{-1} D_r (r \dfc D_r u)]_i^n
= \frac{1}{\Delta r^2}\left(
r_{i+\half}\dfc_{i+\half}(u_{i+1}^n - u_i^n) - r_{i-\half}\dfc_{i-\half}(u_{i}^n - u_{i-1}^n)\right)\tp
$$

<p>
\( \theta \)-rule in time...

<h2 id="diffu:fd2:spherical">Diffusion equation in spherically-symmetric geometries</h2>

<h3 id="___sec315">Discretization in spherical coordinates </h3>

<p>
Let us now pose the problem from the section <a href="#diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</a>
in spherical coordinates, where \( u \) only depends on the radial coordinate
\( r \) and time \( t \). That is, we have spherical symmetry.
For simplicity we restrict the diffusion coefficient \( \dfc \) to be
a constant. The PDE reads

$$
\begin{equation}
\frac{\partial u}{\partial t} = \frac{\dfc}{r^\gamma}\frac{\partial}{\partial r}
\left(r^\gamma\frac{\partial u}{\partial r}\right) + f(t),
\tag{3.84}
\end{equation}
$$

for \( r\in (0,R) \) and \( t\in (0,T] \). The parameter \( \gamma \) is 2 for
spherically-symmetric problems and 1 for axi-symmetric problems.
The boundary and initial conditions
have the same mathematical form as
in <a href="#mjx-eqn-3.77">(3.77)</a>-<a href="#mjx-eqn-3.80">(3.80)</a>.

<p>
Since the PDE in spherical coordinates has the same form as the PDE
in the section <a href="#diffu:fd2:radial">Diffusion equation in axi-symmetric geometries</a>, just with the \( \gamma \) parameter
being different, we can use the same discretization approach.
At the origin \( r=0 \) we get problems with the term

$$ \frac{\gamma}{r}\frac{\partial u}{\partial t},$$

but L'Hosptial's rule shows that this term equals \( \gamma\partial^2 u/
\partial r^2 \), and the PDE at \( r=0 \) becomes

$$
\begin{equation}
\frac{\partial u}{\partial t} = (\gamma+1)\dfc\frac{\partial^2 u}{\partial r^2}
+ f(t)\tp
\tag{3.85}
\end{equation}
$$

The associated discrete form is then

$$
\begin{equation}
[D_t u = \half (\gamma+1)\dfc([D_rD_r \overline{u}^t + \overline{f}^t]^n_i,
\tag{3.86}
\end{equation}
$$

for a Crank-Nicolson scheme.

<h3 id="___sec316">Discretization in Cartesian coordinates </h3>

<p>
The spherically-symmetric spatial derivative can be transformed to
the Cartesian counterpart by introducing

$$ v(r,t) = ru(r,t)\tp$$

Inserting \( u=v/r \) in the PDE yields

$$ \frac{1}{r^2}\frac{\partial}{\partial r}
\left(\dfc(r)r^2\frac{\partial u}{\partial r}\right), $$

and then

$$ r\left(\frac{d c^2}{dr}\frac{\partial v}{\partial r} +
\dfc\frac{\partial^2 v}{\partial r^2}\right) - \frac{d c^2}{dr}v
\tp
$$

The two terms in the parenthesis can be combined to
$$ r\frac{\partial}{\partial r}\left( \dfc\frac{\partial v}{\partial r}\right),
$$

which is recognized as the variable-coefficient Laplace operator in
one Cartesian coordinate.

<h1 id="diffu:2D">Diffusion in 2D</h1>

<p>
We now address a diffusion in two space dimensions:

$$
\begin{align}
\frac{\partial u}{\partial t} & = \dfc\left(
\frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial x^2}\right) + f(x,y),
\tag{3.87}
\end{align}
$$

in a domain

$$ (x,y)\in (0,L_x)\times (0,L_y),\ t\in (0,T], $$

with \( u=0 \) on the boundary and \( u(x,y,0)=I(x,y) \) as initial condition.

<h2 id="diffu:2D:discr">Discretization</h2>

<p>
For generality, it is natural to use a \( \theta \)-rule for the time
discretization. Standard, second-order accurate finite differences are
used for the spatial derivatives. We sample the PDE at a space-time
point \( (i,j,n+\half) \) and apply the difference approximations:

$$
\begin{align}
\lbrack D_t u\rbrack^{n+\half} &=
\theta \lbrack \dfc (D_xD_x u + D_yD_yu) + f\rbrack^{n+1} + \nonumber\\ 
&\quad (1-\theta)\lbrack \dfc (D_xD_x u + D_yD_y u) + f\rbrack^{n}\tp
\tag{3.88}
\end{align}
$$

Written out,

$$
\begin{align}
\frac{u^{n+1}_{i,j}-u^n_{i,j}}{\Delta t} &=
\theta (\dfc
(\frac{u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i+1,j}}{\Delta x^2}) +
(\frac{u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1}}{\Delta y^2})) +
f^{n+1}_{i,j})
+ \nonumber\\ 
&\quad (1-\theta)(\dfc
(\frac{u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i+1,j}}{\Delta x^2}) +
(\frac{u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1}}{\Delta y^2})) +
+ f^{n}_{i,j})
\tag{3.89}
\end{align}
$$

We collect the unknowns on the left-hand side

$$
\begin{align}
& u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= u^n_{i,j} + \nonumber\\ 
&\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \nonumber\\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j},
\tag{3.90}
\end{align}
$$

where

$$ F_x = \frac{\dfc\Delta t}{\Delta x^2},\quad F_y = \frac{\dfc\Delta t}{\Delta y^2},$$

are the Fourier numbers in \( x \) and \( y \) direction, respectively.

<p>
<center> <!-- figure label: --> <div id="diffu:2D:fig:mesh3x2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 48:  3x2 2D mesh.  <!-- caption label: diffu:2D:fig:mesh3x2 --> </p></center>
<p><img src="fig-diffu/mesh3x2.png" align="bottom" width=500></p>
</center>

<h2 id="diffu:2D:numbering">Numbering of mesh points versus equations and unknowns</h2>

<p>
<!-- Nx=3, Ny=2 -->
The equations <a href="#mjx-eqn-3.90">(3.90)</a> are coupled at the new
time level \( n+1 \). That is, we must solve a system of (linear) algebraic
equations, which we will write as \( Ac=b \), where \( A \) is the coefficient
matrix, \( c \) is the vector of unknowns, and \( b \) is the right-hand side.

<p>
Let us examine the equations in \( Ac=b \) on a mesh with \( N_x=3 \) and
\( N_y=2 \) cells in each direction.  The spatial mesh is depicted in
Figure <a href="#diffu:2D:fig:mesh3x2">48</a>.  The equations at the boundary just
implement the boundary condition \( u=0 \):

$$
u^{n+1}_{0,0}=
u^{n+1}_{1,0}=
u^{n+1}_{2,0}=
u^{n+1}_{3,0}=
u^{n+1}_{0,1}=
u^{n+1}_{3,1}=
u^{n+1}_{0,2}=
u^{n+1}_{1,2}=
u^{n+1}_{2,2}=
u^{n+1}_{3,2}= 0\tp
$$

We are left with two interior points, with \( i=1 \), \( j=1 \) and \( i=2 \), \( j=1 \).
The corresponding equations are

$$
\begin{align*}
& u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= u^n_{i,j} + \\ 
&\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j},
\end{align*}
$$

<p>
There are in total 12 unknowns \( u^{n+1}_{i,j} \) for \( i=0,1,2,3 \) and
\( j=0,1,2 \).  To solve the equations, we need to form a matrix system \( Ac=b \).
In that system, the solution vector \( c \) can only one index. Thus,
we need a numbering of the unknowns with one
index, not two as used in the mesh. We introduce a mapping \( m(i,j) \)
from a mesh point with indices \( (i,j) \) to the corresponding unknown
\( p \) in the equation system:

$$ p = m(i,j) = j(N_x+1) + i\tp$$

When \( i \) and \( j \) runs through their values we see the following mapping
to \( p \):

$$
\begin{align*}
&(0,0)\rightarrow 0,\ 
(0,1)\rightarrow 1,\ 
(0,2)\rightarrow 2,\ 
(0,3)\rightarrow 3,\\ 
&(1,0)\rightarrow 4,\ 
(1,1)\rightarrow 5,\ 
(1,2)\rightarrow 6,\ 
(1,3)\rightarrow 7,\\ 
&(2,0)\rightarrow 8,\ 
(2,1)\rightarrow 9,\ 
(2,2)\rightarrow 10,\ 
(2,3)\rightarrow 11\tp
\end{align*}
$$

That is, we number the points along the \( x \) axis, starting with \( y=0 \),
and the progress one horizontal mesh line at a time.
In Figure <a href="#diffu:2D:fig:mesh3x2">48</a> you can see that the \( (i,j) \) and the
corresponding single index (\( p \)) are listed for each mesh point.

<p>
We could equally well numbered the equations in other ways, e.g.,
let the \( j \) index be the fastest varying index:
\( p = m(i,j) = i(N_y+1) + j \).

<p>
Let us form the coefficient matrix \( A \), or more precisely, insert
matrix element (according Python's convention with zero as base
index) for each of the nonzero elements in \( A \) (the indices
run through the values of \( p \), i.e., \( p=0,\ldots,11 \)):

$$
{\tiny
\left(\begin{array}{cccccccccccc}
(0,0) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & (1,1) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   & (2,2) &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   & (3,3) &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   & (4,4) &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & (5,1) &   0   &   0   & (5,4) & (5,5) & (5,6) &   0   &   0   & (5,9) &   0    &   0    \\ 
  0   &   0   & (6,2) &   0   &   0   & (6,5) & (6,6) & (6,7) &   0   &   0   & (6,10) &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   & (7,7) &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & (8,8) &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & (9,9) &   0    &   0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   & (10,10) &    0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0    & (11,11) \\ 
\end{array}\right)
}
$$

Here is a more compact visualization of the coefficient matrix where we
insert dots for zeros and bullets for non-zero elements:

$$
\footnotesize
\left(\begin{array}{cccccccccccc}
\bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}\right)
$$

It is clearly seen that most of the elements are zero. This is a general
feature of coefficient matrices arising from discretizing PDEs by
finite difference methods. We say that the matrix is <em>sparse</em>.

<p>
Let \( A_{p,q} \) be the value of element \( (p,q) \) in the coefficient matrix \( A \),
where \( p \) and \( q \) now correspond to the numbering of the unknowns in the
equation system.
We have \( A_{p,q}=1 \) for \( p=q=0,1,2,3,4,7,8,9,10,11 \), corresponding
to all the known boundary values. Let \( p \) be \( m(i,j) \), i.e.,
the single index corresponding to mesh point \( (i,j) \). Then we have

$$
\begin{align}
A_{m(i,j),m(i,j)} = A_{p,p} &=
1 +
\theta (F_x + F_y),
\tag{3.91}\\ 
A_{p, m(i-1,j)} = A_{p,p-1} &= -\theta F_x,
\tag{3.92}\\ 
A_{p, m(i+1,j)} = A_{p,p+1} &= -\theta F_x,
\tag{3.93}\\ 
A_{p, m(i,j-1)} = A_{p, p-(N_x+1)} &= -\theta F_y,
\tag{3.94}\\ 
A_{p, m(i,j+1)} = A_{p, p+(N_x+1)} &= -\theta F_y,
\tag{3.95}\\ 
\tag{3.96}
\end{align}
$$

for the equations associated with the two interior mesh points.
At these interior points, the single index \( p \) takes on the
specific values \( p=5,6 \), corresponding to the
values \( (1,1) \) and \( (1,2) \) of the pair \( (i,j) \).

<p>
The above values for \( A_{p,q} \) can be inserted in the matrix:

$$
{\tiny
\left(\begin{array}{cccccccccccc}
1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   & 1 &   0   &   0   &   0   &   0   &   0   &   0    &   0    \\ 
  0   & -\theta F_y &   0   &   0   & -\theta F_x & 1+2\theta F_x & -\theta F_x &   0   &   0   & -\theta F_y &   0    &   0    \\ 
  0   &   0   & -\theta F_y &   0   &   0   & -\theta F_x & 1+2\theta F_x & -\theta F_x &   0   &   0   & -\theta F_y &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0   &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0   &   0    &   0    \\ 
  0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   &   0   & 1 &   0    &   0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   & 1 &    0    \\ 
   0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0   &    0    & 1 \\ 
\end{array}\right)
}
$$

The corresponding right-hand side vector in the equation system has
the entries \( b_p \), where \( p \) numbers the equations. We have

$$ b_0=b_1=b_2=b_3=b_4=b_7=b_8=b_9=b_{10}=b_{11}=0,$$

for the boundary values. For the equations associated with the
interior points, we get for \( p=5,6 \), corresponding to \( i=1,2 \) and \( j=1 \):

$$
\begin{align*}
b_p &= u_i +
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\ 
&\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j}\tp
\end{align*}
$$

Recall that \( p=m(i,j)=j(N_x+1)+j \) in this expression.

<p>
We can, as an alternative, leave the boundary mesh points out of the
matrix system. For a mesh with \( N_x=3 \) and \( N_y=2 \) there are only two
internal mesh points whose unknowns will enter the matrix system.
We must now number the unknowns at the interior points:

$$ p = (j-1)(N_x-1) + i,$$

for \( i=1,\ldots,N_x-1 \), \( j=1,\ldots,N_y-1 \).

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 14</b>: Fill in details.)</font>
<!-- end inline comment -->

<p>
<!-- Nx=4, Ny=3 -->

<p>
<center> <!-- figure label: --> <div id="diffu:2D:fig:mesh4x3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 49:  4x3 2D mesh.  <!-- caption label: diffu:2D:fig:mesh4x3 --> </p></center>
<p><img src="fig-diffu/mesh4x3.png" align="bottom" width=700></p>
</center>

<p>
We can continue with illustrating a bit larger mesh, \( N_x=4 \) and \( N_y=3 \),
see Figure <a href="#diffu:2D:fig:mesh4x3">49</a>. The corresponding coefficient matrix
with dots for zeros and bullets for non-zeroes look as follows (values at boundary points are included in the equation system):

$$
{\tiny
\left(\begin{array}{cccccccccccccccccccc}
\bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
\cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}\right)
}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>The coefficient matrix is banded.</b>
Besides being sparse, we observe that the coefficient matrix is <em>banded</em>:
it has five distinct bands. We have the diagonal \( A_{i,i} \), the
subdiagonal \( A_{i-1,j} \), the superdiagonal \( A_{i,i+1} \), a lower
diagonal \( A_{i,i-(Nx+1)} \), and an upper diagonal \( A_{i,i+(Nx+1)} \).
The other matrix entries are known to be zero. With \( N_x+1=N_y+1=N \),
only a fraction \( 5N^{-2} \) of the matrix entries are nonzero, so the
matrix is clearly very sparse for relevant \( N \) values.
The more we can compute with the nonzeros only, the faster the solution
methods will be.
</div>


<h2 id="diffu:2D:alg">Algorithm for setting up the coefficient matrix</h2>

<p>
We looked at a specific mesh in the previous section, formulated
the equations, and saw what the corresponding coefficient matrix and
right-hand side are. Now our aim is to set up a general algorithm, for any
choice of \( N_x \) and \( N_y \), that produces the coefficient matrix and
the right-hand side vector.
We start with a zero matrix and vector, run through each mesh point,
and fill in the values depending on whether the mesh point is an interior
point or on the boundary.

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> for \( j=0,\ldots, N_y \)</li>

<ul>
    <li> \( p=j(N_x+1)+i \)</li>
    <li> if point \( (i,j) \) is on the boundary:</li>

<ul>
      <li> \( A_{p,p}=1 \), \( b_p=0 \)</li>
</ul>

    <li> else:</li>

<ul>
      <li> fill \( A_{p,m(i-1,j)} \), \( A_{p,m(i+1,j)} \), \( A_{p,m(i,j)} \), \( A_{p,m(i,j-1)} \), \( A_{p,m(i,j+1)} \), and \( b_p \)</li>
</ul>

</ul>

</ul>

</ul>

To ease the test on whether \( (i,j) \) is on the boundary or not, we can
split the loops a bit, starting with the boundary line \( j=0 \), then
treat the interior lines \( 1\leq j < N_y \), and finally treat the boundary
line \( j=N_y \):

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=0 \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

 <li> for \( j=0,\ldots,N_y \)</li>

<ul>
  <li> boundary \( i=0 \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
  <li> for \( i=1,\ldots, N_x-1 \)</li>

<ul>
    <li> interior point \( p=j(N_x+1)+i \)</li>
    <li> fill \( A_{p,m(i-1,j)} \), \( A_{p,m(i+1,j)} \), \( A_{p,m(i,j)} \), \( A_{p,m(i,j-1)} \), \( A_{p,m(i,j+1)} \), and \( b_p \)</li>
</ul>

  <li> boundary \( i=N_x \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=N_y \): \( p=j(N_x+1)+i \), \( A_{p,p}=1 \)</li>
</ul>

</ul>

The right-hand side is set up as follows.

<ul>
 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=0 \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

 <li> for \( j=0,\ldots,N_y \)</li>

<ul>
  <li> boundary \( i=0 \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
  <li> for \( i=1,\ldots, N_x-1 \)</li>

<ul>
    <li> interior point \( p=j(N_x+1)+i \)</li>
    <li> fill \( b_p \)</li>
</ul>

  <li> boundary \( i=N_x \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

 <li> for \( i=0,\ldots,N_x \)</li>

<ul>
  <li> boundary \( j=N_y \): \( p=j(N_x+1)+i \), \( b_p=0 \)</li>
</ul>

</ul>

<h2 id="diffu:2D:impl:dense">Implementation with a dense coefficient matrix</h2>

<p>
The goal now is to map the algorithms in the previous section to
Python code. One should for computational efficiency reasons take
advantage of the fact that the coefficient matrix is sparse and/or
banded, i.e., take advantage of all the zeros; however, we first demonstrate
how to fill an \( N\times N \) dense square matrix, where \( N \) is the number
of unknowns, here \( N=(N_x+1)(N_y+1) \). The dense matrix is much easier
to understand than the sparse matrix case.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_dense</span>(
    I, a, f, Lx, Ly, Nx, Ny, dt, T, theta<span style="color: #666666">=0.5</span>, user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u_t = a*(u_xx + u_yy) + f, u(x,y,0)=I(x,y), with u=0</span>
<span style="color: #BA2121; font-style: italic">    on the boundary, on [0,Lx]x[0,Ly]x[0,T], with time step dt,</span>
<span style="color: #BA2121; font-style: italic">    using the theta-scheme.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Lx, Nx<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># mesh points in x dir</span>
    y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Ly, Ny<span style="color: #666666">+1</span>)       <span style="color: #408080; font-style: italic"># mesh points in y dir</span>
    dx <span style="color: #666666">=</span> x[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> x[<span style="color: #666666">0</span>]
    dy <span style="color: #666666">=</span> y[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> y[<span style="color: #666666">0</span>]

    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                    <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># mesh points in time</span>

    <span style="color: #408080; font-style: italic"># Mesh Fourier numbers in each direction</span>
    Fx <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
    Fy <span style="color: #666666">=</span> a<span style="color: #666666">*</span>dt<span style="color: #666666">/</span>dy<span style="color: #666666">**2</span>
</pre></div>
<p>
The \( u^{n+1}_{i,j} \) and \( u^n_{i,j} \) mesh functions are represented
by their spatial values at the mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Ny<span style="color: #666666">+1</span>))      <span style="color: #408080; font-style: italic"># unknown u at new time level</span>
u_1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((Nx<span style="color: #666666">+1</span>, Ny<span style="color: #666666">+1</span>))      <span style="color: #408080; font-style: italic"># u at the previous time level</span>
</pre></div>
<p>
It is a good habit (for extensions) to
introduce index sets for all mesh points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Ix <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nx<span style="color: #666666">+1</span>)
Iy <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Ny<span style="color: #666666">+1</span>)
It <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt<span style="color: #666666">+1</span>)
</pre></div>
<p>
The initial condition is easy to fill in:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Load initial condition into u_1</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
        u_1[i,j] <span style="color: #666666">=</span> I(x[i], y[j])
</pre></div>
<p>
The memory for the coefficient matrix and right-hand side vector
is allocated by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">N <span style="color: #666666">=</span> (Nx<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>(Ny<span style="color: #666666">+1</span>)  <span style="color: #408080; font-style: italic"># no of unknowns</span>
A <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N, N))
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
</pre></div>
<p>
The filling of <code>A</code> goes like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i

<span style="color: #408080; font-style: italic"># Equations corresponding to j=0, i=0,1,... (u known)</span>
j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #408080; font-style: italic"># Loop over all internal mesh points in y diretion</span>
<span style="color: #408080; font-style: italic"># and all mesh points in x direction</span>
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>   <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:                 <span style="color: #408080; font-style: italic"># Interior points</span>
        p <span style="color: #666666">=</span> m(i,j)
        A[p, m(i,j<span style="color: #666666">-1</span>)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
        A[p, m(i<span style="color: #666666">-1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
        A[p, p]        <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
        A[p, m(i<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
        A[p, m(i,j<span style="color: #666666">+1</span>)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
    i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
<span style="color: #408080; font-style: italic"># Equations corresponding to j=Ny, i=0,1,... (u known)</span>
j <span style="color: #666666">=</span> Ny
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
    p <span style="color: #666666">=</span> m(i,j);  A[p, p] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
</pre></div>
<p>
Since <code>A</code> is independent of time, it can be filled once and for all before
the time loop. The right-hand side vector must be filled at each
time level inside the time loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>           <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>   <span style="color: #408080; font-style: italic"># Boundary</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:              <span style="color: #408080; font-style: italic"># Interior points</span>
            p <span style="color: #666666">=</span> m(i,j)
            b[p] <span style="color: #666666">=</span> u_1[i,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
              Fx<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>\ 
              Fy<span style="color: #666666">*</span>(u_1[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">-1</span>]))\ 
                <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt)
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    j <span style="color: #666666">=</span> Ny
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>           <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
            u[i,j] <span style="color: #666666">=</span> c[m(i,j)]

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>
<p>
We use <code>solve</code> from <code>scipy.linalg</code> and not from <code>numpy.linalg</code>. The difference
is stated below.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b><code>scipy.linalg</code> versus <code>numpy.linalg</code>.</b>
Quote from the <a href="http://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html" target="_self">SciPy documentation</a>:

<p>
<code>scipy.linalg</code> contains all the functions in <code>numpy.linalg</code>
plus some other more advanced ones not contained in <code>numpy.linalg</code>.

<p>
Another advantage of using <code>scipy.linalg</code> over numpy.linalg is that it is always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore, the SciPy version might be faster depending on how NumPy was installed.

<p>
Therefore, unless you don't want to add SciPy as a dependency to your NumPy program, use <code>scipy.linalg</code> instead of <code>numpy.linalg</code>.
</div>


<p>
The code shown above is available in the <code>solver_dense</code> function
in the file <a href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>, differing only
in the boundary conditions, which in the code can be an arbitrary function along
each side of the domain.

<p>
We do not bother to look at vectorized versions of filling <code>A</code> since
a dense matrix is just used of pedagogical reasons for the very first
implementation. Vectorization will be treated when <code>A</code> has a sparse
matrix representation, as in the section <a href="#diffu:2D:impl:sparse">Implementation with a sparse coefficient matrix</a>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>How to debug the computation of \( A \) and \( b \).</b>
A good starting point for debugging the filling of \( A \) and \( b \) is
to choose a very coarse mesh, say \( N_x=N_y=2 \), where there is just
one internal mesh point, compute the equations by hand, and
print out <code>A</code> and <code>b</code> for comparison in the code. If wrong elements
in <code>A</code> or <code>b</code> occur, print out each assignment to elements in
<code>A</code> and <code>b</code> inside the loops and compare with what you expect.
</div>


<p>
To let the user store, analyze, or visualize the solution at each
time level, we include a callback function, named <code>user_action</code>,
to be called before the time loop and in each pass in that loop.
The function has the signature

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">user_action(u, x, xv, y, yv, t, n)
</pre></div>
<p>
where <code>u</code> is a two-dimensional array holding the solution at time level <code>n</code>
and time <code>t[n]</code>. The \( x \) and \( y \) coordinates of the mesh points are given by
the arrays <code>x</code> and <code>y</code>, respectively. The arrays <code>xv</code> and <code>yv</code> are
vectorized representations of the mesh points such that vectorized
function evaluations can be invoked. The <code>xv</code> and <code>yv</code> arrays are
defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">xv <span style="color: #666666">=</span> x[:,np<span style="color: #666666">.</span>newaxis]
yv <span style="color: #666666">=</span> y[np<span style="color: #666666">.</span>newaxis,:]
</pre></div>
<p>
One can then evaluate, e.g., \( f(x,y,t) \) at all internal mesh points at time
level <code>n</code> by first evaluating \( f \) at all points,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f_a <span style="color: #666666">=</span> f(xv, yv, t[n])
</pre></div>
<p>
and then use slices to extract a view of the values at the internal
mesh points: <code>f_a[1:-1,1:-1]</code>.
The next section features an example on writing a <code>user_action</code>
callback function.

<h2 id="diffu:2D:verify">Verification: exact numerical solution</h2>

<p>
A good test example to start with is one that preserves the solution
\( u=0 \), i.e., \( f=0 \) and \( I(x,y)=0 \). This trivial solution can uncover
some bugs.

<p>
The first real test example is based on having an exact solution of
the discrete equations. This solution is linear in time and quadratic
in space:

$$ u(x,y,t) = 5tx(L_x-x)y(y-L_y)\tp$$

Inserting this manufactured solution in the PDE shows that the
source term \( f \) must be

$$ f(x,y,t) = 5x(L_x-x)y(y-L_y) + 10\dfc t (x(L_x-x)+ y(y-L_y))\tp$$

<p>
We can use the <code>user_action</code> function to compare the numerical solution
with the exact solution at each time level. A suitable helper function
for checking the solution goes like this:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">def quadratic(theta, Nx, Ny):

    def u_exact(x, y, t):
        return 5*t*x*(Lx-x)*y*(Ly-y)
    def I(x, y):
        return u_exact(x, y, 0)
    def f(x, y, t):
        return 5*x*(Lx-x)*y*(Ly-y) + 10*a*t*(y*(Ly-y)+x*(Lx-x))

    # Use rectangle to detect errors in switching i and j in scheme
    Lx = 0.75
    Ly = 1.5
    a = 3.5
    dt = 0.5
    T = 2

    def assert_no_error(u, x, xv, y, yv, t, n):
        &quot;&quot;&quot;Assert zero error at all mesh points.&quot;&quot;&quot;
        u_e = u_exact(xv, yv, t[n])
        diff = abs(u - u_e).max()
        tol = 1E-12
        msg = &#39;diff=%g, step %d, time=%g&#39; % (diff, n, t[n])
        print msg
        assert diff &lt; tol, msg

    solver_dense(
        I, a, f, Lx, Ly, Nx, Ny,
        dt, T, theta, user_action=assert_no_error)
</pre></div>
<p>
A true test function for checking the quadratic solution for several
different meshes and \( \theta \) values can take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_quadratic</span>():
    <span style="color: #408080; font-style: italic"># For each of the three schemes (theta = 1, 0.5, 0), a series of</span>
    <span style="color: #408080; font-style: italic"># meshes are tested (Nx &gt; Ny and Nx &lt; Ny)</span>
    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0</span>]:
        <span style="color: #008000; font-weight: bold">for</span> Nx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>, <span style="color: #666666">2</span>):
            <span style="color: #008000; font-weight: bold">for</span> Ny <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>, <span style="color: #666666">6</span>, <span style="color: #666666">2</span>):
                <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;testing for </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">x</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> mesh&#39;</span> <span style="color: #666666">%</span> (Nx, Ny)
                quadratic(theta, Nx, Ny)
</pre></div>

<h2 id="diffu:2D:convrate">Verification: convergence rates</h2>

<p>
For any manufactured solution of the PDE problem we can compute the
numerical error and check that this error has the expected dependence
on the discretization parameters. Truncation error analysis and other
forms of error analysis point to a formula like

$$ E = C_t\Delta t^p + C_x\Delta x^2 + C_y\Delta y^2$$

for the error in a 2D problem, where \( p \), \( C_t \), \( C_x \), and \( C_y \) are
unknown constants. A Crank-Nicolson method has \( p=2 \), while the Forward
and Backward Euler schemes have \( p=1 \).

<p>
When checking the error formula empirically, we need to reduce it to
a form \( E=Ch^r \) with a single discretization parameter \( h \) and some
rate \( r \) to be estimated. For the Backward Euler method,
where \( p=1 \), we can introduce a single discretization parameter
according to

$$ h = \Delta x^2 =  \Delta y^2,\quad h = K^{-1}\Delta t,$$

where \( K \) is a constant. The error formula then becomes

$$ E = C_t Kh + C_xh + C_y = \tilde C h,\quad \tilde C = C_tK + C_x + C_y\tp$$

The simplest choice is \( K=1 \), but if we consider
the Forward Euler method instead, stability requires \( \Delta t = hK \leq
h/(4\dfc) \), so \( K\leq 1/(4\dfc) \).

<p>
For the Crank-Nicolson method, \( p=2 \), and we can simply choose

$$ h = \Delta x = \Delta y = \Delta t,$$

since there is no restriction on \( \Delta t \) in terms of \( \Delta x \) and
\( \Delta y \).

<p>
A frequently used error measure is the \( \ell^2 \) norm of the error mesh
point values. The section <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#wave:pde2:fd:MMS">Manufactured solution</a> and the formula
<a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86006.html#mjx-eqn-2.26">(2.26)</a> shows the error measure for a 1D
time-dependent problem. The extension to the current 2D problem
reads

$$ E = \left(\Delta t\Delta x\Delta y \sum_{n=0}^{N_t}
\sum_{i=0}^{N_x}\sum_{j=0}^{N_y}(\uex(x_i,y_j,t_n)
- u^n_{i,j})^2\right)^{\half}\tp$$

<p>
One attractive manufactured solution is

$$ \uex = e^{-pt}\sin(k_xx)\sin(k_yy),\quad k_x=\frac{\pi}{L_x},
k_y=\frac{\pi}{L_y},$$

where \( p \) can be arbitrary. The required source term is

$$ f = (\dfc(k_x^2 + k_y^2) - p)\uex\tp$$

<p>
The function <code>convergence_rates</code> in
<a href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a> implements a convergence
rate test. Two potential difficulties are important to be aware of:

<ol>
<li> The error formula is assumed to be
   correct when \( h\rightarrow 0 \), so for coarse meshes the estimated rate
   \( r \) may be somewhat away from the expected value.
   Fine meshes may lead to prohibitively long execution times.</li>
<li> Choosing \( p=\dfc (k_x^2 + k_y^2) \) in the manufactured solution above
   seems attractive (\( f=0 \)), but leads to a slower approach to the
   asymptotic range where the error formula is valid (i.e., \( r \)
   fluctuates and needs finer meshes to stabilize).</li>
</ol>

<h2 id="diffu:2D:impl:sparse">Implementation with a sparse coefficient matrix</h2>

<p>
We used a sparse matrix implementation in the section <a href="#diffu:pde1:impl:sparse">Sparse matrix implementation</a>
for a 1D problem with a tridiagonal matrix. The present matrix, arising
from a 2D problem, has five diagonals, but we can use the same
sparse matrix data structure <code>scipy.sparse.diags</code>.

<h3 id="___sec325">Understanding the diagonals </h3>

<p>
Let us look closer at the diagonals in the example with a \( 4\times 3 \) mesh
as depicted in Figure <a href="#diffu:2D:fig:mesh4x3">49</a> and its associated matrix
visualized by dots for zeros and bullets for nonzeros. From the example
mesh, we may generalize to an \( N_x\times N_y \) mesh.

$$
{\tiny
\begin{array}{lcccccccccccccccccccc}
0 =m(0,0) & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
1 = m(1,0) & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2 = m(2,0) & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
3 = m(3,0) & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_x=m(N_x,0) & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_x+1=m(0,1) & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+1=m(1,1) & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+2=m(2,1) & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+3=m(3,1) & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
(N_x+1)+N_x=m(N_x,1) & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2(N_x+1)=m(0,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
2(N_x+1)+1=m(1,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
2(N_x+1)+2=m(2,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
2(N_x+1)+3=m(3,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \bullet & \bullet & \bullet & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
2(N_x+1)+N_x=m(N_x,2)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)=m(0,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)+1=m(1,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\ 
N_y(N_x+1)+2=m(2,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot & \cdot \\ 
N_y(N_x+1)+3=m(3,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet & \cdot \\ 
N_y(N_x+1)+N_x=m(N_x,N_y)& \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \bullet \\ 
\end{array}
}
$$

<p>
The main diagonal has \( N=(N_x+1)(N_y+1) \) elements, while the sub- and
super-diagonals have \( N-1 \) elements. By looking at the matrix above,
we realize that the lower diagonal starts in row \( N_x+1 \) and goes to
row \( N \), so its length is \( N-(N_x+1) \). Similarly, the upper diagonal
starts at row 0 and lasts to row \( N-(N_x+1) \), so it has the same length.
Based on this information, we declare the diagonals by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">main   <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)            <span style="color: #408080; font-style: italic"># diagonal</span>
lower  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-1</span>)          <span style="color: #408080; font-style: italic"># subdiagonal</span>
upper  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-1</span>)          <span style="color: #408080; font-style: italic"># superdiagonal</span>
lower2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-</span>(Nx<span style="color: #666666">+1</span>))     <span style="color: #408080; font-style: italic"># lower diagonal</span>
upper2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">-</span>(Nx<span style="color: #666666">+1</span>))     <span style="color: #408080; font-style: italic"># upper diagonal</span>
b      <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)            <span style="color: #408080; font-style: italic"># right-hand side</span>
</pre></div>

<h3 id="___sec326">Filling the diagonals </h3>

<p>
We run through all mesh points and fill in elements on the various
diagonals. The line of mesh points corresponding to \( j=0 \) are all
on the boundary, and only the main diagonal gets a contribution:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i
j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># j=0 boundary line</span>
</pre></div>
<p>
Then we run through all interior \( j=\hbox{const} \) lines of mesh points.
The first and the last point on each line, \( i=0 \) and \( i=N_x \), correspond
to boundary points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:             <span style="color: #408080; font-style: italic"># Interior mesh lines j=1,...,Ny-1</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    i <span style="color: #666666">=</span> Nx;  main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
</pre></div>
<p>
For the interior mesh points \( i=1,\ldots,N_x-1 \) on a mesh line \( y=\hbox{const} \)
we can start with the main diagonal. The entries to be filled go from
\( i=1 \) to \( i=N_x-1 \) so the relevant slice in the <code>main</code> vector is
<code>m(1,j):m(Nx,j)</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">main[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
</pre></div>
<p>
The <code>upper</code> array for the superdiagonal has its index 0 corresponding to
row 0 in the matrix, and the array entries
to be set go from \( m(1,j) \) to \( m(N_x-1,j) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">upper[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
</pre></div>
<p>
The subdiagonal (<code>lower</code> array), however, has its index 0
corresponding to row 1, so there is an offset of 1 in indices compared to
the matrix. The first nonzero occurs (interior point) at a mesh line \( j=\hbox{const} \) corresponds to matrix row \( m(1,j) \), and the corresponding array index
in <code>lower</code> is then \( m(1,j) \). To fill the entries from \( m(1,j) \) to \( m(N_x-1,j) \)
we set the following slice in <code>lower</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower_offset <span style="color: #666666">=</span> <span style="color: #666666">1</span>
lower[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower_offset:m(Nx,j)<span style="color: #666666">-</span>lower_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
</pre></div>
<p>
For the upper diagonal, its index 0 corresponds to matrix row 0, so there
is no offset and we can set the entries correspondingly to <code>upper</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">upper2[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
</pre></div>
<p>
The <code>lower2</code> diagonal, however, has its first index 0 corresponding to row
\( N_x+1 \), so here we need to subtract the offset \( N_x+1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower2_offset <span style="color: #666666">=</span> Nx<span style="color: #666666">+1</span>
lower2[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower2_offset:m(Nx,j)<span style="color: #666666">-</span>lower2_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
</pre></div>
<p>
We can now summarize the above code lines for setting the entries in
the sparse matrix representation of the coefficient matrix:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">lower_offset <span style="color: #666666">=</span> <span style="color: #666666">1</span>
lower2_offset <span style="color: #666666">=</span> Nx<span style="color: #666666">+1</span>
m <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> i, j: j<span style="color: #666666">*</span>(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> i

j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># j=0 boundary line</span>
<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:             <span style="color: #408080; font-style: italic"># Interior mesh lines j=1,...,Ny-1</span>
    i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    i <span style="color: #666666">=</span> Nx;  main[m(i,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #408080; font-style: italic"># Interior i points: i=1,...,N_x-1</span>
    lower2[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower2_offset:m(Nx,j)<span style="color: #666666">-</span>lower2_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
    lower[m(<span style="color: #666666">1</span>,j)<span style="color: #666666">-</span>lower_offset:m(Nx,j)<span style="color: #666666">-</span>lower_offset] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
    main[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">+</span>Fy)
    upper[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fx
    upper2[m(<span style="color: #666666">1</span>,j):m(Nx,j)] <span style="color: #666666">=</span> <span style="color: #666666">-</span> theta<span style="color: #666666">*</span>Fy
j <span style="color: #666666">=</span> Ny; main[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">1</span>  <span style="color: #408080; font-style: italic"># Boundary line</span>
</pre></div>
<p>
The next task is to create the sparse matrix from these diagonals:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
    diagonals<span style="color: #666666">=</span>[main, lower, upper, lower2, upper2],
    offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-</span>lower_offset, lower_offset,
             <span style="color: #666666">-</span>lower2_offset, lower2_offset],
    shape<span style="color: #666666">=</span>(N, N), format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csr&#39;</span>)
</pre></div>

<h3 id="___sec327">Filling the right-hand side; scalar version </h3>

<p>
Setting the entries in the right-hand side is easier since there are no
offsets in the array to take into account. The is in fact similar to
the one previously shown when we used a dense matrix representation
(the right-hand side vector is, of course, independent of what type of
representation we use for the coefficient matrix). The complete time
loop goes as follows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b</span>
    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>                     <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>             <span style="color: #408080; font-style: italic"># Boundary</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
            p <span style="color: #666666">=</span> m(i,j)                            <span style="color: #408080; font-style: italic"># Interior</span>
            b[p] <span style="color: #666666">=</span> u_1[i,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
              Fx<span style="color: #666666">*</span>(u_1[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>\ 
              Fy<span style="color: #666666">*</span>(u_1[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">-1</span>]))\ 
                <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt)
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>            <span style="color: #408080; font-style: italic"># Boundary</span>
    j <span style="color: #666666">=</span> Ny
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span>                     <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy:
            u[i,j] <span style="color: #666666">=</span> c[m(i,j)]

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>

<h3 id="___sec328">Filling the right-hand side; vectorized version </h3>

<p>
Since we use a sparse matrix and try to speed up the computations, we
should examine the loops and see if some can be easily removed by
vectorization. In the filling of \( A \) we have already used vectorized
expressions at each \( j=\hbox{const} \) line of mesh points. We can
very easily do the same in the code above and remove the need for
loops over the <code>i</code> index:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Compute b, vectorized version</span>

    <span style="color: #408080; font-style: italic"># Precompute f in array so we can make slices</span>
    f_a_np1 <span style="color: #666666">=</span> f(xv, yv, t[n<span style="color: #666666">+1</span>])
    f_a_n   <span style="color: #666666">=</span> f(xv, yv, t[n])

    j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; b[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span>     <span style="color: #408080; font-style: italic"># Boundary</span>
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
        i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>
        i <span style="color: #666666">=</span> Nx;  p <span style="color: #666666">=</span> m(i,j);  b[p] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>
        imin <span style="color: #666666">=</span> Ix[<span style="color: #666666">1</span>]
        imax <span style="color: #666666">=</span> Ix[<span style="color: #666666">-1</span>]  <span style="color: #408080; font-style: italic"># for slice, max i index is Ix[-1]-1</span>
        b[m(imin,j):m(imax,j)] <span style="color: #666666">=</span> u_1[imin:imax,j] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
          u_1[imin<span style="color: #666666">+1</span>:imax<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span>
        <span style="color: #666666">2*</span>u_1[imin:imax,j] <span style="color: #666666">+</span> \ 
          u_1[imin<span style="color: #666666">-1</span>:imax<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                         Fy<span style="color: #666666">*</span>(
          u_1[imin:imax,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span>
        <span style="color: #666666">2*</span>u_1[imin:imax,j] <span style="color: #666666">+</span>
          u_1[imin:imax,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
            theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[imin:imax,j] <span style="color: #666666">+</span> \ 
          (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[imin:imax,j]
    j <span style="color: #666666">=</span> Ny;  b[m(<span style="color: #666666">0</span>,j):m(Nx<span style="color: #666666">+1</span>,j)] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># Boundary</span>

    <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
    c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)

    <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
    u[:,:] <span style="color: #666666">=</span> c<span style="color: #666666">.</span>reshape(Ny<span style="color: #666666">+1</span>,Nx<span style="color: #666666">+1</span>)<span style="color: #666666">.</span>T

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>
<p>
The most tricky part of this code snippet is the loading of values in
the one-dimensional array <code>c</code>
into the two-dimensional array <code>u</code>. With our numbering of unknowns
from left to right along &quot;horizontal&quot; mesh lines, the correct
reordering of the one-dimensional array <code>c</code> as a two-dimensional array
requires first a reshaping as an <code>(Ny+1,Nx+1)</code> two-dimensional
array and then taking the transpose. The result is an <code>(Nx+1,Ny+1)</code>
array compatible with <code>u</code> both in size and appearance of the function values.

<p>
The <code>spsolve</code> function in <code>scipy.sparse.linalg</code> is an efficient version
of Gaussian elimination suited for matrices described by diagonals.
Actually, only the matrix elements within the bands (from <code>lower2</code>
to <code>upper2</code>) are computed with, and these elements constitute only a
fraction of all \( N^2 \) matrix elements, a crucial property to exploit.
The Gaussian elimination algorithm for banded matrices is therefore
much faster and requires much less storage than standard Gaussian elimination
for a dense matrix.
More precisely, with \( b=N_x+1 \) as the <em>bandwidth</em> of the matrix
[[[

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 15</b>: Problem: if \( N_x\gg N_y \) one should number the unknowns in \( y \) direction to get a smaller bandwidth.)</font>
<!-- end inline comment -->

<p>
The complete code is found in the <code>solver_sparse</code> function in the file
<a href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>.

<h3 id="___sec329">Verification </h3>

<p>
We can easily extend the function <code>quadratic</code> from
the section <a href="#diffu:2D:verify">Verification: exact numerical solution</a> to include a test of the
<code>solver_sparse</code> function as well.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">quadratic</span>(theta, Nx, Ny):
    <span style="color: #666666">...</span>
    t, cpu <span style="color: #666666">=</span> solver_sparse(
        I, a, f, Lx, Ly, Nx, Ny,
        dt, T, theta, user_action<span style="color: #666666">=</span>assert_no_error)
</pre></div>

<h2 id="___sec330">The Jacobi iterative method </h2>

<p>
So far we have created a matrix and
right-hand side of a linear system \( Ac=b \)
and solved the system for \( c \) by calling an exact algorithm
based on Gaussian elimination. A much simpler implementation, which
requires no memory for the coefficient matrix \( A \), arises if we solve
the system by <em>iterative</em> methods. These methods are only approximate, and
the core algorithm is repeated many times until the solution is
considered to be converged.

<h3 id="___sec331">Numerical scheme and linear system </h3>

<p>
To illustrate the idea of the Jacobi method, we simplify the numerical scheme to the
Backward Euler case, \( \theta=1 \), so there are fewer terms to write:

$$
\begin{align}
& u^{n+1}_{i,j} -
\left(
F_x
(u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= \nonumber\\ &\qquad u^n_{i,j} + \Delta t f^{n+1}_{i,j}
\tag{3.97}
\end{align}
$$

The idea of the <em>Jacobi</em> iterative method is to introduce an iteration,
here with index \( r \), where we in each iteration treat \( u^{n+1}_{i,j} \)
as unknown, but use values from the previous iteration for
the other unknowns \( u^{n+1}_{i\pm 1,j\pm 1} \).

<h3 id="___sec332">Iterations </h3>

<p>
Let \( u^{n+1,r}_{i,j} \)
be the approximation to \( u^{n+1}_{i,j} \) in iteration \( r \), for all
relevant \( i \) and \( j \) indices. We first solve with respect to
\( u^{n+1}_{i,j} \) to get the equation to solve:

$$
\begin{align}
& u^{n+1}_{i,j} = (1+2F_x +2F_y)^{-1}
\left(
F_x
(u^{n+1}_{i-1,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} + u^{n+1}_{i,j+1})\right) +
\nonumber\\ &\qquad
u^n_{i,j} + \Delta t f^{n+1}_{i,j}
\tag{3.98}
\end{align}
$$

The iteration is introduced by using iteration index \( r \), for computed values,
on the right-hand side and \( r+1 \) (unknown in this iteration) on the left-hand
side:

$$
\begin{align}
& u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}((
F_x
(u^{n+1,r}_{i-1,j} + u^{n+1,r}_{i,j}) +
F_y
(u^{n+1,r}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
\nonumber\\ &\qquad
u^n_{i,j} + \Delta t f^{n+1}_{i,j})
\tag{3.99}
\end{align}
$$

<h3 id="___sec333">Initial guess </h3>

<p>
We start the iteration with the computed values at the previous time level:

$$
\begin{equation}
u^{n+1,0}_{i,j} = u^{n}_{i,j},\quad i=0,\ldots,N_x,\ j=0,\ldots,N_y\tp
\tag{3.100}
\end{equation}
$$

<h3 id="___sec334">Relaxation </h3>

<p>
A common technique in iterative methods is to introduce a <em>relaxation</em>,
which means that the new approximation is a weighted mean of the
approximation as suggested by the algorithm and the previous approximation.
Naming the quantity on the left-hand side of <a href="#mjx-eqn-3.99">(3.99)</a>
as \( u^{n+1,*}_{i,j} \), a new approximation based on relaxation reads

$$
\begin{equation}
u^{n+1,r+1} = \omega u^{n+1,*}_{i,j} + (1-\omega) u^{n+1,r}_{i,j}\tp
\tag{3.101}
\end{equation}
$$

Under-relaxation means \( \omega < 1 \), while over-relaxation has
\( \omega > 1 \).

<h3 id="___sec335">Stopping criteria </h3>

<p>
The iteration can be stopped when the change from one iteration to the
next is sufficiently small (\( \epsilon \)), using either an infinity norm,

$$
\begin{equation}
\max_{i,j}\left\vert u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j}
\right\vert \leq \epsilon,
\tag{3.102}
\end{equation}
$$

or an \( L^2 \) norm,

$$
\begin{equation}
\left(\Delta x\Delta y\sum_{i,j} (u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j})^2
\right)^{\half} \leq \epsilon\tp
\tag{3.103}
\end{equation}
$$

<p>
Another widely used criterion measures how well the equations are solved
by looking at the residual (essentially \( b-Ac^{r+1} \) if \( c^{r+1} \) is
the approximation to the solution in iteration \( r+1 \)).
The residual, defined in terms of the finite difference stencil, is

$$
\begin{align}
R_{i,j} &= u^{n+1,r+1}_{i,j} -
(F_x(u^{n+1,r+1}_{i-1,j} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i,j}) +\nonumber\\ 
&\quad\quad F_y(u^{n+1,r+1}_{i,j-1} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i,j+1}))
- \nonumber\\ 
&\qquad u^n_{i,j} -  \Delta t f^{n+1}_{i,j}
\tag{3.104}
\end{align}
$$

One can then iterate until the norm of the mesh function \( R_{i,j} \)
is less than some tolerance:

$$
\begin{equation}
\left(\Delta x\Delta y\sum_{i,j} R_{i,j}^2
\right)^{\half} \leq \epsilon\tp
\tag{3.105}
\end{equation}
$$

<h3 id="___sec336">Code-friendly notation </h3>

<p>
To make the mathematics as close as possible to what we will write in
a computer program, we may introduce some new notation: \( u_{i,j} \) is a
short notation for \( u^{n+1,r+1}_{i,j} \), \( u^{-}_{i,j} \) is a short
notation for \( u^{n+1,r}_{i,j} \), and \( u^{(s)}_{i,j} \) denotes
\( u^{n+1-s}_{i,j} \).  That is, \( u_{i,j} \) is the unknown, \( u^{-}_{i,j} \)
is its most recently computed approximation, and \( s \) counts time
levels backwards in time. The Jacobi method
(ref<a href="#mjx-eqn-3.99">(3.99)</a>) takes the following form with the new
notation:

$$
\begin{align}
& u^{*}_{i,j} = (1+2F_x +2F_y)^{-1}((
F_x
(u^{-}_{i-1,j} + u^{-}_{i,j}) +
F_y
(u^{n+1,r}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \Delta t f^{n+1}_{i,j})
\tag{3.106}
\end{align}
$$

<h3 id="___sec337">Generalization of the scheme </h3>

<p>
We can also quite easily introduce the \( \theta \) rule for discretization in
time and write up the Jacobi iteration in that case as well:

$$
\begin{align}
& u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u^{-}_{i-1,j} + u^{-}_{i,j}) +
F_y
(u^{-}_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\\ 
&\qquad (1-\theta)(
F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1})))\tp
\tag{3.107}
\end{align}
$$

The final update of \( u \) applies relaxation:

$$ u_{i,j} = \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}\tp$$

<h2 id="diffu:2D:Jacobi:impl">Implementation of the Jacobi method</h2>

<p>
The Jacobi method needs no coefficient matrix and right-hand side
vector, but it needs an array for \( u \) in the previous iteration.  We
call this array <code>u_</code>, using the notation at the end of the previous
section (at the same time level). The unknown itself is called <code>u</code>,
while <code>u_1</code> is the computed solution one time level back in time.
With a \( \theta \) rule in time, the time loop can be coded like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Solve linear system by Jacobi iteration at time level n+1</span>
    u_[:,:] <span style="color: #666666">=</span> u_1  <span style="color: #408080; font-style: italic"># Start value</span>
    converged <span style="color: #666666">=</span> <span style="color: #008000">False</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #AA22FF; font-weight: bold">not</span> converged:
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])           <span style="color: #408080; font-style: italic"># Boundary</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   u[i,j] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                i <span style="color: #666666">=</span> Nx;  u[i,j] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
		<span style="color: #408080; font-style: italic"># Interior points</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                    u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
                        Fx<span style="color: #666666">*</span>(u_[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u_[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                        Fy<span style="color: #666666">*</span>(u_[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u_[i,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
                    u_1[i,j] <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
                    u_1[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                      Fy<span style="color: #666666">*</span>(
                    u_1[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">-1</span>]))\ 
                      <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt))
                    u[i,j] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[i,j]
            j <span style="color: #666666">=</span> Ny
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])      <span style="color: #408080; font-style: italic"># Boundary</span>

        <span style="color: #008000; font-weight: bold">elif</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;vectorized&#39;</span>:
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[:,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  u[i,:] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            i <span style="color: #666666">=</span> Nx; u[i,:] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            j <span style="color: #666666">=</span> Ny; u[:,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
	    <span style="color: #408080; font-style: italic"># Internal points</span>
            f_a_np1 <span style="color: #666666">=</span> f(xv, yv, t[n<span style="color: #666666">+1</span>])
            f_a_n   <span style="color: #666666">=</span> f(xv, yv, t[n])
            u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
              u_[<span style="color: #666666">2</span>:,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_[:<span style="color: #666666">-2</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span>
                Fy<span style="color: #666666">*</span>(
              u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>:] <span style="color: #666666">+</span> u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,:<span style="color: #666666">-2</span>])) <span style="color: #666666">+</span>\ 
            u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(Fx<span style="color: #666666">*</span>(
              u_1[<span style="color: #666666">2</span>:,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[:<span style="color: #666666">-2</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span>\ 
                Fy<span style="color: #666666">*</span>(
              u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> u_1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,:<span style="color: #666666">-2</span>]))\ 
              <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> \ 
              (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
            u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
        r <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        converged <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u<span style="color: #666666">-</span>u_)<span style="color: #666666">.</span>max() <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> r <span style="color: #666666">&gt;=</span> max_iter
        u_[:,:] <span style="color: #666666">=</span> u

    <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
    u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>
<p>
The vectorized version should be quite straightforward to understand
once one has an understanding of how a standard 2D finite stencil
is vectorized.

<!-- begin inline comment -->
<font color="red">(<b>hpl 16</b>: Make references to 1D and 2D wave equation vectorization.)</font>
<!-- end inline comment -->

<p>
The first natural verification is to use the test problem
from in the function <code>quadratic</code> from
the section <a href="#diffu:2D:verify">Verification: exact numerical solution</a>. This problem is known to have no
approximation error, but any iterative method will produce an
approximate solution with unknown error. For a tolerance \( 10^{-k} \)
in the iterative method, we can, e.g., use a slightly larger
tolerance \( 10^{-(k-1)} \)
for the difference between the exact and the computed solution.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">quadratic</span>(theta, Nx, Ny):
    <span style="color: #666666">...</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">assert_small_error</span>(u, x, xv, y, yv, t, n):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Assert small error for iterative methods.&quot;&quot;&quot;</span>
        u_e <span style="color: #666666">=</span> u_exact(xv, yv, t[n])
        diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u <span style="color: #666666">-</span> u_e)<span style="color: #666666">.</span>max()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-4</span>
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;diff=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, step </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, time=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (diff, n, t[n])
        <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, msg

    <span style="color: #008000; font-weight: bold">for</span> version <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;scalar&#39;</span>, <span style="color: #BA2121">&#39;vectorized&#39;</span>:
        <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>:
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;testing Jacobi, </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> version, theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
                  (version, theta)
            t, cpu <span style="color: #666666">=</span> solver_Jacobi(
                I<span style="color: #666666">=</span>I, a<span style="color: #666666">=</span>a, f<span style="color: #666666">=</span>f, Lx<span style="color: #666666">=</span>Lx, Ly<span style="color: #666666">=</span>Ly, Nx<span style="color: #666666">=</span>Nx, Ny<span style="color: #666666">=</span>Ny,
                dt<span style="color: #666666">=</span>dt, T<span style="color: #666666">=</span>T, theta<span style="color: #666666">=</span>theta,
                U_0x<span style="color: #666666">=0</span>, U_0y<span style="color: #666666">=0</span>, U_Lx<span style="color: #666666">=0</span>, U_Ly<span style="color: #666666">=0</span>,
                user_action<span style="color: #666666">=</span>assert_small_error,
                version<span style="color: #666666">=</span>version, iteration<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Jacobi&#39;</span>,
                omega<span style="color: #666666">=1.0</span>, max_iter<span style="color: #666666">=100</span>, tol<span style="color: #666666">=1E-5</span>)
</pre></div>
<p>
Even for a very coarse \( 4\times 4 \) mesh, the Jacobi method requires
26 iterations to reach a tolerance of \( 10^{-5} \),
which is quite many iterations, given that there are only 25 unknowns.

<h2 id="diffu:2D:Jacobi:impl:hill">Test problem: diffusion of a sine hill</h2>

<p>
It can be shown that

$$
\begin{equation}
\uex = Ae^{-\dfc\pi^2(L_x^{-2} + L_y^{-2})}
\sin\left(\frac{\pi}{L_x}x\right)\sin\left(\frac{\pi}{L_y}y\right),
\tag{3.108}
\end{equation}
$$

is a solution of the 2D homogeneous diffusion equation
\( u_t = \dfc(u_{xx}+u_{yy}) \) in
a rectangle \( [0,L_x]\times [0,L_y] \), for any value of the amplitude \( A \).
This solution vanishes at the boundaries,
and the initial condition is the product of two sines.
We may choose \( A=1 \) for simplicity.

<p>
It is difficult to know if our Jacobi method works properly since we
are faced with two sources of errors: one from the discretization,
\( E_\Delta \), and one from the iterative Jacobi method, \( E_i \). The total
error in the computed \( u \) can be represented as

$$ E_u = E_\Delta + E_i\tp$$

One error measure is to look at the maximum value, which is obtained for
the midpoint \( x=L_x/2 \) and \( y=L_x/2 \). This midpoint is represented in
the discrete <code>u</code> if \( N_x \) and \( N_y \) are even numbers. We can then
compute \( E_u \) as \( E_u = |\max \uex - \max u| \), when we know an exact
solution \( \uex \) of the problem.

<p>
What about \( E_\Delta \)? If we use the maximum value as a measure of the
error, we have in fact analytical insight into the approximation error in this
particular problem. According to the section <a href="#diffu:2D:analysis">Analysis of the 2D diffusion equation</a>, the exact
solution <a href="#mjx-eqn-3.108">(3.108)</a> of the PDE problem is
also an exact solution of the discrete equations, except that the
damping factor in time is different. More precisely,
<a href="#mjx-eqn-3.66">(3.66)</a> and
<a href="#mjx-eqn-3.67">(3.67)</a> are solutions of the discrete
problem for \( \theta=1 \) (Backward Euler) and \( \theta=\half \)
(Crank-Nicolson), respectively.  The factors raised to the power \( n \)
is the numerical amplitude, and the errors in these factors become

$$
\begin{align*}
E_\Delta &= e^{-\dfc k^2t} - \left(
\frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
\right)^n,\quad \theta=\half,\\ 
E_\Delta &= e^{-\dfc k^2t} -
(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n},\quad\theta=1\tp
\end{align*}
$$

We are now in a position to compute \( E_i \) numerically. That is, we can
compute the error due to iterative solution of the linear system and
see if it corresponds to the convergence tolerance used in the method.
Note that the convergence is based on measuring the difference in
two consecutive approximations, which is not exactly the error
due to the iteration, but it is a kind of measure, and it should
have about the same size as \( E_i \).

<p>
The function <code>demo_classic_iterative</code> in <a href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a> implements the idea above (also for the
methods in the section <a href="#diffu:2D:SOR">The Gauss-Seidel and SOR methods</a>). The value of \( E_i \) is in
particular printed at each time level. By changing the tolerance in
the convergence criterion in the Jacobi method, we can see that \( E_i \)
is of the same order of magnitude as the prescribed tolerance in the
Jacobi method.  For
example: \( E_\Delta\sim 10^{-2} \) with \( N_x=N_y=10 \) and \( \theta=\half \),
as long as \( \max u \) has some significant size (\( \max u >
0.02 \)). An appropriate value of the tolerance is then \( 10^{-3} \),
such that the error in the Jacobi method does not become bigger than
the discretization error. In that case,
\( E_i \) is around \( 5\cdot 10^{-3} \).
The corresponding number of Jacobi
iterations (with \( \omega=1 \)) varies from 31 to 12 during the
time simulation (for \( \max u >
0.02 \)). Changing the tolerance to \( 10^{-5} \) causes many more
iterations (61 to 42) without giving any contribution to the overall
accuracy, because the total error is dominated by \( E_\Delta \).

<p>
Also, with a \( N_x=N_y=20 \), the spatial accuracy increases and many more
iterations are needed (143 to 45), but the dominating error is from
the time discretization. However, with such a finer spatial mesh, a higher
tolerance in the convergence criterion \( 10^{-4} \) is needed to keep
\( E_i\sim 10^{-3} \).  More experiments show the disadvantage of the very
simple Jacobi iteration method: the number of iterations increases
with the number of unknowns, keeping the tolerance fixed, but the
tolerance should also be lowered to avoid the iteration error to
dominate the total error. A small adjustment of the Jacobi method, as
described in the section <a href="#diffu:2D:SOR">The Gauss-Seidel and SOR methods</a>, provides a better method.

<h2 id="diffu:2D:Jacobi_vs_FE">The relaxed Jacobi method and its relation to the Forward Euler method</h2>

<p>
We shall now show that solving the Poisson equation \( -\dfc\nabla^2 u = f \) by
the Jacobi iterative method is in fact equivalent to using a
Forward Euler scheme on \( u_t = \dfc\nabla^2 u + f \) and letting
\( t\rightarrow\infty \).

<p>
A Forward Euler discretization of the 2D diffusion equation,

$$ \lbrack D_t^+ u = \dfc (D_xD_x u + D_yD_y u) + f\rbrack^n_{i,j},$$

can be written out as

$$ u^{n+1} = u^n + \frac{\Delta t}{\dfc h^2}
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),$$

where \( h=\Delta x = \Delta y \) has been introduced for simplicity. The
scheme can be reordered as

$$ u^{n+1} = \left(1 - \omega\right) u_{i,j}^n
+ \frac{1}{4}\omega
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),$$

with

$$ \omega = 4\frac{\Delta t}{\dfc h^2},$$

but this latter form is nothing but the relaxed Jacobi method applied to

$$ [D_xD_x u + D_yD_y u = -f]^n_{i,j}\tp$$

<p>
From the equivalence above we know a couple of things about the Jacobi
method for solving \( -\nabla^2 u = f \):

<ol>
<li> The method is unstable if \( \omega > 1 \) (since the Forward Euler method
   is then unstable).</li>
<li> The convergence is really slow as the iteration index increases (coming from the fact that
   the Forward Euler scheme requires many small time steps to reach the stationary solution).</li>
</ol>

These observations are quite disappointing: if we already have a
time-dependent diffusion problem and want to take larger time steps by
an implicit time discretization method, we will with the Jacobi method
end up with something close to a slow Forward Euler simulation of the
original problem at each time level.  Nevertheless, the are two reasons
for why the Jacobi method
remains a fundamental building block for solving linear systems
arising from PDEs: 1) a couple of iterations remove
large parts of the error and this is effectively used in the very
efficient class of multigrid methods; and 2) the idea of the Jacobi
method can be developed into more efficient methods, especially the
SOR method, which is treated next.

<h2 id="diffu:2D:SOR">The Gauss-Seidel and SOR methods</h2>

<p>
If we update the mesh points according to the
Jacobi method <a href="#mjx-eqn-3.98">(3.98)</a>
for a Backward Euler discretization with a loop over
\( i=1,\ldots,N_x-1 \) and \( j=1,\ldots,Ny-1 \), we realize that
when \( u^{n+1,r+1}_{i,j} \) is computed, \( u^{n+1,r+1}_{i-1,j} \)
and \( u^{n+1,r+1}_{i,j-1} \) are already computed, so these new
values can be used rather than
\( u^{n+1,r}_{i-1,j} \) and \( u^{n+1,r}_{i,j-1} \) (respectively)
in the formula for \( u^{n+1,r+1}_{i,j} \).
This idea gives rise to the <em>Gauss-Seidel</em> iteration method,
which mathematically is just a small adjustment of
<a href="#mjx-eqn-3.98">(3.98)</a>:

$$
\begin{align}
& u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}((\nonumber\\ &\qquad
F_x
(u^{n+1,r+1}_{i-1,j} + u^{n+1,r}_{i,j}) +
F_y
(u^{n+1,r+1}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
u^n_{i,j} + \Delta t f^{n+1}_{i,j})\tp
\tag{3.109}
\end{align}
$$

Observe that the way we access the mesh points in the formula
<a href="#mjx-eqn-3.109">(3.109)</a> is important: points with \( i-1 \) must be computed
before points with \( i \), and points with \( j-1 \) must be computed
before points with \( j \). Any sequence of mesh points can be used
in the Gauss-Seidel method, but the particular math
formula must distinguish between
already visited points in the current iteration and the points not
yet visited.

<p>
The idea of relaxation <a href="#mjx-eqn-3.101">(3.101)</a> can equally
well be applied to the Gauss-Seidel method. Actually, the Gauss-Seidel
method with an arbitrary \( 0 < \omega\leq 2 \) has its own name: the
<em>Successive Over-Relaxation</em> method, abbreviated as SOR.

<p>
The SOR method for a \( \theta \) rule discretization, with the
shortened \( u \) and \( u^{-} \) notation, can be written

$$
\begin{align}
& u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u_{i-1,j} + u^{-}_{i,j}) +
F_y
(u_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\\ &\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\\ 
&\qquad (1-\theta)(
F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1}))),
\tag{3.110}\\ 
u_{i,j} &= \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}
\tag{3.111}
\end{align}
$$

The sequence of mesh points in <a href="#mjx-eqn-3.110">(3.110)</a> is
\( i=1,\ldots,N_x-1 \), \( j=1,\ldots,N_y-1 \) (but whether \( i \) runs faster
or slower than \( j \) does not matter).

<h2 id="diffu:2D:SOR:impl:scalar">Scalar implementation of the SOR method</h2>

<p>
Since the Jacobi and Gauss-Seidel methods with relaxation
are so similar, we can easily make a common code for the two:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
    <span style="color: #408080; font-style: italic"># Solve linear system by Jacobi/SOR iteration at time level n+1</span>
    u_[:,:] <span style="color: #666666">=</span> u_1  <span style="color: #408080; font-style: italic"># Start value</span>
    converged <span style="color: #666666">=</span> <span style="color: #008000">False</span>
    r <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #AA22FF; font-weight: bold">not</span> converged:
        <span style="color: #008000; font-weight: bold">if</span> version <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;scalar&#39;</span>:
            <span style="color: #008000; font-weight: bold">if</span> iteration <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Jacobi&#39;</span>:
                u__ <span style="color: #666666">=</span> u_
            <span style="color: #008000; font-weight: bold">elif</span> iteration <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;SOR&#39;</span>:
                u__ <span style="color: #666666">=</span> u
            j <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                u[i,j] <span style="color: #666666">=</span> U_0y(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
            <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> Iy[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;   u[i,j] <span style="color: #666666">=</span> U_0x(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                i <span style="color: #666666">=</span> Nx;  u[i,j] <span style="color: #666666">=</span> U_Lx(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># Boundary</span>
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]:
                    u_new <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
                        Fx<span style="color: #666666">*</span>(u_[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u__[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                        Fy<span style="color: #666666">*</span>(u_[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u__[i,j<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> \ 
                    u_1[i,j] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
                      Fx<span style="color: #666666">*</span>(
                    u_1[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                      Fy<span style="color: #666666">*</span>(
                    u_1[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[i,j] <span style="color: #666666">+</span> u_1[i,j<span style="color: #666666">-1</span>]))\ 
                      <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dt) <span style="color: #666666">+</span> \ 
                    (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f(i<span style="color: #666666">*</span>dx,j<span style="color: #666666">*</span>dy,n<span style="color: #666666">*</span>dt))
                    u[i,j] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[i,j]
                j <span style="color: #666666">=</span> Ny
                <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> Ix:
                    u[i,j] <span style="color: #666666">=</span> U_Ly(t[n<span style="color: #666666">+1</span>])  <span style="color: #408080; font-style: italic"># boundary</span>
        r <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        converged <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u<span style="color: #666666">-</span>u_)<span style="color: #666666">.</span>max() <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> r <span style="color: #666666">&gt;=</span> max_iter
        u_[:,:] <span style="color: #666666">=</span> u

    u_1, u <span style="color: #666666">=</span> u, u_1  <span style="color: #408080; font-style: italic"># Get ready for next iteration</span>
</pre></div>
<p>
The idea here is to introduce <code>u__</code> to be used for already computed
values (<code>u</code>) in the Gauss-Seidel/SOR version of the implementation, or
just values from the previous iteration (<code>u_</code>) in case of the Jacobi method.

<h2 id="diffu:2D:SOR:impl:vectorized">Vectorized implementation of the SOR method</h2>

<p>
Vectorizing the Gauss-Seidel iteration step turns out to be non-trivial.
The problem is that vectorized operations typically imply
operations on arrays where the sequence we visit the elements in does
not matter. In particular, this principle makes vectorized code trivial to
parallelize. However, in the Gauss-Seidel algorithm the sequence we
visit the elements in the arrays does matter, and it is well known that
the basic method as explained above cannot be parallelized.
Therefore, also vectorization will require new thinking.

<p>
The strategy for vectorizing (and parallelizing) the Gauss-Seidel
method is to use a special numbering of the mesh points called
red-black numbering: every other point is red or black as in a
checkerboard pattern. This numbering requires \( N_x \) and \( N_y \) to
be even numbers.
Here is an example of a \( 6\times 6 \) mesh:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
<p>
The idea now is to first update all the red points. Each formula for
updating a red point involves only the black neighbors. Thereafter, we
update all the black points, and at each black point, only the
recently computed red points are involved.

<p>
The scalar implementation of the red-black numbered Gauss-Seidel
method is really compact, since we can update values directly in
<code>u</code> (that guarantees that we use the most recently computed
values). Here is the relevant code for the Backward Euler
scheme in time and without a source term:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Update internal points</span>
<span style="color: #008000; font-weight: bold">for</span> sweep <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #BA2121">&#39;red&#39;</span>, <span style="color: #BA2121">&#39;black&#39;</span>:
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ny, <span style="color: #666666">1</span>):
        <span style="color: #008000; font-weight: bold">if</span> sweep <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;red&#39;</span>:
            start <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> j <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">2</span>
        <span style="color: #008000; font-weight: bold">elif</span> sweep <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;black&#39;</span>:
            start <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #008000; font-weight: bold">if</span> j <span style="color: #666666">%</span> <span style="color: #666666">2</span> <span style="color: #666666">==</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(start, Nx, <span style="color: #666666">2</span>):
	    u[i,j] <span style="color: #666666">=</span> <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(
                     Fx<span style="color: #666666">*</span>(u[i<span style="color: #666666">+1</span>,j] <span style="color: #666666">+</span> u[i<span style="color: #666666">-1</span>,j]) <span style="color: #666666">+</span>
                     Fy<span style="color: #666666">*</span>(u[i,j<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> u[i,j<span style="color: #666666">-1</span>]) <span style="color: #666666">+</span> u_1[i,j])
</pre></div>
<p>
The vectorized version must be based on slices. Looking at a typical
red-black pattern, e.g.,

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
<p>
we want to update the internal points (marking boundary points with
<code>x</code>):

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x b r b r b x
x r b r b r x
x b r b r b x
x r b r b r x
x x x x x x x
</pre></div>
<p>
It is impossible to make one slice that picks out all the internal
red points. Instead, we need two slices. The first involves points
marked with <code>R</code>:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x R b R b R x
x b r b r b x
x R b R b R x
x b r b r b x
x R b R b R x
x x x x x x x
</pre></div>
<p>
This slice is specified as <code>1::2</code> for <code>i</code> and <code>1::2</code> for <code>j</code>, or with
<code>slice</code> objects:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
The second slice involves the red points with <code>R</code>:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x b R b R b x
x r b r b r x
x b R b R b x
x r b r b r x
x x x x x x x
</pre></div>
<p>
The slices are

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
For the black points, the first slice involves the <code>B</code> points:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r B r B r x
x b r b r b x
x r B r B r x
x b r b r b x
x r B r B r x
x x x x x x x
</pre></div>
<p>
with slice objects

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
The second set of black points is shown here:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x x x x x x x
x r b r b r x
x B r B r B x
x r b r b r x
x B r B r B x
x r b r b r x
x x x x x x x
</pre></div>
<p>
with slice objects

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">i <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>);  j <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>, <span style="color: #008000">None</span>, <span style="color: #666666">2</span>)
</pre></div>
<p>
That is, we need four sets of slices. The simplest way of implementing
the algorithm is to make a function with variables for the slices
representing \( i \), \( i-1 \), \( i+1 \), \( j \), \( j-1 \), and \( j+1 \), here called
<code>ic</code> (&quot;i center&quot;), <code>im1</code> (&quot;i minus 1&quot;, <code>ip1</code> (&quot;i plus 1&quot;), <code>jc</code>, <code>jm1</code>,
and <code>jp1</code>, respectively.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">update</span>(u_, u_1, ic, im1, ip1, jc, jm1, jp1):
    <span style="color: #008000; font-weight: bold">return</span> \ 
       <span style="color: #666666">1.0/</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> <span style="color: #666666">2*</span>theta<span style="color: #666666">*</span>(Fx <span style="color: #666666">+</span> Fy))<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>(
           Fx<span style="color: #666666">*</span>(u_[ip1,jc] <span style="color: #666666">+</span> u_[im1,jc]) <span style="color: #666666">+</span>
           Fy<span style="color: #666666">*</span>(u_[ic,jp1] <span style="color: #666666">+</span> u_[ic,jm1])) <span style="color: #666666">+</span>\ 
       u_1[ic,jc] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>(
         Fx<span style="color: #666666">*</span>(u_1[ip1,jc] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[ic,jc] <span style="color: #666666">+</span> u_1[im1,jc]) <span style="color: #666666">+</span>\ 
         Fy<span style="color: #666666">*</span>(u_1[ic,jp1] <span style="color: #666666">-</span> <span style="color: #666666">2*</span>u_1[ic,jc] <span style="color: #666666">+</span> u_1[ic,jm1]))<span style="color: #666666">+</span>\ 
         theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_np1[ic,jc] <span style="color: #666666">+</span> \ 
         (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>f_a_n[ic,jc])
</pre></div>
<p>
The formula returned from <code>update</code> is to be compared with
<a href="#mjx-eqn-3.110">(3.110)</a>.

<p>
The relaxed Jacobi iteration can be implemented by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">ic  <span style="color: #666666">=</span> jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>)
im1 <span style="color: #666666">=</span> jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>)
ip1 <span style="color: #666666">=</span> jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_, u_1, ic, im1, ip1, jc, jm1, jp1)
u[ic,jc] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new[ic,jc] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[ic,jc]
</pre></div>
<p>
The Gauss-Seidel (or SOR) updates need four different steps.
The <code>ic</code> and <code>jc</code> slices are specified above. For each of these,
we must specify the corresponding <code>im1</code>, <code>ip1</code>, <code>jm1</code>, and <code>jp1</code>
slices. The code below contain the details.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Red points</span>
ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_1, ic, im1, ip1, jc, jm1, jp1)

ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_1, ic, im1, ip1, jc, jm1, jp1)

<span style="color: #408080; font-style: italic"># Black points</span>
ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_1, ic, im1, ip1, jc, jm1, jp1)

ic  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
im1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">0</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
ip1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
jc  <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">2</span>,<span style="color: #666666">-1</span>,<span style="color: #666666">2</span>)
jm1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-2</span>,<span style="color: #666666">2</span>)
jp1 <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">3</span>,<span style="color: #008000">None</span>,<span style="color: #666666">2</span>)
u_new[ic,jc] <span style="color: #666666">=</span> update(
    u_new, u_1, ic, im1, ip1, jc, jm1, jp1)

<span style="color: #408080; font-style: italic"># Relax</span>
c <span style="color: #666666">=</span> <span style="color: #008000">slice</span>(<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>)
u[c,c] <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>u_new[c,c] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_[c,c]
</pre></div>
<p>
The function <code>solver_classic_iterative</code> in
<a href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py" target="_self"><tt>diffu2D_u0.py</tt></a>
contains a unified implementation of the relaxed Jacobi and SOR
methods in scalar and vectorized versions using the techniques
explained above.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 17</b>: Experiments with SOR, benefits. Rerun the Jacobi experiments. Just mention the most important conclusions. We can have more comprehensive experiments with comparison of all methods in a later section, after CG with preconditioning.)</font>
<!-- end inline comment -->

<h2 id="diffu:2D:direct_vs_iter">Direct versus iterative methods</h2>

<h3 id="___sec345">Direct methods </h3>

<p>
There are two classes of methods for solving linear systems: direct methods
and iterative methods. Direct methods are based on variants of the
Gaussian elimination procedure and will produce an exact solution (in
exact arithmetics) in an a priori known number of steps.
Iterative methods, on the other hand, produce an approximate solution,
and the amount of work for reaching a given accuracy is usually not
known.

<p>
The most common direct method today is to use the <em>LU factorization</em>
procedure to factor the coefficient matrix \( A \) as the product of a
lower-triangular matrix \( L \) (with unit diagonal terms)
and an upper-triangular matrix \( U \):
\( A=LU \). As soon as we have \( L \) and \( U \), a system of equations \( LUc=b \)
is easy to solve because of the triangular nature of \( L \) and \( U \). We
first solve \( Ly=b \) for \( y \) (forward substitution), and
thereafter we find \( c \) from solving \( Uc=y \) (backward
substitution).  When \( A \) is a dense \( N\times N \) matrix, the LU
factorization costs \( \frac{1}{3}N^3 \) arithmetic operations, while the
forward and backward substitution steps each require of
the order \( N^2 \) arithmetic operations.
That is, factorization dominates the costs, while the substitution steps are
cheap.

<p>
Symmetric, positive definite coefficient matrices often arise when
discretizing PDEs. In this case, the LU factorization becomes \( A=LL^T \),
and the associated algorithm is known as <em>Cholesky factorization</em>.
Most linear algebra software offers highly optimized implementations of
LU and Cholesky factorization as well as forward and backward
substitution (<code>scipy.linalg</code> is the relevant Python package).

<p>
Finite difference discretizations lead to sparse coefficient matrices.
An extreme case arose in the section <a href="#diffu:pde1:BE">Backward Euler scheme</a> where \( A \) is
tridiagonal. For a tridiagonal matrix, the amount of arithmetic
operations in the LU and Cholesky factorization algorithms is just of
the order \( N \), not \( N^3 \). Tridiagonal matrices are special cases of
<em>banded matrices</em>, where the matrices contain just a set of diagonal
bands.  Finite difference methods on regularly numbered rectangular
and box-shaped meshes give rise to such banded matrices, with 5 bands
in 2D and 7 in 3D for diffusion problems.  Gaussian elimination only
needs to work within the bands, leading to much more efficient
algorithms. For example, factorization of more general, sparse
matrices can often take advantage of the sparsity through modified
Gaussian elimination algorithms. The relevant Python package is
<code>scipy.sparse.linalg</code>.

<p>
Although a direct method is an exact algorithm, rounding errors
may in practice accumulate and pollute the solution. The effect
grows with the size of the linear system, so both for accuracy and
efficiency, iterative methods are better suited than direct methods
for solving really large linear systems.

<h3 id="___sec346">Iterative methods </h3>

<p>
The Jacobi and SOR iterative methods belong to a class of iterative methods
where the idea is to solve \( Au=b \) by splitting A into two parts, \( A=M-N \),
such that solving systems \( Mu=c \) is easy and efficient. With the splitting,
we get a system

$$ Mu = Nu + b,$$

which suggests an iterative method

$$ Mu^{r+1} = Nu^{r} + b,\quad r=0,1,2,\ldots,$$

where \( u^{r+1} \) is a new approximation to \( u \) in the \( r+1 \)-th iteration. To
initiate the iteration, we need a start vector \( u^0 \).

<p>
The Jacobi and SOR methods are based on splitting \( A \) into a lower
tridiagonal part \( L \), the diagonal \( D \), and an upper tridiagonal part \( U \),
such that \( A=L+D+U \). The Jacobi method corresponds to \( M=D \) and \( N=-L-U \).
The Gauss-Seidel method employs \( M=L+D \) and \( N=-U \), while the SOR
method corresponds to

$$ M= \frac{1}{\omega}D + L,\quad N = \frac{1-\omega}{\omega}D - U\tp$$

The relaxed Jacobi method has similar expressions:

$$ M = \frac{1}{\omega}D,\quad N = \frac{1-\omega}{\omega}D - L - U\tp$$

<p>
With the matrix forms of the Jacobi and SOR methods as written above,
we could in an implementation alternatively fill the matrix \( A \) with
entries and call general implementations of the Jacobi or SOR methods
that work on a system \( Au=b \). However, this is almost never done since
forming the matrix \( A \) requires quite some code and storing \( A \) in the
computer's memory is unnecessary. It is much easier to just apply the
Jacobi and SOR ideas to the finite difference stencils directly in an
implementation, as we have shown in detail.

<p>
Nevertheless, the matrix formulation of the Jacobi and SOR methods have
been important for analyzing their convergence behavior. One can show that
the error \( u^r-u \) fulfills \( u^r-u = G^r(u^0-u) \), where \( G=M^{-1}N \)
and \( G^k \) is a matrix exponential. For the method to converge,
\( \lim_{r\rightarrow\infty}||G^r||=0 \) is a necessary and sufficient condition.
This implies that the <em>spectral radius</em> of \( G \) must be less than one.
Since \( G \) is directly related to the finite difference scheme for the
underlying PDE problem, one can in principle compute the spectral radius.
For a given PDE problem, however, this is not a practical strategy, since it
is very difficult to develop useful formulas.
Analysis of model problems, usually
related to the Poisson equation,
reveals some trends of interest: the convergence rate of the Jacobi
method goes like \( h^2 \), while that of SOR with an optimal \( \omega \) goes
like \( h \), where \( h \) is the spatial spacing: \( h=\Delta x=\Delta y \).
That is, the efficiency of the Jacobi method quickly deteriorates with
the increasing mesh resolution, and SOR is much to be preferred
(even if the optimal
\( \omega \) remains an open question). We refer to
Chapter 4 of <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Saad_2003">[5]</a> for more information on the convergence theory.
One important result is that if \( A \) is symmetric and positive definite,
then SOR will converge for any \( 0 < \omega < 2 \).

<p>
The optimal \( \omega \) parameter can be theoretically established for
a Poisson problem as

$$
\begin{equation}
\omega_{o} = \frac{2}{1 + \sqrt{1-\varrho^2}},\quad \varrho = \frac{\cos(\pi/N_x) + (\Delta x/\Delta y)^2\cos(\pi/N_y)}{1 + (\Delta x/\Delta y)^2}\tp
\tag{3.112}
\end{equation}
$$

This formula can be used as a guide also in other problems.

<p>
The Jacobi and the SOR methods have their great advantage of being
trivial to implement, so they are obviously popular of this reason.
However, the slow convergence of these methods limits the popularity to fairly
small linear systems (i.e., coarse meshes). As soon as the matrix size
grows, one is better off with more sophisticated iterative methods
like the preconditioned Conjugate gradient method, which we now turn to.

<p>
Finally, we mention that there is a variant of the SOR method, called
Symmetric Successive Overrelaxation method, known as SSOR, where
one runs a standard SOR sweep through the mesh points and then a
new sweep but visiting the points in reverse order.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 18</b>: Line Jacobi/SOR?)</font>
<!-- end inline comment -->

<h2 id="diffu:2D:CG">The Conjugate gradient method</h2>

<p>
There is no simple intuitive derivation of the Conjugate gradient
method, so we refer to the many excellent expositions in the
literature for the idea of the method and how the algorithm is
derived. In particular, we recommend the books
<a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Templates_LA">[6]</a> <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Saad_2003">[5]</a> <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Greif_Ascher_2011">[7]</a>.  A brief overview is
provided in the <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method" target="_self">Wikipedia article</a>. Here, we
just state the pros and cons of the method from a user's perspective
and how we utilize it in code.

<p>
The original Conjugate gradient method is limited to linear systems \( Au=b \),
where \( A \) is a symmetric and positive definite matrix. There are, however,
extensions of the method to non-symmetric matrices.
<!-- , so when we use the -->
<!-- term <em>Conjugate gradient method</em> hereafter, we usually mean the family of -->
<!-- related methods that can be applied -->
<!-- to most matrix systems arising from discretizing -->
<!-- PDEs. When we need to distinuish between methods for -->
<!-- the symmetric and non-symmetric -->
<!-- cases, we use the terms <em>original Conjugate gradient method</em> and -->
<!-- <em>conjugate gradient-like methods</em>, respectively. -->

<p>
A major advantage of all conjugate gradient methods is that the matrix
\( A \) is only used in matrix-vector products, so we do not need form and
store \( A \) if we can provide code for computing a matrix-vector product
\( Au \).  Another important feature is that the algorithm is very easy to
vectorize and parallelize.  The primary downside of the method is that
it convergences slowly unless one has an effective <em>preconditioner</em>
for the system. That is, instead of solving \( Au=b \), we try to solve
\( M^{-1}Au=M^{-1}b \) in the hope that the method works better for this
<em>preconditioned</em> system. The matrix \( M \) is the <em>preconditioner</em> or
preconditioning matrix.  Now we need to perform matrix-vector products
\( y = M^{-1}Au \), which is done in two steps: first the matrix-vector
product \( v=Au \) is carried out and then the system
\( My=v \) must be solved.
Therefore, \( M \) must be cheap to compute and systems \( My=v \)
must be cheap to solve.

<p>
A perfect preconditioner is \( M=A \), but in each iteration in the
Conjugate gradient method one then has so solve a system with \( A \) as
coefficient matrix! A key idea is to let \( M \) be some kind of <em>cheap
approximation</em> to \( A \).  The simplest preconditioner is to set \( M=D \),
where \( D \) is the diagonal of \( A \). This choice means running one Jacobi
iteration as preconditioner. <a href="#diffu:exer:splitting_prec">Exercise 3.8: Splitting methods and preconditioning</a>
shows that the Jacobi and SOR methods can also be viewed as
preconditioners.

<p>
Constructing good preconditioners is a scientific field on its
own. Here we shall treat the topic just very briefly. For a user
having access to the <code>scipy.sparse.linalg</code> library, there are
Conjugate gradient methods and preconditioners readily available:

<ul>
 <li> For positive definite, symmetric systems: <code>cg</code> (the Conjugate gradient method)</li>
 <li> For symmetric systems: <code>minres</code> (Minimum residual method)</li>
 <li> For non-symmetric systems:</li>

<ul>
  <li> <code>gmres</code> (GMRES: Generalized minimum residual method)</li>
  <li> <code>bicg</code> (BiConjugate gradient method)</li>
  <li> <code>bicgstab</code> (Stabilized BiConjugate gradient method)</li>
  <li> <code>cgs</code> (Conjugate gradient squared method)</li>
  <li> <code>qmr</code> (Quasi-minimal residual iteration)</li>
</ul>

 <li> Preconditioner: <code>spilu</code> (Sparse, incomplete LU factorization)</li>
</ul>

The ILU preconditioner is an attractive all-round type of
preconditioner that is suitable for most problems on serial
computers. A more efficient preconditioner is the multigrid method,
and algebraic multigrid is also an all-round choice as
preconditioner. The Python package <a href="https://github.com/pyamg/pyamg" target="_self">PyAMG</a> offers efficient implementations of
the algebraic multigrid method, to be used both as a preconditioner
and as a stand-alone iterative method.

<p>
The matrix arising from implicit time discretization methods of the
diffusion equation is symmetric and positive definite so we can use
the Conjugate gradient method (<code>cg</code>), typically in combination with an
ILU preconditioner.  The code is very similar to the one we created
when solving the linear system by sparse Gaussian elimination, the
main difference is that we now allow for calling up the Conjugate
gradient function as an alternative solver.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_sparse</span>(
    I, a, f, Lx, Ly, Nx, Ny, dt, T, theta<span style="color: #666666">=0.5</span>,
    U_0x<span style="color: #666666">=0</span>, U_0y<span style="color: #666666">=0</span>, U_Lx<span style="color: #666666">=0</span>, U_Ly<span style="color: #666666">=0</span>, user_action<span style="color: #666666">=</span><span style="color: #008000">None</span>,
    method<span style="color: #666666">=</span><span style="color: #BA2121">&#39;direct&#39;</span>, CG_prec<span style="color: #666666">=</span><span style="color: #BA2121">&#39;ILU&#39;</span>, CG_tol<span style="color: #666666">=1E-5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Full solver for the model problem using the theta-rule</span>
<span style="color: #BA2121; font-style: italic">    difference approximation in time. Sparse matrix with</span>
<span style="color: #BA2121; font-style: italic">    dedicated Gaussian elimination algorithm (method=&#39;direct&#39;)</span>
<span style="color: #BA2121; font-style: italic">    or ILU preconditioned Conjugate Gradients (method=&#39;CG&#39; with</span>
<span style="color: #BA2121; font-style: italic">    tolerance CG_tol and preconditioner CG_prec (&#39;ILU&#39; or None)).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Set up data structures as shown before</span>

    <span style="color: #408080; font-style: italic"># Precompute sparse matrix</span>
    <span style="color: #666666">...</span>

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags(
        diagonals<span style="color: #666666">=</span>[main, lower, upper, lower2, upper2],
        offsets<span style="color: #666666">=</span>[<span style="color: #666666">0</span>, <span style="color: #666666">-</span>lower_offset, lower_offset,
                 <span style="color: #666666">-</span>lower2_offset, lower2_offset],
        shape<span style="color: #666666">=</span>(N, N), format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>)

    <span style="color: #008000; font-weight: bold">if</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;CG&#39;</span>:
        <span style="color: #008000; font-weight: bold">if</span> CG_prec <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;ILU&#39;</span>:
            <span style="color: #408080; font-style: italic"># Find ILU preconditioner (constant in time)</span>
            A_ilu <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spilu(A)  <span style="color: #408080; font-style: italic"># SuperLU defaults</span>
            M <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>LinearOperator(
                shape<span style="color: #666666">=</span>(N, N), matvec<span style="color: #666666">=</span>A_ilu<span style="color: #666666">.</span>solve)
        <span style="color: #008000; font-weight: bold">else</span>:
            M <span style="color: #666666">=</span> <span style="color: #008000">None</span>
        CG_iter <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># No of CG iterations at time level n</span>

    <span style="color: #408080; font-style: italic"># Time loop</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> It[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]:
        <span style="color: #408080; font-style: italic"># Compute b, vectorized version</span>

        <span style="color: #408080; font-style: italic"># Solve matrix system A*c = b</span>
        <span style="color: #008000; font-weight: bold">if</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;direct&#39;</span>:
            c <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
        <span style="color: #008000; font-weight: bold">elif</span> method <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;CG&#39;</span>:
            x0 <span style="color: #666666">=</span> u_1<span style="color: #666666">.</span>T<span style="color: #666666">.</span>reshape(N)  <span style="color: #408080; font-style: italic"># Start vector is u_1</span>
            CG_iter<span style="color: #666666">.</span>append(<span style="color: #666666">0</span>)

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CG_callback</span>(c_k):
                <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Trick to count the no of iterations in CG.&quot;&quot;&quot;</span>
                CG_iter[<span style="color: #666666">-1</span>] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

            c, info <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>cg(
                A, b, x0<span style="color: #666666">=</span>x0, tol<span style="color: #666666">=</span>CG_tol, maxiter<span style="color: #666666">=</span>N, M<span style="color: #666666">=</span>M,
                callback<span style="color: #666666">=</span>CG_callback)

        <span style="color: #408080; font-style: italic"># Fill u with vector c</span>
        <span style="color: #408080; font-style: italic"># Update u_1 before next step</span>
        u_1, u <span style="color: #666666">=</span> u, u_1
</pre></div>
<p>
The number of iterations in the Conjugate gradient method is of interest,
but unfortunately not available from the <code>cg</code> function, so
we perform a trick: in each iteration a user function <code>CG_callback</code>
is called where we accumulate the number of iteration in a list
<code>CG_iter</code>.

<h1 id="diffu:randomwalk">Random walk</h1>

<p>
Models leading to diffusion equations, see the section <a href="#diffu:app">Applications</a>, are
usually based on reasoning with <em>averaged</em> physical quantities such as
concentration, temperature, and velocity.  The underlying physical
processes involve complicated microscopic movement of atoms and
molecules, but an average of a large number of molecules is performed
in a small volume before the modeling starts, and the averaged
quantity inside this volume is assigned as a point value at the
centroid of the volume. This means that concentration, temperature,
and velocity at a space-time point represent averages around the
point in a small time interval and small spatial volume.

<p>
Random walk is a principally totally different kind of modeling procedure.
The idea is to have a large number of &quot;particles&quot; that undergo
random movements. Averaging can then be used afterwards to compute
macroscopic quantities like concentration. The &quot;particles&quot; and their
random movement represent a very simplified microscopic behavior of
molecules, much simpler and computationally much more efficient than
direct <a href="https://en.wikipedia.org/wiki/Molecular_dynamics" target="_self">molecular simulation</a>,
yet the random walk model has been very powerful to describe a wide
range of phenomena, including heat conduction, quantum mechanics,
polymer chains, population genetics, neuroscience, hazard games, and
pricing of financial instruments.

<p>
It can be shown that random walk, when averaged, produces models that
are mathematically equivalent to diffusion equations. This is the
primary reason why we treat random walk in this chapter: two very
different algorithms (finite difference stencils and random walk)
solve the same type of problems. The simplicity of the random walk
algorithm makes it particularly attractive for solving diffusion
equations on massively parallel computers.

<h2 id="diffu:randomwalk:1D">Random walk in 1D</h2>

<p>
Imagine that we have some particles that perform random moves, either
to the right or to the left. We may flip a coin to decide the movement
of each particle, say head implies movement to the right and tail
means movement to the left. Each move is one unit length.  Physicists
use the term <em>random walk</em> for this type of movement.
The movement is also known as <a href="https://en.wikipedia.org/wiki/The_Drunkard%27s_Walk" target="_self">drunkard's walk</a>.
You may try this yourself: flip the coin and make one step to the left
or right, and repeat the process.

<p>
We introduce the symbol \( N \) for the number of steps in a random walk.
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">50</a> shows four different
random walks with \( N=200 \).

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:ensemble"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 50:  Ensemble of 4 random walks, each with 200 steps.  <!-- caption label: diffu:randomwalk:1D:fig:ensemble --> </p></center>
<p><img src="fig-diffu/rw1D_ensemble4.png" align="bottom" width=800></p>
</center>

<h2 id="diffu:randomwalk:1D:EVar">Statistical considerations</h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 19</b>: Need to distinguish between scaled and unscaled position in the notation here!)</font>
<!-- end inline comment -->

<p>
Let \( S_k \) be the stochastic variable representing a step to the left
or to the right in step number \( k \). We have that \( S_k=-1 \) with
probability \( p \) and \( S_k=1 \) with probability \( q=1-p \). The variable
\( S_k \) is known as a <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution" target="_self">Bernoulli variable</a>. The
expectation of \( S_k \) is

$$ \E{S_k} = p\cdot (-1) + q\cdot 1 = 1 - 2p,$$

and the variance is

$$ \Var{S_k} = \E{S_k^2} - \E{S_k}^2 = 1 - (1-2p)^2 = 4p(1-p)\tp$$

<p>
The position after \( k \) steps is another stochastic variable

$$ \bar X_k = \sum_{i=0}^{k-1} S_i\tp$$

The expected position is

$$ \E{\bar X_k} =
\E{\sum_{i=0}^{k-1} S_i} = \sum_{i=0}^{k-1} \E{S_i}= k(1-2p)\tp$$

All the \( S_k \) variables are independent. The variance therefore becomes

$$ \Var{\bar X_k} = \Var{\sum_{i=0}^{k-1} S_i} = \sum_{i=0}^{k-1} \Var{S_i}=
k4p(1-p)\tp$$

We see that \( \Var{\bar X_k} \) is proportional with the number of steps \( k \).
For the very important case \( p=q=\half \), \( \E{\bar X_k}=0 \) and
\( \Var{\bar X_k}=k \).

<p>
How can we estimate \( \E{\bar X_k}=0 \) and \( \Var{\bar X_k}=N \)?
We must have many random walks of the type in
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">50</a>. For a given \( k \), say \( k=100 \),
we find all the values of \( \bar X_k \), name them \( \bar x_{0,k} \), \( \bar x_{1,k} \),
\( \bar x_{2,k} \), and so on. The empirical estimate of \( \E{\bar X_k} \) is the
average,

$$ \E{\bar X_k} \approx = \frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k},$$

while an empirical estimate of \( \Var{\bar X_k} \) is

$$ \Var{\bar X_k} \approx \frac{1}{W}\sum_{j=0}^{W-1} (\bar x_{j,k})^2 -
\left(\frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k}\right)^2\tp$$

That is, we take the statistics for a given \( K \) across the ensemble
of random walks (&quot;vertically&quot; in
Figure <a href="#diffu:randomwalk:1D:fig:ensemble">50</a>). The key quantities
to record are \( \sum_i \bar x_{i,k} \) and \( \sum_i \bar x_{i,k}^2 \).

<h2 id="diffu:randomwalk:1D:code1">Playing around with some code</h2>

<h3 id="___sec352">Scalar code </h3>

<p>
Python has a <code>random</code> module for drawing random numbers, and a function
<code>uniform(a, b)</code> for drawing a uniformly distributed
random number in the interval \( [a,b) \).
If an event happens with probability \( p \), we can simulate this on
the computer by drawing a random number \( r \) in \( [0,1) \), because then \( r\leq p \)
with probability \( p \) and \( r>p \) with probability \( 1-p \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span>
r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
<span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
    <span style="color: #408080; font-style: italic"># Event happens</span>
<span style="color: #008000; font-weight: bold">else</span>:
    <span style="color: #408080; font-style: italic"># Event does not happen</span>
</pre></div>
<p>
A random walk with \( N \) steps, starting at \( x_0 \), where we move
to the left with probability \( p \) and to the right
with probability \( 1-p \) can now be implemented by

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk1D</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;1D random walk with 1 particle.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> x0
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N<span style="color: #666666">-1</span>):
        r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
            current_pos <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            current_pos <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        position[k<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>

<h3 id="___sec353">Vectorized code </h3>

<p>
Since \( N \) is supposed to be large and we want to repeat the process for
many particles, we should speed up the code as much as possible.
Vectorization is the obvious technique here: we draw all the random
numbers at once with aid of <code>numpy</code>, and then we formulate vector
operations to get rid of the loop over the steps (<code>k</code>).
The <code>numpy.random</code> module has vectorized versions of the functions in
Python's built-in <code>random</code> module. For example, <code>numpy.random.uniform(a, b, N)</code>
returns <code>N</code> random numbers uniformly distributed between <code>a</code> (included)
and <code>b</code> (not included).

<p>
We can then make an array of all the steps in a random walk: if
the random number is less than or equal to \( p \), the step is \( -1 \),
otherwise the step is \( 1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
</pre></div>
<p>
The value of <code>position[k]</code> is the sum of all steps up to step <code>k</code>.
Such sums are often needed in vectorized algorithms and therefore
available by the <code>numpy.cumsum</code> function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">3</span>,<span style="color: #666666">4</span>,<span style="color: #666666">6</span>]))
array([ <span style="color: #666666">1</span>,  <span style="color: #666666">4</span>,  <span style="color: #666666">8</span>, <span style="color: #666666">14</span>])
</pre></div>
<p>
The resulting array in this demo has elements \( 1 \), \( 1+3=4 \), \( 1+3+4=8 \),
and \( 1+3+4+6=14 \).

<p>
We can now vectorize the <code>random_walk1D</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk1D_vec</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walk1D.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
    position[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps)
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
This code runs about 10 times faster than the scalar version.
With a parallel <code>numpy</code> library, the code can also automatically take
advantage of hardware for parallel computing because each of the four
array operations can be trivially parallelized.

<h3 id="___sec354">Fixing the random sequence </h3>

<p>
During software development with random numbers it is advantageous to
always generate the same sequence of random numbers as this may help
debugging processes. To fix the sequence, we set a <em>seed</em> of the random
number generator to some chosen integer, e.g.,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
</pre></div>
<p>
Calls to <code>random_walk1D_vec</code> give positions of the particle as
depicted in Figure <a href="#diffu:randomwalk:1D:code1:fig1">51</a>. The particle starts
at the origin and moves with \( p=\half \). Since the seed is the same,
the plot to the left is just a magnification of the first 1/50 steps in
the plot to the right.
<!-- demo_random_walk1D produced the plots -->

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:code1:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 51:  1,000 (left) and 50,000 (right) steps of a random walk.  <!-- caption label: diffu:randomwalk:1D:code1:fig1 --> </p></center>
<p><img src="fig-diffu/rw1D_1sample.png" align="bottom" width=800></p>
</center>

<h3 id="___sec355">Verification </h3>

<p>
When we have a scalar and a vectorized code, it is always a good idea to
develop a unit test for checking that they produce the same result.
A problem in the present context is that the two versions apply to different
random number generators. For a test to be meaningful, we need to fix
the seed and use the same generator. This means that the scalar version
must either use <code>np.random</code> or have this as an option. An option
is the most flexible choice:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">import random

def random_walk1D(x0, N, p, random=random):
    ...
    r = random.uniform(0, 1)
</pre></div>
<p>
Using <code>random=np.random</code>, the <code>r</code> variable gets computed
by <code>np.random.uniform</code>, and the sequence of random numbers will be
the same as in the vectorized version that employs the same generator
(given that the seed is also the same). A proper test function may be
to check that the positions in the walk are the same in the scalar and
vectorized implementations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_random_walk1D</span>():
    <span style="color: #408080; font-style: italic"># For fixed seed, check that scalar and vectorized versions</span>
    <span style="color: #408080; font-style: italic"># produce the same result</span>
    x0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  N <span style="color: #666666">=</span> <span style="color: #666666">4</span>;  p <span style="color: #666666">=</span> <span style="color: #666666">0.6</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    scalar_computed <span style="color: #666666">=</span> random_walk1D(x0, N, p, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized_computed <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (scalar_computed <span style="color: #666666">==</span> vectorized_computed)<span style="color: #666666">.</span>all()
</pre></div>
<p>
Note that we employ <code>==</code> for arrays with real numbers, which is normally
an inadequate test due to rounding errors, but in the present case,
all arithmetics consists of adding or subtracting one, so these operations
are expected to have no rounding errors. Comparing two <code>numpy</code> arrays
with <code>==</code> results in a boolean array, so we need to call the <code>all()</code>
method to ensure that all elements are <code>True</code>, i.e., that all elements
in the two arrays match each other pairwise.

<h2 id="diffu:randomwalk:1D:pde">Equivalence with diffusion</h2>

<p>
The original random walk algorithm can be said to work with
dimensionless coordinates \( \bar x_i = -N + i \), \( i=0,1,\ldots, 2N+1 \)
(\( i\in [-N,N] \)), and \( \bar t_n=n \), \( n=0,1,\ldots,N \).  A mesh with
spacings \( \Delta x \) and \( \Delta t \) with dimensions can be introduced
by

$$ x_i = X_0 + \bar x_i \Delta x,\quad t_n = \bar t_n\Delta t\tp$$

If we implement the algorithm with dimensionless coordinates, we can just
use this rescaling to obtain the movement in a coordinate system
without unit spacings.

<p>
Let \( P^{n+1}_i \) be the probability of finding the particle at mesh point
\( \bar x_i \) at time \( \bar t_{n+1} \). We can reach mesh point \( (i,n+1) \) in two
ways: either coming in from the left from \( (i-1,n) \) or from the
right (\( i+1,n) \). Both has probability \( \half \) (if we assume
\( p=q=\half \)). The fundamental equation for \( P^{n+1}_i \) is

$$
\begin{equation}
P^{n+1}_i = \half P^{n}_{i-1} + \half P^{n}_{i+1}\tp
\tag{3.113}
\end{equation}
$$

(This equation is easiest to understand if one looks at the random walk
as a Markov process and applies the transition probabilities, but this is
beyond scope of the present text.)

<p>
Subtracting \( P^{n}_i \) from (<a href="#diffu:randomwalk:1D">Random walk in 1D</a>) results
in

$$
P^{n+1}_i - P^{n}_i = \half (P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1})\tp
$$

Readers who have seen the Forward Euler discretization of a 1D
diffusion equation recognize this scheme as very close to such a
discretization. We have

$$ \frac{\partial}{\partial t}P(x_i,t_{n})
= \frac{P^{n+1}_i - P^{n}_i}{\Delta t} + \Oof{\Delta t},$$

or in dimensionless coordinates

$$ \frac{\partial}{\partial\bar t}P(\bar x_i,\bar t_n)
\approx P^{n+1}_i - P^{n}_i\tp$$

Similarly, we have

$$
\begin{align*}
\frac{\partial^2}{\partial x^2}P(x_i,t_n) &=
\frac{P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1}}{\Delta x^2}
+ \Oof{\Delta x^2},\\ 
\frac{\partial^2}{\partial x^2}P(\bar x_i,\bar t_n) &\approx
P^{n}_{i-1} -2P^{n}_i + \half P^{n}_{i+1}\tp
\end{align*}
$$

Equation (<a href="#diffu:randomwalk:1D">Random walk in 1D</a>) is therefore equivalent with
the dimensionless diffusion equation

$$
\begin{equation}
\frac{\partial P}{\partial\bar t} = \frac{1}{2}
\frac{\partial^2 P}{\partial \bar x^2},
\tag{3.114}
\end{equation}
$$

or the diffusion equation

$$
\begin{equation}
\frac{\partial P}{\partial t} = D\frac{\partial^2 P}{\partial x^2},
\tag{3.115}
\end{equation}
$$

with diffusion coefficient

$$ D = \frac{\Delta x^2}{2\Delta t}\tp$$

This derivation shows the tight link between random walk and diffusion.
If we keep track of where the particle is, and repeat the process
many times, or run the algorithms for lots of particles, the histogram
of the positions will approximate the solution of the diffusion equation
for the local probability \( P^n_i \).

<p>
Suppose all the random walks start at the origin. Then the initial
condition for the probability distribution is the Dirac delta
function \( \delta(x) \). The solution of <a href="#mjx-eqn-3.114">(3.114)</a>
can be shown to be

$$
\begin{equation}
\bar P(\bar x,\bar t) = \frac{1}{\sqrt{4\pi\dfc t}}e^{-\frac{x^2}{4\dfc t}},
\tag{3.116}
\end{equation}
$$

where \( \dfc = \half \).

<h2 id="___sec357">Implementation of multiple walks </h2>

<p>
Our next task is to implement an ensemble of walks (for statistics,
see the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a>) and also provide data from
the walks such that we can compute the probabilities of the positions
as introduced in the previous section. An appropriate representation
of probabilities \( P^n_i \) are histograms (with \( i \) along the \( x \) axis)
for a few selected values of \( n \).

<p>
To estimate the expectation and variance of the random walks,
the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a> points to recording
\( \sum_j x_{j,k} \) and \( \sum_j x_{j,k}^2 \), where \( x_{j,k} \) is the
position at time/step level \( k \) in random walk number \( j \).
The histogram of positions needs the individual values \( x_{i,k} \)
for all \( i \) values and some selected \( k \) values.

<p>
We introduce <code>position[k]</code> to hold \( \sum_j x_{j,k} \),
<code>position2[k]</code> to hold \( \sum_j (x_{j,k})^2 \), and
<code>pos_hist[i,k]</code> to hold \( x_{i,k} \). A selection of \( k \) values can be
specified by saying how many, <code>num_times</code>, and let them be equally
spaced through time:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]
</pre></div>
<p>
This is one of the few situations we want integer division (<code>//</code>) or
real division rounded to an integer.

<h3 id="___sec358">Scalar version </h3>

<p>
Our scalar implementation of running <code>num_walks</code> random walks may go
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>,
                   random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0<span style="color: #666666">*</span>num_walks
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)   <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    position2[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0<span style="color: #666666">**2*</span>num_walks
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]
    <span style="color: #408080; font-style: italic">#print &#39;save hist:&#39;, post_hist_times</span>

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        current_pos <span style="color: #666666">=</span> x0
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
            <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
                <span style="color: #408080; font-style: italic">#print &#39;save, k:&#39;, k, num_times_counter, n</span>
                pos_hist[n,num_times_counter] <span style="color: #666666">=</span> current_pos
                num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
            <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos
            position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec359">Vectorized version </h3>

<p>
We have already vectorized a single random walk. The additional
challenge here is to vectorize the computation of the data for the
histogram, <code>pos_hist</code>, but given the selected steps in <code>pos_hist_times</code>,
we can find the corresponding positions by indexing with the
list <code>pos_hist_times</code>: <code>position[post_hist_times]</code>, which are to be
inserted in <code>pos_hist[n,:]</code>.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D_vec1</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walk <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)         <span style="color: #408080; font-style: italic"># Positions of current walk</span>
    walk[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N)
        steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
        walk[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps)  <span style="color: #408080; font-style: italic"># Positions of this walk</span>
        position  <span style="color: #666666">+=</span> walk
        position2 <span style="color: #666666">+=</span> walk<span style="color: #666666">**2</span>
        pos_hist[n,:] <span style="color: #666666">=</span> walk[pos_hist_times]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec360">Improved vectorized version </h3>

<p>
Looking at the vectorized version above, we still have one potentially
long Python loop over <code>n</code>. Normally, <code>num_walks</code> will be much larger than <code>N</code>.
The vectorization of the loop over <code>N</code> certainly speeds up the program,
but if we think of vectorization as also a way to parallelize the code,
all the independent walks (the <code>n</code> loop) can be executed in parallel.
Therefore, we should include this loop as well in the vectorized
expressions, at the expense of using more memory.

<p>
We introduce the array <code>walks</code> to hold the \( N+1 \) steps of all the walks:
each row represents the steps in one walk.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
walks[:,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
</pre></div>
<p>
Since all the steps are independent, we can just make one long
vector of enough random numbers (<code>N*num_walks</code>), translate these
numbers to \( \pm 1 \), then we reshape the array such that the steps
of each walk are stored in the rows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks)
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N)
</pre></div>
<p>
The next step is to sum up the steps in each walk. We need the
<code>np.cumsum</code> function for this, with the argument <code>axis=1</code> for
indicating a sum across the columns:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">6</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">2</span>,<span style="color: #666666">3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>],
       [<span style="color: #666666">3</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(a, axis<span style="color: #666666">=1</span>)
array([[ <span style="color: #666666">0</span>,  <span style="color: #666666">1</span>,  <span style="color: #666666">3</span>],
       [ <span style="color: #666666">3</span>,  <span style="color: #666666">7</span>, <span style="color: #666666">12</span>]])
</pre></div>
<p>
Now <code>walks</code> can be computed by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">walks[:,<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
</pre></div>
<p>
The <code>position</code> vector is the sum of all the walks. That is, we want to
sum all the rows, obtained by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks, axis<span style="color: #666666">=0</span>)
</pre></div>
<p>
A corresponding expression computes the squares of the positions.
Finally, we need to compute <code>pos_hist</code>, but that is a matter of
grabbing some of the walks (according to <code>pos_hist_times</code>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">pos_hist[:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times]
</pre></div>
<p>
The complete vectorized algorithm without any loop can now be
summarized:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D_vec2</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
    walks[:,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N)
    walks[:,<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks,    axis<span style="color: #666666">=0</span>)
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks<span style="color: #666666">**2</span>, axis<span style="color: #666666">=0</span>)
    pos_hist[:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
What is the gain of the vectorized implementations? One important gain
is that each vectorized operation can be automatically parallelized
if one applies a parallel <code>numpy</code> library like <a href="http://numba.pydata.org" target="_self">Numba</a>. One a single CPU, however, the speed up of the vectorized operations
is also significant. With \( N=1,000 \) and 50,000 repeated walks,
the two vectorized versions run about 25 and 18 times faster than the scalar
version, with <code>random_walks1D_vec1</code> being fastest.
<!-- The downside of vectorization of random walks is the large -->
<!-- arrays that arise, especially the version in <code>random_walks1D_vec2</code>. -->
<!-- CPU: -->
<!-- N=1000, 50K walks -->
<!-- scalar: 42, vec1: 1.7, vec2: 1.7, factors 25 and 25 -->

<h3 id="___sec361">Remark on vectorized code and parallelization </h3>

<p>
Our first attempt on vectorization removed the loop over the \( N \) steps in
a single walk. However, the number of walks is usually much larger than
\( N \), because of the need for accurate statistics. Therefore, we should
rather remove the loop over all walks. It turns out, from our efficiency
experiments, that the function <code>random_walks1D_vec2</code> (with no loops) is
slower than <code>random_walks1D_vec1</code>. This is a bit surprising and may be
explained by less efficiency in the statements involving very large
arrays, containing all steps for all walks at once.

<p>
From a parallelization and improved vectorization point of view, it
would be more natural to switch the sequence of the loops in the
serial code such that the shortest loop is the outer loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D2</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>, <span style="color: #666666">...</span>):
    <span style="color: #666666">...</span>
    current_pos <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>zeros(num_walks)
    num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">-1</span>

    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
	    num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">True</span>
	<span style="color: #008000; font-weight: bold">else</span>:
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">False</span>

        <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
	    <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos[n] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos[n] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos[n]
            position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">+=</span> current_pos[n]<span style="color: #666666">**2</span>
            <span style="color: #008000; font-weight: bold">if</span> store_hist:
                pos_hist[n,num_times_counter] <span style="color: #666666">=</span> current_pos[n]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
The vectorized version of this code, where we just vectorize the
loop over <code>n</code>, becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walks1D2_vec1</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D2.&quot;&quot;&quot;</span>
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N<span style="color: #666666">+1</span>)    <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(num_walks)
    current_pos[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> x0
    num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">-1</span>

    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
	    num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">True</span>  <span style="color: #408080; font-style: italic"># Store histogram data for this k</span>
	<span style="color: #008000; font-weight: bold">else</span>:
	    store_hist <span style="color: #666666">=</span> <span style="color: #008000">False</span>

        <span style="color: #408080; font-style: italic"># Move all walks one step</span>
        r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>num_walks)
        steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)
        current_pos <span style="color: #666666">+=</span> steps
        position[k<span style="color: #666666">+1</span>]  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(current_pos)
        position2[k<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(current_pos<span style="color: #666666">**2</span>)
        <span style="color: #008000; font-weight: bold">if</span> store_hist:
            pos_hist[:,num_times_counter] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
This function runs significantly faster than the <code>random_walks1D_vec1</code>
function above, typically 1.7 times faster. The code is also more appropriate
in a parallel computing context since each vectorized statement
can work with data of size <code>num_walks</code> over the compute units, repeated <code>N</code>
times (compared with data of size <code>N</code>, repeated <code>num_walks</code> times, in
<code>random_walks1D_vec1</code>).

<p>
The scalar code with switched loops, <code>random_walks1D2</code> runs a bit slower
than the original code in <code>random_walks1D</code>, so with the longest loop as
the inner loop, the vectorized function <code>random_walks1D2_vec1</code>
is almost 60 times faster than the scalar counterpart, while the
code <code>random_walks1D_vec2</code> without loops is only around 18 times faster.
Taking into account the very large arrays required by the latter function,
we end up with <code>random_walks1D2_vec1</code> as the preferred implementation.

<h3 id="___sec362">Test function </h3>

<p>
During program development, it is highly recommended to carry out
computations by hand for, e.g., <code>N=4</code> and <code>num_walks=3</code>.  Normally,
this is done by executing the program with these parameters and
checking with pen and paper that the computations make sense.  The
next step is to use this test for correctness in a formal test
function.

<p>
First, we need to check that the simulation of multiple random walks
reproduces the results of <code>random_walk1D</code>, <code>random_walk1D_vec1</code>, and
<code>random_walk1D_vec2</code> for the first walk, if the seed is the
same. Second, we run three random walks (<code>N=4</code>) with the scalar and
the two vectorized versions and check that the returned arrays are
identical.

<p>
For this type of test to be successful, we must be sure that exactly
the same set of random numbers are used in the three versions, a fact
that requires the same random number generator and the same seed, of
course, but also the same sequence of computations.  This is not
obviously the case with the three <code>random_walk1D*</code> functions we
have presented. The critical issue in <code>random_walk1D_vec1</code> is that the
first random numbers are used for the first walk, the second set of
random numbers is used for the second walk and so, to be compatible
with how the random numbers are used in the function <code>random_walk1D</code>.
For the function <code>random_walk1D_vec2</code> the situation is a bit more
complicated since we generate all the random numbers at once.
However, the critical step now is the reshaping of the array returned
from <code>np.where</code>: we must reshape as <code>(num_walks, N)</code> to ensure that
the first <code>N</code> random numbers are used for the first walk, the next <code>N</code>
numbers are used for the second walk, and so on.

<p>
We arrive at the test function below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_random_walks1D</span>():
    <span style="color: #408080; font-style: italic"># For fixed seed, check that scalar and vectorized versions</span>
    <span style="color: #408080; font-style: italic"># produce the same result</span>
    x0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  N <span style="color: #666666">=</span> <span style="color: #666666">4</span>;  p <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>

    <span style="color: #408080; font-style: italic"># First, check that random_walks1D for 1 walk reproduces</span>
    <span style="color: #408080; font-style: italic"># the walk in random_walk1D</span>
    num_walks <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D(
        x0, N, p, num_walks, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D(
        x0, N, p, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()

    <span style="color: #408080; font-style: italic"># Same for vectorized versions</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D_vec1(x0, N, p, num_walks)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    computed <span style="color: #666666">=</span> random_walks1D_vec2(x0, N, p, num_walks)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    expected <span style="color: #666666">=</span> random_walk1D_vec(x0, N, p)
    <span style="color: #008000; font-weight: bold">assert</span> (computed[<span style="color: #666666">0</span>] <span style="color: #666666">==</span> expected)<span style="color: #666666">.</span>all()

    <span style="color: #408080; font-style: italic"># Second, check multiple walks: scalar == vectorized</span>
    num_walks <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    num_times <span style="color: #666666">=</span> N
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    serial_computed <span style="color: #666666">=</span> random_walks1D(
        x0, N, p, num_walks, num_times, random<span style="color: #666666">=</span>np<span style="color: #666666">.</span>random)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized1_computed <span style="color: #666666">=</span> random_walks1D_vec1(
        x0, N, p, num_walks, num_times)
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)
    vectorized2_computed <span style="color: #666666">=</span> random_walks1D_vec2(
        x0, N, p, num_walks, num_times)
    <span style="color: #408080; font-style: italic"># positions: [0`, 1, 0, 1, 2]</span>
    <span style="color: #408080; font-style: italic"># Can test without tolerance since everything is +/- 1</span>
    return_values <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;pos&#39;</span>, <span style="color: #BA2121">&#39;pos2&#39;</span>, <span style="color: #BA2121">&#39;pos_hist&#39;</span>, <span style="color: #BA2121">&#39;pos_hist_times&#39;</span>]
    <span style="color: #008000; font-weight: bold">for</span> s, v, r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(serial_computed,
                       vectorized1_computed,
                       return_values):
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (serial) vs </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (vectorized)&#39;</span> <span style="color: #666666">%</span> (r, s, v)
        <span style="color: #008000; font-weight: bold">assert</span> (s <span style="color: #666666">==</span> v)<span style="color: #666666">.</span>all(), msg
    <span style="color: #008000; font-weight: bold">for</span> s, v, r <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(serial_computed,
                       vectorized2_computed,
                       return_values):
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (serial) vs </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> (vectorized)&#39;</span> <span style="color: #666666">%</span> (r, s, v)
        <span style="color: #008000; font-weight: bold">assert</span> (s <span style="color: #666666">==</span> v)<span style="color: #666666">.</span>all(), msg
</pre></div>
<p>
Such test functions are indispensable for further development of the code
as we can at any time test whether the basic computations remain correct or not.
This is particularly important in stochastic simulations since without
test functions and fixed seeds, we always experience variations from run to
run, and it can be very difficult to spot bugs through averaged statistical
quantities.

<h2 id="___sec363">Demonstration of multiple walks </h2>

<p>
Assuming now that the code works, we can just scale up the number of
steps in each walk and the number of walks. The latter influences the
accuracy of the statistical estimates.  Figure
<a href="#diffu:randomwalk:1D:fig:demo1:EX">52</a> shows the impact of the number
of walks on the expectation, which should approach zero.  Figure
<a href="#diffu:randomwalk:1D:fig:demo1:VarX">53</a> displays the corresponding
estimate of the variance of the position, which should grow linearly
with the number of steps. It does, seemingly very accurately, but
notice that the scale on the \( y \) axis is so much larger than for the
expectation, so irregularities due to the stochastic nature of the
process become so much less visible in the variance plots.  The
probability of finding a particle at a certain position at time (or
step) 800 is shown in Figure
<a href="#diffu:randomwalk:1D:fig:demo1:HistX">54</a>. The dashed red line is the
theoretical distribution <a href="#mjx-eqn-3.116">(3.116)</a>
arising from solving the diffusion equation
<a href="#mjx-eqn-3.114">(3.114)</a> instead. As always, we realize
that one needs significantly more statistical samples to estimate a
histogram accurately than the expectation or variance.

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:EX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 52:  Estimated expected value for 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:EX --> </p></center>
<p><img src="fig-diffu/rw1D_EX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:VarX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 53:  Estimated variance over 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:VarX --> </p></center>
<p><img src="fig-diffu/rw1D_VarX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:1D:fig:demo1:HistX"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 54:  Estimated probability distribution at step 800, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right).  <!-- caption label: diffu:randomwalk:1D:fig:demo1:HistX --> </p></center>
<p><img src="fig-diffu/rw1D_HistX_100_10000_100000_1000000.png" align="bottom" width=800></p>
</center>

<h2 id="diffu:randomwalk:1D:avplotter">Ascii visualization of 1D random walk</h2>

<p>
If we want to study (very) long time series of random walks, it can be
convenient to plot the position in a terminal window with the time axis
pointing downwards. The module <code>avplotter</code> in SciTools has a class <code>Plotter</code>
for plotting functions in the terminal window with the aid of ascii symbols
only. Below is the code required to visualize a simple random walk,
starting at the origin, and considered over
when the point \( x=-1 \) is reached. We use a spacing \( \Delta x = 0.05 \) (so
\( x=-1 \) corresponds to \( i=-20 \)).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">run_random_walk</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.avplotter</span> <span style="color: #008000; font-weight: bold">import</span> Plotter
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
    p <span style="color: #666666">=</span> Plotter(<span style="color: #666666">-1</span>, <span style="color: #666666">1</span>, width<span style="color: #666666">=75</span>)   <span style="color: #408080; font-style: italic"># Horizontal axis: 75 chars wide</span>
    dx <span style="color: #666666">=</span> <span style="color: #666666">0.05</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">10</span>)

    x <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">True</span>:
        random_step <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>random() <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">-1</span>
        x <span style="color: #666666">=</span> x <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>random_step
        <span style="color: #008000; font-weight: bold">if</span> x <span style="color: #666666">&lt;</span> <span style="color: #666666">-1</span>:
            <span style="color: #008000; font-weight: bold">break</span>                  <span style="color: #408080; font-style: italic"># Destination reached!</span>
        <span style="color: #008000; font-weight: bold">print</span> p<span style="color: #666666">.</span>plot(<span style="color: #666666">0</span>, x)

        <span style="color: #408080; font-style: italic"># Allow Ctrl+c to abort the simulation</span>
        <span style="color: #008000; font-weight: bold">try</span>:
            time<span style="color: #666666">.</span>sleep(<span style="color: #666666">0.1</span>)  <span style="color: #408080; font-style: italic"># Wait for interrupt</span>
        <span style="color: #008000; font-weight: bold">except</span> <span style="color: #D2413A; font-weight: bold">KeyboardInterrupt</span>:
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Interrupted by Ctrl+c&#39;</span>
            <span style="color: #008000; font-weight: bold">break</span>
</pre></div>
<p>
Observe that we implement an infinite loop, but allow a smooth interrupt
of the program by <code>Ctrl+c</code> through Python's <code>KeyboardInterrupt</code>
exception. This is a useful recipe that can be used in many occasions!

<p>
The output looks typically like

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">                            *         |
                              *       |
                            *         |
                              *       |
                            *         |
                              *       |
                                *     |
                              *       |
                            *         |
                          *           |
                        *             |
                      *               |
                        *             |
                      *               |
                     *                |
                   *                  |
                 *                    |
               *                      |
</pre></div>
<p>
Positions beyond the limits of the \( x \) axis appear with a value.
<a href="https://github.com/hplgit/fdm-book/blob/master/doc/.src/chapters/diffu/fig-diffu/rw_ascii.txt" target="_self">A file</a> contains the complete ascii plot corresponding to the
function <code>run_random_walk</code> above.

<h2 id="diffu:randomwalk:1D:ode">Random walk as a stochastic equation</h2>

<p>
The (dimensionless) position in a random walk, \( \bar X_k \), can be expressed as
a stochastic difference equation:

$$
\begin{equation}
\bar X_k = \bar X_{k-1} + s, \quad x_0=0,
\tag{3.117}
\end{equation}
$$

where \( s \) is a <a href="https://en.wikipedia.org/wiki/Bernoulli_distribution" target="_self">Bernoulli variable</a>,
taking on the two values \( s=-1 \) and \( s=1 \)
with equal probability:

$$ \hbox{P}(s=1)=\half,\quad \hbox{P}(s=-1)=\half\tp$$

The \( s \) variable in a step is independent of the \( s \) variable in other steps.

<p>
The difference equation expresses essentially the sum of independent
Bernoulli variables.  Because of the central limit theorem, \( X_k \),
will then be normally distributed with expectation \( k\E{s} \) and
\( k\Var{s} \).  The expectation and variance of a Bernoulli variable with
values \( r=0 \) and \( r=1 \) are \( p \) and \( p(1-p) \), respectively.
The variable \( s=2r-1 \) then has expectation
\( 2\E{r}-1=2p-1=0 \) and variance \( 2^2\Var{r}=4p(1-p)=1 \).  The position
\( X_k \) is normally distributed with zero expectation and variance \( k \),
as we found in the section <a href="#diffu:randomwalk:1D:EVar">Statistical considerations</a>.

<p>
The central limit theorem tells that as long as \( k \) is not small,
the distribution of \( X_k \) remains the same if
we replace the Bernoulli variable \( s \) by any other stochastic variable with
the same expectation and variance. In particular, may let \( s \) be a
standardized Gaussian variable (zero mean, unit variance).

<p>
<!-- Let us introduce -->
<!-- !bt -->
<!-- x_k = \Delta x\bar x_k,\] -->
<!-- !et -->
<!-- such that we take steps of length \( \Delta x \). -->
Dividing <a href="#mjx-eqn-3.117">(3.117)</a> by \( \Delta t \) gives

$$ \frac{\bar X_k - \bar X_{k-1}}{\Delta t} = \frac{1}{\Delta t} s\tp$$

In the limit \( \Delta t\rightarrow 0 \), \( s/\Delta t \) approaches a white noise
stochastic process (\( s \) is standardized Gaussian variable).
With \( \bar X(t) \) as the continuous process in the limit
\( \Delta t\rightarrow 0 \) (\( X_k\rightarrow X(t_k) \)),
we formally get the stochastic differential equation

$$
\begin{equation}
d\bar X = dW,
\tag{3.118}
\end{equation}
$$

where \( W(t) \) is a <a href="https://en.wikipedia.org/wiki/Wiener_process" target="_self">Wiener process</a>. Then \( X \) is also a
Wiener process. It follows from the stochastic ODE \( dX=dW \) that the
probability distribution of \( X \) is given by the <a href="https://en.wikipedia.org/wiki/Fokker-Planck_equation" target="_self">Fokker-Planck
equation</a>
<a href="#mjx-eqn-3.114">(3.114)</a>.  In other words, the key
results for random walk we found earlier can alternatively be
derived via a stochastic ordinary differential equation and its
related Fokker-Planck equation.

<h2 id="___sec366">Random walk in 2D </h2>

<p>
The most obvious generalization of 1D random walk to two spatial
dimensions is to allow movements to the north, east, south, and west,
with equal probability \( \frac{1}{4} \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walk2D</span>(x0, N, p, random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2D random walk with 1 particle and N moves: N, E, W, S.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))
    position[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
        <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.25</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>, <span style="color: #666666">1</span>])   <span style="color: #408080; font-style: italic"># Move north</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0.25</span> <span style="color: #666666">&lt;</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">0</span>])   <span style="color: #408080; font-style: italic"># Move east</span>
        <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0.5</span> <span style="color: #666666">&lt;</span> r <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.75</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>])  <span style="color: #408080; font-style: italic"># Move south</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            current_pos <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">-1</span>, <span style="color: #666666">0</span>])  <span style="color: #408080; font-style: italic"># Move west</span>
        position[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
The left plot in Figure <a href="#diffu:randomwalk:2D:fig:rect_vs_diag">55</a> provides
an example on 200 steps with this kind of walk. We may refer to this walk
as a walk on a <em>rectangular mesh</em> as we move from any spatial
mesh point \( (i,j) \) to one of its four neighbors in the rectangular directions:
\( (i+1,j) \), \( (i-1,j) \), \( (i,j+1) \), or \( (i,j-1) \).

<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:2D:fig:rect_vs_diag"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 55:  Random walks in 2D with 200 steps: rectangular mesh (left) and diagonal mesh (right).  <!-- caption label: diffu:randomwalk:2D:fig:rect_vs_diag --> </p></center>
<p><img src="fig-diffu/rw2D_sample200.png" align="bottom" width=800></p>
</center>

<h2 id="___sec367">Random walk in any number of space dimensions </h2>

<p>
From a programming point of view, especially when implementing a random
walk in any number of dimensions, it is more natural to consider a walk
in the diagonal directions NW, NE, SW, and SE. On a two-dimensional spatial mesh
it means that we go from \( (i,j) \) to either \( (i+1,j+1) \), \( (i-1,j+1) \),
\( (i+1,j-1) \), or \( (i-1,j-1) \). We can with such a <em>diagonal mesh</em>
(see right plot in Figure <a href="#diffu:randomwalk:2D:fig:rect_vs_diag">55</a>)
draw a Bernoulli variable for the step in each spatial direction and
trivially write code that works in any number of spatial directions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walkdD</span>(x0, N, p, random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Any-D (diagonal) random walk with 1 particle and N moves.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))
    position[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
        <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d):
            r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
            <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                current_pos[i] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
            <span style="color: #008000; font-weight: bold">else</span>:
                current_pos[i] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        position[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> current_pos
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
A vectorized version is desired. We follow the ideas from the section <a href="#diffu:randomwalk:1D:code1">Playing around with some code</a>, but each step is now a vector in \( d \)
spatial dimensions. We therefore need to draw \( Nd \) random numbers in <code>r</code>,
compute steps in the various directions through <code>np.where(r &lt;=p, -1, 1)</code>
(each step being \( -1 \) or \( 1 \)),
and then we can reshape this array to an \( N\times d \) array of step
<em>vectors</em>. Doing an <code>np.cumsum</code> summation along axis 0 will add
the vectors, as this demo shows:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">6</span>)<span style="color: #666666">.</span>reshape(<span style="color: #666666">3</span>,<span style="color: #666666">2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> a
array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>],
       [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>],
       [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>]])
<span style="color: #666666">&gt;&gt;&gt;</span> np<span style="color: #666666">.</span>cumsum(a, axis<span style="color: #666666">=0</span>)
array([[ <span style="color: #666666">0</span>,  <span style="color: #666666">1</span>],
       [ <span style="color: #666666">2</span>,  <span style="color: #666666">4</span>],
       [ <span style="color: #666666">6</span>,  <span style="color: #666666">9</span>]])
</pre></div>
<p>
With such summation of step vectors, we get all the positions to be
filled in the <code>position</code> array:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walkdD_vec</span>(x0, N, p):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walkdD.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    <span style="color: #408080; font-style: italic"># Store position in step k in position[k]</span>
    position <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>,d))
    position[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>d)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(N,d)
    position[<span style="color: #666666">1</span>:,:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=0</span>)
    <span style="color: #008000; font-weight: bold">return</span> position
</pre></div>
<p>
<center> <!-- figure label: --> <div id="diffu:randomwalk:2D:fig:samples"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 56:  Four random walks with 5000 steps in 2D.  <!-- caption label: diffu:randomwalk:2D:fig:samples --> </p></center>
<p><img src="fig-diffu/rw2D_samples_5000.png" align="bottom" width=800></p>
</center>

<h2 id="___sec368">Multiple random walks in any number of space dimensions </h2>

<p>
As we did in 1D, we extend one single walk to a number of walks (<code>num_walks</code>
in the code).

<h3 id="___sec369">Scalar code </h3>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walksdD</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>,
                   random<span style="color: #666666">=</span>random):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))   <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))   <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times, d))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_walks):
        num_times_counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        current_pos <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array(x0, dtype<span style="color: #666666">=</span><span style="color: #008000">float</span>)
        <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
            <span style="color: #008000; font-weight: bold">if</span> k <span style="color: #AA22FF; font-weight: bold">in</span> pos_hist_times:
                pos_hist[n,num_times_counter,:] <span style="color: #666666">=</span> current_pos
                num_times_counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            <span style="color: #408080; font-style: italic"># current_pos corresponds to step k+1</span>
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(d):
                r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>)
                <span style="color: #008000; font-weight: bold">if</span> r <span style="color: #666666">&lt;=</span> p:
                    current_pos[i] <span style="color: #666666">-=</span> <span style="color: #666666">1</span>
                <span style="color: #008000; font-weight: bold">else</span>:
                    current_pos[i] <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            position [k<span style="color: #666666">+1</span>,:] <span style="color: #666666">+=</span> current_pos
            position2[k<span style="color: #666666">+1</span>,:] <span style="color: #666666">+=</span> current_pos<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>

<h3 id="___sec370">Vectorized code </h3>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">random_walksdD_vec</span>(x0, N, p, num_walks<span style="color: #666666">=1</span>, num_times<span style="color: #666666">=1</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    d <span style="color: #666666">=</span> <span style="color: #008000">len</span>(x0)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Accumulated positions</span>
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Accumulated positions**2</span>
    walks <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, N<span style="color: #666666">+1</span>, d))  <span style="color: #408080; font-style: italic"># Positions of each walk</span>
    walks[:,<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> x0
    <span style="color: #408080; font-style: italic"># Histogram at num_times selected time points</span>
    pos_hist <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((num_walks, num_times, d))
    pos_hist_times <span style="color: #666666">=</span> [(N<span style="color: #666666">//</span>num_times)<span style="color: #666666">*</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_times)]

    r <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, size<span style="color: #666666">=</span>N<span style="color: #666666">*</span>num_walks<span style="color: #666666">*</span>d)
    steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>where(r <span style="color: #666666">&lt;=</span> p, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>)<span style="color: #666666">.</span>reshape(num_walks, N, d)
    walks[:,<span style="color: #666666">1</span>:,:] <span style="color: #666666">=</span> x0 <span style="color: #666666">+</span> np<span style="color: #666666">.</span>cumsum(steps, axis<span style="color: #666666">=1</span>)
    position  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks,    axis<span style="color: #666666">=0</span>)
    position2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(walks<span style="color: #666666">**2</span>, axis<span style="color: #666666">=0</span>)
    pos_hist[:,:,:] <span style="color: #666666">=</span> walks[:,pos_hist_times,:]
    <span style="color: #008000; font-weight: bold">return</span> position, position2, pos_hist, np<span style="color: #666666">.</span>array(pos_hist_times)
</pre></div>
<p>
<!-- 2D N=4M -->
<!-- scalar/vec (1 walk): 25 -->

<p>
<!-- 2D N=5000 -->
<!-- num_walks=10K -->
<!-- scalar/vec=50 -->
<!-- 3D: 40 -->
<!-- 1D: 100 -->
<!-- scalar is about the same for 1D, 2D, 3D, but vec is 0.3, 0.7, 1.0 -->

<h1 id="diffu:app">Applications</h1>

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 20</b>: Remaining: comment on boundary conditions for diffusion of substance and heat conduction (include Robin/cooling).)</font>
<!-- end inline comment -->

<h2 id="diffu:app:substance">Diffusion of a substance</h2>

<p>
The first process to be considered is a substance that gets transported
through a fluid at rest by pure diffusion. We consider an arbitrary
volume \( V \) of this fluid, containing the substance with concentration
function \( c(\x,t) \). Physically, we can think of a
very small volume with centroid \( \x \) at time \( t \) and assign the ratio
of the volume of the substance and the total volume to \( c(\x, t) \).
This means that the mass of the substance in a
small volume \( \Delta V \) is approximately
\( \varrho c\Delta V \), where \( \varrho \) is the density
of the substance. Consequently, the total mass of the substance inside the volume
\( V \) is the sum of all \( \varrho c\Delta V \), which becomes the
volume integral \( \int_V\varrho cdV \).

<p>
Let us reason how the mass of the substance changes and thereby derive
a PDE governing the concentration \( c \).
Suppose the substance flows out of \( V \) with a flux \( \q \).
If \( \Delta S \) is a small part of the boundary \( \partial V \) of \( V \),
the volume of the substance flowing out through \( dS \) in a small
time interval \( \Delta t \) is \( \varrho \q\cdot\normalvec \Delta t \Delta S \),
where \( \normalvec \) is an outward unit
normal to the boundary \( \partial V \), see Figure <a href="#diffu:app:substance:fig1">57</a>.
We realize that only the normal component of \( \q \) is able to transport mass
in and out of \( V \).
The total outflow of the mass of the substance in a small time interval
\( \Delta t \) becomes the surface integral

$$ \int\limits_{\partial V} \varrho\q\cdot\normalvec \Delta t\,  dS\tp$$

Assuming conservation of mass, this outflow of mass must be balanced by
a loss of mass inside the volume. The increase of mass inside the volume,
during a small time interval \( \Delta t \), is

$$ \int\limits_V \varrho (c(\x,t+\Delta t) - c(\x,t)) dV,$$

assuming \( \varrho \) is constant, which is reasonable.

<p>
Setting the two contributions equal to each other ensures balance of
mass inside \( V \). Dividing by \( \Delta t \) gives

$$ \int\limits_V \varrho \frac{c(\x,t+\Delta t) - c(\x,t)}{\Delta t} dV =
- \int\limits_{\partial V} \varrho\q\cdot\normalvec\, dS\tp$$

Note the minus sign on the right-hand side: the left-hand side expresses
loss of mass, while the integral on the right-hand side is the gain of
mass.

<p>
Now, letting \( \Delta t\rightarrow 0 \), we have

$$ \frac{c(\x,t+\Delta t) - c(\x,t)}{\Delta t} \rightarrow
\frac{\partial c}{\partial t},$$

so

$$
\begin{equation}
\int\limits_V \varrho \frac{\partial c}{\partial t}dV +
\int\limits_{\partial V} \varrho\q\cdot\normalvec\, dS = 0\tp
\tag{3.119}
\end{equation}
$$

To arrive at a PDE,
we express the surface integral as a volume integral using Gauss'
divergence theorem:

$$
\int\limits_V (\varrho \frac{\partial c}{\partial t} +
\nabla\cdot(\varrho \q))dV = 0\tp
$$

Since \( \varrho \) is constant, we can divide by this quantity.
If the integral is to vanish for an arbitrary volume \( V \),
the integrand must vanish too,
and we get the mass conservation PDE for the substance:

$$
\begin{equation}
\frac{\partial c}{\partial t} +
\nabla\cdot \q = 0\tp
\tag{3.120}
\end{equation}
$$

<p>
<center> <!-- figure label: --> <div id="diffu:app:substance:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 57:  An arbitrary volume of a fluid.  <!-- caption label: diffu:app:substance:fig1 --> </p></center>
<p><img src="fig-diffu/continuum.png" align="bottom" width=200></p>
</center>

<p>
A fundamental problem is that this is a scalar PDE for four unknowns:
\( c \) and the three components of \( \q \). We therefore need additional
equations. Here, Fick's law comes at rescue: it models how the flux \( \q \)
of the substance is related to the concentration \( c \). Diffusion is
recognized by mass flowing from regions with high concentration to regions
of low concentration. This principle suggests that \( \q \) is proportional
to the negative gradient of \( c \):

$$
\begin{equation}
\q = -\dfc\nabla c,
\tag{3.121}
\end{equation}
$$

where \( \dfc \) is an empirically determined constant.
The relation <a href="#mjx-eqn-3.121">(3.121)</a> is known as Fick's law.
Inserting <a href="#mjx-eqn-3.121">(3.121)</a> in
<a href="#mjx-eqn-3.120">(3.120)</a> gives a scalar PDE for the
concentration \( c \):

$$
\begin{equation}
\frac{\partial c}{\partial t} = \dfc\nabla^2 c\tp
\tag{3.122}
\end{equation}
$$

<h2 id="diffu:app:heat">Heat conduction</h2>

<p>
Heat conduction is a well-known diffusion process. The governing PDE
is in this case based on the first law of thermodynamics: the increase
in energy of a system is equal to the work done on the system, plus the
supplied heat. Here, we shall media at rest and neglect the work done
on the system. The principle then reduces to a balance between
increase in internal energy and the supplied heat flow by conduction.

<p>
Let \( e(x,t) \) be the <em>internal energy</em> per unit mass. The increase of
the internal energy in a small volume \( \Delta V \) in a small time
interval \( \Delta t \) is then

$$ \varrho (e(\x,t+\Delta t) - e(\x,t))\Delta V,$$

where \( \varrho \) is the density of the material subject to heat conduction.
In an arbitrary volume \( V \), as depicted in
Figure <a href="#diffu:app:substance:fig1">57</a>, the corresponding increase in internal
energy becomes the volume integral

$$ \int\limits_V \varrho (e(\x,t+\Delta t) - e(\x,t))dV\tp$$

This increase in internal energy is balanced by heat supplied by
conduction. Let \( \q \) be the heat flow per time unit. Through the
surface \( \partial V \) of \( V \) the following amount of heat flows out
of \( V \) during a time interval \( \Delta t \):

$$
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS\tp$$

The simplified version of the first law of thermodynamics then states that

$$
\int\limits_V \varrho (e(\x,t+\Delta t) - e(\x,t))dV = -
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS\tp
$$

The minus sign on the right-hand side ensures that the integral there
models net <em>inflow</em> of heat (since \( \normalvec \) is an outward unit normal,
\( \q\cdot\normalvec \) models <em>outflow</em>).
Dividing by \( \Delta t \) and notifying that

$$ \lim_{\Delta t\rightarrow 0}
\frac{e(\x,t+\Delta t) - e(\x,t)}{\Delta t} =
\frac{\partial e}{\partial t},$$

we get (in the limit \( \Delta t\rightarrow 0 \))

$$
\int\limits_V \varrho \frac{\partial e}{\partial t} dV +
\int\limits_{\partial V} \q\cdot\normalvec\Delta t\, dS = 0\tp
$$

This is the integral equation for heat conduction, but we aim at a PDE.
The next step is therefore to transform the surface integral to a
volume integral via Gauss' divergence theorem. The result is

$$
\int\limits_V\left( \varrho \frac{\partial e}{\partial t}
+ \nabla\cdot\q\right) dV = 0\tp
$$

If this equality is to hold for all volumes \( V \), the integrand must vanish,
and we have the PDE

$$
\begin{equation}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\q\tp
\tag{3.123}
\end{equation}
$$

<p>
Sometimes the supplied heat can come from the medium itself. This is
the case, for instance, when radioactive rock generates heat.
Let us add this effect. If \( f(\x,t) \) is the supplied heat
per unit volume per unit time, the heat supplied in a small volume
is \( f\Delta t\Delta V \), and inside an arbitrary volume \( V \) the
supplied generated heat becomes

$$ \int\limits_V f\Delta t dV\tp$$

Adding this to the integral statement of the (simplified) first law of
thermodynamics, and continuing the derivation, leads to the PDE

$$
\begin{equation}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\q + f\tp
\tag{3.124}
\end{equation}
$$

<p>
There are four unknown scalar fields: \( e \) and \( \q \). Moreover, the
temperature \( T \), which is our primary quantity to compute, does not
enter the model yet. We need an additional equation, called the
<em>equation of state</em>, relating \( e \), \( V=1/\varrho= \), and \( T \):
\( e=e(V,T) \). By the chain rule we have

$$ \frac{\partial e}{\partial t} =
\left.\frac{\partial e}{\partial T}\right\vert_{V}
\frac{\partial T}{\partial t} +
\left.\frac{\partial e}{\partial V}\right\vert_{T}
\frac{\partial V}{\partial t}\tp$$

The first coefficient \( \partial e/\partial T \) is called <em>specific heat
capacity at constant volume</em>, denoted by \( c_v \):

$$ c_v = \left.\frac{\partial e}{\partial T}\right\vert_{V}\tp$$

The specific heat capacity will in general vary with \( T \), but taking it as a
constant is a good approximation in many applications.

<p>
The term \( \partial e/\partial V \) models effects due to compressibility
and volume expansion. These effects are often small and can be neglected.
We shall do so here. Using \( \partial e/\partial t = c_v\partial T/\partial t \)
in the PDE gives

$$ \varrho c_v\frac{\partial T}{\partial t} = -\nabla\cdot\q + f\tp$$

We still have four unknown scalar fields (\( T \) and \( \q \)). To close the
system, we need a relation between the heat flux \( \q \) and the temperature \( T \)
called Fourier's law:

$$ \q = -k\nabla T,$$

which simply states that heat flows from hot to cold areas, along the
path of greatest variation. In a solid medium, \( k \) depends on the
material of the medium, and in multi-material media one must regard
\( k \) as spatially dependent. In a fluid, it is common to assume that
\( k \) is a constant. The value of \( k \) reflects how easy heat is
conducted through the medium, and \( k \) is named the <em>coefficient of
heat conduction</em>.

<p>
We have now one scalar PDE for the unknown temperature field \( T(\x,t) \):

$$
\begin{equation}
\varrho  c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T) + f\tp
\tag{3.125}
\end{equation}
$$

<h2 id="diffu:app:Couette">Development of flow between two flat plates</h2>

<p>
Diffusion equations may also arise as simplified versions of other
mathematical models, especially in fluid flow. Consider a fluid flowing
between two flat, parallel plates. The velocity is uni-directional, say
along the \( z \) axis, and depends
only on the distance \( x \) from the plates; \( \u = u(x,t)\kk \).
The flow is governed by the Navier-Stokes equations,

$$
\begin{align*}
\varrho\frac{\partial\u}{\partial t} + \varrho\u\cdot\nabla\u &= -\nabla p
+ \mu\nabla^2\u + \varrho\f,\\ 
\nabla\cdot\u &= 0,
\end{align*}
$$

where \( p \) is the pressure field, unknown along with the velocity \( \u \),
\( \varrho \) is the fluid density, \( \mu \) the dynamic viscosity, and \( \f \)
is some external body force. The geometric restrictions of flow between
two flat plates puts restrictions on the velocity, \( \u = u(x,t)\ii \),
and the \( z \) component of the Navier-Stokes equations collapses to
a diffusion equation:

$$
\varrho\frac{\partial u}{\partial t} = - \frac{\partial p}{\partial z} +
\mu\frac{\partial^2 u}{\partial z^2}
+ \varrho f_z,
$$

if \( f_z \) is the component of \( \f \) in the \( z \) direction.

<p>
The boundary conditions are derived from the fact that the fluid sticks to
the plates, which means \( \u=0 \) at the plates. Say the location of the
plates are \( z=0 \) and \( z=L \). We then have

$$ u(0,t)=u(L,t)=0\tp$$

<p>
One can easily show that \( \partial p/\partial z \) must be a constant or
just a function of time \( t \). We set \( \partial p/\partial z = -\beta(t) \).
The body force could be a component of gravity, if desired, set as
\( f_z = \gamma g \). Switching from \( z \) to \( x \) as independent variable gives
a very standard one-dimensional diffusion equation:

$$
\varrho\frac{\partial u}{\partial t} =
\mu\frac{\partial^2 u}{\partial z^2} + \beta(t) + \varrho\gamma g,\quad
x\in [0,L],\ t\in (0,T]\tp
$$

The boundary conditions are

$$ u(0,t)=u(L,t)=0,$$

while some initial condition

$$ u(x,0) = I(x)$$

must also be prescribed.

<p>
The flow is driven by either the pressure gradient \( \beta \) or gravity, or
a combination of both. One may also consider one moving plate that
drives the fluid. If the plate at \( x=L \) moves with velocity \( U_L(t) \), we have
the adjusted boundary condition

$$ u(L,t) = U_L(t)\tp$$

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 21</b>: Exercises based on this diffusion model.)</font>
<!-- end inline comment -->

<h2 id="diffu:app:pipeflow">Flow in a straight tube</h2>

<p>
Now we consider viscous fluid flow in a straight tube with radius \( R \)
and rigid walls.
The governing equations are the Navier-Stokes equations, but as
in the section <a href="#diffu:app:Couette">Development of flow between two flat plates</a>, it is natural to assume that the
velocity is directed along the tube, and that it is axi-symmetric.
These assumptions reduced the velocity field to \( \u = u(r,x,t)\ii \), if the
\( x \) axis is directed along the tube. From the equation of continuity,
\( \nabla\cdot\u = 0 \), we see that \( u \) must be independent of \( x \).
Inserting \( \u = u(r,t)\ii \) in the Navier-Stokes equations, expressed
in axi-symmetric cylindrical coordinates, results in

$$
\begin{equation}
\varrho\frac{\partial u}{\partial t} =
\mu\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) + \beta(t) + \varrho\gamma g,\quad
r\in [0,R],\ t\in (0,T]\tp
\tag{3.126}
\end{equation}
$$

Here, \( \beta(t) = -\partial p/\partial x \) is the pressure gradient along
the tube. The associated boundary condition is \( u(R,t)=0 \).

<h2 id="___sec376">Tribology: thin film fluid flow </h2>

<p>
Thin fluid films are extremely important inside machinery to reduce friction
between gliding surfaces. The mathematical model for the fluid motion takes
the form of a diffusion problem and is quickly derived here.
We consider two solid surfaces whose distance is described by a
gap function \( h(x,y) \). The space between these surfaces is filled with
a fluid with dynamic viscosity \( \mu \). The fluid may move partially
because of pressure gradients and partially because the surfaces
move. Let \( U\ii + V\jj \) be the relative velocity of the two surfaces and
\( p \) the pressure in the fluid. The mathematical model builds on two
principles: 1) conservation of mass, 2) assumption of locally quasi-static
flow between flat plates.

<p>
The conservation of mass equation reads \( \nabla\cdot\u \), where \( \u \) is
the local fluid velocity. For thin films the detailed variation between
the surfaces is not of interest, so \( \nabla\cdot\u = 0 \) is integrated
(average) in the direction perpendicular to the surfaces. This gives
rise to the alternative mass conservation equation

$$ \nabla\cdot\q = 0,\quad \q = \int\limits_0^{h(x,y)}\u dz,$$

where \( z \) is the coordinate perpendicular to the surfaces, and \( \q \)
is then the volume flux in the fluid gap.

<p>
Locally, we may assume that we have steady flow between two flat
surfaces, with a pressure gradient and where the lower surface is at rest
and the upper moves with velocity \( U\ii + V\jj \).
The corresponding mathematical problem is actually the limit problem
in the section <a href="#diffu:app:Couette">Development of flow between two flat plates</a> as \( t\rightarrow\infty \). The limit
problem can be solved analytically, and the local volume flux becomes

$$ \q(x,y,z) = \int\limits_0^{h}\u(x,y,z) dz
= -\frac{h^3}{12\mu}\nabla p + \half Uh\ii + \half Vh\jj\tp$$

The idea is to use this expression locally
also when the surfaces are not flat,
but slowly varying, and if \( U \), \( V \), or \( p \) varies in time, provided the
time variation is sufficiently slow. This is a common quasi-static
approximation much used in mathematical modeling.

<p>
Inserting the expression for \( \q \) via \( p \), \( U \), and \( V \) in the
equation \( \nabla\q = 0 \) gives a diffusion PDE for \( p \):

$$
\begin{equation}
\nabla\cdot\left(\frac{h^3}{12\mu}\nabla p\right) =
\half\frac{\partial}{\partial x}(hU)
+ \half\frac{\partial}{\partial x}(hV)\tp
\tag{3.127}
\end{equation}
$$

The boundary conditions must involve \( p \) or \( \q \) at the boundary.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 22</b>: Exercise!)</font>
<!-- end inline comment -->

<h2 id="___sec377">Propagation of electrical signals in the brain </h2>

<p>
<!-- <a href="http://icwww.epfl.ch/~gerstner/SPNM/node17.html" target="_self"><tt>http://icwww.epfl.ch/~gerstner/SPNM/node17.html</tt></a> -->
<!-- <a href="http://www.uio.no/studier/emner/matnat/ifi/INF5610/h09/Lecture04.pdf" target="_self"><tt>http://www.uio.no/studier/emner/matnat/ifi/INF5610/h09/Lecture04.pdf</tt></a> -->
<!-- <a href="http://people.mbi.ohio-state.edu/schwemmer.2/Publications/Schwemmer_Dissertation_Final.pdf" target="_self"><tt>http://people.mbi.ohio-state.edu/schwemmer.2/Publications/Schwemmer_Dissertation_Final.pdf</tt></a> -->
<!-- The book by Peskin & ... -->

<p>
One can make a model of how electrical signals are propagated along the
neuronal fibers that receive synaptic inputs in the brain. The signal
propagation is one-dimensional and can, in the simplest cases, be
governed by the <a href="http://en.wikipedia.org/wiki/Cable_equation" target="_self">Cable equation</a>:

$$
\begin{equation}
c_m \frac{\partial V}{\partial t} =
\frac{1}{r_l}\frac{\partial^2 V}{\partial x^2} - \frac{1}{r_m}V
\label{}
\end{equation}
$$

where \( V(x,t) \) is the voltage to be determined,
\( c_m \) is capacitance of the neuronal fiber, while
\( r_l \) and \( r_m \) are measures of the resistance.
The boundary conditions are often taken as \( V=0 \) at a short circuit or open end,
\( \partial V/\partial x=0 \) at a sealed end, or \( \partial V/\partial x \propto
V \) where there is an injection of current.

<h1 id="___sec378">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:CN:Rannacher">Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</h2>

<p>
It is well known that the Crank-Nicolson method may give rise to
non-physical oscillations in the solution of diffusion equations
if the initial data exhibit jumps (see the section <a href="#diffu:pde1:analysis:CN">Analysis of the Crank-Nicolson scheme</a>).
Rannacher <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Rannacher_1984">[8]</a> suggested a stabilizing technique
consisting of using the Backward Euler scheme for the first two
time steps with step length \( \half\Delta t \). One can generalize
this idea to taking \( 2m \) time steps of size \( \half\Delta t \) with
the Backward Euler method and then continuing with the
Crank-Nicolson method, which is of second-order in time.
The idea is that the high frequencies of the initial solution are
quickly damped out, and the Backward Euler scheme treats these
high frequencies correctly. Thereafter, the high frequency content of
the solution is gone and the Crank-Nicolson method will do well.

<p>
Test this idea for \( m=1,2,3 \) on a diffusion problem with a
discontinuous initial condition. Measure the convergence rate using
the solution <a href="#mjx-eqn-3.45">(3.45)</a> with the boundary
conditions
<a href="#mjx-eqn-3.46">(3.46)</a>-<a href="#mjx-eqn-3.47">(3.47)</a>
for \( t \) values such that the conditions are in the vicinity of \( \pm 1 \).
For example, \( t < 5a 1.6\cdot 10^{-2} \) makes the solution diffusion from
a step to almost a straight line. The
program <code>diffu_erf_sol.py</code> shows how to compute the analytical
solution.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:energy:estimates">Project 3.7: Energy estimates for diffusion problems</h2>

<p>
This project concerns so-called <em>energy estimates</em> for diffusion problems
that can be used for qualitative analytical insight and for
verification of implementations.

<p>
<b>a)</b>
We start with a 1D homogeneous diffusion equation with zero Dirichlet
conditions:

$$
\begin{align}
u_t &= \alpha u_xx, & x\in \Omega =(0,L),\ t\in (0,T],
\tag{3.128} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{3.129}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{3.130}
\tp
\end{align}
$$

The energy estimate for this problem reads

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2},
\tag{3.131}
\end{equation}
$$

where the \( ||\cdot ||_{L^2} \) norm is defined by

$$
\begin{equation}
||g||_{L^2} = \sqrt{\int_0^L g^2dx}\tp
\tag{3.132}
\end{equation}
$$

The quantify  \( ||u||_{L^2} \) or \( \half ||u||_{L^2} \) is known
as the <em>energy</em> of the solution, although it is not the physical
energy of the system. A mathematical tradition has introduced the
notion <em>energy</em> in this context.

<p>
The estimate <a href="#mjx-eqn-3.131">(3.131)</a> says that the
&quot;size of $u$&quot; never exceeds that of the initial condition,
or more precisely, it says that the area under the \( u \) curve decreases
with time.

<p>
To show <a href="#mjx-eqn-3.131">(3.131)</a>, multiply the PDE
by \( u \) and integrate from \( 0 \) to \( L \). Use that \( uu_t \) can be
expressed as the time derivative of \( u^2 \) and that \( u_xxu \) can
integrated by parts to form an integrand \( u_x^2 \). Show that
the time derivative of \( ||u||_{L^2}^2 \) must be less than or equal
to zero. Integrate this expression and derive
<a href="#mjx-eqn-3.131">(3.131)</a>.

<p>
<!-- <a href="http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf" target="_self"><tt>http://www.ann.jussieu.fr/~frey/cours/UdC/ma691/ma691_ch6.pdf</tt></a> -->

<p>
<b>b)</b>
Now we address a slightly different problem,

$$
\begin{align}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{3.133} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{3.134}\\ 
u(x,0) &= 0, & x\in [0,L]
\tag{3.135}
\tp
\end{align}
$$

The associated energy estimate is

$$
\begin{equation}
||u||_{L^2} \leq ||f||_{L^2}\tp
\tag{3.136}
\end{equation}
$$

(This result is more difficult to derive.)

<p>
Now consider the compound problem with an initial condition \( I(x) \) and
a right-hand side \( f(x,t) \):

$$
\begin{align}
u_t &= \alpha u_xx + f(x,t), & x\in \Omega =(0,L),\ t\in (0,T],
\tag{3.137} \\ 
u(0,t) = u(L,t) &= 0, & t\in (0,T],
\tag{3.138}\\ 
u(x,0) &= I(x), & x\in [0,L]
\tag{3.139}
\tp
\end{align}
$$

Show that if \( w_1 \) fulfills
<a href="#mjx-eqn-3.128">(3.128)</a>-<a href="#mjx-eqn-3.130">(3.130)</a>
and \( w_2 \) fulfills
<a href="#mjx-eqn-3.133">(3.133)</a>-<a href="#mjx-eqn-3.135">(3.135)</a>,
then \( u=w_1 + w_2 \) is the solution of
<a href="#mjx-eqn-3.137">(3.137)</a>-<a href="#mjx-eqn-3.139">(3.139)</a>.
Using the triangle inequality for norms,

$$ ||a + b|| \leq ||a|| + ||b||,$$

show that the energy estimate for
<a href="#mjx-eqn-3.137">(3.137)</a>-<a href="#mjx-eqn-3.139">(3.139)</a>
becomes

$$
\begin{equation}
||u||_{L^2} \leq ||I||_{L^2} + ||f||_{L^2}\tp
\tag{3.140}
\end{equation}
$$

<p>
<b>c)</b>
One application of <a href="#mjx-eqn-3.140">(3.140)</a> is to prove uniqueness
of the solution.
Suppose \( u_1 \) and \( u_2 \) both fulfill
<a href="#mjx-eqn-3.137">(3.137)</a>-<a href="#mjx-eqn-3.139">(3.139)</a>.
Show that \( u=u_1 - u_2 \) then fulfills
<a href="#mjx-eqn-3.137">(3.137)</a>-<a href="#mjx-eqn-3.139">(3.139)</a>
with \( f=0 \) and \( I=0 \). Use <a href="#mjx-eqn-3.140">(3.140)</a>
to deduce that the energy must be zero for all times and therefore
that \( u_1=u_2 \), which proves that the solution is unique.

<p>
<b>d)</b>
Generalize <a href="#mjx-eqn-3.140">(3.140)</a> to a 2D/3D
diffusion equation \( u_t = \nabla\cdot (\alpha \nabla u) \) for \( x\in\Omega \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_62_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_62_1">

<p>
Use integration by parts in multi dimensions:

$$ \int_\Omega u \nabla\cdot (\alpha\nabla u)\dx =
- \int_\Omega \alpha \nabla u\cdot\nabla u\dx
+ \int_{\partial\Omega} u \alpha\frac{\partial u}{\partial n},$$

where \( \frac{\partial u}{\partial n} = \boldsymbol{n}\cdot\nabla u \),
\( \boldsymbol{n} \) being the outward unit normal to the boundary \( \partial\Omega \)
of the domain \( \Omega \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Now we also consider the multi-dimensional PDE \( u_t =
\nabla\cdot (\alpha \nabla u) \). Integrate both sides over \( \Omega \)
and use Gauss' divergence theorem, \( \int_\Omega \nabla\cdot\boldsymbol{q}\dx
= \int_{\partial\Omega}\boldsymbol{q}\cdot\boldsymbol{n}\ds \) for a vector field
\( \boldsymbol{q} \). Show that if we have homogeneous Neumann conditions
on the boundary, \( \partial u/\partial n=0 \), area under the
\( u \) surface remains constant in time and

$$
\begin{equation}
\int_{\Omega} u\dx = \int_{\Omega} I\dx
\tp
\tag{3.141}
\end{equation}
$$

<p>
<b>f)</b>
Establish a code in 1D, 2D, or 3D that can solve a diffusion equation with a
source term \( f \), initial condition \( I \), and zero Dirichlet or
Neumann conditions on the whole boundary.

<p>
We can use <a href="#mjx-eqn-3.140">(3.140)</a>
and <a href="#mjx-eqn-3.141">(3.141)</a> as a partial verification
of the code. Choose some functions \( f \) and \( I \) and
check that <a href="#mjx-eqn-3.140">(3.140)</a> is obeyed at any
time when zero Dirichlet conditions are used.
Iterate over the same \( I \) functions and check that
<a href="#mjx-eqn-3.141">(3.141)</a> is fulfilled
when using zero Neumann conditions.

<p>
<b>g)</b>
Make a list of some possible bugs in the code, such as indexing errors
in arrays, failure to set the correct boundary conditions,
evaluation of a term at a wrong time level, and similar.
For each of the bugs, see if the verification tests from the previous
subexercise pass or fail. This investigation shows how strong
the energy estimates and the estimate <a href="#mjx-eqn-3.141">(3.141)</a>
are for pointing out errors in the implementation.

<p>
Filename: <code>diffu_energy</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:splitting_prec">Exercise 3.8: Splitting methods and preconditioning</h2>

<p>
In the section <a href="#diffu:2D:direct_vs_iter">Direct versus iterative methods</a>, we outlined a class of
iterative methods for \( Au=b \) based on splitting \( A \) into \( A=M-N \)
and introducing the iteration

$$ Mu^{k} = Nu^k + b\tp$$

The very simplest splitting is \( M=I \), where \( I \) is the identity
matrix. Show that this choice corresponds to the iteration

$$
\begin{equation}
u^k = u^{k-1} + r^{k-1},\quad r^{k-1} = b - Au^{k-1},
\tag{3.142}
\end{equation}
$$

where \( r^{k-1} \) is the residual in the linear system in iteration
\( k-1 \). The formula <a href="#mjx-eqn-3.142">(3.142)</a> is known
as Richardson's iteration.
Show that if we apply the simple iteration method
<a href="#mjx-eqn-3.142">(3.142)</a> to the <em>preconditioned</em>
system \( M^{-1}Au=M^{-1}b \), we arrive at the Jacobi method by choosing
\( M=D \) (the diagonal of \( A \)) as preconditioner and the SOR method by
choosing \( M=\omega^{-1}D + L \) (\( L \) being the lower triangular part of
\( A \)).  This equivalence shows that we can apply one iteration of the
Jacobi or SOR method as preconditioner.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_63_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_63_1">

<p>
Inserting \( M=I \) and \( N=I-A \) in the iterative method leads to

$$ u^{k} = (I-A)u^{k-1} + b = u^{k-1} + (b  - Au^{k-1}),$$

which is <a href="#mjx-eqn-3.142">(3.142)</a>.
Replacing \( A \) by \( M^{-1}A \) and \( b \) by \( M^{-1}b \) in this equation
gives

$$ u^k = u^{k-1} + M^{-1}r^{k-1},\quad r^{k-1}=b-Au^{k-1},$$

which we after multiplication by \( M \) and reordering can write
as

$$ Mu^k = (M-A)u^{k-1} + b = Nu^{k-1} + b,$$

which is the standard form for the Jacobi and SOR methods. Choosing \( M=D \)
gives Jacobi and \( M=\omega^{-1}D+L \) gives SOR. We have shown that we may
view \( M \) as a preconditioner of a simplest possible iteration method.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:earthosc">Exercise 3.9: Oscillating surface temperature of the earth</h2>

<p>
Consider a day-and-night or seasonal variation in temperature at
the surface of the earth. How deep down in the ground will the
surface oscillations reach? For simplicity, we model only the
vertical variation along a coordinate \( x \), where \( x=0 \) at the
surface, and \( x \) increases as we go down in the ground.
The temperature is governed by the heat equation

$$ \varrho c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T),$$

in some spatial domain \( x\in [0,L] \), where \( L \) is chosen large enough such
that we can assume that \( T \) is approximately constant, independent of the surface
oscillations, for \( x>L \). The parameters \( \varrho \), \( c_v \), and \( k \) are the
density, the specific heat capacity at constant volume, and the
heat conduction coefficient, respectively.

<p>
<b>a)</b>
Derive the mathematical model for computing \( T(x,t) \).
Assume the surface oscillations to be sinusoidal around some mean
temperature \( T_m \). Let \( T=T_m \) initially. At \( x=L \), assume \( T\approx T_m \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_64_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_64_1">

<p>
The surface temperature is set as

$$ T(0,t) = T_m + A\sin(\omega t)\tp$$

With only one &quot;active&quot; spatial coordinate we get the initial-boundary
value problem

$$
\begin{align*}
\varrho c_v \frac{\partial T}{\partial t} &= \frac{\partial}{\partial x}
\left(k(x)\frac{\partial T}{\partial x}\right), & x\in (0,L),\ t\in (0,T],\\ 
T(x,0)&= T_m, & x\in [0,L],\\ 
T(0,t)&= T_m + A\sin(\omega t), & t\in (0,T],\\ 
T(L,t) &= T_m, & t\in (0,T].
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Scale the model in a) assuming \( k \) is constant. Use a time scale
\( t_c = \omega^{-1} \) and a length scale \( x_c = \sqrt{2\dfc/omega} \),
where \( \dfc = k/(\varrho c_v) \). The primary unknown can be scaled
as \( \frac{T-T_m}{2A} \).

<p>
Show that the scaled PDE is

$$
\frac{\partial u}{\partial \bar t} =
\frac{1}{2}\frac{\partial^2 u}{\partial x^2},$$

with initial condition \( u(\bar x,0) = 0 \),
left boundary condition
\( u(0,\bar t)  = \sin(\bar t) \),
and right boundary condition
\( u(\bar L,\bar t)  = 0 \). The bar indicates a dimensionless quantity.

<p>
Show that \( u(\bar x, \bar t)=e^{-\bar x}\sin (\bar x - \bar t) \) is a
solution that fulfills the PDE and the boundary condition at \( \bar x
=0 \) (this is the solution we will experience as \( \bar
t\rightarrow\infty \) and \( L\rightarrow\infty \)).  Conclude that an
appropriate domain for \( x \) is \( [0,4] \) if a damping \( e^{-4}\approx
0.18 \) is appropriate for implementing \( \bar u\approx\hbox{const} \);
increasing to \( [0,6] \) damps \( \bar u \) to 0.0025.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_64_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_64_2">

<p>
Chapter 3.2.4 in the book <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86028.html#Langtangen_scaling">[4]</a> describes the
scaling of this problem in detail.
Inserting dimensionless variables \( \bar t = \omega t \), \( \bar x =
\sqrt{omega/(2\dfc)} x \), and

$$ u = \frac{T-T_m}{2A},$$

leads to

$$
\begin{align*}
\frac{\partial u}{\partial \bar t} &=
\frac{1}{2}\frac{\partial^2 u}{\partial x^2},
\quad & \bar x\in (0,\bar L),\ \bar t\in (0,\bar T],
\\ 
u(\bar x,0) &= 0,
\quad &\bar x\in [0,1],
\\ 
u(0,\bar t) & = \sin(\bar t),
\quad  &\bar t\in (0,\bar T],
\\ 
u(\bar L,\bar t) & = 0,
\quad &\bar t\in (0,\bar T].
\end{align*}
$$

The domain lengths \( \bar L \) and \( \bar T \) follows from straightforward
scaling of \( L \) and \( T \).

<p>
Inserting \( u(\bar x, \bar t)=e^{-\bar x}\sin (\bar t - \bar x) \) in the
PDE shows that this is a solution. It also obeys
the boundary condition \( \bar u(0,\bar t)=sin(\bar t) \). As
\( \bar t\rightarrow\infty \), the initial condition has no longer impact
on the solution and is &quot;forgotten&quot; and of no interest.
The boundary condition at \( \bar x=\bar L \) is never compatible with the
given solution unless \( \bar u \) is damped to zero, which happens
mathematically as \( \bar L\rightarrow\infty \). For a numerical solution,
however, we may use a small finite value such as \( \bar L=4 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Compute the scaled temperature and make animations comparing two solutions
with \( \bar L=4 \) and \( \bar L=8 \), respectively (keep \( \Delta x \) the same).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_64_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_64_3">

<p>
We can use the <code>viz</code> function in <code>diff1D_vc.py</code> to do the number
crunching. Appropriate calls and visualization go here:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span><span style="color: #666666">,</span> <span style="color: #0000FF; font-weight: bold">os</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>insert(<span style="color: #666666">0</span>, os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>join(os<span style="color: #666666">.</span>pardir, <span style="color: #BA2121">&#39;src-diffu&#39;</span>))
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">diffu1D_vc</span> <span style="color: #008000; font-weight: bold">import</span> viz

sol <span style="color: #666666">=</span> []  <span style="color: #408080; font-style: italic"># store solutions</span>
<span style="color: #008000; font-weight: bold">for</span> Nx, L <span style="color: #AA22FF; font-weight: bold">in</span> [[<span style="color: #666666">20</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">40</span>, <span style="color: #666666">8</span>]]:
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    dx <span style="color: #666666">=</span> <span style="color: #008000">float</span>(L)<span style="color: #666666">/</span>Nx
    D <span style="color: #666666">=</span> dt<span style="color: #666666">/</span>dx<span style="color: #666666">**2</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
    T <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">*6</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros
    a <span style="color: #666666">=</span> zeros(Nx<span style="color: #666666">+1</span>) <span style="color: #666666">+</span> <span style="color: #666666">0.5</span>
    cpu, u_ <span style="color: #666666">=</span> viz(
        I<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">0</span>, a<span style="color: #666666">=</span>a, L<span style="color: #666666">=</span>L, Nx<span style="color: #666666">=</span>Nx, D<span style="color: #666666">=</span>D, T<span style="color: #666666">=</span>T,
        umin<span style="color: #666666">=-1.1</span>, umax<span style="color: #666666">=1.1</span>, theta<span style="color: #666666">=0.5</span>,
        u_L<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: sin(t),
        u_R<span style="color: #666666">=0</span>,
        animate<span style="color: #666666">=</span><span style="color: #008000">False</span>, store_u<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    sol<span style="color: #666666">.</span>append(u_)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;computed solution for Nx=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> in [0,</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">]&#39;</span> <span style="color: #666666">%</span> (Nx, L)

<span style="color: #008000; font-weight: bold">print</span> sol[<span style="color: #666666">0</span>]<span style="color: #666666">.</span>shape
<span style="color: #008000; font-weight: bold">print</span> sol[<span style="color: #666666">1</span>]<span style="color: #666666">.</span>shape
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>
<span style="color: #008000; font-weight: bold">for</span> u0, u1 <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">zip</span>(sol[<span style="color: #666666">0</span>][<span style="color: #666666">2</span>:], sol[<span style="color: #666666">1</span>][<span style="color: #666666">2</span>:]):
    x0 <span style="color: #666666">=</span> sol[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]
    x1 <span style="color: #666666">=</span> sol[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]
    plt<span style="color: #666666">.</span>plot(x0, u0, <span style="color: #BA2121">&#39;r-&#39;</span>, x1, u1, <span style="color: #BA2121">&#39;b-&#39;</span>, legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;short&#39;</span>, <span style="color: #BA2121">&#39;long&#39;</span>], savefig<span style="color: #666666">=</span><span style="color: #BA2121">&#39;tmp_</span><span style="color: #BB6688; font-weight: bold">%04d</span><span style="color: #BA2121">.png&#39;</span> <span style="color: #666666">%</span> counter, axis<span style="color: #666666">=</span>[x1[<span style="color: #666666">0</span>], x1[<span style="color: #666666">-1</span>], <span style="color: #666666">-1.1</span>, <span style="color: #666666">1.1</span>])
    counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
</pre></div>
<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='https://github.com/hplgit/fdm-book/raw/master/doc/pub/book/html/mov-diffu/surface_osc/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="diffu:exer:bloodflow">Exercise 3.10: Oscillating and pulsating flow in tubes</h2>

<p>
We consider flow in a straight tube with radius \( R \) and straight walls.
The flow is driven by a pressure gradient \( \beta(t) \). The effect of
gravity can be neglected. The mathematical problem reads

$$
\begin{align}
\varrho\frac{\partial u}{\partial t} &=
\mu\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) + \beta(t),\quad
& r\in [0,R],\ t\in (0,T],
\tag{3.143}\\ 
u(r,0) &= 0,\quad & r\in [0,R],
\tag{3.144}\\ 
u(R,0) &= 0,\quad & t\in (0,T],
\tag{3.145}\\ 
\frac{\partial u}{\partial r}(0,t) &= 0,\quad & t\in (0,T].
\tag{3.146}
\end{align}
$$

We consider two models for \( \beta(t) \). One plain, sinusoidal oscillation:

$$
\begin{equation}
\beta = A\sin(\omega t),
\tag{3.147}
\end{equation}
$$

and one with periodic pulses,

$$
\begin{equation}
\beta = A\sin^{16}(\omega t),
\tag{3.148}
\end{equation}
$$

Note that both models can be written as \( \beta = A\sin^m(\omega t) \), with
\( m=1 \) and \( m=16 \), respectively.

<p>
<b>a)</b>
Scale the mathematical model, using the viscous time scale \( \varrho R^2/\mu \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_65_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_65_2">

<p>
We can introduce

$$ \bar r = \frac{r}{R}, \quad \bar t = \frac{t}{\varrho R^2/\mu},\quad u = \frac{u}{u_c}\tp$$

Inserted in the PDE, we get

$$ \frac{\partial\bar u}{\partial\bar t} =
\frac{1}{\bar r}\frac{\partial}{\partial\bar r}\left(
\bar r\frac{\partial\bar u}{\partial\bar r}\right) +
\frac{R^2 A}{u_c \mu}\sin^m (\alpha\bar t)
$$

where \( \alpha \) is a dimensionless number

$$  \alpha = \frac{\omega\varrho R^2}{\mu} = \frac{\varrho R^2/\mu}{1/\omega},
$$

reflecting the ratio of the viscous diffusion time scale and the
time scale of the oscillating pressure gradient.
We may choose \( u_c \) such that the coefficient in the pressure gradient
term equals unity:

$$ u_c = \frac{R^2 A}{\mu}\tp$$

The governing PDE, dropping the bars, then reads

$$ \frac{\partial u}{\partial t} =
\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) +
\sin^m (\alpha\bar t),\quad r\in (0,1),\ t\in (0,T]\tp
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Implement the scaled model from a), using the unifying \( \theta \) scheme
in time and centered differences in space.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_65_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_65_3">

<p>
We need to take into account extensions below: a coefficient in front of
the viscous term, and an extra source term.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Verify the implementation in b) using a manufactured solution that is
quadratic in \( r \) and linear in \( t \). Make a corresponding test function.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_65_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_65_1">

<p>
You need to include an extra source term
in the equation to allow for such tests. Let the spatial variation be
\( 1-r^2 \) such that the boundary condition is fulfilled.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Make animations for \( m=1,16 \) and \( \alpha=1,0.1 \). Choose \( T \) such that
the motion has reached a steady state (non-visible changes from period to
period in \( u \)).

<p>
<b>e)</b>
For \( \alpha\gg 1 \), the scaling in a) is not good, because the
characteristic time for changes (due to the pressure) is much smaller
than the viscous diffusion time scale (\( \alpha \) becomes large).
We should in this case base
the short time scale on \( 1/\omega \). Scale the model again, and
make an animation for \( m=1,16 \) and \( \alpha = 10 \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_65_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_65_4">

<p>
Now the governing PDE becomes

$$ \frac{\partial u}{\partial t} =
\alpha^{-1}\frac{1}{r}\frac{\partial}{\partial r}\left(
r\frac{\partial u}{\partial r}\right) +
\sin^m t,\quad r\in (0,1),\ t\in (0,T]\tp
$$

In this case,

$$ u_c = \frac{A}{\varrho\omega}\tp$$

We see that for \( \alpha\gg 1 \), we can neglect the viscous term, and we
basically have a balance between the acceleration and the driving pressure
gradient:

$$\frac{\partial u}{\partial t} = \sin^m t\tp$$


<!-- begin inline comment -->
<font color="red">(<b>hpl 23</b>: This may be a great challenge numerically, since we have a plug independent of r that oscillates back and forth. CN is probably very unstable. Can make a point out of this. Try \( \alpha=1 \) and increase gently.)</font>
<!-- end inline comment -->

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- ===== Exercise: Radial heat conduction out of offshore pipelines ===== -->

<p>
<!-- Easy to make something out of the ideas/5620/apps/offshore... mekit -->
<!-- paper where one has a multi-walled radial heat conduction equation. -->
<!-- Can, as in the paper, use one cell per material. Coupling to soil -->
<!-- outside with many parameters given. The discussion of the Fourier -->
<!-- number is interesting - I guess time changes here relates to -->
<!-- BCs on the inner wall because the gas suddenly has a different -->
<!-- temperature? Could be a good project perhaps; anyway, the theory -->
<!-- can be written up. -->

<p>
Filename: <code>axyiymm_flow</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86011.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._.trash82dee82e1274a586571086dca04d00308d3a0d86013.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright only on the titlepage -->
</center>


</body>
</html>
    

