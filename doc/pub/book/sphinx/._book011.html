
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Diffusion equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Advection-dominated equations" href="._book012.html" />
    <link rel="prev" title="Exercises" href="._book010.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book012.html" title="Advection-dominated equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book010.html" title="Exercises"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="diffusion-equations">
<span id="ch-diffu"></span><h1>Diffusion equations<a class="headerlink" href="#diffusion-equations" title="Permalink to this headline">¶</a></h1>
<p>[<strong>hpl 10</strong>: Here is a todo list.]</p>
<blockquote>
<div><ul class="simple">
<li>There are few index entries, see the &#8220;wave equation&#8221; index entries and
how many sub-entries we have there...</li>
<li>Check if the material on diffusion equation with radial symmetry is
okay.</li>
<li>Implement a diffusion equation with axi-symmetry such we can solve
pulsating flow in a circular blood vessel, see <a class="reference internal" href="#diffu-exer-bloodflow"><span class="std std-ref">Exercise 3.10: Oscillating and pulsating flow in tubes</span></a>.</li>
</ul>
</div></blockquote>
<span class="target" id="index-0"></span><p id="index-1">The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads</p>
<div class="math">
\[\frac{\partial u}{\partial t} =
{\alpha} \frac{\partial^2 u}{\partial x^2},\]</div>
<p>where <span class="math">\(u(x,t)\)</span> is the unknown function to be solved for, <span class="math">\(x\)</span> is a coordinate
in space, and <span class="math">\(t\)</span> is time. The coefficient <span class="math">\({\alpha}\)</span> is the <em>diffusion
coefficient</em> and determines how fast <span class="math">\(u\)</span> changes in time. A quick
short form for the diffusion equation is <span class="math">\(u_t = {\alpha} u_{xx}\)</span>.</p>
<p>Compared to the wave equation, <span class="math">\(u_{tt}=c^2u_{xx}\)</span>, which looks very similar,
the diffusion equation features solutions that are very different from
those of the wave equation. Also, the diffusion equation
makes quite different demands to the numerical
methods.</p>
<p id="index-2">Typical diffusion problems may experience rapid change in the very
beginning, but then the evolution of <span class="math">\(u\)</span> becomes slower and slower.
The solution is usually very smooth, and after some time, one cannot
recognize the initial shape of <span class="math">\(u\)</span>. This is in sharp contrast to solutions
of the wave equation where the initial shape is preserved - the solution
is basically a moving initial condition. The standard wave equation
<span class="math">\(u_{tt}=c^2u_{xx}\)</span> has solutions that propagates with speed <span class="math">\(c\)</span> forever,
without  changing shape, while the diffusion equation converges to
a <em>stationary solution</em> <span class="math">\(\bar u(x)\)</span> as <span class="math">\(t\rightarrow\infty\)</span>. In this
limit, <span class="math">\(u_t=0\)</span>, and <span class="math">\(\bar u\)</span> is governed by <span class="math">\(\bar u''(x)=0\)</span>.
This stationary limit of the diffusion equation is called
the <em>Laplace</em> equation and arises in a very wide range of applications
throughout the sciences.</p>
<p>It is possible to solve for <span class="math">\(u(x,t)\)</span> using an explicit scheme, as we do
in the section <a class="reference internal" href="#diffu-pde1-fesec"><span class="std std-ref">An explicit method for the 1D diffusion equation</span></a>, but the time step restrictions soon
become much less favorable than for an explicit scheme for the wave
equation. And of more importance, since the solution <span class="math">\(u\)</span> of the
diffusion equation is very smooth and changes slowly, small time steps
are not convenient and not required by accuracy as the diffusion
process converges to a stationary state. Therefore, implicit schemes
as described in the section <a class="reference internal" href="#diffu-pde1-implicit"><span class="std std-ref">Implicit methods for the 1D diffusion equation</span></a> are popular, but
these require solutions of systems of algebraic equations. We shall
use ready-made software for this purpose, but also program some simple
iterative methods.</p>
<p>The exposition below assumes that the reader is familiar with the
basic ideas of discretization and implementation of wave
equations from the chapter <a class="reference internal" href="._book005.html#ch-wave"><span class="std std-ref">Wave equations</span></a>. Readers not familiar with the
Forward Euler, Backward Euler, and Crank-Nicolson (or centered or
midpoint) discretization methods in time should consult, e.g.,
the
section <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book002.html#finite-difference-methods">Finite difference methods</a> in <a class="reference internal" href="._book027.html#ref3" id="id1">[Ref3]</a>.</p>
<div class="section" id="an-explicit-method-for-the-1d-diffusion-equation">
<span id="diffu-pde1-fesec"></span><h2>An explicit method for the 1D diffusion equation<a class="headerlink" href="#an-explicit-method-for-the-1d-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-initial-boundary-value-problem-for-1d-diffusion">
<h3>The initial-boundary value problem for 1D diffusion<a class="headerlink" href="#the-initial-boundary-value-problem-for-1d-diffusion" title="Permalink to this headline">¶</a></h3>
<p>To obtain a unique solution of the diffusion equation, or equivalently,
to apply numerical methods, we need initial and boundary conditions.
The diffusion equation goes with one initial condition <span class="math">\(u(x,0)=I(x)\)</span>, where
<span class="math">\(I\)</span> is a prescribed function. One boundary condition is required at
each point on the boundary, which in 1D means that <span class="math">\(u\)</span> must be known,
<span class="math">\(u_x\)</span> must be known, or some combination of them.</p>
<p>We shall start
with the simplest boundary condition: <span class="math">\(u=0\)</span>. The complete
initial-boundary value diffusion problem in one
space dimension can then be specified as</p>
<div class="math" id="eq-diffu-pde1">
\[\tag{306}
\frac{\partial u}{\partial t} =
    {\alpha} \frac{\partial^2 u}{\partial x^2} + f, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-diffu-pde1-ic-u">
\[\tag{307}
u(x,0) = I(x), \quad  x\in [0,L]\]</div>
<div class="math" id="eq-diffu-pde1-bc-0">
\[\begin{split}\tag{308}
u(0,t)  = 0, \quad  t&gt;0,\end{split}\]</div>
<div class="math" id="eq-diffu-pde1-bc-l">
\[\begin{split}\tag{309}
u(L,t)  = 0, \quad  t&gt;0{\thinspace .}\end{split}\]</div>
<p>With only a first-order derivative in time,
only one <em>initial condition</em> is needed, while the second-order
derivative in space leads to a demand for two <em>boundary conditions</em>.
We have added a source term <span class="math">\(f=f(x,t)\)</span> for
convenience when testing implementations.</p>
<p>Diffusion equations like <a class="reference internal" href="#eq-diffu-pde1"><span class="std std-ref">(306)</span></a> have a wide range of
applications throughout physical, biological, and financial sciences.
One of the most common applications is propagation of heat, where
<span class="math">\(u(x,t)\)</span> represents the temperature of some substance at point <span class="math">\(x\)</span> and
time <span class="math">\(t\)</span>.</p>
</div>
<div class="section" id="forward-euler-scheme">
<span id="diffu-pde1-fe"></span><h3>Forward Euler scheme<a class="headerlink" href="#forward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-3"></span><p id="index-4">The first step in the discretization procedure is to replace the
domain <span class="math">\([0,L]\times [0,T]\)</span> by a set of mesh points. Here we apply
equally spaced mesh points</p>
<div class="math">
\[x_i=i\Delta x,\quad i=0,\ldots,N_x,\]</div>
<p>and</p>
<div class="math">
\[t_n=n\Delta t,\quad n=0,\ldots,N_t {\thinspace .}\]</div>
<p>Moreover, <span class="math">\(u^n_i\)</span> denotes the mesh function that
approximates <span class="math">\(u(x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Requiring the PDE <a class="reference internal" href="#eq-diffu-pde1"><span class="std std-ref">(306)</span></a> to be fulfilled at a mesh point <span class="math">\((x_i,t_n)\)</span>
leads to the equation</p>
<div class="math" id="eq-diffu-pde1-step2">
\[\tag{310}
\frac{\partial}{\partial t} u(x_i, t_n) =
    {\alpha}\frac{\partial^2}{\partial x^2} u(x_i, t_n) + f(x_i,t_n),\]</div>
<p>The next step is to replace the derivatives by finite difference approximations.
The computationally simplest method arises from
using a forward difference in time and a central difference in
space:</p>
<div class="math" id="eq-diffu-pde1-step3a">
\[\tag{311}
[D_t^+ u = {\alpha} D_xD_x u + f]^n_i {\thinspace .}\]</div>
<p>Written out,</p>
<div class="math" id="eq-diffu-pde1-step3b">
\[\tag{312}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = {\alpha} \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n{\thinspace .}\]</div>
<p>We have turned the PDE into algebraic equations, also often called
discrete equations. The key property of the equations is that they
are algebraic, which makes them easy to solve.
As usual, we anticipate that <span class="math">\(u^n_i\)</span> is already computed such that
<span class="math">\(u^{n+1}_i\)</span> is the only unknown in <a class="reference internal" href="#eq-diffu-pde1-step3b"><span class="std std-ref">(312)</span></a>.
Solving with respect to this unknown is easy:</p>
<div class="math" id="eq-diffu-pde1-step4">
\[\tag{313}
u^{n+1}_i = u^n_i + F\left(
    u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right) + \Delta t f_i^n,\]</div>
<p>where we have introduced the <em>mesh Fourier number</em>:</p>
<div class="math" id="eq-auto117">
\[\tag{314}
F = {\alpha}\frac{\Delta t}{\Delta x^2}{\thinspace .}\]</div>
<div class="admonition-math-f-is-the-key-parameter-in-the-discrete-diffusion-equation admonition">
<p class="first admonition-title"><span class="math">\(F\)</span> is the key parameter in the discrete diffusion equation</p>
<p class="last">Note that <span class="math">\(F\)</span> is a <em>dimensionless</em> number that lumps the key physical
parameter in the problem, <span class="math">\({\alpha}\)</span>, and the discretization parameters
<span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span> into a single parameter. All the properties
of the numerical method are critically dependent upon the value of
<span class="math">\(F\)</span> (see the section <a class="reference internal" href="#diffu-pde1-analysis"><span class="std std-ref">Analysis of schemes for the diffusion equation</span></a> for details).</p>
</div>
<p>The computational algorithm then becomes</p>
<blockquote>
<div><ol class="arabic simple">
<li>compute $u^0_i=I(x_i)$for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>for <span class="math">\(n=0,1,\ldots,N_t\)</span>:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>apply <a class="reference internal" href="#eq-diffu-pde1-step4"><span class="std std-ref">(313)</span></a> for all the internal
spatial points <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set the boundary values
<span class="math">\(u^{n+1}_i=0\)</span> for <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span></li>
</ol>
</div></blockquote>
</div></blockquote>
<p>The algorithm is compactly and fully specified in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in space</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># unknown u at new time level</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># u at the previous time level</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Compute u at inner mesh points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
               <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">[:]</span><span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>Note that we use <code class="docutils literal"><span class="pre">a</span></code> for <span class="math">\({\alpha}\)</span> in the code, motivated by easy visual
mapping between the variable name and the mathematical symbol in formulas.</p>
<p>We need to state already now that the shown algorithm does not
produce meaningful results unless <span class="math">\(F\leq 1/2\)</span>. Why is explained in
the section <a class="reference internal" href="#diffu-pde1-analysis"><span class="std std-ref">Analysis of schemes for the diffusion equation</span></a>.</p>
</div>
<div class="section" id="implementation-7">
<span id="diffu-pde1-fe-code"></span><h3>Implementation<a class="headerlink" href="#implementation-7" title="Permalink to this headline">¶</a></h3>
<p>The file <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py">diffu1D_u0.py</a>
contains a complete function <code class="docutils literal"><span class="pre">solver_FE_simple</span></code>
for solving the 1D diffusion equation with <span class="math">\(u=0\)</span> on the boundary
as specified in the algorithm above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver_FE_simple</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplest expression of the computational algorithm</span>
<span class="sd">    using the Forward Euler method and explicit Python loops.</span>
<span class="sd">    For this method F &lt;= 0.5 for stability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>  <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>  <span class="c"># For measuring the CPU time</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">F</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Mesh points in space</span>
    <span class="c"># Make sure dx and dt are compatible with x and t</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Set initial condition u(x,0) = I(x)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c"># Compute u at inner mesh points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                   <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="c"># Insert boundary conditions</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Switch variables before next step</span>
        <span class="c">#u_1[:] = u  # safe, but slow</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span>  <span class="c"># u_1 holds latest u</span>
</pre></div>
</div>
<p>A faster version, based on vectorization of the finite difference
scheme, is available in the function <code class="docutils literal"><span class="pre">solver_FE</span></code>.
The vectorized version replaces the explicit loop</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> \
           <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>by arithmetics on displaced slices of the <code class="docutils literal"><span class="pre">u</span></code> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> \
          <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="c"># or</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> \
          <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>For example,
the
vectorized version runs 70 times faster than the scalar version
in a case with 100 time steps and a spatial mesh of <span class="math">\(10^5\)</span> cells.</p>
<p>The <code class="docutils literal"><span class="pre">solver_FE</span></code> function also features a callback function such that the
user can process the solution at each time level. The callback
function looks like <code class="docutils literal"><span class="pre">user_action(u,</span> <span class="pre">x,</span> <span class="pre">t,</span> <span class="pre">n)</span></code>, where <code class="docutils literal"><span class="pre">u</span></code> is the array
containing the solution at time level <code class="docutils literal"><span class="pre">n</span></code>, <code class="docutils literal"><span class="pre">x</span></code> holds all the
spatial mesh points, while <code class="docutils literal"><span class="pre">t</span></code> holds all the temporal mesh points.
Apart from the vectorized loop over the spatial mesh points, the
callback function, and a bit more complicated setting of the source
<code class="docutils literal"><span class="pre">f</span></code> it is not specified (<code class="docutils literal"><span class="pre">None</span></code>), the <code class="docutils literal"><span class="pre">solver_FE</span></code> is identical to
<code class="docutils literal"><span class="pre">solver_FE_simple</span></code> above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_FE</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
              <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vectorized implementation of solver_FE_simple.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>  <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>  <span class="c"># for measuring the CPU time</span>

    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">F</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Mesh points in space</span>
    <span class="c"># Make sure dx and dt are compatible with x and t</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># solution array</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># solution at t-dt</span>

    <span class="c"># Set initial condition</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c"># Update all inner points</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>\
                       <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;vectorized&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span>  \
                      <span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>\
                      <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">Nx</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;version=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">version</span><span class="p">)</span>

        <span class="c"># Insert boundary conditions</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Switch variables before next step</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-6">
<span id="diffu-pde1-fe-verify"></span><h3>Verification<a class="headerlink" href="#verification-6" title="Permalink to this headline">¶</a></h3>
<p>Before thinking about running the functions in the previous section,
we need to construct a suitable test example for verification. It
appears that a manufactured solution that is linear in time and at
most quadratic in space fulfills the Forward Euler scheme
exactly. With the restriction that <span class="math">\(u=0\)</span> for <span class="math">\(x=0,L\)</span>, we can try the
solution</p>
<div class="math">
\[u(x,t) = 5tx(L-x){\thinspace .}\]</div>
<p>Inserted in the PDE, it requires a source term</p>
<div class="math">
\[f(x,t) = 10{\alpha} t + 5x(L-x){\thinspace .}\]</div>
<p>With the formulas from  <a class="reference internal" href="._book020.html#sec-form-fdtn"><span class="std std-ref">Finite differences of </span></a> we can easily check
that the manufactured <code class="docutils literal"><span class="pre">u</span></code> fulfills the scheme:</p>
<div class="math">
\[\begin{split}\lbrack D_t^+ u = {\alpha} D_x D_x u + f\rbrack^n_i &amp;=
\lbrack 5x(L-x)D_t^+ t  = 5 t{\alpha} D_x D_x (xL-x^2) +\\
&amp;\quad\quad 10{\alpha} t + 5x(L-x)\rbrack^n_i\\
&amp;=
\lbrack 5x(L-x)  = 5 t{\alpha} (-2) + 10{\alpha} t + 5x(L-x) \rbrack^n_i{\thinspace .}\end{split}\]</div>
<p>The computation of the source term, given any <span class="math">\(u\)</span>,
is easily automated with <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x t a L&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="n">t</span>

<span class="k">def</span> <span class="nf">pde</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">pde</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
</pre></div>
</div>
<p>Now we can choose any expression for <code class="docutils literal"><span class="pre">u</span></code> and automatically
get the suitable source term <code class="docutils literal"><span class="pre">f</span></code>. However, the manufactured solution
<code class="docutils literal"><span class="pre">u</span></code> will in general
not be exactly reproduced by the scheme: only constant and linear
functions are differentiated correctly by a forward difference, while only
constant, linear, and quadratic functions are differentiated exactly by
a <span class="math">\([D_xD_x u]^n_i\)</span> difference.</p>
<p>The numerical code will need to access the <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">f</span></code> above
as Python functions. The exact solution is wanted as a Python
function <code class="docutils literal"><span class="pre">u_exact(x,</span> <span class="pre">t)</span></code>, while the source term is wanted as
<code class="docutils literal"><span class="pre">f(x,</span> <span class="pre">t)</span></code>. The parameters <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> in <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">f</span></code> above
are symbols and must be replaced by <code class="docutils literal"><span class="pre">float</span></code> objects in a Python
function. This can be done by redefining <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">L</span></code> as
<code class="docutils literal"><span class="pre">float</span></code> objects and performing substitutions of symbols by
numbers in <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">f</span></code>. The appropriate code looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">L</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">u_exact</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">u</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">modules</span><span class="o">=</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
<span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we also make a function <code class="docutils literal"><span class="pre">I</span></code> for the initial condition.</p>
<p>The idea now is that our manufactured solution should be
exactly reproduced by the code (to machine precision).
For this purpose we make a test function for comparing
the exact and numerical solutions at the end of the
time interval:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver_FE</span><span class="p">():</span>
    <span class="c"># Define u_exact, f, I as explained above</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">3</span>  <span class="c"># 3 cells</span>
    <span class="n">F</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_FE_simple</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max diff solver_FE_simple: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_FE</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max diff solver_FE, scalar: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_FE</span><span class="p">(</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_e</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="s">&#39;max diff solver_FE, vectorized: </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">diff</span>
</pre></div>
</div>
<p>We emphasize that the value <code class="docutils literal"><span class="pre">F=0.5</span></code> is critical: the tests above
will fail if <code class="docutils literal"><span class="pre">F</span></code> has a larger value (this is because the Forward
Euler scheme is unstable for <span class="math">\(F&gt;1/2\)</span>).</p>
</div>
<div class="section" id="numerical-experiments">
<span id="diffu-pde1-fe-experiments"></span><h3>Numerical experiments<a class="headerlink" href="#numerical-experiments" title="Permalink to this headline">¶</a></h3>
<p>When a test function like the one above runs silently without
errors, we have some evidence for a correct implementation of the
numerical method.
The next step is to do some experiments with more interesting solutions.</p>
<p>We target a scaled diffusion problem where <span class="math">\(x/L\)</span> is a new spatial
coordinate and <span class="math">\({\alpha} t/L^2\)</span> is a new time coordinate. The source term
<span class="math">\(f\)</span> is omitted, and <span class="math">\(u\)</span> is scaled by <span class="math">\(\max_{x\in [0,L]}|I(x)|\)</span>
(see <a class="reference external" href="http://hplgit.github.io/scaling-book/doc/pub/book/html/._scaling-book008.html#sec:scale:diffu">Scaling of the diffusion equation</a> in <a class="reference internal" href="._book027.html#ref4" id="id2">[Ref4]</a> for details).
The governing PDE is then</p>
<div class="math">
\[\frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2},\]</div>
<p>in the spatial domain <span class="math">\([0,L]\)</span>, with boundary conditions <span class="math">\(u(0)=u(1)=0\)</span>.
Two initial conditions will be tested: a discontinuous plug,</p>
<div class="math">
\[\begin{split}I(x) = \left\lbrace\begin{array}{ll}
0, &amp; |x-L/2| &gt; 0.1\\
1, &amp; \hbox{otherwise}
\end{array}\right.\end{split}\]</div>
<p>and a smooth Gaussian function,</p>
<div class="math">
\[I(x) = e^{-\frac{1}{2\sigma^2}(x-L/2)^2}{\thinspace .}\]</div>
<p>The functions <code class="docutils literal"><span class="pre">plug</span></code> and <code class="docutils literal"><span class="pre">gaussian</span></code> in <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py">diffu1D_u0.py</a> run the two cases,
respectively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">plug</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="c"># Compute dt from Nx and F</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="n">F</span><span class="o">/</span><span class="n">a</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plug profile as initial condition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="n">cpu</span> <span class="o">=</span> <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
              <span class="n">umin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
              <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">framefiles</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;CPU time:&#39;</span><span class="p">,</span> <span class="n">cpu</span>

<span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="c"># Compute dt from Nx and F</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="n">Nx</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="n">F</span><span class="o">/</span><span class="n">a</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gaussian profile as initial condition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                 <span class="n">umin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">umax</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
                 <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">framefiles</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;CPU time:&#39;</span><span class="p">,</span> <span class="n">cpu</span>
</pre></div>
</div>
<p>These functions make use of the function <code class="docutils literal"><span class="pre">viz</span></code> for running the
solver and visualizing the solution using a callback function
with plotting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">viz</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">,</span>
        <span class="n">scheme</span><span class="o">=</span><span class="s">&#39;FE&#39;</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">framefiles</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
                 <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">framefiles</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp_frame</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">framefiles</span><span class="p">:</span>
            <span class="c"># It takes time to write files so pause is needed</span>
            <span class="c"># for screen only animation</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="n">user_action</span> <span class="o">=</span> <span class="n">plot_u</span> <span class="k">if</span> <span class="n">animate</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">n</span><span class="p">:</span> <span class="bp">None</span>

    <span class="n">cpu</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;solver_&#39;</span><span class="o">+</span><span class="n">scheme</span><span class="p">)(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                                 <span class="n">user_action</span><span class="o">=</span><span class="n">user_action</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpu</span>
</pre></div>
</div>
<p>Notice that this <code class="docutils literal"><span class="pre">viz</span></code> function stores all the solutions in a
list <code class="docutils literal"><span class="pre">solutions</span></code> in the callback function. Modern computers have
hardly any problem with storing a lot of such solutions for moderate
values of <span class="math">\(N_x\)</span> in 1D problems, but for 2D and 3D problems, this
technique cannot be used and solutions must be stored in files.</p>
<p>[<strong>hpl 11</strong>: Better to show the scalable file solution here?]</p>
<p>Our experiments employ a time step <span class="math">\(\Delta t = 0.0002\)</span> and
simulate for <span class="math">\(t\in [0,0.1]\)</span>. First we try the highest value of
<span class="math">\(F\)</span>: <span class="math">\(F=0.5\)</span>. This resolution corresponds to
<span class="math">\(N_x=50\)</span>. A possible terminal command is</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python -c &#39;from diffu1D_u0 import gaussian
&gt; gaussian(&quot;solver_FE&quot;, F=0.5, dt=0.0002)&#39;
</pre></div>
</div>
<p>The <span class="math">\(u(x,t)\)</span> curve as a function of <span class="math">\(x\)</span> is shown
in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a> at four time
levels.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug/movie.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>We see that the curves have saw-tooth waves in the beginning of the
simulation. This non-physical noise is smoothed out with time, but
solutions of the diffusion equations are known to be smooth, and
this numerical solution is definitely not smooth.
Lowering <span class="math">\(F\)</span> helps: <span class="math">\(F\leq 0.25\)</span> gives a smooth solution, see
Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-25"><span class="std std-ref">Forward Euler scheme for </span></a>.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug_F025/movie.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug_F025/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_plug_F025/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Increasing <span class="math">\(F\)</span> slightly beyond the limit 0.5, to <span class="math">\(F=0.51\)</span>,
gives growing, non-physical instabilities,
as seen in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-51"><span class="std std-ref">Forward Euler scheme for </span></a>.</p>
<div class="figure" id="id8">
<span id="diffu-pde1-fe-fig-f-0-5"></span><a class="reference internal image-reference" href="_images/plug_FE_F05.png"><img alt="_images/plug_FE_F05.png" src="_images/plug_FE_F05.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Forward Euler scheme for <span class="math">\(F=0.5\)</span></span></p>
</div>
<div class="figure" id="id9">
<span id="diffu-pde1-fe-fig-f-0-25"></span><a class="reference internal image-reference" href="_images/plug_FE_F025.png"><img alt="_images/plug_FE_F025.png" src="_images/plug_FE_F025.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Forward Euler scheme for <span class="math">\(F=0.25\)</span></span></p>
</div>
<div class="figure" id="id10">
<span id="diffu-pde1-fe-fig-f-0-51"></span><a class="reference internal image-reference" href="_images/plug_FE_F051.png"><img alt="_images/plug_FE_F051.png" src="_images/plug_FE_F051.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Forward Euler scheme for <span class="math">\(F=0.51\)</span></span></p>
</div>
<p>Instead of a discontinuous initial condition we now try the smooth
Gaussian function for <span class="math">\(I(x)\)</span>. A simulation for <span class="math">\(F=0.5\)</span>
is shown in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-gauss-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>. Now the numerical solution
is smooth for all times, and this is true for any <span class="math">\(F\leq 0.5\)</span>.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><div class="figure" id="id11">
<span id="diffu-pde1-fe-fig-gauss-f-0-5"></span><a class="reference internal image-reference" href="_images/gaussian_FE_F05.png"><img alt="_images/gaussian_FE_F05.png" src="_images/gaussian_FE_F05.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Forward Euler scheme for <span class="math">\(F=0.5\)</span></span></p>
</div>
<p>Experiments with these two choices of <span class="math">\(I(x)\)</span> reveal some
important observations:</p>
<blockquote>
<div><ul class="simple">
<li>The Forward Euler scheme leads to growing solutions if <span class="math">\(F&gt;\frac{1}{2}\)</span>.</li>
<li><span class="math">\(I(x)\)</span> as a discontinuous plug leads to a saw tooth-like noise
for <span class="math">\(F=\frac{1}{2}\)</span>, which is absent for <span class="math">\(F\leq\frac{1}{4}\)</span>.</li>
<li>The smooth Gaussian initial function leads to a smooth solution
for all relevant <span class="math">\(F\)</span> values (<span class="math">\(F\geq \frac{1}{2}\)</span>).</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="implicit-methods-for-the-1d-diffusion-equation">
<span id="diffu-pde1-implicit"></span><h2>Implicit methods for the 1D diffusion equation<a class="headerlink" href="#implicit-methods-for-the-1d-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>Simulations with the Forward Euler scheme shows that the time step
restriction, <span class="math">\(F\leq\frac{1}{2}\)</span>, which means <span class="math">\(\Delta t \leq \Delta x^2/(2{\alpha})\)</span>,
may be relevant in the beginning of the diffusion process, when the
solution changes quite fast, but as time increases, the process slows
down, and a small <span class="math">\(\Delta t\)</span> may be inconvenient. By using
<em>implicit schemes</em>, which lead to a coupled system of linear equations
to be solved at each time level, any size of <span class="math">\(\Delta t\)</span> is possible
(but the accuracy decreases with increasing <span class="math">\(\Delta t\)</span>).
The Backward Euler scheme, derived and implemented below, is the
simplest implicit scheme for the diffusion equation.</p>
<div class="section" id="backward-euler-scheme">
<span id="diffu-pde1-be"></span><h3>Backward Euler scheme<a class="headerlink" href="#backward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p id="index-5">We now apply a backward difference in time in <a class="reference internal" href="#eq-diffu-pde1-step2"><span class="std std-ref">(310)</span></a>,
but the same central difference in space:</p>
<div class="math" id="eq-diffu-pde1-step3abe">
\[\tag{315}
[D_t^- u = D_xD_x u + f]^n_i,\]</div>
<p>which written out reads</p>
<div class="math" id="eq-diffu-pde1-step3bbe">
\[\tag{316}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = {\alpha}\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} + f_i^n{\thinspace .}\]</div>
<p>Now we assume <span class="math">\(u^{n-1}_i\)</span> is already computed, but all quantities at the &#8220;new&#8221;
time level <span class="math">\(n\)</span> are unknown. This time it is not possible to solve
with respect to <span class="math">\(u_i^{n}\)</span> because this value couples to its neighbors
in space, <span class="math">\(u^n_{i-1}\)</span> and <span class="math">\(u^n_{i+1}\)</span>, which are also unknown.
Let us examine this fact for the case when <span class="math">\(N_x=3\)</span>. Equation <a class="reference internal" href="#eq-diffu-pde1-step3bbe"><span class="std std-ref">(316)</span></a> written for <span class="math">\(i=1,\ldots,Nx-1= 1,2\)</span> becomes</p>
<div class="math" id="eq-auto118">
\[\tag{317}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} = {\alpha}\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2} + f_1^n\]</div>
<div class="math" id="eq-auto119">
\[\tag{318}
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} = {\alpha}\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2} + f_2^n\]</div>
<p>The boundary values <span class="math">\(u^n_0\)</span> and <span class="math">\(u^n_3\)</span> are known as zero. Collecting the
unknown new values <span class="math">\(u^n_1\)</span> and <span class="math">\(u^n_2\)</span> on the left-hand side and multiplying
by <span class="math">\(\Delta t\)</span> gives</p>
<div class="math" id="eq-auto120">
\[\tag{319}
\left(1+  2F\right) u^{n}_1 - F u^{n}_{2}    = u^{n-1}_1 + \Delta t f_1^n,\]</div>
<div class="math" id="eq-auto121">
\[\tag{320}
- F u^{n}_{1} + \left(1+  2F\right) u^{n}_2  = u^{n-1}_2 + \Delta t f_2^n{\thinspace .}\]</div>
<p>This is a coupled <span class="math">\(2\times 2\)</span> system of algebraic equations for
the unknowns <span class="math">\(u^n_1\)</span> and <span class="math">\(u^n_2\)</span>. The equivalent matrix form is</p>
<div class="math">
\[\begin{split}\left(\begin{array}{cc}
1+  2F &amp;   - F\\
- F    &amp; 1+  2F
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\
u^{n}_2
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1 + \Delta t f_1^n\\
u^{n-1}_2 + \Delta t f_2^n
\end{array}\right)\end{split}\]</div>
<div class="admonition-implicit-vs-explicit-methods admonition">
<p class="first admonition-title">Implicit vs. explicit methods</p>
<p class="last">Discretization methods that lead to a coupled system of equations
for the unknown function at a new time level are said to be
<em>implicit methods</em>.
The counterpart, <em>explicit methods</em>, refers to discretization
methods where there is a simple explicit formula for the values of
the unknown function at each of the spatial mesh points at the new
time level. From an implementational point of view, implicit methods
are more comprehensive to code since they require
the solution of coupled equations, i.e., a matrix system, at each time level.</p>
</div>
<p>In the general case, <a class="reference internal" href="#eq-diffu-pde1-step3bbe"><span class="std std-ref">(316)</span></a> gives rise to
a coupled <span class="math">\((Nx-1)\times (Nx-1)\)</span> system of algebraic equations for
all the unknown <span class="math">\(u^n_i\)</span> at the interior spatial points <span class="math">\(i=1,\ldots,Nx-1\)</span>.
Collecting the unknowns on the left-hand side,
<a class="reference internal" href="#eq-diffu-pde1-step3bbe"><span class="std std-ref">(316)</span></a> can be written</p>
<div class="math" id="eq-diffu-pde1-step4be">
\[\tag{321}
- F u^n_{i-1} + \left(1+  2F \right) u^{n}_i - F u^n_{i+1} =
    u_{i-1}^{n-1},\]</div>
<p>for <span class="math">\(i=1,\ldots,Nx-1\)</span>.
One can either view these equations as a system for where the
<span class="math">\(u^{n}_i\)</span> values at the internal mesh points, <span class="math">\(i=1,\ldots,N_x-1\)</span>, are
unknown, or we may append the boundary values <span class="math">\(u^n_0\)</span> and <span class="math">\(u^n_{N_x}\)</span>
to the system. In the latter case, all <span class="math">\(u^n_i\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span>
are unknown and we must add the boundary equations to
the <span class="math">\(N_x-1\)</span> equations in <a class="reference internal" href="#eq-diffu-pde1-step4be"><span class="std std-ref">(321)</span></a>:</p>
<div class="math" id="eq-diffu-pde1-step4be-bc-0">
\[\tag{322}
u_0^n = 0,\]</div>
<div class="math" id="eq-diffu-pde1-step4be-bc-l">
\[\tag{323}
u_{N_x}^n = 0{\thinspace .}\]</div>
<p>A coupled system of algebraic equations can be written on matrix form,
and this is important if we want to call up ready-made software for
solving the system.  The equations <a class="reference internal" href="#eq-diffu-pde1-step4be"><span class="std std-ref">(321)</span></a>
and <a class="reference internal" href="#eq-diffu-pde1-step4be-bc-0"><span class="std std-ref">(322)</span></a>&#8211;<a class="reference internal" href="#eq-diffu-pde1-step4be-bc-l"><span class="std std-ref">(323)</span></a>
correspond to the matrix equation</p>
<div class="math">
\[AU = b\]</div>
<p>where <span class="math">\(U=(u^n_0,\ldots,u^n_{N_x})\)</span>, and
the matrix <span class="math">\(A\)</span> has the following structure:</p>
<div class="math" id="eq-diffu-pde1-matrix-sparsity">
\[\begin{split}\tag{324}
A =
    \left(
    \begin{array}{cccccccccc}
    A_{0,0} &amp; A_{0,1} &amp; 0
    &amp;\cdots &amp;
    \cdots &amp; \cdots &amp; \cdots &amp;
    \cdots &amp; 0 \\
    A_{1,0} &amp; A_{1,1} &amp; A_{1,2} &amp; \ddots &amp;   &amp; &amp;  &amp; &amp;  \vdots \\
    0 &amp; A_{2,1} &amp; A_{2,2} &amp; A_{2,3} &amp;
    \ddots &amp; &amp;  &amp;  &amp; \vdots \\
    \vdots &amp; \ddots &amp;  &amp; \ddots &amp; \ddots &amp; 0 &amp;  &amp; &amp; \vdots \\
    \vdots &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \vdots \\
    \vdots &amp; &amp;  &amp; 0 &amp; A_{i,i-1} &amp; A_{i,i} &amp; A_{i,i+1} &amp; \ddots &amp; \vdots \\
    \vdots &amp; &amp; &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp;\ddots  &amp; 0 \\
    \vdots &amp; &amp; &amp; &amp;  &amp;\ddots  &amp; \ddots &amp;\ddots  &amp; A_{N_x-1,N_x} \\
    0 &amp;\cdots &amp; \cdots &amp;\cdots &amp; \cdots &amp; \cdots  &amp; 0 &amp; A_{N_x,N_x-1} &amp; A_{N_x,N_x}
    \end{array}
    \right)\end{split}\]</div>
<p>The nonzero elements are given by</p>
<div class="math" id="eq-auto122">
\[\tag{325}
A_{i,i-1} = -F\]</div>
<div class="math" id="eq-auto123">
\[\tag{326}
A_{i,i} = 1+ 2F\]</div>
<div class="math" id="eq-auto124">
\[\tag{327}
A_{i,i+1} = -F\]</div>
<p>for the equations for internal points, <span class="math">\(i=1,\ldots,N_x-1\)</span>. The first and last
equation correspond to the boundary condition, where we know the solution,
and therefore we must have</p>
<div class="math" id="eq-auto125">
\[\tag{328}
A_{0,0} = 1,\]</div>
<div class="math" id="eq-auto126">
\[\tag{329}
A_{0,1} = 0,\]</div>
<div class="math" id="eq-auto127">
\[\tag{330}
A_{N_x,N_x-1} = 0,\]</div>
<div class="math" id="eq-auto128">
\[\tag{331}
A_{N_x,N_x} = 1{\thinspace .}\]</div>
<p>The right-hand side <span class="math">\(b\)</span> is written as</p>
<div class="math" id="eq-auto129">
\[\begin{split}\tag{332}
b = \left(\begin{array}{c}
    b_0\\
    b_1\\
    \vdots\\
    b_i\\
    \vdots\\
    b_{N_x}
    \end{array}\right)\end{split}\]</div>
<p>with</p>
<div class="math" id="eq-auto130">
\[\tag{333}
b_0 = 0,\]</div>
<div class="math" id="eq-auto131">
\[\tag{334}
b_i = u^{n-1}_i,\quad i=1,\ldots,N_x-1,\]</div>
<div class="math" id="eq-auto132">
\[\tag{335}
b_{N_x} = 0 {\thinspace .}\]</div>
<p>We observe that the matrix <span class="math">\(A\)</span> contains quantities that do not change
in time. Therefore, <span class="math">\(A\)</span> can be formed once and for all before we enter
the recursive formulas for the time evolution.
The right-hand side <span class="math">\(b\)</span>, however, must be updated at each time step.
This leads to the following computational algorithm, here sketched
with Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in space</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># mesh points in time</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>          <span class="c"># unknown u at new time level</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>          <span class="c"># u at the previous time level</span>

<span class="c"># Data structures for the linear system</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">F</span>
<span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Compute b and solve linear system</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-matrix-implementation">
<span id="diffu-pde1-impl-sparse"></span><h3>Sparse matrix implementation<a class="headerlink" href="#sparse-matrix-implementation" title="Permalink to this headline">¶</a></h3>
<p>We have seen from <a class="reference internal" href="#eq-diffu-pde1-matrix-sparsity"><span class="std std-ref">(324)</span></a> that the matrix <span class="math">\(A\)</span>
is tridiagonal. The code segment above used a full, dense matrix
representation of <span class="math">\(A\)</span>, which stores a lot of values we know are zero
beforehand, and worse, the solution algorithm computes with all these zeros.
With <span class="math">\(N_x+1\)</span> unknowns, the work by the solution algorithm is <span class="math">\(\frac{1}{3}
(N_x+1)^3\)</span> and the storage requirements <span class="math">\((N_x+1)^2\)</span>. By utilizing
the fact that <span class="math">\(A\)</span> is tridiagonal and employing corresponding software
tools that work with the three diagonals,
the work and storage demands can be proportional to <span class="math">\(N_x\)</span> only.
This leads to a dramatic improvement: with <span class="math">\(N_x=200\)</span>, which is an often
needed resolution, the code runs about 40,000 times faster and reduces
the storage to just 1.5%! It is no doubt that we need to take advantage
of the fact that <span class="math">\(A\)</span> is tridiagonal.</p>
<p>The key idea is to apply a data structure for a
tridiagonal or sparse matrix. The <code class="docutils literal"><span class="pre">scipy.sparse</span></code> package has
relevant utilities. For example, we can store the nonzero diagonals of
a matrix. The package also has linear system solvers that operate on
sparse matrix data structures. The code below illustrates how we
can store only the main diagonal and the upper and lower diagonals.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Representation of sparse matrix and right-hand side</span>
<span class="n">main</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
<span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
<span class="n">b</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Precompute sparse matrix</span>
<span class="n">main</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">F</span>
<span class="n">lower</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span>
<span class="n">upper</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">F</span>
<span class="c"># Insert boundary conditions</span>
<span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">main</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
    <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">],</span>
    <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>  <span class="c"># Check that A is correct</span>

<span class="c"># Set initial condition</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">u_1</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c"># boundary conditions</span>
    <span class="n">u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">scipy.sparse.linalg.spsolve</span></code> function utilizes the sparse storage
structure of <code class="docutils literal"><span class="pre">A</span></code> and performs in this case a very efficient Gaussian
elimination solve.</p>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu1D_u0.py">diffu1D_u0.py</a>
contains a function <code class="docutils literal"><span class="pre">solver_BE</span></code>, which implements the Backward Euler scheme
sketched above.
As mentioned in the section <a class="reference internal" href="#diffu-pde1-fe"><span class="std std-ref">Forward Euler scheme</span></a>,
the functions <code class="docutils literal"><span class="pre">plug</span></code> and <code class="docutils literal"><span class="pre">gaussian</span></code>
runs the case with <span class="math">\(I(x)\)</span> as a discontinuous plug or a smooth
Gaussian function. All experiments point to two characteristic
features of the Backward Euler scheme: 1) it is always stable, and
2) it always gives a smooth, decaying solution.</p>
</div>
<div class="section" id="crank-nicolson-scheme">
<span id="diffu-pde1-cn"></span><h3>Crank-Nicolson scheme<a class="headerlink" href="#crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>The idea in the Crank-Nicolson scheme is to apply centered
differences in space and time, combined with an average in time.
We demand the PDE to be fulfilled at the spatial mesh points, but
midway between the points in the time mesh:</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i, t_{n+\frac{1}{2}}) =
{\alpha}\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\frac{1}{2}}) + f(x_i,t_{n+\frac{1}{2}}),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=0,\ldots, N_t-1\)</span>.</p>
<p>With centered differences in space and time, we get</p>
<div class="math">
\[[D_t u = {\alpha} D_xD_x u + f]^{n+\frac{1}{2}}_i{\thinspace .}\]</div>
<p>On the right-hand side we get an expression</p>
<div class="math">
\[\frac{1}{\Delta x^2}\left(u^{n+\frac{1}{2}}_{i-1} - 2u^{n+\frac{1}{2}}_i + u^{n+\frac{1}{2}}_{i+1}\right) + f_i^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>This expression is problematic since <span class="math">\(u^{n+\frac{1}{2}}_i\)</span> is not one of
the unknowns we compute. A possibility is to replace <span class="math">\(u^{n+\frac{1}{2}}_i\)</span>
by an arithmetic average:</p>
<div class="math">
\[u^{n+\frac{1}{2}}_i\approx
\frac{1}{2}\left(u^{n}_i +u^{n+1}_{i}\right){\thinspace .}\]</div>
<p>In the compact notation, we can use the arithmetic average
notation <span class="math">\(\overline{u}^t\)</span>:</p>
<div class="math">
\[[D_t u = {\alpha} D_xD_x \overline{u}^t + f]^{n+\frac{1}{2}}_i{\thinspace .}\]</div>
<p>We can also use an average for <span class="math">\(f_i^{n+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[[D_t u = {\alpha} D_xD_x \overline{u}^t + \overline{f}^t]^{n+\frac{1}{2}}_i{\thinspace .}\]</div>
<p>After writing out the differences and average, multiplying by <span class="math">\(\Delta t\)</span>,
and collecting all unknown terms on the left-hand side, we get</p>
<div class="math">
\[u^{n+1}_i - \frac{1}{2} F(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
= u^{n}_i + \frac{1}{2} F(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})\nonumber\]</div>
<div class="math" id="eq-auto133">
\[\tag{336}
\qquad \frac{1}{2} f_i^{n+1} + \frac{1}{2} f_i^n{\thinspace .}\]</div>
<p>Also here, as in the Backward Euler scheme, the new unknowns
<span class="math">\(u^{n+1}_{i-1}\)</span>, <span class="math">\(u^{n+1}_{i}\)</span>, and <span class="math">\(u^{n+1}_{i+1}\)</span> are coupled
in a linear system <span class="math">\(AU=b\)</span>, where <span class="math">\(A\)</span> has the same structure
as in <a class="reference internal" href="#eq-diffu-pde1-matrix-sparsity"><span class="std std-ref">(324)</span></a>, but with slightly
different entries:</p>
<div class="math" id="eq-auto134">
\[\tag{337}
A_{i,i-1} = -\frac{1}{2} F\]</div>
<div class="math" id="eq-auto135">
\[\tag{338}
A_{i,i} = \frac{1}{2} + F\]</div>
<div class="math" id="eq-auto136">
\[\tag{339}
A_{i,i+1} = -\frac{1}{2} F\]</div>
<p>for the equations for internal points, <span class="math">\(i=1,\ldots,N_x-1\)</span>. The equations
for the boundary points correspond to</p>
<div class="math" id="eq-auto137">
\[\tag{340}
A_{0,0} = 1,\]</div>
<div class="math" id="eq-auto138">
\[\tag{341}
A_{0,1} = 0,\]</div>
<div class="math" id="eq-auto139">
\[\tag{342}
A_{N_x,N_x-1} = 0,\]</div>
<div class="math" id="eq-auto140">
\[\tag{343}
A_{N_x,N_x} = 1{\thinspace .}\]</div>
<p>The right-hand side <span class="math">\(b\)</span> has entries</p>
<div class="math" id="eq-auto141">
\[\tag{344}
b_0 = 0,\]</div>
<div class="math" id="eq-auto142">
\[\tag{345}
b_i = u^{n-1}_i + \frac{1}{2}(f_i^n + f_i^{n+1}),\quad i=1,\ldots,N_x-1,\]</div>
<div class="math" id="eq-auto143">
\[\tag{346}
b_{N_x} = 0 {\thinspace .}\]</div>
</div>
<div class="section" id="the-unifying-rule">
<span id="diffu-pde1-theta"></span><h3>The unifying <span class="math">\(\theta\)</span> rule<a class="headerlink" href="#the-unifying-rule" title="Permalink to this headline">¶</a></h3>
<p>For the equation</p>
<div class="math">
\[\frac{\partial u}{\partial t} = G(u),\]</div>
<p>where <span class="math">\(G(u)\)</span> is some
a spatial differential operator, the <span class="math">\(\theta\)</span>-rule
looks like</p>
<div class="math">
\[\frac{u^{n+1}_i - u^n_i}{\Delta t} =
\theta G(u^{n+1}_i) + (1-\theta) G(u^{n}_i){\thinspace .}\]</div>
<p>The important feature of this time discretization scheme is that
we can implement one formula and then generate a family of
well-known and widely used schemes:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\theta=0\)</span> gives the Forward Euler scheme in time</li>
<li><span class="math">\(\theta=1\)</span> gives the Backward Euler scheme in time</li>
<li><span class="math">\(\theta=\frac{1}{2}\)</span> gives the Crank-Nicolson scheme in time</li>
</ul>
</div></blockquote>
<p>Applied to the 1D diffusion problem, the <span class="math">\(\theta\)</span>-rule gives</p>
<div class="math">
\[\begin{split}\frac{u^{n+1}_i-u^n_i}{\Delta t} &amp;=
{\alpha}\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)\\
&amp;\qquad + \theta f_i^{n+1} + (1-\theta)f_i^n
{\thinspace .}\end{split}\]</div>
<p>This scheme also leads to a matrix system with entries</p>
<div class="math">
\[A_{i,i-1} = -F\theta,\quad A_{i,i} = 1+2F\theta\quad,
A_{i,i+1} = -F\theta,\]</div>
<p>while right-hand side entry <span class="math">\(b_i\)</span> is</p>
<div class="math">
\[b_i = u^n_{i} + F(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2} +
\Delta t\theta f_i^{n+1} + \Delta t(1-\theta)f_i^n{\thinspace .}\]</div>
<p>The corresponding entries for the boundary points are as in the Backward
Euler and Crank-Nicolson schemes listed earlier.</p>
</div>
<div class="section" id="experiments">
<span id="diffu-pde1-theta-experiments"></span><h3>Experiments<a class="headerlink" href="#experiments" title="Permalink to this headline">¶</a></h3>
<p>We can repeat the experiments from the section <a class="reference internal" href="#diffu-pde1-fe-experiments"><span class="std std-ref">Numerical experiments</span></a>
to see if the Backward Euler or Crank-Nicolson schemes have problems
with sawtooth-like noise when starting with a discontinuous initial
condition. We can also verify that we can have <span class="math">\(F&gt;\frac{1}{2}\)</span>,
which allows larger time steps than in the Forward Euler method.</p>
<div class="figure" id="id12">
<span id="diffu-pde1-be-fig-f-0-5"></span><a class="reference internal image-reference" href="_images/plug_BE_F05.png"><img alt="_images/plug_BE_F05.png" src="_images/plug_BE_F05.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Backward Euler scheme for <span class="math">\(F=0.5\)</span></span></p>
</div>
<p>The Backward Euler scheme always produces smooth solutions for any <span class="math">\(F\)</span>.
Figure <a class="reference internal" href="#diffu-pde1-be-fig-f-0-5"><span class="std std-ref">Backward Euler scheme for </span></a> shows one example.
The Crank-Nicolson method produces smooth solutions for small <span class="math">\(F\)</span>,
<span class="math">\(F\leq\frac{1}{2}\)</span>, but small noise is more and more evident as <span class="math">\(F\)</span>
increases. Figures <a class="reference internal" href="#diffu-pde1-cn-fig-f-3"><span class="std std-ref">Crank-Nicolson scheme for </span></a> and <a class="reference internal" href="#diffu-pde1-cn-fig-f-10"><span class="std std-ref">Crank-Nicolson scheme for </span></a>
demonstrates the effect for <span class="math">\(F=3\)</span> and <span class="math">\(F=10\)</span>, respectively.
The section <a class="reference internal" href="#diffu-pde1-analysis"><span class="std std-ref">Analysis of schemes for the diffusion equation</span></a> explains why such noise occur.</p>
<div class="figure" id="id13">
<span id="diffu-pde1-cn-fig-f-3"></span><a class="reference internal image-reference" href="_images/plug_CN_F3.png"><img alt="_images/plug_CN_F3.png" src="_images/plug_CN_F3.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Crank-Nicolson scheme for <span class="math">\(F=3\)</span></span></p>
</div>
<div class="figure" id="id14">
<span id="diffu-pde1-cn-fig-f-10"></span><a class="reference internal image-reference" href="_images/plug_CN_F10.png"><img alt="_images/plug_CN_F10.png" src="_images/plug_CN_F10.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Crank-Nicolson scheme for <span class="math">\(F=10\)</span></span></p>
</div>
</div>
<div class="section" id="the-laplace-and-poisson-equation">
<h3>The Laplace and Poisson equation<a class="headerlink" href="#the-laplace-and-poisson-equation" title="Permalink to this headline">¶</a></h3>
<p>The Laplace equation, <span class="math">\(\nabla^2 u = 0\)</span>, and the Poisson equation,
<span class="math">\(-\nabla^2 u = f\)</span>, occur in numerous applications throughout science and
engineering. In 1D these equations read
<span class="math">\(u''(x)=0\)</span> and <span class="math">\(-u''(x)=f(x)\)</span>, respectively.
We can solve 1D variants of the Laplace equations with the listed
software, because we can interpret <span class="math">\(u_{xx}=0\)</span> as the limiting solution
of <span class="math">\(u_t = {\alpha} u_{xx}\)</span> when <span class="math">\(u\)</span> reaches a steady state limit where
<span class="math">\(u_t\rightarrow 0\)</span>.
Similarly, Poisson&#8217;s equation <span class="math">\(-u_{xx}=f\)</span> arises from solving
<span class="math">\(u_t = u_{xx} + f\)</span> and letting <span class="math">\(t\rightarrow\infty\)</span> so <span class="math">\(u_t\rightarrow 0\)</span>.</p>
<p>Technically in a program, we can simulate <span class="math">\(t\rightarrow\infty\)</span>
by just taking one large time step:
<span class="math">\(\Delta t\rightarrow\infty\)</span>. In the limit, the Backward Euler
scheme gives</p>
<div class="math">
\[-\frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2} = f^{n+1}_i,\]</div>
<p>which is nothing but the discretization <span class="math">\([-D_xD_x u = f]^{n+1}_i=0\)</span> of
<span class="math">\(-u_{xx}=f\)</span>.</p>
<p>The result above means that
the Backward Euler scheme can solve the limit equation directly and
hence produce a solution of the 1D Laplace equation.
With the Forward Euler scheme we must do the time stepping since <span class="math">\(\Delta t &gt;
\Delta x^2/{\alpha}\)</span>
is illegal and leads to instability.
We may interpret this time stepping
as solving the equation system from <span class="math">\(-u_{xx}=f\)</span> by iterating on a
pseudo time variable.</p>
<p>[<strong>hpl 12</strong>: Better to say the last sentence when we treat iterative methods.]</p>
</div>
</div>
<div class="section" id="analysis-of-schemes-for-the-diffusion-equation">
<span id="diffu-pde1-analysis"></span><h2>Analysis of schemes for the diffusion equation<a class="headerlink" href="#analysis-of-schemes-for-the-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>The numerical experiments in the sections <a class="reference internal" href="#diffu-pde1-fe-experiments"><span class="std std-ref">Numerical experiments</span></a> and <a class="reference internal" href="#diffu-pde1-theta-experiments"><span class="std std-ref">Experiments</span></a>
reveal that there are some
numerical problems with the Forward Euler and Crank-Nicolson schemes:
sawtooth-like noise is sometimes present in solutions that are,
from a mathematical point of view, expected to be smooth.
This section presents a mathematical analysis that explains the
observed behavior and arrives at criteria for obtaining numerical
solutions that reproduce the qualitative properties of the exact
solutions. In short, we shall explain what is observed in
Figures
<a class="reference internal" href="#diffu-pde1-fe-fig-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>,
<a class="reference internal" href="#diffu-pde1-fe-fig-f-0-25"><span class="std std-ref">Forward Euler scheme for </span></a>,
<a class="reference internal" href="#diffu-pde1-fe-fig-f-0-51"><span class="std std-ref">Forward Euler scheme for </span></a>,
<a class="reference internal" href="#diffu-pde1-fe-fig-gauss-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>,
<a class="reference internal" href="#diffu-pde1-be-fig-f-0-5"><span class="std std-ref">Backward Euler scheme for </span></a>,
<a class="reference internal" href="#diffu-pde1-cn-fig-f-3"><span class="std std-ref">Crank-Nicolson scheme for </span></a>,
and
<a class="reference internal" href="#diffu-pde1-cn-fig-f-10"><span class="std std-ref">Crank-Nicolson scheme for </span></a>.</p>
<div class="section" id="properties-of-the-solution">
<span id="diffu-pde1-analysis-uex"></span><h3>Properties of the solution<a class="headerlink" href="#properties-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>A particular characteristic of diffusive processes, governed
by an equation like</p>
<div class="math" id="eq-diffu-pde1-eq">
\[\tag{347}
u_t = {\alpha} u_{xx},\]</div>
<p>is that the
initial shape <span class="math">\(u(x,0)=I(x)\)</span> spreads out in space with time,
along with a decaying amplitude.
Three different examples will illustrate the spreading of <span class="math">\(u\)</span> in
space and the decay in time.</p>
<div class="section" id="similarity-solution">
<h4>Similarity solution<a class="headerlink" href="#similarity-solution" title="Permalink to this headline">¶</a></h4>
<p>The diffusion equation <a class="reference internal" href="#eq-diffu-pde1-eq"><span class="std std-ref">(347)</span></a> admits solutions
that depend on <span class="math">\(\eta = (x-c)/\sqrt{4{\alpha} t}\)</span> for a given value
of <span class="math">\(c\)</span>. One particular solution
is</p>
<div class="math" id="eq-diffu-pdf1-erf-sol">
\[\tag{348}
u(x,t) = a\,\mbox{erf}(\eta) + b,\]</div>
<p>where</p>
<div class="math" id="eq-diffu-analysis-erf-def">
\[\tag{349}
\mbox{erf}(\eta) = \frac{2}{\sqrt{\pi}}\int_0^\eta e^{-\zeta^2}d\zeta,\]</div>
<p>is the <em>error function</em>, and <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are arbitrary constants.
The error function lies in <span class="math">\((-1,1)\)</span>, is odd around <span class="math">\(\eta =0\)</span>, and
goes relatively quickly to <span class="math">\(\pm 1\)</span>:</p>
<div class="math">
\[\begin{split}\lim_{\eta\rightarrow -\infty}\mbox{erf}(\eta) &amp;=-1,\\
\lim_{\eta\rightarrow \infty}\mbox{erf}(\eta) &amp;=1,\\
\mbox{erf}(\eta) &amp;= -\mbox{erf}(-\eta),\\
\mbox{erf}(0) &amp;=0,\\
\mbox{erf}(2) &amp;=0.99532227,\\
\mbox{erf}(3) &amp;=0.99997791
{\thinspace .}\end{split}\]</div>
<p>As <span class="math">\(t\rightarrow 0\)</span>, the error function approaches a step function centered
at <span class="math">\(x=c\)</span>. For a diffusion problem posed on the unit interval <span class="math">\([0,1]\)</span>,
we may choose the step at <span class="math">\(x=1/2\)</span> (meaning <span class="math">\(c=1/2\)</span>), <span class="math">\(a=-1/2\)</span>, <span class="math">\(b=1/2\)</span>.
Then</p>
<div class="math" id="eq-diffu-analysis-pde1-step-erf-sol">
\[\tag{350}
u(x,t) = \frac{1}{2}\left(1 -
    \mbox{erf}\left(\frac{x-\frac{1}{2}}{\sqrt{4{\alpha} t}}\right)\right) =
    \frac{1}{2}\mbox{erfc}\left(\frac{x-\frac{1}{2}}{\sqrt{4{\alpha} t}}\right),\]</div>
<p>where we have introduced the <em>complementary error function</em>
<span class="math">\(\mbox{erfc}(\eta) = 1-\mbox{erf}(\eta)\)</span>.
The solution <a class="reference internal" href="#eq-diffu-analysis-pde1-step-erf-sol"><span class="std std-ref">(350)</span></a>
implies the boundary conditions</p>
<div class="math" id="eq-diffu-analysis-pde1-p1-erf-ul">
\[\tag{351}
u(0,t) = \frac{1}{2}\left(1 - \mbox{erf}\left(\frac{-1/2}{\sqrt{4{\alpha} t}}\right)\right),\]</div>
<div class="math" id="eq-diffu-analysis-pde1-p1-erf-ur">
\[\tag{352}
u(1,t) = \frac{1}{2}\left(1 - \mbox{erf}\left(\frac{1/2}{\sqrt{4{\alpha} t}}\right)\right)\]\[    {\thinspace .}\]</div>
<p>For small enough <span class="math">\(t\)</span>, <span class="math">\(u(0,t)\approx 1\)</span> and <span class="math">\(u(1,t)\approx 1\)</span>, but as
<span class="math">\(t\rightarrow\infty\)</span>, <span class="math">\(u(x,t)\rightarrow 1/2\)</span> on <span class="math">\([0,1]\)</span>.</p>
</div>
<div class="section" id="solution-for-a-gaussian-pulse">
<h4>Solution for a Gaussian pulse<a class="headerlink" href="#solution-for-a-gaussian-pulse" title="Permalink to this headline">¶</a></h4>
<p>The standard diffusion equation <span class="math">\(u_t = {\alpha} u_{xx}\)</span> admits a
Gaussian function as solution:</p>
<div class="math" id="eq-diffu-pde1-sol-gaussian">
\[\tag{353}
u(x,t) = \frac{1}{\sqrt{4\pi{\alpha} t}} \exp{\left({-\frac{(x-c)^2}{4{\alpha} t}}\right)}\]\[    {\thinspace .}\]</div>
<p>At <span class="math">\(t=0\)</span> this is a Dirac delta function, so for computational
purposes one must start to view the solution at some time <span class="math">\(t=t_\epsilon&gt;0\)</span>.
Replacing <span class="math">\(t\)</span> by <span class="math">\(t_\epsilon +t\)</span> in <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a>
makes it easy to operate with a (new) <span class="math">\(t\)</span> that starts at <span class="math">\(t=0\)</span>
with an initial condition with a finite width.
The important feature of <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a> is that
the standard deviation <span class="math">\(\sigma\)</span> of a sharp initial Gaussian pulse
increases in time according to <span class="math">\(\sigma = \sqrt{2{\alpha} t}\)</span>, making
the pulse diffuse and flatten out.</p>
</div>
<div class="section" id="solution-for-a-sine-component">
<h4>Solution for a sine component<a class="headerlink" href="#solution-for-a-sine-component" title="Permalink to this headline">¶</a></h4>
<p>For example, <a class="reference internal" href="#eq-diffu-pde1-eq"><span class="std std-ref">(347)</span></a>
admits a solution of the form</p>
<div class="math" id="eq-diffu-pde1-sol1">
\[\tag{354}
u(x,t) = Qe^{-at}\sin\left( kx\right)\]\[    {\thinspace .}\]</div>
<p>The parameters <span class="math">\(Q\)</span> and <span class="math">\(k\)</span> can be freely chosen, while
inserting <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> in <a class="reference internal" href="#eq-diffu-pde1-eq"><span class="std std-ref">(347)</span></a> gives the constraint</p>
<div class="math">
\[a = -{\alpha} k^2
{\thinspace .}\]</div>
<p>A very important feature is that the initial shape <span class="math">\(I(x)=Q\sin kx\)</span>
undergoes a damping <span class="math">\(\exp{(-{\alpha} k^2t)}\)</span>, meaning that
rapid oscillations in space, corresponding to large <span class="math">\(k\)</span>, are very much
faster dampened than slow oscillations in space, corresponding to small
<span class="math">\(k\)</span>. This feature leads to a smoothing of the initial condition with time.</p>
<p>The following examples illustrates the damping properties of <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a>. We consider the specific problem</p>
<div class="math">
\[\begin{split}u_t &amp;= u_{xx},\quad x\in (0,1),\ t\in (0,T],\\
u(0,t) &amp;= u(1,t) = 0,\quad t\in (0,T],\\
u(x,0) &amp; = \sin (\pi x) + 0.1\sin(100\pi x)
{\thinspace .}\end{split}\]</div>
<p>The initial condition has been chosen such that adding
two solutions like <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> constructs
an analytical solution to the problem:</p>
<div class="math" id="eq-diffu-pde1-sol2">
\[\tag{355}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)\]\[    {\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#diffu-pde1-fig-damping"><span class="std std-ref">Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right)</span></a> illustrates the rapid damping of
rapid oscillations <span class="math">\(\sin (100\pi x)\)</span> and the very much slower damping of the
slowly varying <span class="math">\(\sin (\pi x)\)</span> term. After about <span class="math">\(t=0.5\cdot10^{-4}\)</span> the rapid
oscillations do not have a visible amplitude, while we have to wait
until <span class="math">\(t\sim 0.5\)</span> before the amplitude of the long wave <span class="math">\(\sin (\pi x)\)</span>
becomes very small.</p>
<div class="figure" id="id15">
<span id="diffu-pde1-fig-damping"></span><a class="reference internal image-reference" href="_images/diffusion_damping.png"><img alt="_images/diffusion_damping.png" src="_images/diffusion_damping.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Evolution of the solution of a diffusion problem: initial condition (upper left), 1/100 reduction of the small waves (upper right), 1/10 reduction of the long wave (lower left), and 1/100 reduction of the long wave (lower right)</em></span></p>
</div>
</div>
</div>
<div class="section" id="analysis-of-discrete-equations">
<h3>Analysis of discrete equations<a class="headerlink" href="#analysis-of-discrete-equations" title="Permalink to this headline">¶</a></h3>
<p>A counterpart to <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> is the complex representation
of the same function:</p>
<div class="math">
\[u(x,t) = Qe^{-at}e^{ikx},\]</div>
<p>where <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit.
We can add such functions, often referred to as wave components,
to make a Fourier representation
of a general solution of the diffusion equation:</p>
<div class="math" id="eq-diffu-pde1-u-fourier">
\[\tag{356}
u(x,t) \approx \sum_{k\in K} b_k e^{-{\alpha} k^2t}e^{ikx},\]</div>
<p>where <span class="math">\(K\)</span> is a set of an infinite number of <span class="math">\(k\)</span> values needed to construct
the solution. In practice, however, the series is truncated and
<span class="math">\(K\)</span> is a finite set of <span class="math">\(k\)</span> values
needed to build a good approximate solution.
Note that <a class="reference internal" href="#eq-diffu-pde1-sol2"><span class="std std-ref">(355)</span></a> is a special case of
<a class="reference internal" href="#eq-diffu-pde1-u-fourier"><span class="std std-ref">(356)</span></a> where <span class="math">\(K=\{\pi, 100\pi\}\)</span>, <span class="math">\(b_{\pi}=1\)</span>,
and <span class="math">\(b_{100\pi}=0.1\)</span>.</p>
<p>The amplitudes <span class="math">\(b_k\)</span> of the individual Fourier waves must be determined
from the initial condition. At <span class="math">\(t=0\)</span> we have <span class="math">\(u\approx\sum_kb_k\exp{(ikx)}\)</span>
and find <span class="math">\(K\)</span> and <span class="math">\(b_k\)</span> such that</p>
<div class="math" id="eq-auto144">
\[\tag{357}
I(x) \approx \sum_{k\in K} b_k e^{ikx}{\thinspace .}\]</div>
<p>(The relevant formulas for <span class="math">\(b_k\)</span> come from Fourier analysis, or
equivalently, a least-squares method for approximating <span class="math">\(I(x)\)</span>
in a function space with basis <span class="math">\(\exp{(ikx)}\)</span>.)</p>
<p>Much insight about the behavior of numerical methods can be obtained
by investigating how a wave component <span class="math">\(\exp{(-{\alpha} k^2
t)}\exp{(ikx)}\)</span> is treated by the numerical scheme. It appears that
such wave components are also solutions of the schemes, but the
damping factor <span class="math">\(\exp{(-{\alpha} k^2 t)}\)</span> varies among the schemes.  To
ease the forthcoming algebra, we write the damping factor as
<span class="math">\(A^n\)</span>. The exact amplification factor corresponding to <span class="math">\(A\)</span> is <span class="math">\({A_{\small\mbox{e}}} =
\exp{(-{\alpha} k^2\Delta t)}\)</span>.</p>
</div>
<div class="section" id="analysis-of-the-finite-difference-schemes">
<span id="diffu-pde1-analysis-details"></span><h3>Analysis of the finite difference schemes<a class="headerlink" href="#analysis-of-the-finite-difference-schemes" title="Permalink to this headline">¶</a></h3>
<p>We have seen that a general solution of the diffusion equation
can be built as a linear combination of basic components</p>
<div class="math">
\[e^{-{\alpha} k^2t}e^{ikx} {\thinspace .}\]</div>
<p>A fundamental question is whether such components are also solutions of
the finite difference schemes. This is indeed the case, but the
amplitude <span class="math">\(\exp{(-{\alpha} k^2t)}\)</span> might be modified (which also happens when
solving the ODE counterpart <span class="math">\(u'=-{\alpha} u\)</span>).
We therefore look for numerical solutions of the form</p>
<div class="math" id="eq-diffu-pde1-analysis-uni">
\[\tag{358}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx},\]</div>
<p>where the amplification factor <span class="math">\(A\)</span>
must be determined by inserting the component into an actual scheme.</p>
<div class="section" id="stability-3">
<h4>Stability<a class="headerlink" href="#stability-3" title="Permalink to this headline">¶</a></h4>
<p>The exact amplification factor is <span class="math">\({A_{\small\mbox{e}}}=\exp{(-{\alpha}^2 k^2\Delta t)}\)</span>.
We should therefore require <span class="math">\(|A| &lt; 1\)</span> to have a decaying numerical
solution as well. If
<span class="math">\(-1\leq A&lt;0\)</span>, <span class="math">\(A^n\)</span> will change sign from time level to
time level, and we get stable, non-physical oscillations in the numerical
solutions that are not present in the exact solution.</p>
</div>
<div class="section" id="accuracy-1">
<span id="index-6"></span><h4>Accuracy<a class="headerlink" href="#accuracy-1" title="Permalink to this headline">¶</a></h4>
<p>To determine how accurately a finite difference scheme treats one
wave component <a class="reference internal" href="#eq-diffu-pde1-analysis-uni"><span class="std std-ref">(358)</span></a>, we see that the basic
deviation from the exact solution is reflected in how well
<span class="math">\(A^n\)</span> approximates <span class="math">\({A_{\small\mbox{e}}}^n\)</span>,
or how well <span class="math">\(A\)</span> approximates <span class="math">\({A_{\small\mbox{e}}}\)</span>.
We can plot <span class="math">\({A_{\small\mbox{e}}}\)</span> and the various expressions for <span class="math">\(A\)</span>, and we can
make Taylor expansions of <span class="math">\(A/{A_{\small\mbox{e}}}\)</span> to see the error more analytically.</p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme-2">
<span id="diffu-pde1-analysis-fe"></span><h3>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme-2" title="Permalink to this headline">¶</a></h3>
<p>The Forward Euler finite difference scheme for <span class="math">\(u_t = {\alpha} u_{xx}\)</span> can
be written as</p>
<div class="math">
\[[D_t^+ u = {\alpha} D_xD_x u]^n_q{\thinspace .}\]</div>
<p>Inserting a wave component <a class="reference internal" href="#eq-diffu-pde1-analysis-uni"><span class="std std-ref">(358)</span></a>
in the scheme demands calculating the terms</p>
<div class="math">
\[e^{ikq\Delta x}[D_t^+ A]^n = e^{ikq\Delta x}A^n\frac{A-1}{\Delta t},\]</div>
<p>and</p>
<div class="math">
\[A^nD_xD_x [e^{ikx}]_q = A^n\left( - e^{ikq\Delta x}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)\right)
{\thinspace .}\]</div>
<p>Inserting these terms in the discrete equation and
dividing by <span class="math">\(A^n e^{ikq\Delta x}\)</span> leads to</p>
<div class="math">
\[\frac{A-1}{\Delta t} = -{\alpha} \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),\]</div>
<p>and consequently</p>
<div class="math" id="eq-auto145">
\[\tag{359}
A = 1 -4F\sin^2 p\]</div>
<p>where</p>
<div class="math" id="eq-auto146">
\[\tag{360}
F = \frac{{\alpha}\Delta t}{\Delta x^2}\]</div>
<p>is the <em>numerical Fourier number</em>, and <span class="math">\(p=k\Delta x/2\)</span>.
The complete numerical solution is then</p>
<div class="math" id="eq-auto147">
\[\tag{361}
u^n_q = \left(1 -4F\sin^2 p\right)^ne^{ikq\Delta x}
    {\thinspace .}\]</div>
<div class="section" id="stability-4">
<h4>Stability<a class="headerlink" href="#stability-4" title="Permalink to this headline">¶</a></h4>
<p>We easily see that <span class="math">\(A\leq 1\)</span>. However, the <span class="math">\(A\)</span> can be less than <span class="math">\(-1\)</span>,
which will lead
to growth of a numerical wave component. The criterion <span class="math">\(A\geq -1\)</span> implies</p>
<div class="math">
\[4F\sin^2 (p/2)\leq 2
{\thinspace .}\]</div>
<p>The worst case is when <span class="math">\(\sin^2 (p/2)=1\)</span>, so a sufficient criterion for
stability is</p>
<div class="math" id="eq-auto148">
\[\tag{362}
F\leq {\frac{1}{2}},\]</div>
<p>or expressed as a condition on <span class="math">\(\Delta t\)</span>:</p>
<div class="math" id="eq-auto149">
\[\tag{363}
\Delta t\leq \frac{\Delta x^2}{2{\alpha}}{\thinspace .}\]</div>
<p>Note that halving the spatial mesh size, <span class="math">\(\Delta x \rightarrow {\frac{1}{2}}
\Delta x\)</span>, requires <span class="math">\(\Delta t\)</span> to be reduced by a factor of <span class="math">\(1/4\)</span>.
The method hence becomes very expensive for fine spatial meshes.</p>
</div>
<div class="section" id="accuracy-2">
<h4>Accuracy<a class="headerlink" href="#accuracy-2" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="math">\(A\)</span> is expressed in terms of <span class="math">\(F\)</span> and the parameter we now call
<span class="math">\(p=k\Delta x/2\)</span>, we should also express <span class="math">\({A_{\small\mbox{e}}}\)</span> by <span class="math">\(F\)</span> and <span class="math">\(p\)</span>. The exponent
in <span class="math">\({A_{\small\mbox{e}}}\)</span> is <span class="math">\(-{\alpha} k^2\Delta t\)</span>, which equals <span class="math">\(-F k^2\Delta x^2=-F4p^2\)</span>.
Consequently,</p>
<div class="math">
\[{A_{\small\mbox{e}}} = \exp{(-{\alpha} k^2\Delta t)} = \exp{(-4Fp^2)}
{\thinspace .}\]</div>
<p>All our <span class="math">\(A\)</span> expressions as well as <span class="math">\({A_{\small\mbox{e}}}\)</span> are now functions of the two
dimensionless parameters <span class="math">\(F\)</span> and <span class="math">\(p\)</span>.</p>
<p>Computing
the Taylor series expansion of <span class="math">\(A/{A_{\small\mbox{e}}}\)</span> in terms of <span class="math">\(F\)</span>
can easily be done with aid of <code class="docutils literal"><span class="pre">sympy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">A_exact</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">F</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">A_FE</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">F</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">F</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;F p&#39;</span><span class="p">)</span>
<span class="n">A_err_FE</span> <span class="o">=</span> <span class="n">A_FE</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">A_exact</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="k">print</span> <span class="n">A_err_FE</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is</p>
<div class="math">
\[\frac{A}{{A_{\small\mbox{e}}}} = 1 - 4 F \sin^{2}p + 2F p^{2} - 16F^{2} p^{2} \sin^{2}p + 8 F^{2} p^{4} + \cdots\]</div>
<p>Recalling that <span class="math">\(F={\alpha}\Delta t/\Delta x\)</span>, <span class="math">\(p=k\Delta x/2\)</span>, and that
<span class="math">\(\sin^2p\leq 1\)</span>, we
realize that the dominating terms in <span class="math">\(A/{A_{\small\mbox{e}}}\)</span> are at most</p>
<div class="math">
\[1 - 4{\alpha} \frac{\Delta t}{\Delta x^2} +
{\alpha}\Delta t - 4{\alpha}^2\Delta t^2
+ {\alpha}^2 \Delta t^2\Delta x^2 + \cdots
{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="analysis-of-the-backward-euler-scheme">
<span id="diffu-pde1-analysis-be"></span><h3>Analysis of the Backward Euler scheme<a class="headerlink" href="#analysis-of-the-backward-euler-scheme" title="Permalink to this headline">¶</a></h3>
<p>Discretizing <span class="math">\(u_t = {\alpha} u_{xx}\)</span> by a Backward Euler scheme,</p>
<div class="math">
\[[D_t^- u = {\alpha} D_xD_x u]^n_q,\]</div>
<p>and inserting a wave component <a class="reference internal" href="#eq-diffu-pde1-analysis-uni"><span class="std std-ref">(358)</span></a>,
leads to calculations similar to those arising from the Forward Euler scheme,
but since</p>
<div class="math">
\[e^{ikq\Delta x}[D_t^- A]^n = A^ne^{ikq\Delta x}\frac{1 - A^{-1}}{\Delta t},\]</div>
<p>we get</p>
<div class="math">
\[\frac{1-A^{-1}}{\Delta t} = -{\alpha} \frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right),\]</div>
<p>and then</p>
<div class="math" id="eq-diffu-pde1-analysis-be-a">
\[\tag{364}
A = \left(1  + 4F\sin^2p\right)^{-1}\]\[    {\thinspace .}\]</div>
<p>The complete numerical solution can be written</p>
<div class="math" id="eq-auto150">
\[\tag{365}
u^n_q = \left(1  + 4F\sin^2 p\right)^{-n}
    e^{ikq\Delta x} {\thinspace .}\]</div>
<div class="section" id="stability-5">
<h4>Stability<a class="headerlink" href="#stability-5" title="Permalink to this headline">¶</a></h4>
<p>We see from <a class="reference internal" href="#eq-diffu-pde1-analysis-be-a"><span class="std std-ref">(364)</span></a> that <span class="math">\(0&lt;A&lt;1\)</span>, which means
that all numerical wave components are stable and non-oscillatory
for any <span class="math">\(\Delta t &gt;0\)</span>.</p>
</div>
</div>
<div class="section" id="analysis-of-the-crank-nicolson-scheme">
<span id="diffu-pde1-analysis-cn"></span><h3>Analysis of the Crank-Nicolson scheme<a class="headerlink" href="#analysis-of-the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Crank-Nicolson scheme can be written as</p>
<div class="math">
\[[D_t u = {\alpha} D_xD_x \overline{u}^x]^{n+\frac{1}{2}}_q,\]</div>
<p>or</p>
<div class="math">
\[[D_t u]^{n+\frac{1}{2}}_q = \frac{1}{2}{\alpha}\left( [D_xD_x u]^{n}_q +
[D_xD_x u]^{n+1}_q\right)
{\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-diffu-pde1-analysis-uni"><span class="std std-ref">(358)</span></a> in the time derivative approximation
leads to</p>
<div class="math">
\[[D_t A^n e^{ikq\Delta x}]^{n+\frac{1}{2}} = A^{n+\frac{1}{2}} e^{ikq\Delta x}\frac{A^{\frac{1}{2}}-A^{-\frac{1}{2}}}{\Delta t} = A^ne^{ikq\Delta x}\frac{A-1}{\Delta t}
{\thinspace .}\]</div>
<p>Inserting <a class="reference internal" href="#eq-diffu-pde1-analysis-uni"><span class="std std-ref">(358)</span></a> in the other terms
and dividing by
<span class="math">\(A^ne^{ikq\Delta x}\)</span> gives the relation</p>
<div class="math">
\[\frac{A-1}{\Delta t} = -\frac{1}{2}{\alpha}\frac{4}{\Delta x^2}
\sin^2\left(\frac{k\Delta x}{2}\right)
(1 + A),\]</div>
<p>and after some more algebra,</p>
<div class="math" id="eq-auto151">
\[\tag{366}
A = \frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}
    {\thinspace .}\]</div>
<p>The exact numerical solution is hence</p>
<div class="math" id="eq-auto152">
\[\tag{367}
u^n_q = \left(\frac{ 1 - 2F\sin^2p}{1 + 2F\sin^2p}\right)^ne^{ikp\Delta x}
    {\thinspace .}\]</div>
<div class="section" id="stability-6">
<h4>Stability<a class="headerlink" href="#stability-6" title="Permalink to this headline">¶</a></h4>
<p>The criteria <span class="math">\(A&gt;-1\)</span> and <span class="math">\(A&lt;1\)</span> are fulfilled for any <span class="math">\(\Delta t &gt;0\)</span>.
Therefore, the solution cannot grow, but it will oscillate if
<span class="math">\(1-2F\sin^p &lt; 0\)</span>. To avoid such non-physical oscillations, we must demand
<span class="math">\(F\leq\frac{1}{2}\)</span>.</p>
</div>
</div>
<div class="section" id="summary-of-accuracy-of-amplification-factors">
<h3>Summary of accuracy of amplification factors<a class="headerlink" href="#summary-of-accuracy-of-amplification-factors" title="Permalink to this headline">¶</a></h3>
<p>We can plot the various amplification factors against <span class="math">\(p=k\Delta x/2\)</span>
for different choices of the <span class="math">\(F\)</span> parameter. Figures
<a class="reference internal" href="#diffu-pde1-fig-a-err-c20"><span class="std std-ref">Amplification factors for large time steps</span></a>, <a class="reference internal" href="#diffu-pde1-fig-a-err-c0-5"><span class="std std-ref">Amplification factors for time steps around the Forward Euler stability limit</span></a>, and
<a class="reference internal" href="#diffu-pde1-fig-a-err-c0-1"><span class="std std-ref">Amplification factors for small time steps</span></a> show how long and small waves are
damped by the various schemes compared to the exact damping. As long
as all schemes are stable, the amplification factor is positive,
except for Crank-Nicolson when <span class="math">\(F&gt;0.5\)</span>.</p>
<div class="figure" id="id16">
<span id="diffu-pde1-fig-a-err-c20"></span><a class="reference internal image-reference" href="_images/diffusion_A_F20_F2.png"><img alt="_images/diffusion_A_F20_F2.png" src="_images/diffusion_A_F20_F2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Amplification factors for large time steps</em></span></p>
</div>
<div class="figure" id="id17">
<span id="diffu-pde1-fig-a-err-c0-5"></span><a class="reference internal image-reference" href="_images/diffusion_A_F05_F025.png"><img alt="_images/diffusion_A_F05_F025.png" src="_images/diffusion_A_F05_F025.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Amplification factors for time steps around the Forward Euler stability limit</em></span></p>
</div>
<div class="figure" id="id18">
<span id="diffu-pde1-fig-a-err-c0-1"></span><a class="reference internal image-reference" href="_images/diffusion_A_F01_F001.png"><img alt="_images/diffusion_A_F01_F001.png" src="_images/diffusion_A_F01_F001.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Amplification factors for small time steps</em></span></p>
</div>
<p>The effect of negative amplification factors is that <span class="math">\(A^n\)</span> changes
sign from one time level to the next, thereby giving rise to
oscillations in time in an animation of the solution. We see from
Figure <a class="reference internal" href="#diffu-pde1-fig-a-err-c20"><span class="std std-ref">Amplification factors for large time steps</span></a> that for <span class="math">\(F=20\)</span>, waves with
<span class="math">\(p\geq \pi/2\)</span> undergo a damping close to <span class="math">\(-1\)</span>, which means that the
amplitude does not decay and that the wave component jumps up and down
(flips amplitude)
in time. For <span class="math">\(F=2\)</span> we have a damping of a factor of 0.5 from one time
level to the next, which is very much smaller than the exact
damping. Short waves will therefore fail to be effectively dampened.
These waves will manifest themselves as high frequency oscillatory
noise in the solution.</p>
<p>A value <span class="math">\(p=\pi/4\)</span> corresponds to four mesh points per wave length of
<span class="math">\(e^{ikx}\)</span>, while <span class="math">\(p=\pi/2\)</span> implies only two points per wave length,
which is the smallest number of points we can have to represent the
wave on the mesh.</p>
<p>To demonstrate the oscillatory behavior of the Crank-Nicolson scheme, we
choose an initial condition that leads to short waves with
significant amplitude. A discontinuous <span class="math">\(I(x)\)</span> will in particular serve
this purpose.</p>
<p>[<strong>hpl 13</strong>: Run example!!]</p>
</div>
<div class="section" id="analysis-of-the-2d-diffusion-equation">
<span id="diffu-2d-analysis"></span><h3>Analysis of the 2D diffusion equation<a class="headerlink" href="#analysis-of-the-2d-diffusion-equation" title="Permalink to this headline">¶</a></h3>
<p>We first consider the 2D diffusion equation</p>
<div class="math">
\[u_{t} = {\alpha}(u_{xx} + u_{yy}),\]</div>
<p>which has Fourier component solutions of the form</p>
<div class="math">
\[u(x,y,t) = Ae^{-{\alpha} k^2t}e^{i(k_x x + k_yy)},\]</div>
<p>and the schemes have discrete versions of this Fourier component:</p>
<div class="math">
\[u^{n}_{q,r} = A\xi^{n}e^{i(k_x q\Delta x + k_y r\Delta y)}{\thinspace .}\]</div>
<div class="section" id="the-forward-euler-scheme-2">
<h4>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme-2" title="Permalink to this headline">¶</a></h4>
<p>For the Forward Euler discretization,</p>
<div class="math">
\[[D_t^+u = {\alpha}(D_xD_x u + D_yD_y u)]_{i,j}^n,\]</div>
<p>we get</p>
<div class="math">
\[\frac{\xi - 1}{\Delta t}
=
-{\alpha}\frac{4}{\Delta x^2}\sin^2\left(\frac{k_x\Delta x}{2}\right) -
{\alpha}\frac{4}{\Delta y^2}\sin^2\left(\frac{k_y\Delta y}{2}\right){\thinspace .}\]</div>
<p>Introducing</p>
<div class="math">
\[p_x = \frac{k_x\Delta x}{2},\quad p_y = \frac{k_y\Delta y}{2},\]</div>
<p>we can write the equation for <span class="math">\(\xi\)</span> more compactly as</p>
<div class="math">
\[\frac{\xi - 1}{\Delta t}
=
-{\alpha}\frac{4}{\Delta x^2}\sin^2 p_x -
{\alpha}\frac{4}{\Delta y^2}\sin^2 p_y,\]</div>
<p>and solve for <span class="math">\(\xi\)</span>:</p>
<div class="math" id="eq-diffu-2d-analysis-xi">
\[\tag{368}
\xi = 1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y{\thinspace .}\]</div>
<p>The complete numerical solution for a wave component is</p>
<div class="math" id="eq-diffu-2d-analysis-fe-numexact">
\[\tag{369}
u^{n}_{q,r} = A(1 - 4F_x\sin^2 p_x - 4F_y\sin^2 p_y)^n
    e^{i(k_xp\Delta x + k_yq\Delta y)}{\thinspace .}\]</div>
<p>For stability we demand <span class="math">\(-1\leq\xi\leq 1\)</span>, and <span class="math">\(-1\leq\xi\)</span> is the
critical limit, since clearly <span class="math">\(\xi \leq 1\)</span>, and the worst case
happens when the sines are at their maximum. The stability criterion
becomes</p>
<div class="math" id="eq-diffu-2d-analysis-fe-stab">
\[\tag{370}
F_x + F_y \leq \frac{1}{2}{\thinspace .}\]</div>
<p>For the special, yet common, case <span class="math">\(\Delta x=\Delta y=h\)</span>, the
stability criterion can be written as</p>
<div class="math">
\[\Delta t \leq \frac{h^2}{2d{\alpha}},\]</div>
<p>where <span class="math">\(d\)</span> is the number of space dimensions: <span class="math">\(d=1,2,3\)</span>.</p>
</div>
<div class="section" id="the-backward-euler-scheme-2">
<h4>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme-2" title="Permalink to this headline">¶</a></h4>
<p>The Backward Euler method,</p>
<div class="math">
\[[D_t^-u = {\alpha}(D_xD_x u + D_yD_y u)]_{i,j}^n,\]</div>
<p>results in</p>
<div class="math">
\[1 - \xi^{-1} = - 4F_x \sin^2 p_x - 4F_y \sin^2 p_y,\]</div>
<p>and</p>
<div class="math">
\[\xi = (1 + 4F_x \sin^2 p_x + 4F_y \sin^2 p_y)^{-1},\]</div>
<p>which is always in <span class="math">\((0,1]\)</span>. The solution for a wave component becomes</p>
<div class="math" id="eq-diffu-2d-analysis-bn-numexact">
\[\tag{371}
u^{n}_{q,r} = A(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n}
    e^{i(k_xq\Delta x + k_yr\Delta y)}{\thinspace .}\]</div>
</div>
<div class="section" id="the-crank-nicolson-scheme-2">
<h4>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme-2" title="Permalink to this headline">¶</a></h4>
<p>With a Crank-Nicolson discretization,</p>
<div class="math">
\[[D_tu]^{n+\frac{1}{2}}_{i,j} =
\frac{1}{2} [{\alpha}(D_xD_x u + D_yD_y u)]_{i,j}^{n+1} +
\frac{1}{2} [{\alpha}(D_xD_x u + D_yD_y u)]_{i,j}^n,\]</div>
<p>we have, after some algebra,</p>
<div class="math">
\[\xi = \frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{\thinspace .}\]</div>
<p>The fraction on the right-hand side is always less than 1, so stability
in the sense of non-growing wave components is guaranteed for all
physical and numerical parameters. However,
the fraction can become negative and result in non-physical
oscillations. This phenomenon happens when</p>
<div class="math">
\[\begin{split}F_x\sin^2 p_x + F_x\sin^2p_y &gt; \frac{1}{2}{\thinspace .}\end{split}\]</div>
<p>A criterion against non-physical oscillations is therefore</p>
<div class="math">
\[F_x + F_y \leq \frac{1}{2},\]</div>
<p>which is the same limit as the stability criterion for the Forward Euler
scheme.</p>
<p>The exact discrete solution is</p>
<div class="math" id="eq-diffu-2d-analysis-cn-numexact">
\[\tag{372}
u^{n}_{q,r} = A
    \left(
    \frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
    \right)^n
    e^{i(k_xq\Delta x + k_yr\Delta y)}{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="explanation-of-numerical-artifacts">
<h3>Explanation of numerical artifacts<a class="headerlink" href="#explanation-of-numerical-artifacts" title="Permalink to this headline">¶</a></h3>
<p>The behavior of the Forward Euler discretization in time (and centered
differences in space) is summarized at the end of
the section <a class="reference internal" href="#diffu-pde1-fe-experiments"><span class="std std-ref">Numerical experiments</span></a>. Can we from the analysis
above explain the behavior?</p>
<p>We may start by looking at Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-51"><span class="std std-ref">Forward Euler scheme for </span></a>
where <span class="math">\(F=0.51\)</span>. The figure shows that the solution is unstable and
grows in time. The stability limit for such growth is <span class="math">\(F=0.5\)</span> and
since the <span class="math">\(F\)</span> in this simulation is slightly larger, growth is
unavoidable.</p>
<p>Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a> has unexpected features:
we would expect the solution of the diffusion equation to be
smooth, but the graphs in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>
contain non-smooth noise. Turning to Figure
<a class="reference internal" href="#diffu-pde1-fe-fig-gauss-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>,  which has a quite similar
initial condition, we see that the curves are indeed smooth.
The problem with the results in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>
is that the initial condition is discontinuous. To represent it, we
need a significant amplitude on the shortest waves in the mesh.
However, for <span class="math">\(F=0.5\)</span>, the shortest wave (<span class="math">\(p=\pi/2\)</span>) gives
the amplitude in the numerical solution as <span class="math">\((1-4F)^n\)</span>, which oscillates
between negative and positive values at subsequent time levels
for <span class="math">\(F&gt;\frac{1}{4}\)</span>. Since the shortest waves have visible amplitudes in
the solution profile, the oscillations becomes visible. The
smooth initial condition in Figure <a class="reference internal" href="#diffu-pde1-fe-fig-gauss-f-0-5"><span class="std std-ref">Forward Euler scheme for </span></a>,
on the other hand, lead to very small amplitudes of the shortest waves.
That these waves then oscillate in a non-physical way for
<span class="math">\(F=0.5\)</span> is not a visible effect. The oscillations
in time in the amplitude <span class="math">\((1-4F)^n\)</span> disappear for <span class="math">\(F\leq\frac{1}{4}\)</span>,
and that is why also the discontinuous initial condition leads to
always smooth solutions in Figure ref:ref:<cite>diffu:pde1:FE:fig:F=0.25</cite>, where
<span class="math">\(F=\frac{1}{4}\)</span>.</p>
<p>Turning the attention to the Backward Euler scheme and the experiments
in Figure <a class="reference internal" href="#diffu-pde1-be-fig-f-0-5"><span class="std std-ref">Backward Euler scheme for </span></a>, we see that even the discontinuous
initial condition gives smooth solutions for <span class="math">\(F=0.5\)</span> (and in fact all other
<span class="math">\(F\)</span> values). From the exact expression of the numerical amplitude,
<span class="math">\((1  + 4F\sin^2p)^{-1}\)</span>, we realize that this factor can never flip between
positive and negative values, and no instabilities can occur. The conclusion
is that the Backward Euler scheme always produces smooth solutions.
Also, the Backward Euler scheme guarantees that the solution cannot grow
in time (unless we add a source term to the PDE, but that is meant to
represent a physically relevant growth).</p>
<p>Finally, we have some small, strange artifacts when simulating the
development of the initial plug profile with the Crank-Nicolson scheme,
see Figure <a class="reference internal" href="#diffu-pde1-cn-fig-f-10"><span class="std std-ref">Crank-Nicolson scheme for </span></a>, where <span class="math">\(F=3\)</span>.
The Crank-Nicolson scheme cannot give growing amplitudes, but it may
give oscillating amplitudes in time. The critical factor is
<span class="math">\(1 - 2F\sin^2p\)</span>, which for the shortest waves (<span class="math">\(p=\pi/2\)</span>) indicates
a stability limit <span class="math">\(F=0.5\)</span>. With the discontinuous initial condition, we have
enough amplitude on the shortest waves so their wrong behavior is visible,
and this is what we see as small instabilities in
Figure <a class="reference internal" href="#diffu-pde1-cn-fig-f-10"><span class="std std-ref">Crank-Nicolson scheme for </span></a>. The only remedy is to lower the <span class="math">\(F\)</span> value.</p>
</div>
</div>
<div class="section" id="exercises-6">
<h2>Exercises<a class="headerlink" href="#exercises-6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-3-1-explore-symmetry-in-a-1d-problem">
<span id="diffu-exer-1d-gaussian-symmetric"></span><h3>Exercise 3.1: Explore symmetry in a 1D problem<a class="headerlink" href="#exercise-3-1-explore-symmetry-in-a-1d-problem" title="Permalink to this headline">¶</a></h3>
<p>This exercise simulates the exact solution <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a>.
Suppose for simplicity that <span class="math">\(c=0\)</span>.</p>
<p><strong>a)</strong>
Formulate an initial-boundary value problem that has
<a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a> as solution in the domain <span class="math">\([-L,L]\)</span>.
Use the exact solution <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a> as Dirichlet
condition at the boundaries.
Simulate the diffusion of the Gaussian peak. Observe that the
solution is symmetric around <span class="math">\(x=0\)</span>.</p>
<p><strong>b)</strong>
Show from <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a> that <span class="math">\(u_x(c,t)=0\)</span>.
Since the solution is symmetric around <span class="math">\(x=c=0\)</span>, we can solve the
numerical problem in half of the domain, using a <em>symmetry boundary condition</em>
<span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>. Set up the
initial-boundary value problem in this case. Simulate the
diffusion problem in <span class="math">\([0,L]\)</span> and compare with the solution in a).</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_symmetric_gaussian</span></code>.</p>
</div>
<div class="section" id="exercise-3-2-investigate-approximation-errors-from-a-boundary-condition">
<span id="diffu-exer-1d-ux-onesided"></span><h3>Exercise 3.2: Investigate approximation errors from a <span class="math">\(u_x=0\)</span> boundary condition<a class="headerlink" href="#exercise-3-2-investigate-approximation-errors-from-a-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>We consider the problem solved in <a class="reference internal" href="#diffu-exer-1d-gaussian-symmetric"><span class="std std-ref">Exercise 3.1: Explore symmetry in a 1D problem</span></a>
part b). The boundary condition <span class="math">\(u_x(0,t)=0\)</span> can be implemented in
two ways: 1) by a standard symmetric finite difference <span class="math">\([D_{2x}u]_i^n=0\)</span>,
or 2) by a one-sided difference <span class="math">\([D^+u=0]^n_i=0\)</span>.
Investigate the effect of these two conditions on the
convergence rate in space.</p>
<p><strong>Hint.</strong>
If you use a Forward Euler scheme, choose a discretization parameter
<span class="math">\(h=\Delta t = \Delta x^2\)</span> and assume the error goes like <span class="math">\(E\sim h^r\)</span>.
The error in the scheme is <span class="math">\({\mathcal{O}(\Delta t,\Delta x^2)}\)</span> so one should
expect that the estimated <span class="math">\(r\)</span> approaches 1. The question is if
a one-sided difference approximation to <span class="math">\(u_x(0,t)=0\)</span> destroys this
convergence rate.</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_onesided_fd</span></code>.</p>
</div>
<div class="section" id="exercise-3-3-experiment-with-open-boundary-conditions-in-1d">
<span id="diffu-exer-1d-openbc"></span><h3>Exercise 3.3: Experiment with open boundary conditions in 1D<a class="headerlink" href="#exercise-3-3-experiment-with-open-boundary-conditions-in-1d" title="Permalink to this headline">¶</a></h3>
<p>We address diffusion of a Gaussian function
as in <a class="reference internal" href="#diffu-exer-1d-gaussian-symmetric"><span class="std std-ref">Exercise 3.1: Explore symmetry in a 1D problem</span></a>,
in the domain <span class="math">\([0,L]\)</span>,
but now we shall explore different types of boundary
conditions on <span class="math">\(x=L\)</span>. In real-life problems we do not know
the exact solution on <span class="math">\(x=L\)</span> and must use something simpler.</p>
<p><strong>a)</strong>
Imagine that we want to solve the problem numerically on
<span class="math">\([0,L]\)</span>, with a symmetry boundary condition <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>,
but we do not know the exact solution and cannot of that
reason assign a correct Dirichlet condition at <span class="math">\(x=L\)</span>.
One idea is to simply set <span class="math">\(u(L,t)=0\)</span> since this will be an
accurate approximation before the diffused pulse reaches <span class="math">\(x=L\)</span>
and even thereafter it might be a satisfactory condition if the exact <span class="math">\(u\)</span> has
a small value.
Let <span class="math">\({u_{\small\mbox{e}}}\)</span> be the exact solution and let <span class="math">\(u\)</span> be the solution
of <span class="math">\(u_t={\alpha} u_{xx}\)</span> with an initial Gaussian pulse and
the boundary conditions <span class="math">\(u_x(0,t)=u(L,t)=0\)</span>. Derive a diffusion
problem for the error <span class="math">\(e={u_{\small\mbox{e}}} - u\)</span>. Solve this problem
numerically using an exact Dirichlet condition at <span class="math">\(x=L\)</span>.
Animate the evolution of the error and make a curve plot of
the error measure</p>
<div class="math">
\[E(t)=\sqrt{\frac{\int_0^L e^2dx}{\int_0^L udx}}{\thinspace .}\]</div>
<p>Is this a suitable error measure for the present problem?</p>
<p><strong>b)</strong>
Instead of using <span class="math">\(u(L,t)=0\)</span> as approximate boundary condition for
letting the diffused Gaussian pulse move out of our finite domain,
one may try <span class="math">\(u_x(L,t)=0\)</span> since the solution for large <span class="math">\(t\)</span> is
quite flat. Argue that this condition gives a completely wrong
asymptotic solution as <span class="math">\(t\rightarrow 0\)</span>. To do this,
integrate the diffusion equation from <span class="math">\(0\)</span> to <span class="math">\(L\)</span>, integrate
<span class="math">\(u_{xx}\)</span> by parts (or use Gauss&#8217; divergence theorem in 1D) to
arrive at the important property</p>
<div class="math">
\[\frac{d}{dt}\int_{0}^L u(x,t)dx = 0,\]</div>
<p>implying that <span class="math">\(\int_0^Ludx\)</span> must be constant in time, and therefore</p>
<div class="math">
\[\int_{0}^L u(x,t)dx = \int_{0}^LI(x)dx{\thinspace .}\]</div>
<p>The integral of the initial pulse is 1.</p>
<p><strong>c)</strong>
Another idea for an artificial boundary condition at <span class="math">\(x=L\)</span>
is to use a cooling law</p>
<div class="math" id="eq-diffu-pde1-gaussian-xl-cooling">
\[\tag{373}
-{\alpha} u_x = q(u - u_S),\]</div>
<p>where <span class="math">\(q\)</span> is an unknown heat transfer coefficient and <span class="math">\(u_S\)</span> is
the surrounding temperature in the medium outside of <span class="math">\([0,L]\)</span>.
(Note that arguing that <span class="math">\(u_S\)</span> is approximately <span class="math">\(u(L,t)\)</span> gives
the <span class="math">\(u_x=0\)</span> condition from the previous subexercise that is
qualitatively wrong for large <span class="math">\(t\)</span>.)
Develop a diffusion problem for the error in the solution using
<a class="reference internal" href="#eq-diffu-pde1-gaussian-xl-cooling"><span class="std std-ref">(373)</span></a> as boundary condition.
Assume one can take <span class="math">\(u_S=0\)</span> &#8220;outside the domain&#8221; since
<span class="math">\({u_{\small\mbox{e}}}\rightarrow 0\)</span> as <span class="math">\(x\rightarrow\infty\)</span>.
Find a function <span class="math">\(q=q(t)\)</span> such that the exact solution
obeys the condition <a class="reference internal" href="#eq-diffu-pde1-gaussian-xl-cooling"><span class="std std-ref">(373)</span></a>.
Test some constant values of <span class="math">\(q\)</span> and animate how the corresponding
error function behaves. Also compute <span class="math">\(E(t)\)</span> curves as defined above.</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_open_BC</span></code>.</p>
</div>
<div class="section" id="exercise-3-4-simulate-a-diffused-gaussian-peak-in-2d-3d">
<h3>Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D<a class="headerlink" href="#exercise-3-4-simulate-a-diffused-gaussian-peak-in-2d-3d" title="Permalink to this headline">¶</a></h3>
<p><strong>a)</strong>
Generalize <a class="reference internal" href="#eq-diffu-pde1-sol-gaussian"><span class="std std-ref">(353)</span></a> to multi dimensions by
assuming that one-dimensional solutions can be multiplied to solve
<span class="math">\(u_t = {\alpha}\nabla^2 u\)</span>. Set <span class="math">\(c=0\)</span> such that the peak of
the Gaussian is at the origin.</p>
<p><strong>b)</strong>
One can from the exact solution show
that <span class="math">\(u_x=0\)</span> on <span class="math">\(x=0\)</span>, <span class="math">\(u_y=0\)</span> on <span class="math">\(y=0\)</span>, and <span class="math">\(u_z=0\)</span> on <span class="math">\(z=0\)</span>.
The approximately correct condition <span class="math">\(u=0\)</span> can be set
on the remaining boundaries (say <span class="math">\(x=L\)</span>, <span class="math">\(y=L\)</span>, <span class="math">\(z=L\)</span>), cf. <a class="reference internal" href="#diffu-exer-1d-openbc"><span class="std std-ref">Exercise 3.3: Experiment with open boundary conditions in 1D</span></a>.
Simulate a 2D case and make an animation of the diffused Gaussian peak.</p>
<p><strong>c)</strong>
The formulation in b) makes use of symmetry of the solution such that we
can solve the problem in the first quadrant (2D) or octant (3D) only.
To check that the symmetry assumption is correct, formulate the problem
without symmetry in a domain <span class="math">\([-L,L]\times [L,L]\)</span> in 2D. Use <span class="math">\(u=0\)</span> as
approximately correct boundary condition. Simulate the same case as
in b), but in a four times as large domain. Make an animation and compare
it with the one in b).</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_symmetric_gaussian_2D</span></code>.</p>
</div>
<div class="section" id="exercise-3-5-examine-stability-of-a-diffusion-model-with-a-source-term">
<span id="diffu-exer-uterm"></span><h3>Exercise 3.5: Examine stability of a diffusion model with a source term<a class="headerlink" href="#exercise-3-5-examine-stability-of-a-diffusion-model-with-a-source-term" title="Permalink to this headline">¶</a></h3>
<p>Consider a diffusion equation with a linear <span class="math">\(u\)</span> term:</p>
<div class="math">
\[u_t = {\alpha} u_{xx} + \beta u{\thinspace .}\]</div>
<p><strong>a)</strong>
Derive in detail a Forward Euler scheme, a Backward Euler scheme,
and a Crank-Nicolson for this type of diffusion model.
Thereafter, formulate a <span class="math">\(\theta\)</span>-rule to summarize the three schemes.</p>
<p><strong>b)</strong>
Assume a solution like <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> and find the relation
between <span class="math">\(a\)</span>, <span class="math">\(k\)</span>, <span class="math">\({\alpha}\)</span>, and <span class="math">\(\beta\)</span>.</p>
<p><strong>Hint.</strong>
Insert <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> in the PDE problem.</p>
<p><strong>c)</strong>
Calculate the stability of the Forward Euler scheme. Design
numerical experiments to confirm the results.</p>
<p><strong>Hint.</strong>
Insert the discrete counterpart to <a class="reference internal" href="#eq-diffu-pde1-sol1"><span class="std std-ref">(354)</span></a> in the
numerical scheme. Run experiments at the stability limit and slightly above.</p>
<p><strong>d)</strong>
Repeat c) for the Backward Euler scheme.</p>
<p><strong>e)</strong>
Repeat c) for the Crank-Nicolson scheme.</p>
<p><strong>f)</strong>
How does the extra term <span class="math">\(bu\)</span> impact the accuracy of the three schemes?</p>
<p><strong>Hint.</strong>
For analysis of the accuracy,
compare the numerical and exact amplification factors, in
graphs and/or by Taylor series expansion.</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_stability_uterm</span></code>.</p>
</div>
</div>
<div class="section" id="diffusion-in-heterogeneous-media">
<span id="diffu-varcoeff"></span><h2>Diffusion in heterogeneous media<a class="headerlink" href="#diffusion-in-heterogeneous-media" title="Permalink to this headline">¶</a></h2>
<p>Diffusion in heterogeneous media normally implies a non-constant
diffusion coefficient <span class="math">\(\alpha = \alpha (x)\)</span>.
A 1D diffusion model with such a variable diffusion coefficient reads</p>
<div class="math" id="eq-diffu-pde2">
\[\tag{374}
\frac{\partial u}{\partial t} =
    \frac{\partial}{\partial x}\left( \alpha (x) \frac{\partial u}{\partial x^2}
    \right) + f(x,t), \quad x\in (0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-diffu-pde2-ic-u">
\[\tag{375}
u(x,0) = I(x), \quad  x\in [0,L],\]</div>
<div class="math" id="eq-diffu-pde2-bc-0">
\[\begin{split}\tag{376}
u(0,t)  = U_0, \quad  t&gt;0,\end{split}\]</div>
<div class="math" id="eq-diffu-pde2-bc-l">
\[\begin{split}\tag{377}
u(L,t)  = U_L, \quad  t&gt;0.\end{split}\]</div>
<p>A short form of the diffusion equation with variable coefficients is
<span class="math">\(u_t = (\alpha u_x)_x\)</span>.</p>
<div class="section" id="discretization-2">
<span id="diffu-varcoeff-discr"></span><h3>Discretization<a class="headerlink" href="#discretization-2" title="Permalink to this headline">¶</a></h3>
<p>We can discretize <a class="reference internal" href="#eq-diffu-pde2"><span class="std std-ref">(374)</span></a> by a <span class="math">\(\theta\)</span>-rule in time
and centered differences in space:</p>
<div class="math">
\[\lbrack D_t u\rbrack^{n+\frac{1}{2}} = \theta\lbrack D_x\overline{{\alpha}}^x
D_x u + f\rbrack^{n+1} +
(1-\theta)\lbrack D_x\overline{{\alpha}}^x
D_x u + f\rbrack^{n}{\thinspace .}\]</div>
<p>Written out, this becomes</p>
<div class="math">
\[\begin{split}\frac{u^{n+1}-u^{n}}{\Delta t} &amp;=
\theta\frac{1}{\Delta x^2}
({\alpha}_{i+\frac{1}{2}}(u^{n+1}_{i+1} - u^{n+1}_{i})
- {\alpha}_{i-\frac{1}{2}}(u^{n+1}_i - u^{n+1}_{i+1})) +\\
&amp;\quad (1-\theta)\frac{1}{\Delta x^2}
({\alpha}_{i+\frac{1}{2}}(u^{n}_{i+1} - u^{n}_{i})
- {\alpha}_{i-\frac{1}{2}}(u^{n}_i - u^{n}_{i+1})) +\\
&amp;\quad \theta f_i^{n+1} + (1-\theta)f_i^{n},\end{split}\]</div>
<p>where, e.g., an arithmetic mean can to be used for <span class="math">\({\alpha}_{i+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[{\alpha}_{i+\frac{1}{2}} = \frac{1}{2}({\alpha}_i + {\alpha}_{i+1}){\thinspace .}\]</div>
</div>
<div class="section" id="implementation-8">
<span id="diffu-varcoeff-impl"></span><h3>Implementation<a class="headerlink" href="#implementation-8" title="Permalink to this headline">¶</a></h3>
<p>Suitable code for solving the discrete equations is very similar to
what we created for a constant <span class="math">\({\alpha}\)</span>.
Since the Fourier number has no meaning for varying
<span class="math">\({\alpha}\)</span>, we introduce a related parameter <span class="math">\(D=\Delta t /\Delta x^2\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_theta</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">u_L</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">u_R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in space</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in time</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># solution array at t[n+1]</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># solution at t[n]</span>

    <span class="n">Dl</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">theta</span>
    <span class="n">Dr</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span>

    <span class="c"># Representation of sparse matrix and right-hand side</span>
    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lower</span>    <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">upper</span>    <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">b</span>        <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Precompute sparse matrix (scipy format)</span>
    <span class="n">diagonal</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Dl</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">lower</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Dl</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">upper</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="o">=</span> <span class="o">-</span><span class="n">Dl</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c"># Insert boundary conditions</span>
    <span class="n">diagonal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">upper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">diagonal</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">lower</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
        <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">],</span>
        <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)</span>

    <span class="c"># Set initial condition</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c"># Time loop</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Dr</span><span class="o">*</span><span class="p">(</span>
            <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
            <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
        <span class="c"># Boundary conditions</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">u_L</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_R</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="c"># Solve</span>
        <span class="n">u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Switch variables before next step</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
<p>The code is found in the file <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu1D_vc.py">diffu1D_vc.py</a>.</p>
</div>
<div class="section" id="stationary-solution">
<span id="diffu-varcoeff-stationary"></span><h3>Stationary solution<a class="headerlink" href="#stationary-solution" title="Permalink to this headline">¶</a></h3>
<p>As <span class="math">\(t\rightarrow\infty\)</span>, the solution of the
problem <a class="reference internal" href="#eq-diffu-pde2"><span class="std std-ref">(374)</span></a>-<a class="reference internal" href="#eq-diffu-pde2-bc-l"><span class="std std-ref">(377)</span></a>
will approach
a stationary limit where <span class="math">\(\partial u/\partial t=0\)</span>. The governing
equation is then</p>
<div class="math" id="eq-diffu-fd2-pde-st">
\[\tag{378}
\frac{d}{dx}\left(\alpha\frac{du}{dx}\right) =0,\]</div>
<p>with boundary conditions <span class="math">\(u(0)=U_0\)</span> and <span class="math">\(u(L)=u_L\)</span>.
It is possible to obtain an exact solution of <a class="reference internal" href="#eq-diffu-fd2-pde-st"><span class="std std-ref">(378)</span></a>
for any <span class="math">\(\alpha\)</span>. Integrating twice and applying the boundary conditions
to determine the integration constants gives</p>
<div class="math" id="eq-diffu-fd2-pde-st-sol">
\[\tag{379}
u(x) = U_0 + (U_L-U_0)\frac{\int_0^x (\alpha(\xi))^{-1}d\xi}{\int_0^L (\alpha(\xi))^{-1}d\xi}
    {\thinspace .}\]</div>
</div>
<div class="section" id="piecewise-constant-medium">
<span id="diffu-varcoeff-piecewise"></span><h3>Piecewise constant medium<a class="headerlink" href="#piecewise-constant-medium" title="Permalink to this headline">¶</a></h3>
<p>Consider a medium built of <span class="math">\(M\)</span> layers. The boundaries between the
layers are denoted by <span class="math">\(b_0, \ldots, b_M\)</span>,
where <span class="math">\(b_0=0\)</span> and <span class="math">\(b_M=L\)</span>.
If the material in each layer potentially differs from the others, but
is otherwise constant, we can express <span class="math">\(\alpha\)</span> as a
<em>piecewise constant function</em> according to</p>
<div class="math" id="eq-diffu-fd2-pde-st-pc-alpha">
\[\begin{split}\tag{380}
\alpha (x) = \left\lbrace\begin{array}{ll}
    \alpha_0,&amp; b_0 \leq x &lt; b_1,\\
    \vdots &amp;\\
    \alpha_i,&amp; b_i \leq x &lt; b_{i+1},\\
    \vdots &amp;\\
    \alpha_0,&amp; b_{M-1} \leq x \leq b_M.
    \end{array}\right.\end{split}\]</div>
<p>The exact solution <a class="reference internal" href="#eq-diffu-fd2-pde-st-sol"><span class="std std-ref">(379)</span></a> in case of such a
piecewise constant <span class="math">\(\alpha\)</span> function is easy to derive. Assume that
<span class="math">\(x\)</span> is in the <span class="math">\(m\)</span>-th layer: <span class="math">\(x\in [b_m, b_{m+1}]\)</span>. In the integral
<span class="math">\(\int_0^x (a(\xi))^{-1}d\xi\)</span> we must integrate through the first
<span class="math">\(m-1\)</span> layers and then add the contribution from the remaining part
<span class="math">\(x-b_m\)</span> into the <span class="math">\(m\)</span>-th layer:</p>
<div class="math" id="eq-diffu-fd2-pde-st-sol-pc">
\[\tag{381}
u(x) = U_0 + (U_L-U_0)
    \frac{\sum_{j=0}^{m-1} (b_{j+1}-b_j)/\alpha(b_j) + (x-b_m)/\alpha(b_m)}{\sum_{j=0}^{M-1} (b_{j+1}-b_j)/\alpha(b_j)}\]</div>
<p><strong>Remark.</strong>
It may sound strange to have a discontinuous <span class="math">\(\alpha\)</span> in a differential
equation where one is to differentiate, but a discontinuous <span class="math">\(\alpha\)</span>
is compensated by a discontinuous <span class="math">\(u_x\)</span> such that <span class="math">\(\alpha u_x\)</span> is
continuous and therefore can be differentiated as <span class="math">\((\alpha u_x)_x\)</span>.</p>
</div>
<div class="section" id="implementation-of-diffusion-in-a-piecewise-constant-medium">
<span id="diffu-varcoeff-impl-piecewise"></span><h3>Implementation of diffusion in a piecewise constant medium<a class="headerlink" href="#implementation-of-diffusion-in-a-piecewise-constant-medium" title="Permalink to this headline">¶</a></h3>
<p>Programming with piecewise function definition quickly becomes
cumbersome as the most naive approach is to test for which interval
<span class="math">\(x\)</span> lies, and then start evaluating a formula like
<a class="reference internal" href="#eq-diffu-fd2-pde-st-sol-pc"><span class="std std-ref">(381)</span></a>. In Python, vectorized expressions may
help to speed up the computations.
The convenience classes <code class="docutils literal"><span class="pre">PiecewiseConstant</span></code> and
<code class="docutils literal"><span class="pre">IntegratedPiecewiseConstant</span></code> in the <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/Heaviside.py">Heaviside</a>
module were made to simplify programming with
functions like <a class="reference internal" href="#eq-diffu-fd2-pde-st-pc-alpha"><span class="std std-ref">(380)</span></a> and expressions like
<a class="reference internal" href="#eq-diffu-fd2-pde-st-sol-pc"><span class="std std-ref">(381)</span></a>. These utilities not only represent
piecewise constant functions, but also <em>smoothed</em> versions of them
where the discontinuities can be smoothed out in a controlled fashion.
This is advantageous in many computational contexts (although seldom
for pure finite difference computations of the solution <span class="math">\(u\)</span>).</p>
<p>The <code class="docutils literal"><span class="pre">PiecewiseConstant</span></code> class is created by sending in the domain as a
2-tuple or 2-list and a <code class="docutils literal"><span class="pre">data</span></code> object describing the boundaries
<span class="math">\(b_0,\ldots,b_M\)</span> and the corresponding function values
<span class="math">\(\alpha_0,\ldots,\alpha_{M-1}\)</span>. More precisely, <code class="docutils literal"><span class="pre">data</span></code> is a nested
list, where <code class="docutils literal"><span class="pre">data[i][0]</span></code> holds <span class="math">\(b_i\)</span> and <code class="docutils literal"><span class="pre">data[i][1]</span></code> holds the
corresponding value <span class="math">\(\alpha_i\)</span>, for <span class="math">\(i=0,\ldots,M-1\)</span>. Given <span class="math">\(b_i\)</span> and
<span class="math">\(\alpha_i\)</span> in arrays <code class="docutils literal"><span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">a</span></code>, it is easy to fill out the nested
list <code class="docutils literal"><span class="pre">data</span></code>.</p>
<p>In our application, we want to represent <span class="math">\(\alpha\)</span> and <span class="math">\(1/\alpha\)</span>
as piecewise constant function, in addition to the <span class="math">\(u(x)\)</span> function
which involves the integrals of <span class="math">\(1/\alpha\)</span>. A class creating the
functions we need and a method for evaluating <span class="math">\(u\)</span>, can take the
form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SerialLayers</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    b: coordinates of boundaries of layers, b[0] is left boundary</span>
<span class="sd">    and b[-1] is right boundary of the domain [0,L].</span>
<span class="sd">    a: values of the functions in each layer (len(a) = len(b)-1).</span>
<span class="sd">    U_0: u(x) value at left boundary x=0=b[0].</span>
<span class="sd">    U_L: u(x) value at right boundary x=L=b[0].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>  <span class="c"># smoothing parameter for smoothed a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">U_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_L</span> <span class="o">=</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span>

        <span class="n">a_data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bi</span><span class="p">,</span> <span class="n">ai</span><span class="p">]</span> <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)]</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_func</span> <span class="o">=</span> <span class="n">PiecewiseConstant</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">a_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

        <span class="c"># inv_a = 1/a is needed in formulas</span>
        <span class="n">inv_a_data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bi</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">ai</span><span class="p">]</span> <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_a_func</span> <span class="o">=</span> \
             <span class="n">PiecewiseConstant</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">inv_a_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_of_inv_a_func</span> <span class="o">=</span> \
             <span class="n">IntegratedPiecewiseConstant</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">inv_a_data</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="c"># Denominator in the exact formula is constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_a_0L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_of_inv_a_func</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U_0</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U_L</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">U_0</span><span class="p">)</span><span class="o">*</span>\
                   <span class="bp">self</span><span class="o">.</span><span class="n">integral_of_inv_a_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_a_0L</span>
        <span class="k">return</span> <span class="n">solution</span>
</pre></div>
</div>
<p>A visualization method is also convenient to have. Below we plot <span class="math">\(u(x)\)</span>
along with <span class="math">\(\alpha (x)\)</span> (which works well as long as <span class="math">\(\max \alpha(x)\)</span>
is of the same size as <span class="math">\(\max u = \max(U_0,U_L)\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SerialLayers</span><span class="p">:</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_func</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y_a</span><span class="p">)</span>
        <span class="n">y_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_exact</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_u</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>  <span class="c"># Matlab style</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_a</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">y_u</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">y_a</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s">&#39;solution $u$&#39;</span><span class="p">,</span> <span class="s">&#39;coefficient $a$&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Smoothing eps: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#diffu-fd2-pde-st-sol-pc-fig1"><span class="std std-ref">Solution of the stationary diffusion equation corresponding to a piecewise constant diffusion coefficient</span></a> shows the case where</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>   <span class="c"># material boundaries</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>       <span class="c"># material values</span>
<span class="n">U_0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>  <span class="n">U_L</span> <span class="o">=</span> <span class="mi">5</span>     <span class="c"># boundary conditions</span>
</pre></div>
</div>
<div class="figure" id="id19">
<span id="diffu-fd2-pde-st-sol-pc-fig1"></span><a class="reference internal image-reference" href="_images/flow_in_layers_case1.png"><img alt="_images/flow_in_layers_case1.png" src="_images/flow_in_layers_case1.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Solution of the stationary diffusion equation corresponding to a piecewise constant diffusion coefficient</em></span></p>
</div>
<p>By adding the <code class="docutils literal"><span class="pre">eps</span></code> parameter to the constructor of the <code class="docutils literal"><span class="pre">SerialLayers</span></code>
class, we can experiment with smoothed versions of <span class="math">\(\alpha\)</span> and see
the (small) impact on <span class="math">\(u\)</span>. Figure <a class="reference internal" href="#diffu-fd2-pde-st-sol-pc-fig2"><span class="std std-ref">Solution of the stationary diffusion equation corresponding to a smoothed piecewise constant diffusion coefficient</span></a>
shows the result.</p>
<div class="figure" id="id20">
<span id="diffu-fd2-pde-st-sol-pc-fig2"></span><a class="reference internal image-reference" href="_images/flow_in_layers_case1_eps.png"><img alt="_images/flow_in_layers_case1_eps.png" src="_images/flow_in_layers_case1_eps.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text">Solution of the stationary diffusion equation corresponding to a <em>smoothed</em> piecewise constant diffusion coefficient</span></p>
</div>
</div>
<div class="section" id="diffusion-equation-in-axi-symmetric-geometries">
<span id="diffu-fd2-radial"></span><h3>Diffusion equation in axi-symmetric geometries<a class="headerlink" href="#diffusion-equation-in-axi-symmetric-geometries" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a diffusion process taking care in a straight tube
with radius <span class="math">\(R\)</span>. We assume axi-symmetry such that <span class="math">\(u\)</span> is just a
function of <span class="math">\(r\)</span> and <span class="math">\(t\)</span>. A model problem is</p>
<div class="math" id="eq-diffu-fd2-radial-pde">
\[\tag{382}
\frac{\partial u}{\partial t} = \frac{1}{r}\frac{\partial}{\partial r}
    \left(r{\alpha}(r)\frac{\partial u}{\partial r}\right) + f(t),  r\in (0,R),\ t\in (0,T],\]</div>
<div class="math" id="eq-diffu-fd2-radial-symmr0">
\[\tag{383}
\frac{\partial u}{\partial r}(0,t) = 0,  t\in (0,T],\]</div>
<div class="math" id="eq-diffu-fd2-radial-ur">
\[\tag{384}
u(R,t) = 0,  t\in (0,T],\]</div>
<div class="math" id="eq-diffu-fd2-radial-initial">
\[\tag{385}
u(r,0) = I(r),  r\in [0,R].\]</div>
<p>The condition <a class="reference internal" href="#eq-diffu-fd2-radial-symmr0"><span class="std std-ref">(383)</span></a> is a necessary symmetry condition
at <span class="math">\(r=0\)</span>, while <a class="reference internal" href="#eq-diffu-fd2-radial-ur"><span class="std std-ref">(384)</span></a> could be any Dirichlet
or Neumann condition (or Robin condition in case of cooling or heating).</p>
<p>The finite difference approximation at <span class="math">\(r=0\)</span> of the spatial derivative term
is the only new challenge in this problem. Let us in case of
constant <span class="math">\({\alpha}\)</span> expand the derivative to</p>
<div class="math">
\[\frac{\partial^2 u}{\partial r^2} + \frac{1}{r}\frac{\partial u}{\partial r}{\thinspace .}\]</div>
<p>The last term faces a difficulty at <span class="math">\(r=0\)</span> since it becomes a <span class="math">\(0/0\)</span> expression
because of the symmetry condition.
L&#8217;Hosptial&#8217;s rule can be used:</p>
<div class="math">
\[\lim_{r\rightarrow 0} \frac{1}{r}\frac{\partial u}{\partial r}
= \lim_{r\rightarrow 0} \frac{\partial^2 u}{\partial r^2}{\thinspace .}\]</div>
<p>The PDE at <span class="math">\(r=0\)</span> therefore becomes</p>
<div class="math" id="eq-auto153">
\[\tag{386}
\frac{\partial u}{\partial t} = 2{\alpha}\frac{\partial^2 u}{\partial r^2}
    + f(t){\thinspace .}\]</div>
<p>For a variable coefficient <span class="math">\({\alpha}(r)\)</span> the expanded derivative reads</p>
<div class="math">
\[{\alpha}(r)\frac{\partial^2 u}{\partial r^2} +
\frac{1}{r}({\alpha}(r) + r{\alpha}'(r))\frac{\partial u}{\partial r}{\thinspace .}\]</div>
<p>We have that the <a class="reference external" href="https://en.wikibooks.org/wiki/Calculus/Proofs_of_Some_Basic_Limit_Rules">limit of a product</a> is</p>
<div class="math">
\[\lim_{r\rightarrow 0}
\frac{1}{r}({\alpha}(r) + r{\alpha}'(r))\frac{\partial u}{\partial r} =
\lim_{r\rightarrow 0} ({\alpha}(r) + r{\alpha}'(r))\
\lim_{x\rightarrow c}
\frac{1}{r}\frac{\partial u}{\partial r}{\thinspace .}\]</div>
<p>The second limit becomes as above, so the PDE at <span class="math">\(r=0\)</span>,
assuming <span class="math">\(({\alpha}(0) + r{\alpha}'(0))\neq 0\)</span>,
looks like</p>
<div class="math" id="eq-auto154">
\[\tag{387}
\frac{\partial u}{\partial t} = (2{\alpha} + r{\alpha}')
    \frac{\partial^2 u}{\partial r^2}
    + f(t){\thinspace .}\]</div>
<p>The second-order derivative is discretized in the usual way.
Consider first constant <span class="math">\({\alpha}\)</span>:</p>
<div class="math">
\[2{\alpha}\frac{\partial^2}{\partial r^2}u(r_0,t_n) \approx
[2{\alpha} 2D_rD_r u]^n_0 =
2{\alpha} \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}{\thinspace .}\]</div>
<p>The fictitious value <span class="math">\(u^n_{-1}\)</span> can be eliminated using the discrete
symmetry condition</p>
<div class="math">
\[[D_{2r} u =0]^n_0 \quad\Rightarrow\quad u^n_{-1} = u^n_1,\]</div>
<p>which then gives the modified approximation to the second-order derivative
of <span class="math">\(u\)</span> in <span class="math">\(r\)</span> at <span class="math">\(r=0\)</span>:</p>
<div class="math" id="eq-auto155">
\[\tag{388}
4{\alpha} \frac{u^{n}_{1} - u^{n}_0}{\Delta r^2}{\thinspace .}\]</div>
<p>With variable <span class="math">\({\alpha}\)</span> we simply get</p>
<div class="math">
\[(2{\alpha} + r{\alpha}')2D_rD_r u]^n_0 =
(2{\alpha}(0) + r{\alpha}'(0)) \frac{u^{n}_{1} - 2u^{n}_0 + u^n_{-1}}{\Delta r^2}{\thinspace .}\]</div>
<p>The discretization of the second-order derivative in <span class="math">\(r\)</span> at another
internal mesh point is straightforward:</p>
<div class="math">
\[\left.\frac{1}{r}\frac{\partial}{\partial r}
\left(r{\alpha}\frac{\partial u}{\partial r}\right)\right\vert_{r=r_i}^{t=t_n}
\approx [r^{-1} D_r (r {\alpha} D_r u)]_i^n
= \frac{1}{\Delta r^2}\left(
r_{i+\frac{1}{2}}{\alpha}_{i+\frac{1}{2}}(u_{i+1}^n - u_i^n) - r_{i-\frac{1}{2}}{\alpha}_{i-\frac{1}{2}}(u_{i}^n - u_{i-1}^n)\right){\thinspace .}\]</div>
<p><span class="math">\(\theta\)</span>-rule in time...</p>
</div>
<div class="section" id="diffusion-equation-in-spherically-symmetric-geometries">
<span id="diffu-fd2-spherical"></span><h3>Diffusion equation in spherically-symmetric geometries<a class="headerlink" href="#diffusion-equation-in-spherically-symmetric-geometries" title="Permalink to this headline">¶</a></h3>
<div class="section" id="discretization-in-spherical-coordinates">
<h4>Discretization in spherical coordinates<a class="headerlink" href="#discretization-in-spherical-coordinates" title="Permalink to this headline">¶</a></h4>
<p>Let us now pose the problem from the section <a class="reference internal" href="#diffu-fd2-radial"><span class="std std-ref">Diffusion equation in axi-symmetric geometries</span></a>
in spherical coordinates, where <span class="math">\(u\)</span> only depends on the radial coordinate
<span class="math">\(r\)</span> and time <span class="math">\(t\)</span>. That is, we have spherical symmetry.
For simplicity we restrict the diffusion coefficient <span class="math">\({\alpha}\)</span> to be
a constant. The PDE reads</p>
<div class="math" id="eq-auto156">
\[\tag{389}
\frac{\partial u}{\partial t} = \frac{{\alpha}}{r^\gamma}\frac{\partial}{\partial r}
    \left(r^\gamma\frac{\partial u}{\partial r}\right) + f(t),\]</div>
<p>for <span class="math">\(r\in (0,R)\)</span> and <span class="math">\(t\in (0,T]\)</span>. The parameter <span class="math">\(\gamma\)</span> is 2 for
spherically-symmetric problems and 1 for axi-symmetric problems.
The boundary and initial conditions
have the same mathematical form as
in <a class="reference internal" href="#eq-diffu-fd2-radial-pde"><span class="std std-ref">(382)</span></a>-<a class="reference internal" href="#eq-diffu-fd2-radial-initial"><span class="std std-ref">(385)</span></a>.</p>
<p>Since the PDE in spherical coordinates has the same form as the PDE
in the section <a class="reference internal" href="#diffu-fd2-radial"><span class="std std-ref">Diffusion equation in axi-symmetric geometries</span></a>, just with the <span class="math">\(\gamma\)</span> parameter
being different, we can use the same discretization approach.
At the origin <span class="math">\(r=0\)</span> we get problems with the term</p>
<div class="math">
\[\frac{\gamma}{r}\frac{\partial u}{\partial t},\]</div>
<p>but L&#8217;Hosptial&#8217;s rule shows that this term equals <span class="math">\(\gamma\partial^2 u/
\partial r^2\)</span>, and the PDE at <span class="math">\(r=0\)</span> becomes</p>
<div class="math" id="eq-auto157">
\[\tag{390}
\frac{\partial u}{\partial t} = (\gamma+1){\alpha}\frac{\partial^2 u}{\partial r^2}
    + f(t){\thinspace .}\]</div>
<p>The associated discrete form is then</p>
<div class="math" id="eq-auto158">
\[\tag{391}
[D_t u = \frac{1}{2} (\gamma+1){\alpha}([D_rD_r \overline{u}^t + \overline{f}^t]^n_i,\]</div>
<p>for a Crank-Nicolson scheme.</p>
</div>
<div class="section" id="discretization-in-cartesian-coordinates">
<h4>Discretization in Cartesian coordinates<a class="headerlink" href="#discretization-in-cartesian-coordinates" title="Permalink to this headline">¶</a></h4>
<p>The spherically-symmetric spatial derivative can be transformed to
the Cartesian counterpart by introducing</p>
<div class="math">
\[v(r,t) = ru(r,t){\thinspace .}\]</div>
<p>Inserting <span class="math">\(u=v/r\)</span> in the PDE yields</p>
<div class="math">
\[\frac{1}{r^2}\frac{\partial}{\partial r}
\left({\alpha}(r)r^2\frac{\partial u}{\partial r}\right),\]</div>
<p>and then</p>
<div class="math">
\[r\left(\frac{d c^2}{dr}\frac{\partial v}{\partial r} +
{\alpha}\frac{\partial^2 v}{\partial r^2}\right) - \frac{d c^2}{dr}v
{\thinspace .}\]</div>
<p>The two terms in the parenthesis can be combined to</p>
<div class="math">
\[r\frac{\partial}{\partial r}\left( {\alpha}\frac{\partial v}{\partial r}\right),\]</div>
<p>which is recognized as the variable-coefficient Laplace operator in
one Cartesian coordinate.</p>
</div>
</div>
</div>
<div class="section" id="diffusion-in-2d">
<span id="diffu-2d"></span><h2>Diffusion in 2D<a class="headerlink" href="#diffusion-in-2d" title="Permalink to this headline">¶</a></h2>
<p>We now address a diffusion in two space dimensions:</p>
<div class="math" id="eq-auto159">
\[\tag{392}
\frac{\partial u}{\partial t}  = {\alpha}\left(
    \frac{\partial^2 u}{\partial x^2} +
    \frac{\partial^2 u}{\partial x^2}\right) + f(x,y),\]</div>
<p>in a domain</p>
<div class="math">
\[(x,y)\in (0,L_x)\times (0,L_y),\ t\in (0,T],\]</div>
<p>with <span class="math">\(u=0\)</span> on the boundary and <span class="math">\(u(x,y,0)=I(x,y)\)</span> as initial condition.</p>
<div class="section" id="discretization-3">
<span id="diffu-2d-discr"></span><h3>Discretization<a class="headerlink" href="#discretization-3" title="Permalink to this headline">¶</a></h3>
<p>For generality, it is natural to use a <span class="math">\(\theta\)</span>-rule for the time
discretization. Standard, second-order accurate finite differences are
used for the spatial derivatives. We sample the PDE at a space-time
point <span class="math">\((i,j,n+\frac{1}{2})\)</span> and apply the difference approximations:</p>
<div class="math">
\[\lbrack D_t u\rbrack^{n+\frac{1}{2}} =
\theta \lbrack {\alpha} (D_xD_x u + D_yD_yu) + f\rbrack^{n+1} + \nonumber\]</div>
<div class="math" id="eq-auto160">
\[\tag{393}
\quad (1-\theta)\lbrack {\alpha} (D_xD_x u + D_yD_y u) + f\rbrack^{n}{\thinspace .}\]</div>
<p>Written out,</p>
<div class="math">
\[\frac{u^{n+1}_{i,j}-u^n_{i,j}}{\Delta t} =
\theta ({\alpha}
(\frac{u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i+1,j}}{\Delta x^2}) +
(\frac{u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1}}{\Delta y^2})) +
f^{n+1}_{i,j})
+ \nonumber\]</div>
<div class="math" id="eq-auto161">
\[\tag{394}
\quad (1-\theta)({\alpha}
    (\frac{u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i+1,j}}{\Delta x^2}) +
    (\frac{u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1}}{\Delta y^2})) +
    + f^{n}_{i,j})\]</div>
<p>We collect the unknowns on the left-hand side</p>
<div class="math">
\[ u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= u^n_{i,j} + \nonumber\]</div>
<div class="math">
\[\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \nonumber\]</div>
<div class="math" id="eq-diffu-2d-theta-scheme2">
\[\tag{395}
\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j},\]</div>
<p>where</p>
<div class="math">
\[F_x = \frac{{\alpha}\Delta t}{\Delta x^2},\quad F_y = \frac{{\alpha}\Delta t}{\Delta y^2},\]</div>
<p>are the Fourier numbers in <span class="math">\(x\)</span> and <span class="math">\(y\)</span> direction, respectively.</p>
<div class="figure" id="id21">
<span id="diffu-2d-fig-mesh3x2"></span><a class="reference internal image-reference" href="_images/mesh3x2.png"><img alt="_images/mesh3x2.png" src="_images/mesh3x2.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>3x2 2D mesh</em></span></p>
</div>
</div>
<div class="section" id="numbering-of-mesh-points-versus-equations-and-unknowns">
<span id="diffu-2d-numbering"></span><h3>Numbering of mesh points versus equations and unknowns<a class="headerlink" href="#numbering-of-mesh-points-versus-equations-and-unknowns" title="Permalink to this headline">¶</a></h3>
<p>The equations <a class="reference internal" href="#eq-diffu-2d-theta-scheme2"><span class="std std-ref">(395)</span></a> are coupled at the new
time level <span class="math">\(n+1\)</span>. That is, we must solve a system of (linear) algebraic
equations, which we will write as <span class="math">\(Ac=b\)</span>, where <span class="math">\(A\)</span> is the coefficient
matrix, <span class="math">\(c\)</span> is the vector of unknowns, and <span class="math">\(b\)</span> is the right-hand side.</p>
<p>Let us examine the equations in <span class="math">\(Ac=b\)</span> on a mesh with <span class="math">\(N_x=3\)</span> and
<span class="math">\(N_y=2\)</span> cells in each direction.  The spatial mesh is depicted in
Figure <a class="reference internal" href="#diffu-2d-fig-mesh3x2"><span class="std std-ref">3x2 2D mesh</span></a>.  The equations at the boundary just
implement the boundary condition <span class="math">\(u=0\)</span>:</p>
<div class="math">
\[u^{n+1}_{0,0}=
u^{n+1}_{1,0}=
u^{n+1}_{2,0}=
u^{n+1}_{3,0}=
u^{n+1}_{0,1}=
u^{n+1}_{3,1}=
u^{n+1}_{0,2}=
u^{n+1}_{1,2}=
u^{n+1}_{2,2}=
u^{n+1}_{3,2}= 0{\thinspace .}\]</div>
<p>We are left with two interior points, with <span class="math">\(i=1\)</span>, <span class="math">\(j=1\)</span> and <span class="math">\(i=2\)</span>, <span class="math">\(j=1\)</span>.
The corresponding equations are</p>
<div class="math">
\[\begin{split}&amp; u^{n+1}_{i,j} -
\theta\left(
F_x
(u^{n+1}_{i-1,j} - 2^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= u^n_{i,j} + \\
&amp;\qquad
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\
&amp;\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j},\end{split}\]</div>
<p>There are in total 12 unknowns <span class="math">\(u^{n+1}_{i,j}\)</span> for <span class="math">\(i=0,1,2,3\)</span> and
<span class="math">\(j=0,1,2\)</span>.  To solve the equations, we need to form a matrix system <span class="math">\(Ac=b\)</span>.
In that system, the solution vector <span class="math">\(c\)</span> can only one index. Thus,
we need a numbering of the unknowns with one
index, not two as used in the mesh. We introduce a mapping <span class="math">\(m(i,j)\)</span>
from a mesh point with indices <span class="math">\((i,j)\)</span> to the corresponding unknown
<span class="math">\(p\)</span> in the equation system:</p>
<div class="math">
\[p = m(i,j) = j(N_x+1) + i{\thinspace .}\]</div>
<p>When <span class="math">\(i\)</span> and <span class="math">\(j\)</span> runs through their values we see the following mapping
to <span class="math">\(p\)</span>:</p>
<div class="math">
\[\begin{split}&amp;(0,0)\rightarrow 0,\
(0,1)\rightarrow 1,\
(0,2)\rightarrow 2,\
(0,3)\rightarrow 3,\\
&amp;(1,0)\rightarrow 4,\
(1,1)\rightarrow 5,\
(1,2)\rightarrow 6,\
(1,3)\rightarrow 7,\\
&amp;(2,0)\rightarrow 8,\
(2,1)\rightarrow 9,\
(2,2)\rightarrow 10,\
(2,3)\rightarrow 11{\thinspace .}\end{split}\]</div>
<p>That is, we number the points along the <span class="math">\(x\)</span> axis, starting with <span class="math">\(y=0\)</span>,
and the progress one horizontal mesh line at a time.
In Figure <a class="reference internal" href="#diffu-2d-fig-mesh3x2"><span class="std std-ref">3x2 2D mesh</span></a> you can see that the <span class="math">\((i,j)\)</span> and the
corresponding single index (<span class="math">\(p\)</span>) are listed for each mesh point.</p>
<p>We could equally well numbered the equations in other ways, e.g.,
let the <span class="math">\(j\)</span> index be the fastest varying index:
<span class="math">\(p = m(i,j) = i(N_y+1) + j\)</span>.</p>
<p>Let us form the coefficient matrix <span class="math">\(A\)</span>, or more precisely, insert
matrix element (according Python&#8217;s convention with zero as base
index) for each of the nonzero elements in <span class="math">\(A\)</span> (the indices
run through the values of <span class="math">\(p\)</span>, i.e., <span class="math">\(p=0,\ldots,11\)</span>):</p>
<div class="math">
\[\begin{split}{\tiny
\left(\begin{array}{cccccccccccc}
(0,0) &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp; (1,1) &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp; (2,2) &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp; (3,3) &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp; (4,4) &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp; (5,1) &amp;   0   &amp;   0   &amp; (5,4) &amp; (5,5) &amp; (5,6) &amp;   0   &amp;   0   &amp; (5,9) &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp; (6,2) &amp;   0   &amp;   0   &amp; (6,5) &amp; (6,6) &amp; (6,7) &amp;   0   &amp;   0   &amp; (6,10) &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; (7,7) &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; (8,8) &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; (9,9) &amp;   0    &amp;   0    \\
   0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp; (10,10) &amp;    0    \\
   0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0    &amp; (11,11) \\
\end{array}\right)
}\end{split}\]</div>
<p>Here is a more compact visualization of the coefficient matrix where we
insert dots for zeros and bullets for non-zero elements:</p>
<div class="math">
\[\begin{split}\footnotesize
\left(\begin{array}{cccccccccccc}
\bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet \\
\end{array}\right)\end{split}\]</div>
<p>It is clearly seen that most of the elements are zero. This is a general
feature of coefficient matrices arising from discretizing PDEs by
finite difference methods. We say that the matrix is <em>sparse</em>.</p>
<p id="index-7">Let <span class="math">\(A_{p,q}\)</span> be the value of element <span class="math">\((p,q)\)</span> in the coefficient matrix <span class="math">\(A\)</span>,
where <span class="math">\(p\)</span> and <span class="math">\(q\)</span> now correspond to the numbering of the unknowns in the
equation system.
We have <span class="math">\(A_{p,q}=1\)</span> for <span class="math">\(p=q=0,1,2,3,4,7,8,9,10,11\)</span>, corresponding
to all the known boundary values. Let <span class="math">\(p\)</span> be <span class="math">\(m(i,j)\)</span>, i.e.,
the single index corresponding to mesh point <span class="math">\((i,j)\)</span>. Then we have</p>
<div class="math" id="eq-auto162">
\[\tag{396}
A_{m(i,j),m(i,j)} = A_{p,p} =
    1 +
    \theta (F_x + F_y),\]</div>
<div class="math" id="eq-auto163">
\[\tag{397}
A_{p, m(i-1,j)} = A_{p,p-1} = -\theta F_x,\]</div>
<div class="math" id="eq-auto164">
\[\tag{398}
A_{p, m(i+1,j)} = A_{p,p+1} = -\theta F_x,\]</div>
<div class="math" id="eq-auto165">
\[\tag{399}
A_{p, m(i,j-1)} = A_{p, p-(N_x+1)} = -\theta F_y,\]</div>
<div class="math" id="eq-auto166">
\[\tag{400}
A_{p, m(i,j+1)} = A_{p, p+(N_x+1)} = -\theta F_y,\]</div>
<div class="math" id="eq-auto167">
\[\tag{401}
for the equations associated with the two interior mesh points.\]</div>
<p>At these interior points, the single index <span class="math">\(p\)</span> takes on the
specific values <span class="math">\(p=5,6\)</span>, corresponding to the
values <span class="math">\((1,1)\)</span> and <span class="math">\((1,2)\)</span> of the pair <span class="math">\((i,j)\)</span>.</p>
<p>The above values for <span class="math">\(A_{p,q}\)</span> can be inserted in the matrix:</p>
<div class="math">
\[\begin{split}{\tiny
\left(\begin{array}{cccccccccccc}
1 &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp; 1 &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp; 1 &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp; 1 &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp; 1 &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp; -\theta F_y &amp;   0   &amp;   0   &amp; -\theta F_x &amp; 1+2\theta F_x &amp; -\theta F_x &amp;   0   &amp;   0   &amp; -\theta F_y &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp; -\theta F_y &amp;   0   &amp;   0   &amp; -\theta F_x &amp; 1+2\theta F_x &amp; -\theta F_x &amp;   0   &amp;   0   &amp; -\theta F_y &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; 1 &amp;   0   &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; 1 &amp;   0   &amp;   0    &amp;   0    \\
  0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp;   0   &amp; 1 &amp;   0    &amp;   0    \\
   0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp; 1 &amp;    0    \\
   0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0   &amp;    0    &amp; 1 \\
\end{array}\right)
}\end{split}\]</div>
<p>The corresponding right-hand side vector in the equation system has
the entries <span class="math">\(b_p\)</span>, where <span class="math">\(p\)</span> numbers the equations. We have</p>
<div class="math">
\[b_0=b_1=b_2=b_3=b_4=b_7=b_8=b_9=b_{10}=b_{11}=0,\]</div>
<p>for the boundary values. For the equations associated with the
interior points, we get for <span class="math">\(p=5,6\)</span>, corresponding to <span class="math">\(i=1,2\)</span> and <span class="math">\(j=1\)</span>:</p>
<div class="math">
\[\begin{split}b_p &amp;= u_i +
(1-\theta)\left(
F_x
(u^{n}_{i-1,j} - 2^{n}_{i,j} + u^{n}_{i,j}) +
F_y
(u^{n}_{i,j-1} - 2^{n}_{i,j} + u^{n}_{i,j+1})\right) + \\
&amp;\qquad \theta \Delta t f^{n+1}_{i,j} + (1-\theta) \Delta t f^{n}_{i,j}{\thinspace .}\end{split}\]</div>
<p>Recall that <span class="math">\(p=m(i,j)=j(N_x+1)+j\)</span> in this expression.</p>
<p>We can, as an alternative, leave the boundary mesh points out of the
matrix system. For a mesh with <span class="math">\(N_x=3\)</span> and <span class="math">\(N_y=2\)</span> there are only two
internal mesh points whose unknowns will enter the matrix system.
We must now number the unknowns at the interior points:</p>
<div class="math">
\[p = (j-1)(N_x-1) + i,\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span>, <span class="math">\(j=1,\ldots,N_y-1\)</span>.</p>
<p>[<strong>hpl 14</strong>: Fill in details.]</p>
<div class="figure" id="id22">
<span id="diffu-2d-fig-mesh4x3"></span><a class="reference internal image-reference" href="_images/mesh4x3.png"><img alt="_images/mesh4x3.png" src="_images/mesh4x3.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><em>4x3 2D mesh</em></span></p>
</div>
<p>We can continue with illustrating a bit larger mesh, <span class="math">\(N_x=4\)</span> and <span class="math">\(N_y=3\)</span>,
see Figure <a class="reference internal" href="#diffu-2d-fig-mesh4x3"><span class="std std-ref">4x3 2D mesh</span></a>. The corresponding coefficient matrix
with dots for zeros and bullets for non-zeroes look as follows (values at boundary points are included in the equation system):</p>
<div class="math">
\[\begin{split}{\tiny
\left(\begin{array}{cccccccccccccccccccc}
\bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet \\
\end{array}\right)
}\end{split}\]</div>
<div class="admonition-the-coefficient-matrix-is-banded admonition">
<p class="first admonition-title">The coefficient matrix is banded</p>
<p class="last">Besides being sparse, we observe that the coefficient matrix is <em>banded</em>:
it has five distinct bands. We have the diagonal <span class="math">\(A_{i,i}\)</span>, the
subdiagonal <span class="math">\(A_{i-1,j}\)</span>, the superdiagonal <span class="math">\(A_{i,i+1}\)</span>, a lower
diagonal <span class="math">\(A_{i,i-(Nx+1)}\)</span>, and an upper diagonal <span class="math">\(A_{i,i+(Nx+1)}\)</span>.
The other matrix entries are known to be zero. With <span class="math">\(N_x+1=N_y+1=N\)</span>,
only a fraction <span class="math">\(5N^{-2}\)</span> of the matrix entries are nonzero, so the
matrix is clearly very sparse for relevant <span class="math">\(N\)</span> values.
The more we can compute with the nonzeros only, the faster the solution
methods will be.</p>
</div>
</div>
<div class="section" id="algorithm-for-setting-up-the-coefficient-matrix">
<span id="diffu-2d-alg"></span><h3>Algorithm for setting up the coefficient matrix<a class="headerlink" href="#algorithm-for-setting-up-the-coefficient-matrix" title="Permalink to this headline">¶</a></h3>
<p>We looked at a specific mesh in the previous section, formulated
the equations, and saw what the corresponding coefficient matrix and
right-hand side are. Now our aim is to set up a general algorithm, for any
choice of <span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span>, that produces the coefficient matrix and
the right-hand side vector.
We start with a zero matrix and vector, run through each mesh point,
and fill in the values depending on whether the mesh point is an interior
point or on the boundary.</p>
<blockquote>
<div><ul class="simple">
<li>for <span class="math">\(i=0,\ldots,N_x\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>for <span class="math">\(j=0,\ldots, N_y\)</span><ul>
<li><span class="math">\(p=j(N_x+1)+i\)</span></li>
<li>if point <span class="math">\((i,j)\)</span> is on the boundary:<ul>
<li><span class="math">\(A_{p,p}=1\)</span>, <span class="math">\(b_p=0\)</span></li>
</ul>
</li>
<li>else:<ul>
<li>fill <span class="math">\(A_{p,m(i-1,j)}\)</span>, <span class="math">\(A_{p,m(i+1,j)}\)</span>, <span class="math">\(A_{p,m(i,j)}\)</span>, <span class="math">\(A_{p,m(i,j-1)}\)</span>, <span class="math">\(A_{p,m(i,j+1)}\)</span>, and <span class="math">\(b_p\)</span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></blockquote>
</div></blockquote>
<p>To ease the test on whether <span class="math">\((i,j)\)</span> is on the boundary or not, we can
split the loops a bit, starting with the boundary line <span class="math">\(j=0\)</span>, then
treat the interior lines <span class="math">\(1\leq j&lt;N_y\)</span>, and finally treat the boundary
line <span class="math">\(j=N_y\)</span>:</p>
<blockquote>
<div><ul class="simple">
<li>for <span class="math">\(i=0,\ldots,N_x\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(j=0\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(A_{p,p}=1\)</span></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>for <span class="math">\(j=0,\ldots,N_y\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(i=0\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(A_{p,p}=1\)</span></li>
<li>for <span class="math">\(i=1,\ldots, N_x-1\)</span><ul>
<li>interior point <span class="math">\(p=j(N_x+1)+i\)</span></li>
<li>fill <span class="math">\(A_{p,m(i-1,j)}\)</span>, <span class="math">\(A_{p,m(i+1,j)}\)</span>, <span class="math">\(A_{p,m(i,j)}\)</span>, <span class="math">\(A_{p,m(i,j-1)}\)</span>, <span class="math">\(A_{p,m(i,j+1)}\)</span>, and <span class="math">\(b_p\)</span></li>
</ul>
</li>
<li>boundary <span class="math">\(i=N_x\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(A_{p,p}=1\)</span></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>for <span class="math">\(i=0,\ldots,N_x\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(j=N_y\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(A_{p,p}=1\)</span></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>The right-hand side is set up as follows.</p>
<blockquote>
<div><ul class="simple">
<li>for <span class="math">\(i=0,\ldots,N_x\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(j=0\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(b_p=0\)</span></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>for <span class="math">\(j=0,\ldots,N_y\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(i=0\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(b_p=0\)</span></li>
<li>for <span class="math">\(i=1,\ldots, N_x-1\)</span><ul>
<li>interior point <span class="math">\(p=j(N_x+1)+i\)</span></li>
<li>fill <span class="math">\(b_p\)</span></li>
</ul>
</li>
<li>boundary <span class="math">\(i=N_x\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(b_p=0\)</span></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>for <span class="math">\(i=0,\ldots,N_x\)</span></li>
</ul>
<blockquote>
<div><ul class="simple">
<li>boundary <span class="math">\(j=N_y\)</span>: <span class="math">\(p=j(N_x+1)+i\)</span>, <span class="math">\(b_p=0\)</span></li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="implementation-with-a-dense-coefficient-matrix">
<span id="diffu-2d-impl-dense"></span><h3>Implementation with a dense coefficient matrix<a class="headerlink" href="#implementation-with-a-dense-coefficient-matrix" title="Permalink to this headline">¶</a></h3>
<p>The goal now is to map the algorithms in the previous section to
Python code. One should for computational efficiency reasons take
advantage of the fact that the coefficient matrix is sparse and/or
banded, i.e., take advantage of all the zeros; however, we first demonstrate
how to fill an <span class="math">\(N\times N\)</span> dense square matrix, where <span class="math">\(N\)</span> is the number
of unknowns, here <span class="math">\(N=(N_x+1)(N_y+1)\)</span>. The dense matrix is much easier
to understand than the sparse matrix case.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">solver_dense</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u_t = a*(u_xx + u_yy) + f, u(x,y,0)=I(x,y), with u=0</span>
<span class="sd">    on the boundary, on [0,Lx]x[0,Ly]x[0,T], with time step dt,</span>
<span class="sd">    using the theta-scheme.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># mesh points in x dir</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># mesh points in y dir</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>                    <span class="c"># avoid integer division</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># mesh points in time</span>

    <span class="c"># Mesh Fourier numbers in each direction</span>
    <span class="n">Fx</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Fy</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dy</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>The <span class="math">\(u^{n+1}_{i,j}\)</span> and <span class="math">\(u^n_{i,j}\)</span> mesh functions are represented
by their spatial values at the mesh points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>      <span class="c"># unknown u at new time level</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>      <span class="c"># u at the previous time level</span>
</pre></div>
</div>
<p>It is a good habit (for extensions) to
introduce index sets for all mesh points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The initial condition is easy to fill in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Load initial condition into u_1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>The memory for the coefficient matrix and right-hand side vector
is allocated by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># no of unknowns</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>The filling of <code class="docutils literal"><span class="pre">A</span></code> goes like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>

<span class="c"># Equations corresponding to j=0, i=0,1,... (u known)</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># Loop over all internal mesh points in y diretion</span>
<span class="c"># and all mesh points in x direction</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c"># Boundary</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>                 <span class="c"># Interior points</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
        <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
        <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">+</span><span class="n">Fy</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
        <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Boundary</span>
<span class="c"># Equations corresponding to j=Ny, i=0,1,... (u known)</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Since <code class="docutils literal"><span class="pre">A</span></code> is independent of time, it can be filled once and for all before
the time loop. The right-hand side vector must be filled at each
time level inside the time loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Compute b</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>           <span class="c"># Boundary</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Boundary</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>              <span class="c"># Interior points</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
              <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>\
              <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>\
                <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Boundary</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>           <span class="c"># Boundary</span>

    <span class="c"># Solve matrix system A*c = b</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Fill u with vector c</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
<p>We use <code class="docutils literal"><span class="pre">solve</span></code> from <code class="docutils literal"><span class="pre">scipy.linalg</span></code> and not from <code class="docutils literal"><span class="pre">numpy.linalg</span></code>. The difference
is stated below.</p>
<div class="admonition-scipy-linalg-versus-numpy-linalg admonition">
<p class="first admonition-title"><code class="docutils literal"><span class="pre">scipy.linalg</span></code> versus <code class="docutils literal"><span class="pre">numpy.linalg</span></code></p>
<p>Quote from the <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html">SciPy documentation</a>:</p>
<p><code class="docutils literal"><span class="pre">scipy.linalg</span></code> contains all the functions in <code class="docutils literal"><span class="pre">numpy.linalg</span></code>
plus some other more advanced ones not contained in <code class="docutils literal"><span class="pre">numpy.linalg</span></code>.</p>
<p>Another advantage of using <code class="docutils literal"><span class="pre">scipy.linalg</span></code> over numpy.linalg is that it is always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore, the SciPy version might be faster depending on how NumPy was installed.</p>
<p class="last">Therefore, unless you don&#8217;t want to add SciPy as a dependency to your NumPy program, use <code class="docutils literal"><span class="pre">scipy.linalg</span></code> instead of <code class="docutils literal"><span class="pre">numpy.linalg</span></code>.</p>
</div>
<p>The code shown above is available in the <code class="docutils literal"><span class="pre">solver_dense</span></code> function
in the file <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py">diffu2D_u0.py</a>, differing only
in the boundary conditions, which in the code can be an arbitrary function along
each side of the domain.</p>
<p>We do not bother to look at vectorized versions of filling <code class="docutils literal"><span class="pre">A</span></code> since
a dense matrix is just used of pedagogical reasons for the very first
implementation. Vectorization will be treated when <code class="docutils literal"><span class="pre">A</span></code> has a sparse
matrix representation, as in the section <a class="reference internal" href="#diffu-2d-impl-sparse"><span class="std std-ref">Implementation with a sparse coefficient matrix</span></a>.</p>
<div class="admonition-how-to-debug-the-computation-of-math-a-and-math-b admonition">
<p class="first admonition-title">How to debug the computation of <span class="math">\(A\)</span> and <span class="math">\(b\)</span></p>
<p class="last">A good starting point for debugging the filling of <span class="math">\(A\)</span> and <span class="math">\(b\)</span> is
to choose a very coarse mesh, say <span class="math">\(N_x=N_y=2\)</span>, where there is just
one internal mesh point, compute the equations by hand, and
print out <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> for comparison in the code. If wrong elements
in <code class="docutils literal"><span class="pre">A</span></code> or <code class="docutils literal"><span class="pre">b</span></code> occur, print out each assignment to elements in
<code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">b</span></code> inside the loops and compare with what you expect.</p>
</div>
<p>To let the user store, analyze, or visualize the solution at each
time level, we include a callback function, named <code class="docutils literal"><span class="pre">user_action</span></code>,
to be called before the time loop and in each pass in that loop.
The function has the signature</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">u</span></code> is a two-dimensional array holding the solution at time level <code class="docutils literal"><span class="pre">n</span></code>
and time <code class="docutils literal"><span class="pre">t[n]</span></code>. The <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates of the mesh points are given by
the arrays <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>, respectively. The arrays <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> are
vectorized representations of the mesh points such that vectorized
function evaluations can be invoked. The <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> arrays are
defined by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>One can then evaluate, e.g., <span class="math">\(f(x,y,t)\)</span> at all internal mesh points at time
level <code class="docutils literal"><span class="pre">n</span></code> by first evaluating <span class="math">\(f\)</span> at all points,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>and then use slices to extract a view of the values at the internal
mesh points: <code class="docutils literal"><span class="pre">f_a[1:-1,1:-1]</span></code>.
The next section features an example on writing a <code class="docutils literal"><span class="pre">user_action</span></code>
callback function.</p>
</div>
<div class="section" id="verification-exact-numerical-solution">
<span id="diffu-2d-verify"></span><h3>Verification: exact numerical solution<a class="headerlink" href="#verification-exact-numerical-solution" title="Permalink to this headline">¶</a></h3>
<p>A good test example to start with is one that preserves the solution
<span class="math">\(u=0\)</span>, i.e., <span class="math">\(f=0\)</span> and <span class="math">\(I(x,y)=0\)</span>. This trivial solution can uncover
some bugs.</p>
<p>The first real test example is based on having an exact solution of
the discrete equations. This solution is linear in time and quadratic
in space:</p>
<div class="math">
\[u(x,y,t) = 5tx(L_x-x)y(y-L_y){\thinspace .}\]</div>
<p>Inserting this manufactured solution in the PDE shows that the
source term <span class="math">\(f\)</span> must be</p>
<div class="math">
\[f(x,y,t) = 5x(L_x-x)y(y-L_y) + 10{\alpha} t (x(L_x-x)+ y(y-L_y)){\thinspace .}\]</div>
<p>We can use the <code class="docutils literal"><span class="pre">user_action</span></code> function to compare the numerical solution
with the exact solution at each time level. A suitable helper function
for checking the solution goes like this:</p>
<div class="highlight-text"><div class="highlight"><pre>def quadratic(theta, Nx, Ny):

    def u_exact(x, y, t):
        return 5*t*x*(Lx-x)*y*(Ly-y)
    def I(x, y):
        return u_exact(x, y, 0)
    def f(x, y, t):
        return 5*x*(Lx-x)*y*(Ly-y) + 10*a*t*(y*(Ly-y)+x*(Lx-x))

    # Use rectangle to detect errors in switching i and j in scheme
    Lx = 0.75
    Ly = 1.5
    a = 3.5
    dt = 0.5
    T = 2

    def assert_no_error(u, x, xv, y, yv, t, n):
        &quot;&quot;&quot;Assert zero error at all mesh points.&quot;&quot;&quot;
        u_e = u_exact(xv, yv, t[n])
        diff = abs(u - u_e).max()
        tol = 1E-12
        msg = &#39;diff=%g, step %d, time=%g&#39; % (diff, n, t[n])
        print msg
        assert diff &lt; tol, msg

    solver_dense(
        I, a, f, Lx, Ly, Nx, Ny,
        dt, T, theta, user_action=assert_no_error)
</pre></div>
</div>
<p>A true test function for checking the quadratic solution for several
different meshes and <span class="math">\(\theta\)</span> values can take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_quadratic</span><span class="p">():</span>
    <span class="c"># For each of the three schemes (theta = 1, 0.5, 0), a series of</span>
    <span class="c"># meshes are tested (Nx &gt; Ny and Nx &lt; Ny)</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">Nx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">Ny</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">&#39;testing for </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> mesh&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
                <span class="n">quadratic</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="verification-convergence-rates">
<span id="diffu-2d-convrate"></span><h3>Verification: convergence rates<a class="headerlink" href="#verification-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>For any manufactured solution of the PDE problem we can compute the
numerical error and check that this error has the expected dependence
on the discretization parameters. Truncation error analysis and other
forms of error analysis point to a formula like</p>
<div class="math">
\[E = C_t\Delta t^p + C_x\Delta x^2 + C_y\Delta y^2\]</div>
<p>for the error in a 2D problem, where <span class="math">\(p\)</span>, <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, and <span class="math">\(C_y\)</span> are
unknown constants. A Crank-Nicolson method has <span class="math">\(p=2\)</span>, while the Forward
and Backward Euler schemes have <span class="math">\(p=1\)</span>.</p>
<p>When checking the error formula empirically, we need to reduce it to
a form <span class="math">\(E=Ch^r\)</span> with a single discretization parameter <span class="math">\(h\)</span> and some
rate <span class="math">\(r\)</span> to be estimated. For the Backward Euler method,
where <span class="math">\(p=1\)</span>, we can introduce a single discretization parameter
according to</p>
<div class="math">
\[h = \Delta x^2 =  \Delta y^2,\quad h = K^{-1}\Delta t,\]</div>
<p>where <span class="math">\(K\)</span> is a constant. The error formula then becomes</p>
<div class="math">
\[E = C_t Kh + C_xh + C_y = \tilde C h,\quad \tilde C = C_tK + C_x + C_y{\thinspace .}\]</div>
<p>The simplest choice is <span class="math">\(K=1\)</span>, but if we consider
the Forward Euler method instead, stability requires <span class="math">\(\Delta t = hK \leq
h/(4{\alpha})\)</span>, so <span class="math">\(K\leq 1/(4{\alpha})\)</span>.</p>
<p>For the Crank-Nicolson method, <span class="math">\(p=2\)</span>, and we can simply choose</p>
<div class="math">
\[h = \Delta x = \Delta y = \Delta t,\]</div>
<p>since there is no restriction on <span class="math">\(\Delta t\)</span> in terms of <span class="math">\(\Delta x\)</span> and
<span class="math">\(\Delta y\)</span>.</p>
<p>A frequently used error measure is the <span class="math">\(\ell^2\)</span> norm of the error mesh
point values. The section <a class="reference internal" href="._book005.html#wave-pde2-fd-mms"><span class="std std-ref">Manufactured solution</span></a> and the formula
<a class="reference internal" href="._book005.html#eq-wave-pde2-fd-mms-e-l2"><span class="std std-ref">(144)</span></a> shows the error measure for a 1D
time-dependent problem. The extension to the current 2D problem
reads</p>
<div class="math">
\[E = \left(\Delta t\Delta x\Delta y \sum_{n=0}^{N_t}
\sum_{i=0}^{N_x}\sum_{j=0}^{N_y}({u_{\small\mbox{e}}}(x_i,y_j,t_n)
- u^n_{i,j})^2\right)^{\frac{1}{2}}{\thinspace .}\]</div>
<p>One attractive manufactured solution is</p>
<div class="math">
\[{u_{\small\mbox{e}}} = e^{-pt}\sin(k_xx)\sin(k_yy),\quad k_x=\frac{\pi}{L_x},
k_y=\frac{\pi}{L_y},\]</div>
<p>where <span class="math">\(p\)</span> can be arbitrary. The required source term is</p>
<div class="math">
\[f = ({\alpha}(k_x^2 + k_y^2) - p){u_{\small\mbox{e}}}{\thinspace .}\]</div>
<p>The function <code class="docutils literal"><span class="pre">convergence_rates</span></code> in
<a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py">diffu2D_u0.py</a> implements a convergence
rate test. Two potential difficulties are important to be aware of:</p>
<ol class="arabic simple">
<li>The error formula is assumed to be
correct when <span class="math">\(h\rightarrow 0\)</span>, so for coarse meshes the estimated rate
<span class="math">\(r\)</span> may be somewhat away from the expected value.
Fine meshes may lead to prohibitively long execution times.</li>
<li>Choosing <span class="math">\(p={\alpha} (k_x^2 + k_y^2)\)</span> in the manufactured solution above
seems attractive (<span class="math">\(f=0\)</span>), but leads to a slower approach to the
asymptotic range where the error formula is valid (i.e., <span class="math">\(r\)</span>
fluctuates and needs finer meshes to stabilize).</li>
</ol>
</div>
<div class="section" id="implementation-with-a-sparse-coefficient-matrix">
<span id="diffu-2d-impl-sparse"></span><h3>Implementation with a sparse coefficient matrix<a class="headerlink" href="#implementation-with-a-sparse-coefficient-matrix" title="Permalink to this headline">¶</a></h3>
<p>We used a sparse matrix implementation in the section <a class="reference internal" href="#diffu-pde1-impl-sparse"><span class="std std-ref">Sparse matrix implementation</span></a>
for a 1D problem with a tridiagonal matrix. The present matrix, arising
from a 2D problem, has five diagonals, but we can use the same
sparse matrix data structure <code class="docutils literal"><span class="pre">scipy.sparse.diags</span></code>.</p>
<div class="section" id="understanding-the-diagonals">
<h4>Understanding the diagonals<a class="headerlink" href="#understanding-the-diagonals" title="Permalink to this headline">¶</a></h4>
<p>Let us look closer at the diagonals in the example with a <span class="math">\(4\times 3\)</span> mesh
as depicted in Figure <a class="reference internal" href="#diffu-2d-fig-mesh4x3"><span class="std std-ref">4x3 2D mesh</span></a> and its associated matrix
visualized by dots for zeros and bullets for nonzeros. From the example
mesh, we may generalize to an <span class="math">\(N_x\times N_y\)</span> mesh.</p>
<div class="math">
\[\begin{split}{\tiny
\begin{array}{lcccccccccccccccccccc}
0 =m(0,0) &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
1 = m(1,0) &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
2 = m(2,0) &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
3 = m(3,0) &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
N_x=m(N_x,0) &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
N_x+1=m(0,1) &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
(N_x+1)+1=m(1,1) &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
(N_x+1)+2=m(2,1) &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
(N_x+1)+3=m(3,1) &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
(N_x+1)+N_x=m(N_x,1) &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
2(N_x+1)=m(0,2)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
2(N_x+1)+1=m(1,2)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot \\
2(N_x+1)+2=m(2,2)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
2(N_x+1)+3=m(3,2)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \bullet &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
2(N_x+1)+N_x=m(N_x,2)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
N_y(N_x+1)=m(0,N_y)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\
N_y(N_x+1)+1=m(1,N_y)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot &amp; \cdot \\
N_y(N_x+1)+2=m(2,N_y)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot &amp; \cdot \\
N_y(N_x+1)+3=m(3,N_y)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet &amp; \cdot \\
N_y(N_x+1)+N_x=m(N_x,N_y)&amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; \bullet \\
\end{array}
}\end{split}\]</div>
<p>The main diagonal has <span class="math">\(N=(N_x+1)(N_y+1)\)</span> elements, while the sub- and
super-diagonals have <span class="math">\(N-1\)</span> elements. By looking at the matrix above,
we realize that the lower diagonal starts in row <span class="math">\(N_x+1\)</span> and goes to
row <span class="math">\(N\)</span>, so its length is <span class="math">\(N-(N_x+1)\)</span>. Similarly, the upper diagonal
starts at row 0 and lasts to row <span class="math">\(N-(N_x+1)\)</span>, so it has the same length.
Based on this information, we declare the diagonals by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">main</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>            <span class="c"># diagonal</span>
<span class="n">lower</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>          <span class="c"># subdiagonal</span>
<span class="n">upper</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>          <span class="c"># superdiagonal</span>
<span class="n">lower2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>     <span class="c"># lower diagonal</span>
<span class="n">upper2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>     <span class="c"># upper diagonal</span>
<span class="n">b</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>            <span class="c"># right-hand side</span>
</pre></div>
</div>
</div>
<div class="section" id="filling-the-diagonals">
<h4>Filling the diagonals<a class="headerlink" href="#filling-the-diagonals" title="Permalink to this headline">¶</a></h4>
<p>We run through all mesh points and fill in elements on the various
diagonals. The line of mesh points corresponding to <span class="math">\(j=0\)</span> are all
on the boundary, and only the main diagonal gets a contribution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># j=0 boundary line</span>
</pre></div>
</div>
<p>Then we run through all interior <span class="math">\(j=\hbox{const}\)</span> lines of mesh points.
The first and the last point on each line, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, correspond
to boundary points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>             <span class="c"># Interior mesh lines j=1,...,Ny-1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Boundary</span>
</pre></div>
</div>
<p>For the interior mesh points <span class="math">\(i=1,\ldots,N_x-1\)</span> on a mesh line <span class="math">\(y=\hbox{const}\)</span>
we can start with the main diagonal. The entries to be filled go from
<span class="math">\(i=1\)</span> to <span class="math">\(i=N_x-1\)</span> so the relevant slice in the <code class="docutils literal"><span class="pre">main</span></code> vector is
<code class="docutils literal"><span class="pre">m(1,j):m(Nx,j)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">+</span><span class="n">Fy</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">upper</span></code> array for the superdiagonal has its index 0 corresponding to
row 0 in the matrix, and the array entries
to be set go from <span class="math">\(m(1,j)\)</span> to <span class="math">\(m(N_x-1,j)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">upper</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
</pre></div>
</div>
<p>The subdiagonal (<code class="docutils literal"><span class="pre">lower</span></code> array), however, has its index 0
corresponding to row 1, so there is an offset of 1 in indices compared to
the matrix. The first nonzero occurs (interior point) at a mesh line <span class="math">\(j=\hbox{const}\)</span> corresponds to matrix row <span class="math">\(m(1,j)\)</span>, and the corresponding array index
in <code class="docutils literal"><span class="pre">lower</span></code> is then <span class="math">\(m(1,j)\)</span>. To fill the entries from <span class="math">\(m(1,j)\)</span> to <span class="math">\(m(N_x-1,j)\)</span>
we set the following slice in <code class="docutils literal"><span class="pre">lower</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lower_offset</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">lower</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower_offset</span><span class="p">:</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower_offset</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
</pre></div>
</div>
<p>For the upper diagonal, its index 0 corresponds to matrix row 0, so there
is no offset and we can set the entries correspondingly to <code class="docutils literal"><span class="pre">upper</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">upper2</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">lower2</span></code> diagonal, however, has its first index 0 corresponding to row
<span class="math">\(N_x+1\)</span>, so here we need to subtract the offset <span class="math">\(N_x+1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lower2_offset</span> <span class="o">=</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span>
<span class="n">lower2</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower2_offset</span><span class="p">:</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower2_offset</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
</pre></div>
</div>
<p>We can now summarize the above code lines for setting the entries in
the sparse matrix representation of the coefficient matrix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lower_offset</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">lower2_offset</span> <span class="o">=</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span>
<span class="n">m</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>

<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># j=0 boundary line</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>             <span class="c"># Interior mesh lines j=1,...,Ny-1</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Boundary</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Boundary</span>
    <span class="c"># Interior i points: i=1,...,N_x-1</span>
    <span class="n">lower2</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower2_offset</span><span class="p">:</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower2_offset</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
    <span class="n">lower</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower_offset</span><span class="p">:</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">-</span><span class="n">lower_offset</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
    <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">+</span><span class="n">Fy</span><span class="p">)</span>
    <span class="n">upper</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fx</span>
    <span class="n">upper2</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span><span class="o">*</span><span class="n">Fy</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span><span class="p">;</span> <span class="n">main</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># Boundary line</span>
</pre></div>
</div>
<p>The next task is to create the sparse matrix from these diagonals:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.sparse</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
    <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower2</span><span class="p">,</span> <span class="n">upper2</span><span class="p">],</span>
    <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">lower_offset</span><span class="p">,</span> <span class="n">lower_offset</span><span class="p">,</span>
             <span class="o">-</span><span class="n">lower2_offset</span><span class="p">,</span> <span class="n">lower2_offset</span><span class="p">],</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="filling-the-right-hand-side-scalar-version">
<h4>Filling the right-hand side; scalar version<a class="headerlink" href="#filling-the-right-hand-side-scalar-version" title="Permalink to this headline">¶</a></h4>
<p>Setting the entries in the right-hand side is easier since there are no
offsets in the array to take into account. The is in fact similar to
the one previously shown when we used a dense matrix representation
(the right-hand side vector is, of course, independent of what type of
representation we use for the coefficient matrix). The complete time
loop goes as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Compute b</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                     <span class="c"># Boundary</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>             <span class="c"># Boundary</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>                            <span class="c"># Interior</span>
            <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
              <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>\
              <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>\
                <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>            <span class="c"># Boundary</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                     <span class="c"># Boundary</span>

    <span class="c"># Solve matrix system A*c = b</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Fill u with vector c</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
</div>
<div class="section" id="filling-the-right-hand-side-vectorized-version">
<h4>Filling the right-hand side; vectorized version<a class="headerlink" href="#filling-the-right-hand-side-vectorized-version" title="Permalink to this headline">¶</a></h4>
<p>Since we use a sparse matrix and try to speed up the computations, we
should examine the loops and see if some can be easily removed by
vectorization. In the filling of <span class="math">\(A\)</span> we have already used vectorized
expressions at each <span class="math">\(j=\hbox{const}\)</span> line of mesh points. We can
very easily do the same in the code above and remove the need for
loops over the <code class="docutils literal"><span class="pre">i</span></code> index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Compute b, vectorized version</span>

    <span class="c"># Precompute f in array so we can make slices</span>
    <span class="n">f_a_np1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">f_a_n</span>   <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c"># Boundary</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Boundary</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>  <span class="n">b</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Boundary</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># for slice, max i index is Ix[-1]-1</span>
        <span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">*</span><span class="p">(</span>
          <span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">imax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span>
        <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
          <span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">imax</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                         <span class="n">Fy</span><span class="o">*</span><span class="p">(</span>
          <span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
        <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span>
          <span class="n">u_1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
            <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_np1</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
          <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_n</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span><span class="p">;</span>  <span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">):</span><span class="n">m</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Boundary</span>

    <span class="c"># Solve matrix system A*c = b</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c"># Fill u with vector c</span>
    <span class="n">u</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
<p>The most tricky part of this code snippet is the loading of values in
the one-dimensional array <code class="docutils literal"><span class="pre">c</span></code>
into the two-dimensional array <code class="docutils literal"><span class="pre">u</span></code>. With our numbering of unknowns
from left to right along &#8220;horizontal&#8221; mesh lines, the correct
reordering of the one-dimensional array <code class="docutils literal"><span class="pre">c</span></code> as a two-dimensional array
requires first a reshaping as an <code class="docutils literal"><span class="pre">(Ny+1,Nx+1)</span></code> two-dimensional
array and then taking the transpose. The result is an <code class="docutils literal"><span class="pre">(Nx+1,Ny+1)</span></code>
array compatible with <code class="docutils literal"><span class="pre">u</span></code> both in size and appearance of the function values.</p>
<p>The <code class="docutils literal"><span class="pre">spsolve</span></code> function in <code class="docutils literal"><span class="pre">scipy.sparse.linalg</span></code> is an efficient version
of Gaussian elimination suited for matrices described by diagonals.
Actually, only the matrix elements within the bands (from <code class="docutils literal"><span class="pre">lower2</span></code>
to <code class="docutils literal"><span class="pre">upper2</span></code>) are computed with, and these elements constitute only a
fraction of all <span class="math">\(N^2\)</span> matrix elements, a crucial property to exploit.
The Gaussian elimination algorithm for banded matrices is therefore
much faster and requires much less storage than standard Gaussian elimination
for a dense matrix.
More precisely, with <span class="math">\(b=N_x+1\)</span> as the <em>bandwidth</em> of the matrix
[[[</p>
<p>[<strong>hpl 15</strong>: Problem: if <span class="math">\(N_x\gg N_y\)</span> one should number the unknowns in <span class="math">\(y\)</span> direction to get a smaller bandwidth.]</p>
<p>The complete code is found in the <code class="docutils literal"><span class="pre">solver_sparse</span></code> function in the file
<a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py">diffu2D_u0.py</a>.</p>
</div>
<div class="section" id="verification-7">
<h4>Verification<a class="headerlink" href="#verification-7" title="Permalink to this headline">¶</a></h4>
<p>We can easily extend the function <code class="docutils literal"><span class="pre">quadratic</span></code> from
the section <a class="reference internal" href="#diffu-2d-verify"><span class="std std-ref">Verification: exact numerical solution</span></a> to include a test of the
<code class="docutils literal"><span class="pre">solver_sparse</span></code> function as well.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_sparse</span><span class="p">(</span>
        <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span>
        <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="n">assert_no_error</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-jacobi-iterative-method">
<h3>The Jacobi iterative method<a class="headerlink" href="#the-jacobi-iterative-method" title="Permalink to this headline">¶</a></h3>
<p id="index-8">So far we have created a matrix and
right-hand side of a linear system <span class="math">\(Ac=b\)</span>
and solved the system for <span class="math">\(c\)</span> by calling an exact algorithm
based on Gaussian elimination. A much simpler implementation, which
requires no memory for the coefficient matrix <span class="math">\(A\)</span>, arises if we solve
the system by <em>iterative</em> methods. These methods are only approximate, and
the core algorithm is repeated many times until the solution is
considered to be converged.</p>
<div class="section" id="numerical-scheme-and-linear-system">
<h4>Numerical scheme and linear system<a class="headerlink" href="#numerical-scheme-and-linear-system" title="Permalink to this headline">¶</a></h4>
<p>To illustrate the idea of the Jacobi method, we simplify the numerical scheme to the
Backward Euler case, <span class="math">\(\theta=1\)</span>, so there are fewer terms to write:</p>
<div class="math">
\[ u^{n+1}_{i,j} -
\left(
F_x
(u^{n+1}_{i-1,j} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} - 2u^{n+1}_{i,j} + u^{n+1}_{i,j+1})\right)
= \nonumber\]</div>
<div class="math" id="eq-diffu-2d-be-scheme">
\[\tag{402}
\qquad u^n_{i,j} + \Delta t f^{n+1}_{i,j}\]</div>
<p>The idea of the <em>Jacobi</em> iterative method is to introduce an iteration,
here with index <span class="math">\(r\)</span>, where we in each iteration treat <span class="math">\(u^{n+1}_{i,j}\)</span>
as unknown, but use values from the previous iteration for
the other unknowns <span class="math">\(u^{n+1}_{i\pm 1,j\pm 1}\)</span>.</p>
</div>
<div class="section" id="iterations">
<h4>Iterations<a class="headerlink" href="#iterations" title="Permalink to this headline">¶</a></h4>
<p>Let <span class="math">\(u^{n+1,r}_{i,j}\)</span>
be the approximation to <span class="math">\(u^{n+1}_{i,j}\)</span> in iteration <span class="math">\(r\)</span>, for all
relevant <span class="math">\(i\)</span> and <span class="math">\(j\)</span> indices. We first solve with respect to
<span class="math">\(u^{n+1}_{i,j}\)</span> to get the equation to solve:</p>
<div class="math">
\[ u^{n+1}_{i,j} = (1+2F_x +2F_y)^{-1}
\left(
F_x
(u^{n+1}_{i-1,j} + u^{n+1}_{i,j}) +
F_y
(u^{n+1}_{i,j-1} + u^{n+1}_{i,j+1})\right) +
\nonumber\]</div>
<div class="math" id="eq-diffu-2d-jacobi0">
\[\tag{403}
\qquad
    u^n_{i,j} + \Delta t f^{n+1}_{i,j}\]</div>
<p>The iteration is introduced by using iteration index <span class="math">\(r\)</span>, for computed values,
on the right-hand side and <span class="math">\(r+1\)</span> (unknown in this iteration) on the left-hand
side:</p>
<div class="math">
\[ u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}((
F_x
(u^{n+1,r}_{i-1,j} + u^{n+1,r}_{i,j}) +
F_y
(u^{n+1,r}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
\nonumber\]</div>
<div class="math" id="eq-diffu-2d-jacobi">
\[\tag{404}
\qquad
    u^n_{i,j} + \Delta t f^{n+1}_{i,j})\]</div>
</div>
<div class="section" id="initial-guess">
<h4>Initial guess<a class="headerlink" href="#initial-guess" title="Permalink to this headline">¶</a></h4>
<p>We start the iteration with the computed values at the previous time level:</p>
<div class="math" id="eq-diffu-2d-iter-startvector">
\[\tag{405}
u^{n+1,0}_{i,j} = u^{n}_{i,j},\quad i=0,\ldots,N_x,\ j=0,\ldots,N_y{\thinspace .}\]</div>
</div>
<div class="section" id="relaxation-1">
<h4>Relaxation<a class="headerlink" href="#relaxation-1" title="Permalink to this headline">¶</a></h4>
<p>A common technique in iterative methods is to introduce a <em>relaxation</em>,
which means that the new approximation is a weighted mean of the
approximation as suggested by the algorithm and the previous approximation.
Naming the quantity on the left-hand side of <a class="reference internal" href="#eq-diffu-2d-jacobi"><span class="std std-ref">(404)</span></a>
as <span class="math">\(u^{n+1,*}_{i,j}\)</span>, a new approximation based on relaxation reads</p>
<div class="math" id="eq-diffu-2d-iter-relaxation">
\[\tag{406}
u^{n+1,r+1} = \omega u^{n+1,*}_{i,j} + (1-\omega) u^{n+1,r}_{i,j}{\thinspace .}\]</div>
<p>Under-relaxation means <span class="math">\(\omega &lt; 1\)</span>, while over-relaxation has
<span class="math">\(\omega &gt; 1\)</span>.</p>
</div>
<div class="section" id="stopping-criteria-1">
<h4>Stopping criteria<a class="headerlink" href="#stopping-criteria-1" title="Permalink to this headline">¶</a></h4>
<p>The iteration can be stopped when the change from one iteration to the
next is sufficiently small (<span class="math">\(\epsilon\)</span>), using either an infinity norm,</p>
<div class="math" id="eq-auto168">
\[\tag{407}
\max_{i,j}\left\vert u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j}
    \right\vert \leq \epsilon,\]</div>
<p>or an <span class="math">\(L^2\)</span> norm,</p>
<div class="math" id="eq-auto169">
\[\tag{408}
\left(\Delta x\Delta y\sum_{i,j} (u^{n+1,r+1}_{i,j}-u^{n+1,r}_{i,j})^2
    \right)^{\frac{1}{2}} \leq \epsilon{\thinspace .}\]</div>
<p>Another widely used criterion measures how well the equations are solved
by looking at the residual (essentially <span class="math">\(b-Ac^{r+1}\)</span> if <span class="math">\(c^{r+1}\)</span> is
the approximation to the solution in iteration <span class="math">\(r+1\)</span>).
The residual, defined in terms of the finite difference stencil, is</p>
<div class="math">
\[R_{i,j} = u^{n+1,r+1}_{i,j} -
(F_x(u^{n+1,r+1}_{i-1,j} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i,j}) +\nonumber\]</div>
<div class="math">
\[\quad\quad F_y(u^{n+1,r+1}_{i,j-1} - 2u^{n+1,r+1}_{i,j} + u^{n+1,r+1}_{i,j+1}))
- \nonumber\]</div>
<div class="math" id="eq-diffu-2d-residual">
\[\tag{409}
\qquad u^n_{i,j} -  \Delta t f^{n+1}_{i,j}\]</div>
<p>One can then iterate until the norm of the mesh function <span class="math">\(R_{i,j}\)</span>
is less than some tolerance:</p>
<div class="math" id="eq-auto170">
\[\tag{410}
\left(\Delta x\Delta y\sum_{i,j} R_{i,j}^2
    \right)^{\frac{1}{2}} \leq \epsilon{\thinspace .}\]</div>
</div>
<div class="section" id="code-friendly-notation">
<h4>Code-friendly notation<a class="headerlink" href="#code-friendly-notation" title="Permalink to this headline">¶</a></h4>
<p>To make the mathematics as close as possible to what we will write in
a computer program, we may introduce some new notation: <span class="math">\(u_{i,j}\)</span> is a
short notation for <span class="math">\(u^{n+1,r+1}_{i,j}\)</span>, <span class="math">\(u^{-}_{i,j}\)</span> is a short
notation for <span class="math">\(u^{n+1,r}_{i,j}\)</span>, and <span class="math">\(u^{(s)}_{i,j}\)</span> denotes
<span class="math">\(u^{n+1-s}_{i,j}\)</span>.  That is, <span class="math">\(u_{i,j}\)</span> is the unknown, <span class="math">\(u^{-}_{i,j}\)</span>
is its most recently computed approximation, and <span class="math">\(s\)</span> counts time
levels backwards in time. The Jacobi method
(ref:ref:<cite>(404) &lt;Eq:diffu:2D:Jacobi&gt;</cite>) takes the following form with the new
notation:</p>
<div class="math">
\[ u^{*}_{i,j} = (1+2F_x +2F_y)^{-1}((
F_x
(u^{-}_{i-1,j} + u^{-}_{i,j}) +
F_y
(u^{n+1,r}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
\nonumber\]</div>
<div class="math" id="eq-diffu-2d-jacobi2">
\[\tag{411}
\qquad
    u^{(1)}_{i,j} + \Delta t f^{n+1}_{i,j})\]</div>
</div>
<div class="section" id="generalization-of-the-scheme">
<h4>Generalization of the scheme<a class="headerlink" href="#generalization-of-the-scheme" title="Permalink to this headline">¶</a></h4>
<p>We can also quite easily introduce the <span class="math">\(\theta\)</span> rule for discretization in
time and write up the Jacobi iteration in that case as well:</p>
<div class="math">
\[ u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u^{-}_{i-1,j} + u^{-}_{i,j}) +
F_y
(u^{-}_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\]</div>
<div class="math">
\[\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\]</div>
<div class="math" id="eq-diffu-2d-jacobi3">
\[\tag{412}
\qquad (1-\theta)(
    F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
    F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1}))){\thinspace .}\]</div>
<p>The final update of <span class="math">\(u\)</span> applies relaxation:</p>
<div class="math">
\[u_{i,j} = \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="implementation-of-the-jacobi-method">
<span id="diffu-2d-jacobi-impl"></span><h3>Implementation of the Jacobi method<a class="headerlink" href="#implementation-of-the-jacobi-method" title="Permalink to this headline">¶</a></h3>
<p>The Jacobi method needs no coefficient matrix and right-hand side
vector, but it needs an array for <span class="math">\(u\)</span> in the previous iteration.  We
call this array <code class="docutils literal"><span class="pre">u_</span></code>, using the notation at the end of the previous
section (at the same time level). The unknown itself is called <code class="docutils literal"><span class="pre">u</span></code>,
while <code class="docutils literal"><span class="pre">u_1</span></code> is the computed solution one time level back in time.
With a <span class="math">\(\theta\)</span> rule in time, the time loop can be coded like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Solve linear system by Jacobi iteration at time level n+1</span>
    <span class="n">u_</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">u_1</span>  <span class="c"># Start value</span>
    <span class="n">converged</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0y</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>           <span class="c"># Boundary</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0x</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_Lx</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
                <span class="c"># Interior points</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">u_new</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span> <span class="o">+</span> <span class="n">Fy</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span>
                        <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                      <span class="n">Fy</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>\
                      <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span>
                    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">u_new</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_Ly</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>      <span class="c"># Boundary</span>

        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;vectorized&#39;</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0y</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">U_0x</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">U_Lx</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span><span class="p">;</span> <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_Ly</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
            <span class="c"># Internal points</span>
            <span class="n">f_a_np1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">f_a_n</span>   <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">u_new</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span> <span class="o">+</span> <span class="n">Fy</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">*</span><span class="p">(</span>
              <span class="n">u_</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">Fy</span><span class="o">*</span><span class="p">(</span>
              <span class="n">u_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="o">+</span>\
            <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span><span class="o">*</span><span class="p">(</span>
              <span class="n">u_1</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>\
                <span class="n">Fy</span><span class="o">*</span><span class="p">(</span>
              <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>\
              <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_np1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
              <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">u_new</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">u_</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">max_iter</span>
        <span class="n">u_</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="c"># Update u_1 before next step</span>
    <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
<p>The vectorized version should be quite straightforward to understand
once one has an understanding of how a standard 2D finite stencil
is vectorized.
[<strong>hpl 16</strong>: Make references to 1D and 2D wave equation vectorization.]</p>
<p>The first natural verification is to use the test problem
from in the function <code class="docutils literal"><span class="pre">quadratic</span></code> from
the section <a class="reference internal" href="#diffu-2d-verify"><span class="std std-ref">Verification: exact numerical solution</span></a>. This problem is known to have no
approximation error, but any iterative method will produce an
approximate solution with unknown error. For a tolerance <span class="math">\(10^{-k}\)</span>
in the iterative method, we can, e.g., use a slightly larger
tolerance <span class="math">\(10^{-(k-1)}\)</span>
for the difference between the exact and the computed solution.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">quadratic</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">assert_small_error</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assert small error for iterative methods.&quot;&quot;&quot;</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_e</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-4</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;diff=</span><span class="si">%g</span><span class="s">, step </span><span class="si">%d</span><span class="s">, time=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">,</span> <span class="n">msg</span>

    <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="s">&#39;scalar&#39;</span><span class="p">,</span> <span class="s">&#39;vectorized&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;testing Jacobi, </span><span class="si">%s</span><span class="s"> version, theta=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> \
                  <span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver_Jacobi</span><span class="p">(</span>
                <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">Lx</span><span class="o">=</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="o">=</span><span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="o">=</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="n">Ny</span><span class="p">,</span>
                <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                <span class="n">U_0x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_0y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_Lx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_Ly</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">user_action</span><span class="o">=</span><span class="n">assert_small_error</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="s">&#39;Jacobi&#39;</span><span class="p">,</span>
                <span class="n">omega</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">)</span>
</pre></div>
</div>
<p>Even for a very coarse <span class="math">\(4\times 4\)</span> mesh, the Jacobi method requires
26 iterations to reach a tolerance of <span class="math">\(10^{-5}\)</span>,
which is quite many iterations, given that there are only 25 unknowns.</p>
</div>
<div class="section" id="test-problem-diffusion-of-a-sine-hill">
<span id="diffu-2d-jacobi-impl-hill"></span><h3>Test problem: diffusion of a sine hill<a class="headerlink" href="#test-problem-diffusion-of-a-sine-hill" title="Permalink to this headline">¶</a></h3>
<p>It can be shown that</p>
<div class="math" id="eq-diffu-2d-jacobi-impl-hill-uex">
\[\tag{413}
{u_{\small\mbox{e}}} = Ae^{-{\alpha}\pi^2(L_x^{-2} + L_y^{-2})}
    \sin\left(\frac{\pi}{L_x}x\right)\sin\left(\frac{\pi}{L_y}y\right),\]</div>
<p>is a solution of the 2D homogeneous diffusion equation
<span class="math">\(u_t = {\alpha}(u_{xx}+u_{yy})\)</span> in
a rectangle <span class="math">\([0,L_x]\times [0,L_y]\)</span>, for any value of the amplitude <span class="math">\(A\)</span>.
This solution vanishes at the boundaries,
and the initial condition is the product of two sines.
We may choose <span class="math">\(A=1\)</span> for simplicity.</p>
<p>It is difficult to know if our Jacobi method works properly since we
are faced with two sources of errors: one from the discretization,
<span class="math">\(E_\Delta\)</span>, and one from the iterative Jacobi method, <span class="math">\(E_i\)</span>. The total
error in the computed <span class="math">\(u\)</span> can be represented as</p>
<div class="math">
\[E_u = E_\Delta + E_i{\thinspace .}\]</div>
<p>One error measure is to look at the maximum value, which is obtained for
the midpoint <span class="math">\(x=L_x/2\)</span> and <span class="math">\(y=L_x/2\)</span>. This midpoint is represented in
the discrete <code class="docutils literal"><span class="pre">u</span></code> if <span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span> are even numbers. We can then
compute <span class="math">\(E_u\)</span> as <span class="math">\(E_u = |\max {u_{\small\mbox{e}}} - \max u|\)</span>, when we know an exact
solution <span class="math">\({u_{\small\mbox{e}}}\)</span> of the problem.</p>
<p>What about <span class="math">\(E_\Delta\)</span>? If we use the maximum value as a measure of the
error, we have in fact analytical insight into the approximation error in this
particular problem. According to the section <a class="reference internal" href="#diffu-2d-analysis"><span class="std std-ref">Analysis of the 2D diffusion equation</span></a>, the exact
solution <a class="reference internal" href="#eq-diffu-2d-jacobi-impl-hill-uex"><span class="std std-ref">(413)</span></a> of the PDE problem is
also an exact solution of the discrete equations, except that the
damping factor in time is different. More precisely,
<a class="reference internal" href="#eq-diffu-2d-analysis-bn-numexact"><span class="std std-ref">(371)</span></a> and
<a class="reference internal" href="#eq-diffu-2d-analysis-cn-numexact"><span class="std std-ref">(372)</span></a> are solutions of the discrete
problem for <span class="math">\(\theta=1\)</span> (Backward Euler) and <span class="math">\(\theta=\frac{1}{2}\)</span>
(Crank-Nicolson), respectively.  The factors raised to the power <span class="math">\(n\)</span>
is the numerical amplitude, and the errors in these factors become</p>
<div class="math">
\[\begin{split}E_\Delta &amp;= e^{-{\alpha} k^2t} - \left(
\frac{1 - 2(F_x\sin^2 p_x + F_x\sin^2p_y)}{1 + 2(F_x\sin^2 p_x + F_x\sin^2p_y)}
\right)^n,\quad \theta=\frac{1}{2},\\
E_\Delta &amp;= e^{-{\alpha} k^2t} -
(1 + 4F_x\sin^2 p_x + 4F_y\sin^2 p_y)^{-n},\quad\theta=1{\thinspace .}\end{split}\]</div>
<p>We are now in a position to compute <span class="math">\(E_i\)</span> numerically. That is, we can
compute the error due to iterative solution of the linear system and
see if it corresponds to the convergence tolerance used in the method.
Note that the convergence is based on measuring the difference in
two consecutive approximations, which is not exactly the error
due to the iteration, but it is a kind of measure, and it should
have about the same size as <span class="math">\(E_i\)</span>.</p>
<p>The function <code class="docutils literal"><span class="pre">demo_classic_iterative</span></code> in <a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py">diffu2D_u0.py</a> implements the idea above (also for the
methods in the section <a class="reference internal" href="#diffu-2d-sor"><span class="std std-ref">The Gauss-Seidel and SOR methods</span></a>). The value of <span class="math">\(E_i\)</span> is in
particular printed at each time level. By changing the tolerance in
the convergence criterion in the Jacobi method, we can see that <span class="math">\(E_i\)</span>
is of the same order of magnitude as the prescribed tolerance in the
Jacobi method.  For
example: <span class="math">\(E_\Delta\sim 10^{-2}\)</span> with <span class="math">\(N_x=N_y=10\)</span> and <span class="math">\(\theta=\frac{1}{2}\)</span>,
as long as <span class="math">\(\max u\)</span> has some significant size (<span class="math">\(\max u &gt;
0.02\)</span>). An appropriate value of the tolerance is then <span class="math">\(10^{-3}\)</span>,
such that the error in the Jacobi method does not become bigger than
the discretization error. In that case,
<span class="math">\(E_i\)</span> is around <span class="math">\(5\cdot 10^{-3}\)</span>.
The corresponding number of Jacobi
iterations (with <span class="math">\(\omega=1\)</span>) varies from 31 to 12 during the
time simulation (for <span class="math">\(\max u &gt;
0.02\)</span>). Changing the tolerance to <span class="math">\(10^{-5}\)</span> causes many more
iterations (61 to 42) without giving any contribution to the overall
accuracy, because the total error is dominated by <span class="math">\(E_\Delta\)</span>.</p>
<p>Also, with a <span class="math">\(N_x=N_y=20\)</span>, the spatial accuracy increases and many more
iterations are needed (143 to 45), but the dominating error is from
the time discretization. However, with such a finer spatial mesh, a higher
tolerance in the convergence criterion <span class="math">\(10^{-4}\)</span> is needed to keep
<span class="math">\(E_i\sim 10^{-3}\)</span>.  More experiments show the disadvantage of the very
simple Jacobi iteration method: the number of iterations increases
with the number of unknowns, keeping the tolerance fixed, but the
tolerance should also be lowered to avoid the iteration error to
dominate the total error. A small adjustment of the Jacobi method, as
described in the section <a class="reference internal" href="#diffu-2d-sor"><span class="std std-ref">The Gauss-Seidel and SOR methods</span></a>, provides a better method.</p>
</div>
<div class="section" id="the-relaxed-jacobi-method-and-its-relation-to-the-forward-euler-method">
<span id="diffu-2d-jacobi-vs-fe"></span><h3>The relaxed Jacobi method and its relation to the Forward Euler method<a class="headerlink" href="#the-relaxed-jacobi-method-and-its-relation-to-the-forward-euler-method" title="Permalink to this headline">¶</a></h3>
<p>We shall now show that solving the Poisson equation <span class="math">\(-{\alpha}\nabla^2 u = f\)</span> by
the Jacobi iterative method is in fact equivalent to using a
Forward Euler scheme on <span class="math">\(u_t = {\alpha}\nabla^2 u + f\)</span> and letting
<span class="math">\(t\rightarrow\infty\)</span>.</p>
<p>A Forward Euler discretization of the 2D diffusion equation,</p>
<div class="math">
\[\lbrack D_t^+ u = {\alpha} (D_xD_x u + D_yD_y u) + f\rbrack^n_{i,j},\]</div>
<p>can be written out as</p>
<div class="math">
\[u^{n+1} = u^n + \frac{\Delta t}{{\alpha} h^2}
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),\]</div>
<p>where <span class="math">\(h=\Delta x = \Delta y\)</span> has been introduced for simplicity. The
scheme can be reordered as</p>
<div class="math">
\[u^{n+1} = \left(1 - \omega\right) u_{i,j}^n
+ \frac{1}{4}\omega
\left( u_{i-1,j}^n + u_{i+1,j}^n + u_{i,j-1}^n + u_{i,j+1}^n - 4u_{i,j}^n
+ h^2f_{i,j}\right),\]</div>
<p>with</p>
<div class="math">
\[\omega = 4\frac{\Delta t}{{\alpha} h^2},\]</div>
<p>but this latter form is nothing but the relaxed Jacobi method applied to</p>
<div class="math">
\[[D_xD_x u + D_yD_y u = -f]^n_{i,j}{\thinspace .}\]</div>
<p>From the equivalence above we know a couple of things about the Jacobi
method for solving <span class="math">\(-\nabla^2 u = f\)</span>:</p>
<ol class="arabic simple">
<li>The method is unstable if <span class="math">\(\omega &gt; 1\)</span> (since the Forward Euler method
is then unstable).</li>
<li>The convergence is really slow as the iteration index increases (coming from the fact that
the Forward Euler scheme requires many small time steps to reach the stationary solution).</li>
</ol>
<p>These observations are quite disappointing: if we already have a
time-dependent diffusion problem and want to take larger time steps by
an implicit time discretization method, we will with the Jacobi method
end up with something close to a slow Forward Euler simulation of the
original problem at each time level.  Nevertheless, the are two reasons
for why the Jacobi method
remains a fundamental building block for solving linear systems
arising from PDEs: 1) a couple of iterations remove
large parts of the error and this is effectively used in the very
efficient class of multigrid methods; and 2) the idea of the Jacobi
method can be developed into more efficient methods, especially the
SOR method, which is treated next.</p>
</div>
<div class="section" id="the-gauss-seidel-and-sor-methods">
<span id="diffu-2d-sor"></span><h3>The Gauss-Seidel and SOR methods<a class="headerlink" href="#the-gauss-seidel-and-sor-methods" title="Permalink to this headline">¶</a></h3>
<p id="index-9">If we update the mesh points according to the
Jacobi method <a class="reference internal" href="#eq-diffu-2d-jacobi0"><span class="std std-ref">(403)</span></a>
for a Backward Euler discretization with a loop over
<span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(j=1,\ldots,Ny-1\)</span>, we realize that
when <span class="math">\(u^{n+1,r+1}_{i,j}\)</span> is computed, <span class="math">\(u^{n+1,r+1}_{i-1,j}\)</span>
and <span class="math">\(u^{n+1,r+1}_{i,j-1}\)</span> are already computed, so these new
values can be used rather than
<span class="math">\(u^{n+1,r}_{i-1,j}\)</span> and <span class="math">\(u^{n+1,r}_{i,j-1}\)</span> (respectively)
in the formula for <span class="math">\(u^{n+1,r+1}_{i,j}\)</span>.
This idea gives rise to the <em>Gauss-Seidel</em> iteration method,
which mathematically is just a small adjustment of
<a class="reference internal" href="#eq-diffu-2d-jacobi0"><span class="std std-ref">(403)</span></a>:</p>
<div class="math">
\[u^{n+1,r+1}_{i,j} = (1+2F_x +2F_y)^{-1}((\nonumber\]</div>
<div class="math" id="eq-diffu-2d-sor-eq">
\[\tag{414}
\qquad
    F_x
    (u^{n+1,r+1}_{i-1,j} + u^{n+1,r}_{i,j}) +
    F_y
    (u^{n+1,r+1}_{i,j-1} + u^{n+1,r}_{i,j+1})) +
    u^n_{i,j} + \Delta t f^{n+1}_{i,j}){\thinspace .}\]</div>
<p>Observe that the way we access the mesh points in the formula
<a class="reference internal" href="#eq-diffu-2d-sor-eq"><span class="std std-ref">(414)</span></a> is important: points with <span class="math">\(i-1\)</span> must be computed
before points with <span class="math">\(i\)</span>, and points with <span class="math">\(j-1\)</span> must be computed
before points with <span class="math">\(j\)</span>. Any sequence of mesh points can be used
in the Gauss-Seidel method, but the particular math
formula must distinguish between
already visited points in the current iteration and the points not
yet visited.</p>
<p id="index-10">The idea of relaxation <a class="reference internal" href="#eq-diffu-2d-iter-relaxation"><span class="std std-ref">(406)</span></a> can equally
well be applied to the Gauss-Seidel method. Actually, the Gauss-Seidel
method with an arbitrary <span class="math">\(0&lt;\omega\leq 2\)</span> has its own name: the
<em>Successive Over-Relaxation</em> method, abbreviated as SOR.</p>
<p>The SOR method for a <span class="math">\(\theta\)</span> rule discretization, with the
shortened <span class="math">\(u\)</span> and <span class="math">\(u^{-}\)</span> notation, can be written</p>
<div class="math">
\[ u^{*}_{i,j} = (1+ 2\theta(F_x +F_y))^{-1}(\theta(
F_x
(u_{i-1,j} + u^{-}_{i,j}) +
F_y
(u_{i,j-1} + u^{-}_{i,j+1})) +
\nonumber\]</div>
<div class="math">
\[\qquad
u^{(1)}_{i,j} + \theta \Delta t f^{n+1}_{i,j}
+ (1-\theta)\Delta t f^n_{i,j} + \nonumber\]</div>
<div class="math" id="eq-diffu-2d-sor3">
\[\tag{415}
\qquad (1-\theta)(
    F_x(u^{(1)}_{i-1,j}-2u^{(1)}_{i,j} + u^{(1)}_{i+1,j}) +
    F_y(u^{(1)}_{i,j-1}-2u^{(1)}_{i,j} + u^{(1)}_{i,j+1}))),\]</div>
<div class="math" id="eq-auto171">
\[\tag{416}
u_{i,j} = \omega u^{*}_{i,j} + (1-\omega)u^{-}_{i,j}\]</div>
<p>The sequence of mesh points in <a class="reference internal" href="#eq-diffu-2d-sor3"><span class="std std-ref">(415)</span></a> is
<span class="math">\(i=1,\ldots,N_x-1\)</span>, <span class="math">\(j=1,\ldots,N_y-1\)</span> (but whether <span class="math">\(i\)</span> runs faster
or slower than <span class="math">\(j\)</span> does not matter).</p>
</div>
<div class="section" id="scalar-implementation-of-the-sor-method">
<span id="diffu-2d-sor-impl-scalar"></span><h3>Scalar implementation of the SOR method<a class="headerlink" href="#scalar-implementation-of-the-sor-method" title="Permalink to this headline">¶</a></h3>
<p>Since the Jacobi and Gauss-Seidel methods with relaxation
are so similar, we can easily make a common code for the two:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
    <span class="c"># Solve linear system by Jacobi/SOR iteration at time level n+1</span>
    <span class="n">u_</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">u_1</span>  <span class="c"># Start value</span>
    <span class="n">converged</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s">&#39;scalar&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="s">&#39;Jacobi&#39;</span><span class="p">:</span>
                <span class="n">u__</span> <span class="o">=</span> <span class="n">u_</span>
            <span class="k">elif</span> <span class="n">iteration</span> <span class="o">==</span> <span class="s">&#39;SOR&#39;</span><span class="p">:</span>
                <span class="n">u__</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0y</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_0x</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_Lx</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Boundary</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">u_new</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span> <span class="o">+</span> <span class="n">Fy</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span>
                        <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u__</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u__</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> \
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
                      <span class="n">Fx</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                      <span class="n">Fy</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>\
                      <span class="o">+</span> <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span><span class="n">j</span><span class="o">*</span><span class="n">dy</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span>
                    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">u_new</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">Ny</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
                    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_Ly</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># boundary</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="o">-</span><span class="n">u_</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">max_iter</span>
        <span class="n">u_</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>  <span class="c"># Get ready for next iteration</span>
</pre></div>
</div>
<p>The idea here is to introduce <code class="docutils literal"><span class="pre">u__</span></code> to be used for already computed
values (<code class="docutils literal"><span class="pre">u</span></code>) in the Gauss-Seidel/SOR version of the implementation, or
just values from the previous iteration (<code class="docutils literal"><span class="pre">u_</span></code>) in case of the Jacobi method.</p>
</div>
<div class="section" id="vectorized-implementation-of-the-sor-method">
<span id="diffu-2d-sor-impl-vectorized"></span><h3>Vectorized implementation of the SOR method<a class="headerlink" href="#vectorized-implementation-of-the-sor-method" title="Permalink to this headline">¶</a></h3>
<p>Vectorizing the Gauss-Seidel iteration step turns out to be non-trivial.
The problem is that vectorized operations typically imply
operations on arrays where the sequence we visit the elements in does
not matter. In particular, this principle makes vectorized code trivial to
parallelize. However, in the Gauss-Seidel algorithm the sequence we
visit the elements in the arrays does matter, and it is well known that
the basic method as explained above cannot be parallelized.
Therefore, also vectorization will require new thinking.</p>
<p id="index-11">The strategy for vectorizing (and parallelizing) the Gauss-Seidel
method is to use a special numbering of the mesh points called
red-black numbering: every other point is red or black as in a
checkerboard pattern. This numbering requires <span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span> to
be even numbers.
Here is an example of a <span class="math">\(6\times 6\)</span> mesh:</p>
<div class="highlight-text"><div class="highlight"><pre>r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
</div>
<p>The idea now is to first update all the red points. Each formula for
updating a red point involves only the black neighbors. Thereafter, we
update all the black points, and at each black point, only the
recently computed red points are involved.</p>
<p>The scalar implementation of the red-black numbered Gauss-Seidel
method is really compact, since we can update values directly in
<code class="docutils literal"><span class="pre">u</span></code> (that guarantees that we use the most recently computed
values). Here is the relevant code for the Backward Euler
scheme in time and without a source term:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Update internal points</span>
<span class="k">for</span> <span class="n">sweep</span> <span class="ow">in</span> <span class="s">&#39;red&#39;</span><span class="p">,</span> <span class="s">&#39;black&#39;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sweep</span> <span class="o">==</span> <span class="s">&#39;red&#39;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">sweep</span> <span class="o">==</span> <span class="s">&#39;black&#39;</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span> <span class="o">+</span> <span class="n">Fy</span><span class="p">))</span><span class="o">*</span><span class="p">(</span>
                     <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                     <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
</pre></div>
</div>
<p>The vectorized version must be based on slices. Looking at a typical
red-black pattern, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
b r b r b r b
r b r b r b r
</pre></div>
</div>
<p>we want to update the internal points (marking boundary points with
<code class="docutils literal"><span class="pre">x</span></code>):</p>
<div class="highlight-text"><div class="highlight"><pre>x x x x x x x
x r b r b r x
x b r b r b x
x r b r b r x
x b r b r b x
x r b r b r x
x x x x x x x
</pre></div>
</div>
<p>It is impossible to make one slice that picks out all the internal
red points. Instead, we need two slices. The first involves points
marked with <code class="docutils literal"><span class="pre">R</span></code>:</p>
<div class="highlight-text"><div class="highlight"><pre>x x x x x x x
x R b R b R x
x b r b r b x
x R b R b R x
x b r b r b x
x R b R b R x
x x x x x x x
</pre></div>
</div>
<p>This slice is specified as <code class="docutils literal"><span class="pre">1::2</span></code> for <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">1::2</span></code> for <code class="docutils literal"><span class="pre">j</span></code>, or with
<code class="docutils literal"><span class="pre">slice</span></code> objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="n">j</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The second slice involves the red points with <code class="docutils literal"><span class="pre">R</span></code>:</p>
<div class="highlight-text"><div class="highlight"><pre>x x x x x x x
x r b r b r x
x b R b R b x
x r b r b r x
x b R b R b x
x r b r b r x
x x x x x x x
</pre></div>
</div>
<p>The slices are</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="n">j</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>For the black points, the first slice involves the <code class="docutils literal"><span class="pre">B</span></code> points:</p>
<div class="highlight-text"><div class="highlight"><pre>x x x x x x x
x r B r B r x
x b r b r b x
x r B r B r x
x b r b r b x
x r B r B r x
x x x x x x x
</pre></div>
</div>
<p>with slice objects</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="n">j</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The second set of black points is shown here:</p>
<div class="highlight-text"><div class="highlight"><pre>x x x x x x x
x r b r b r x
x B r B r B x
x r b r b r x
x B r B r B x
x r b r b r x
x x x x x x x
</pre></div>
</div>
<p>with slice objects</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="n">j</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>That is, we need four sets of slices. The simplest way of implementing
the algorithm is to make a function with variables for the slices
representing <span class="math">\(i\)</span>, <span class="math">\(i-1\)</span>, <span class="math">\(i+1\)</span>, <span class="math">\(j\)</span>, <span class="math">\(j-1\)</span>, and <span class="math">\(j+1\)</span>, here called
<code class="docutils literal"><span class="pre">ic</span></code> (&#8220;i center&#8221;), <code class="docutils literal"><span class="pre">im1</span></code> (&#8220;i minus 1&#8221;, <code class="docutils literal"><span class="pre">ip1</span></code> (&#8220;i plus 1&#8221;), <code class="docutils literal"><span class="pre">jc</span></code>, <code class="docutils literal"><span class="pre">jm1</span></code>,
and <code class="docutils literal"><span class="pre">jp1</span></code>, respectively.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">):</span>
    <span class="k">return</span> \
       <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">Fx</span> <span class="o">+</span> <span class="n">Fy</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span>
           <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">ip1</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">im1</span><span class="p">,</span><span class="n">jc</span><span class="p">])</span> <span class="o">+</span>
           <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jp1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jm1</span><span class="p">]))</span> <span class="o">+</span>\
       <span class="n">u_1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
         <span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">ip1</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">im1</span><span class="p">,</span><span class="n">jc</span><span class="p">])</span> <span class="o">+</span>\
         <span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jp1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jm1</span><span class="p">]))</span><span class="o">+</span>\
         <span class="n">theta</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_np1</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> \
         <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">f_a_n</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">])</span>
</pre></div>
</div>
<p>The formula returned from <code class="docutils literal"><span class="pre">update</span></code> is to be compared with
<a class="reference internal" href="#eq-diffu-2d-sor3"><span class="std std-ref">(415)</span></a>.</p>
<p>The relaxed Jacobi iteration can be implemented by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ic</span>  <span class="o">=</span> <span class="n">jc</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="n">jm1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="n">jp1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
<span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">u_</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">)</span>
<span class="n">u</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span>
</pre></div>
</div>
<p>The Gauss-Seidel (or SOR) updates need four different steps.
The <code class="docutils literal"><span class="pre">ic</span></code> and <code class="docutils literal"><span class="pre">jc</span></code> slices are specified above. For each of these,
we must specify the corresponding <code class="docutils literal"><span class="pre">im1</span></code>, <code class="docutils literal"><span class="pre">ip1</span></code>, <code class="docutils literal"><span class="pre">jm1</span></code>, and <code class="docutils literal"><span class="pre">jp1</span></code>
slices. The code below contain the details.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Red points</span>
<span class="n">ic</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jc</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jm1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jp1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">u_new</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">)</span>

<span class="n">ic</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jc</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jm1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jp1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">u_new</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">)</span>

<span class="c"># Black points</span>
<span class="n">ic</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jc</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jm1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jp1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">u_new</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">)</span>

<span class="n">ic</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">im1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ip1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jc</span>  <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jm1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">jp1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">u_new</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span><span class="n">jc</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">u_new</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">im1</span><span class="p">,</span> <span class="n">ip1</span><span class="p">,</span> <span class="n">jc</span><span class="p">,</span> <span class="n">jm1</span><span class="p">,</span> <span class="n">jp1</span><span class="p">)</span>

<span class="c"># Relax</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">u_new</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">omega</span><span class="p">)</span><span class="o">*</span><span class="n">u_</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">solver_classic_iterative</span></code> in
<a class="reference external" href="http://tinyurl.com/nm5587k/diffu/diffu2D_u0.py">diffu2D_u0.py</a>
contains a unified implementation of the relaxed Jacobi and SOR
methods in scalar and vectorized versions using the techniques
explained above.</p>
<p>[<strong>hpl 17</strong>: Experiments with SOR, benefits. Rerun the Jacobi experiments. Just mention the most important conclusions. We can have more comprehensive experiments with comparison of all methods in a later section, after CG with preconditioning.]</p>
</div>
<div class="section" id="direct-versus-iterative-methods">
<span id="diffu-2d-direct-vs-iter"></span><h3>Direct versus iterative methods<a class="headerlink" href="#direct-versus-iterative-methods" title="Permalink to this headline">¶</a></h3>
<div class="section" id="direct-methods">
<h4>Direct methods<a class="headerlink" href="#direct-methods" title="Permalink to this headline">¶</a></h4>
<p>There are two classes of methods for solving linear systems: direct methods
and iterative methods. Direct methods are based on variants of the
Gaussian elimination procedure and will produce an exact solution (in
exact arithmetics) in an a priori known number of steps.
Iterative methods, on the other hand, produce an approximate solution,
and the amount of work for reaching a given accuracy is usually not
known.</p>
<span class="target" id="index-12"></span><p id="index-13">The most common direct method today is to use the <em>LU factorization</em>
procedure to factor the coefficient matrix <span class="math">\(A\)</span> as the product of a
lower-triangular matrix <span class="math">\(L\)</span> (with unit diagonal terms)
and an upper-triangular matrix <span class="math">\(U\)</span>:
<span class="math">\(A=LU\)</span>. As soon as we have <span class="math">\(L\)</span> and <span class="math">\(U\)</span>, a system of equations <span class="math">\(LUc=b\)</span>
is easy to solve because of the triangular nature of <span class="math">\(L\)</span> and <span class="math">\(U\)</span>. We
first solve <span class="math">\(Ly=b\)</span> for <span class="math">\(y\)</span> (forward substitution), and
thereafter we find <span class="math">\(c\)</span> from solving <span class="math">\(Uc=y\)</span> (backward
substitution).  When <span class="math">\(A\)</span> is a dense <span class="math">\(N\times N\)</span> matrix, the LU
factorization costs <span class="math">\(\frac{1}{3}N^3\)</span> arithmetic operations, while the
forward and backward substitution steps each require of
the order <span class="math">\(N^2\)</span> arithmetic operations.
That is, factorization dominates the costs, while the substitution steps are
cheap.</p>
<p>Symmetric, positive definite coefficient matrices often arise when
discretizing PDEs. In this case, the LU factorization becomes <span class="math">\(A=LL^T\)</span>,
and the associated algorithm is known as <em>Cholesky factorization</em>.
Most linear algebra software offers highly optimized implementations of
LU and Cholesky factorization as well as forward and backward
substitution (<code class="docutils literal"><span class="pre">scipy.linalg</span></code> is the relevant Python package).</p>
<p>Finite difference discretizations lead to sparse coefficient matrices.
An extreme case arose in the section <a class="reference internal" href="#diffu-pde1-be"><span class="std std-ref">Backward Euler scheme</span></a> where <span class="math">\(A\)</span> is
tridiagonal. For a tridiagonal matrix, the amount of arithmetic
operations in the LU and Cholesky factorization algorithms is just of
the order <span class="math">\(N\)</span>, not <span class="math">\(N^3\)</span>. Tridiagonal matrices are special cases of
<em>banded matrices</em>, where the matrices contain just a set of diagonal
bands.  Finite difference methods on regularly numbered rectangular
and box-shaped meshes give rise to such banded matrices, with 5 bands
in 2D and 7 in 3D for diffusion problems.  Gaussian elimination only
needs to work within the bands, leading to much more efficient
algorithms. For example, factorization of more general, sparse
matrices can often take advantage of the sparsity through modified
Gaussian elimination algorithms. The relevant Python package is
<code class="docutils literal"><span class="pre">scipy.sparse.linalg</span></code>.</p>
<p>Although a direct method is an exact algorithm, rounding errors
may in practice accumulate and pollute the solution. The effect
grows with the size of the linear system, so both for accuracy and
efficiency, iterative methods are better suited than direct methods
for solving really large linear systems.</p>
</div>
<div class="section" id="iterative-methods">
<h4>Iterative methods<a class="headerlink" href="#iterative-methods" title="Permalink to this headline">¶</a></h4>
<p>The Jacobi and SOR iterative methods belong to a class of iterative methods
where the idea is to solve <span class="math">\(Au=b\)</span> by splitting A into two parts, <span class="math">\(A=M-N\)</span>,
such that solving systems <span class="math">\(Mu=c\)</span> is easy and efficient. With the splitting,
we get a system</p>
<div class="math">
\[Mu = Nu + b,\]</div>
<p>which suggests an iterative method</p>
<div class="math">
\[Mu^{r+1} = Nu^{r} + b,\quad r=0,1,2,\ldots,\]</div>
<p>where <span class="math">\(u^{r+1}\)</span> is a new approximation to <span class="math">\(u\)</span> in the <span class="math">\(r+1\)</span>-th iteration. To
initiate the iteration, we need a start vector <span class="math">\(u^0\)</span>.</p>
<p>The Jacobi and SOR methods are based on splitting <span class="math">\(A\)</span> into a lower
tridiagonal part <span class="math">\(L\)</span>, the diagonal <span class="math">\(D\)</span>, and an upper tridiagonal part <span class="math">\(U\)</span>,
such that <span class="math">\(A=L+D+U\)</span>. The Jacobi method corresponds to <span class="math">\(M=D\)</span> and <span class="math">\(N=-L-U\)</span>.
The Gauss-Seidel method employs <span class="math">\(M=L+D\)</span> and <span class="math">\(N=-U\)</span>, while the SOR
method corresponds to</p>
<div class="math">
\[M= \frac{1}{\omega}D + L,\quad N = \frac{1-\omega}{\omega}D - U{\thinspace .}\]</div>
<p>The relaxed Jacobi method has similar expressions:</p>
<div class="math">
\[M = \frac{1}{\omega}D,\quad N = \frac{1-\omega}{\omega}D - L - U{\thinspace .}\]</div>
<p>With the matrix forms of the Jacobi and SOR methods as written above,
we could in an implementation alternatively fill the matrix <span class="math">\(A\)</span> with
entries and call general implementations of the Jacobi or SOR methods
that work on a system <span class="math">\(Au=b\)</span>. However, this is almost never done since
forming the matrix <span class="math">\(A\)</span> requires quite some code and storing <span class="math">\(A\)</span> in the
computer&#8217;s memory is unnecessary. It is much easier to just apply the
Jacobi and SOR ideas to the finite difference stencils directly in an
implementation, as we have shown in detail.</p>
<p>Nevertheless, the matrix formulation of the Jacobi and SOR methods have
been important for analyzing their convergence behavior. One can show that
the error <span class="math">\(u^r-u\)</span> fulfills <span class="math">\(u^r-u = G^r(u^0-u)\)</span>, where <span class="math">\(G=M^{-1}N\)</span>
and <span class="math">\(G^k\)</span> is a matrix exponential. For the method to converge,
<span class="math">\(\lim_{r\rightarrow\infty}||G^r||=0\)</span> is a necessary and sufficient condition.
This implies that the <em>spectral radius</em> of <span class="math">\(G\)</span> must be less than one.
Since <span class="math">\(G\)</span> is directly related to the finite difference scheme for the
underlying PDE problem, one can in principle compute the spectral radius.
For a given PDE problem, however, this is not a practical strategy, since it
is very difficult to develop useful formulas.
Analysis of model problems, usually
related to the Poisson equation,
reveals some trends of interest: the convergence rate of the Jacobi
method goes like <span class="math">\(h^2\)</span>, while that of SOR with an optimal <span class="math">\(\omega\)</span> goes
like <span class="math">\(h\)</span>, where <span class="math">\(h\)</span> is the spatial spacing: <span class="math">\(h=\Delta x=\Delta y\)</span>.
That is, the efficiency of the Jacobi method quickly deteriorates with
the increasing mesh resolution, and SOR is much to be preferred
(even if the optimal
<span class="math">\(\omega\)</span> remains an open question). We refer to
Chapter 4 of <a class="reference internal" href="._book027.html#ref5" id="id3">[Ref5]</a> for more information on the convergence theory.
One important result is that if <span class="math">\(A\)</span> is symmetric and positive definite,
then SOR will converge for any <span class="math">\(0&lt;\omega &lt;2\)</span>.</p>
<p>The optimal <span class="math">\(\omega\)</span> parameter can be theoretically established for
a Poisson problem as</p>
<div class="math" id="eq-auto172">
\[\tag{417}
\omega_{o} = \frac{2}{1 + \sqrt{1-\varrho^2}},\quad \varrho = \frac{\cos(\pi/N_x) + (\Delta x/\Delta y)^2\cos(\pi/N_y)}{1 + (\Delta x/\Delta y)^2}{\thinspace .}\]</div>
<p>This formula can be used as a guide also in other problems.</p>
<p>The Jacobi and the SOR methods have their great advantage of being
trivial to implement, so they are obviously popular of this reason.
However, the slow convergence of these methods limits the popularity to fairly
small linear systems (i.e., coarse meshes). As soon as the matrix size
grows, one is better off with more sophisticated iterative methods
like the preconditioned Conjugate gradient method, which we now turn to.</p>
<p>Finally, we mention that there is a variant of the SOR method, called
Symmetric Successive Overrelaxation method, known as SSOR, where
one runs a standard SOR sweep through the mesh points and then a
new sweep but visiting the points in reverse order.</p>
<p>[<strong>hpl 18</strong>: Line Jacobi/SOR?]</p>
</div>
</div>
<div class="section" id="the-conjugate-gradient-method">
<span id="diffu-2d-cg"></span><h3>The Conjugate gradient method<a class="headerlink" href="#the-conjugate-gradient-method" title="Permalink to this headline">¶</a></h3>
<p>There is no simple intuitive derivation of the Conjugate gradient
method, so we refer to the many excellent expositions in the
literature for the idea of the method and how the algorithm is
derived. In particular, we recommend the books
<a class="reference internal" href="._book027.html#ref6" id="id4">[Ref6]</a> <a class="reference internal" href="._book027.html#ref5" id="id5">[Ref5]</a> <a class="reference internal" href="._book027.html#ref7" id="id6">[Ref7]</a>.  A brief overview is
provided in the <a class="reference external" href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">Wikipedia article</a>. Here, we
just state the pros and cons of the method from a user&#8217;s perspective
and how we utilize it in code.</p>
<p>The original Conjugate gradient method is limited to linear systems <span class="math">\(Au=b\)</span>,
where <span class="math">\(A\)</span> is a symmetric and positive definite matrix. There are, however,
extensions of the method to non-symmetric matrices.</p>
<p id="index-14">A major advantage of all conjugate gradient methods is that the matrix
<span class="math">\(A\)</span> is only used in matrix-vector products, so we do not need form and
store <span class="math">\(A\)</span> if we can provide code for computing a matrix-vector product
<span class="math">\(Au\)</span>.  Another important feature is that the algorithm is very easy to
vectorize and parallelize.  The primary downside of the method is that
it convergences slowly unless one has an effective <em>preconditioner</em>
for the system. That is, instead of solving <span class="math">\(Au=b\)</span>, we try to solve
<span class="math">\(M^{-1}Au=M^{-1}b\)</span> in the hope that the method works better for this
<em>preconditioned</em> system. The matrix <span class="math">\(M\)</span> is the <em>preconditioner</em> or
preconditioning matrix.  Now we need to perform matrix-vector products
<span class="math">\(y = M^{-1}Au\)</span>, which is done in two steps: first the matrix-vector
product <span class="math">\(v=Au\)</span> is carried out and then the system
<span class="math">\(My=v\)</span> must be solved.
Therefore, <span class="math">\(M\)</span> must be cheap to compute and systems <span class="math">\(My=v\)</span>
must be cheap to solve.</p>
<p>A perfect preconditioner is <span class="math">\(M=A\)</span>, but in each iteration in the
Conjugate gradient method one then has so solve a system with <span class="math">\(A\)</span> as
coefficient matrix! A key idea is to let <span class="math">\(M\)</span> be some kind of <em>cheap
approximation</em> to <span class="math">\(A\)</span>.  The simplest preconditioner is to set <span class="math">\(M=D\)</span>,
where <span class="math">\(D\)</span> is the diagonal of <span class="math">\(A\)</span>. This choice means running one Jacobi
iteration as preconditioner. <a class="reference internal" href="#diffu-exer-splitting-prec"><span class="std std-ref">Exercise 3.8: Splitting methods and preconditioning</span></a>
shows that the Jacobi and SOR methods can also be viewed as
preconditioners.</p>
<p>Constructing good preconditioners is a scientific field on its
own. Here we shall treat the topic just very briefly. For a user
having access to the <code class="docutils literal"><span class="pre">scipy.sparse.linalg</span></code> library, there are
Conjugate gradient methods and preconditioners readily available:</p>
<blockquote>
<div><ul class="simple">
<li>For positive definite, symmetric systems: <code class="docutils literal"><span class="pre">cg</span></code> (the Conjugate gradient method)</li>
<li>For symmetric systems: <code class="docutils literal"><span class="pre">minres</span></code> (Minimum residual method)</li>
<li>For non-symmetric systems:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">gmres</span></code> (GMRES: Generalized minimum residual method)</li>
<li><code class="docutils literal"><span class="pre">bicg</span></code> (BiConjugate gradient method)</li>
<li><code class="docutils literal"><span class="pre">bicgstab</span></code> (Stabilized BiConjugate gradient method)</li>
<li><code class="docutils literal"><span class="pre">cgs</span></code> (Conjugate gradient squared method)</li>
<li><code class="docutils literal"><span class="pre">qmr</span></code> (Quasi-minimal residual iteration)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Preconditioner: <code class="docutils literal"><span class="pre">spilu</span></code> (Sparse, incomplete LU factorization)</li>
</ul>
</div></blockquote>
<p>The ILU preconditioner is an attractive all-round type of
preconditioner that is suitable for most problems on serial
computers. A more efficient preconditioner is the multigrid method,
and algebraic multigrid is also an all-round choice as
preconditioner. The Python package <a class="reference external" href="https://github.com/pyamg/pyamg">PyAMG</a> offers efficient implementations of
the algebraic multigrid method, to be used both as a preconditioner
and as a stand-alone iterative method.</p>
<p>The matrix arising from implicit time discretization methods of the
diffusion equation is symmetric and positive definite so we can use
the Conjugate gradient method (<code class="docutils literal"><span class="pre">cg</span></code>), typically in combination with an
ILU preconditioner.  The code is very similar to the one we created
when solving the linear system by sparse Gaussian elimination, the
main difference is that we now allow for calling up the Conjugate
gradient function as an alternative solver.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver_sparse</span><span class="p">(</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">U_0x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_0y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_Lx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_Ly</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">,</span> <span class="n">CG_prec</span><span class="o">=</span><span class="s">&#39;ILU&#39;</span><span class="p">,</span> <span class="n">CG_tol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Full solver for the model problem using the theta-rule</span>
<span class="sd">    difference approximation in time. Sparse matrix with</span>
<span class="sd">    dedicated Gaussian elimination algorithm (method=&#39;direct&#39;)</span>
<span class="sd">    or ILU preconditioned Conjugate Gradients (method=&#39;CG&#39; with</span>
<span class="sd">    tolerance CG_tol and preconditioner CG_prec (&#39;ILU&#39; or None)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Set up data structures as shown before</span>

    <span class="c"># Precompute sparse matrix</span>
    <span class="o">...</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
        <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower2</span><span class="p">,</span> <span class="n">upper2</span><span class="p">],</span>
        <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">lower_offset</span><span class="p">,</span> <span class="n">lower_offset</span><span class="p">,</span>
                 <span class="o">-</span><span class="n">lower2_offset</span><span class="p">,</span> <span class="n">lower2_offset</span><span class="p">],</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;csc&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;CG&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">CG_prec</span> <span class="o">==</span> <span class="s">&#39;ILU&#39;</span><span class="p">:</span>
            <span class="c"># Find ILU preconditioner (constant in time)</span>
            <span class="n">A_ilu</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c"># SuperLU defaults</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">matvec</span><span class="o">=</span><span class="n">A_ilu</span><span class="o">.</span><span class="n">solve</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">CG_iter</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># No of CG iterations at time level n</span>

    <span class="c"># Time loop</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">It</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c"># Compute b, vectorized version</span>

        <span class="c"># Solve matrix system A*c = b</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;direct&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;CG&#39;</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">u_1</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c"># Start vector is u_1</span>
            <span class="n">CG_iter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">CG_callback</span><span class="p">(</span><span class="n">c_k</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Trick to count the no of iterations in CG.&quot;&quot;&quot;</span>
                <span class="n">CG_iter</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">c</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cg</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">CG_tol</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">CG_callback</span><span class="p">)</span>

        <span class="c"># Fill u with vector c</span>
        <span class="c"># Update u_1 before next step</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
<p>The number of iterations in the Conjugate gradient method is of interest,
but unfortunately not available from the <code class="docutils literal"><span class="pre">cg</span></code> function, so
we perform a trick: in each iteration a user function <code class="docutils literal"><span class="pre">CG_callback</span></code>
is called where we accumulate the number of iteration in a list
<code class="docutils literal"><span class="pre">CG_iter</span></code>.</p>
</div>
</div>
<div class="section" id="random-walk">
<span id="diffu-randomwalk"></span><h2>Random walk<a class="headerlink" href="#random-walk" title="Permalink to this headline">¶</a></h2>
<p id="index-15">Models leading to diffusion equations, see the section <a class="reference internal" href="#diffu-app"><span class="std std-ref">Applications</span></a>, are
usually based on reasoning with <em>averaged</em> physical quantities such as
concentration, temperature, and velocity.  The underlying physical
processes involve complicated microscopic movement of atoms and
molecules, but an average of a large number of molecules is performed
in a small volume before the modeling starts, and the averaged
quantity inside this volume is assigned as a point value at the
centroid of the volume. This means that concentration, temperature,
and velocity at a space-time point represent averages around the
point in a small time interval and small spatial volume.</p>
<p>Random walk is a principally totally different kind of modeling procedure.
The idea is to have a large number of &#8220;particles&#8221; that undergo
random movements. Averaging can then be used afterwards to compute
macroscopic quantities like concentration. The &#8220;particles&#8221; and their
random movement represent a very simplified microscopic behavior of
molecules, much simpler and computationally much more efficient than
direct <a class="reference external" href="https://en.wikipedia.org/wiki/Molecular_dynamics">molecular simulation</a>,
yet the random walk model has been very powerful to describe a wide
range of phenomena, including heat conduction, quantum mechanics,
polymer chains, population genetics, neuroscience, hazard games, and
pricing of financial instruments.</p>
<p>It can be shown that random walk, when averaged, produces models that
are mathematically equivalent to diffusion equations. This is the
primary reason why we treat random walk in this chapter: two very
different algorithms (finite difference stencils and random walk)
solve the same type of problems. The simplicity of the random walk
algorithm makes it particularly attractive for solving diffusion
equations on massively parallel computers.</p>
<div class="section" id="random-walk-in-1d">
<span id="diffu-randomwalk-1d"></span><h3>Random walk in 1D<a class="headerlink" href="#random-walk-in-1d" title="Permalink to this headline">¶</a></h3>
<p>Imagine that we have some particles that perform random moves, either
to the right or to the left. We may flip a coin to decide the movement
of each particle, say head implies movement to the right and tail
means movement to the left. Each move is one unit length.  Physicists
use the term <em>random walk</em> for this type of movement.
The movement is also known as <a class="reference external" href="https://en.wikipedia.org/wiki/The_Drunkard%27s_Walk">drunkard&#8217;s walk</a>.
You may try this yourself: flip the coin and make one step to the left
or right, and repeat the process.</p>
<p>We introduce the symbol <span class="math">\(N\)</span> for the number of steps in a random walk.
Figure <a class="reference internal" href="#diffu-randomwalk-1d-fig-ensemble"><span class="std std-ref">Ensemble of 4 random walks, each with 200 steps</span></a> shows four different
random walks with <span class="math">\(N=200\)</span>.</p>
<div class="figure" id="id23">
<span id="diffu-randomwalk-1d-fig-ensemble"></span><a class="reference internal image-reference" href="_images/rw1D_ensemble4.png"><img alt="_images/rw1D_ensemble4.png" src="_images/rw1D_ensemble4.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Ensemble of 4 random walks, each with 200 steps</em></span></p>
</div>
</div>
<div class="section" id="statistical-considerations">
<span id="diffu-randomwalk-1d-evar"></span><h3>Statistical considerations<a class="headerlink" href="#statistical-considerations" title="Permalink to this headline">¶</a></h3>
<p>[<strong>hpl 19</strong>: Need to distinguish between scaled and unscaled position in the notation here!]</p>
<p>Let <span class="math">\(S_k\)</span> be the stochastic variable representing a step to the left
or to the right in step number <span class="math">\(k\)</span>. We have that <span class="math">\(S_k=-1\)</span> with
probability <span class="math">\(p\)</span> and <span class="math">\(S_k=1\)</span> with probability <span class="math">\(q=1-p\)</span>. The variable
<span class="math">\(S_k\)</span> is known as a <a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli variable</a>. The
expectation of <span class="math">\(S_k\)</span> is</p>
<div class="math">
\[{\hbox{E}\lbrack S_k \rbrack} = p\cdot (-1) + q\cdot 1 = 1 - 2p,\]</div>
<p>and the variance is</p>
<div class="math">
\[{\hbox{Var}\lbrack S_k \rbrack} = {\hbox{E}\lbrack S_k^2 \rbrack} - {\hbox{E}\lbrack S_k \rbrack}^2 = 1 - (1-2p)^2 = 4p(1-p){\thinspace .}\]</div>
<p>The position after <span class="math">\(k\)</span> steps is another stochastic variable</p>
<div class="math">
\[\bar X_k = \sum_{i=0}^{k-1} S_i{\thinspace .}\]</div>
<p>The expected position is</p>
<div class="math">
\[{\hbox{E}\lbrack \bar X_k \rbrack} =
{\hbox{E}\lbrack \sum_{i=0 \rbrack}^{k-1} S_i} = \sum_{i=0}^{k-1} {\hbox{E}\lbrack S_i \rbrack}= k(1-2p){\thinspace .}\]</div>
<p>All the <span class="math">\(S_k\)</span> variables are independent. The variance therefore becomes</p>
<div class="math">
\[{\hbox{Var}\lbrack \bar X_k \rbrack} = {\hbox{Var}\lbrack \sum_{i=0 \rbrack}^{k-1} S_i} = \sum_{i=0}^{k-1} {\hbox{Var}\lbrack S_i \rbrack}=
k4p(1-p){\thinspace .}\]</div>
<p>We see that <span class="math">\({\hbox{Var}\lbrack \bar X_k \rbrack}\)</span> is proportional with the number of steps <span class="math">\(k\)</span>.
For the very important case <span class="math">\(p=q=\frac{1}{2}\)</span>, <span class="math">\({\hbox{E}\lbrack \bar X_k \rbrack}=0\)</span> and
<span class="math">\({\hbox{Var}\lbrack \bar X_k \rbrack}=k\)</span>.</p>
<p>How can we estimate <span class="math">\({\hbox{E}\lbrack \bar X_k \rbrack}=0\)</span> and <span class="math">\({\hbox{Var}\lbrack \bar X_k \rbrack}=N\)</span>?
We must have many random walks of the type in
Figure <a class="reference internal" href="#diffu-randomwalk-1d-fig-ensemble"><span class="std std-ref">Ensemble of 4 random walks, each with 200 steps</span></a>. For a given <span class="math">\(k\)</span>, say <span class="math">\(k=100\)</span>,
we find all the values of <span class="math">\(\bar X_k\)</span>, name them <span class="math">\(\bar x_{0,k}\)</span>, <span class="math">\(\bar x_{1,k}\)</span>,
<span class="math">\(\bar x_{2,k}\)</span>, and so on. The empirical estimate of <span class="math">\({\hbox{E}\lbrack \bar X_k \rbrack}\)</span> is the
average,</p>
<div class="math">
\[{\hbox{E}\lbrack \bar X_k \rbrack} \approx = \frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k},\]</div>
<p>while an empirical estimate of <span class="math">\({\hbox{Var}\lbrack \bar X_k \rbrack}\)</span> is</p>
<div class="math">
\[{\hbox{Var}\lbrack \bar X_k \rbrack} \approx \frac{1}{W}\sum_{j=0}^{W-1} (\bar x_{j,k})^2 -
\left(\frac{1}{W}\sum_{j=0}^{W-1} \bar x_{j,k}\right)^2{\thinspace .}\]</div>
<p>That is, we take the statistics for a given <span class="math">\(K\)</span> across the ensemble
of random walks (&#8220;vertically&#8221; in
Figure <a class="reference internal" href="#diffu-randomwalk-1d-fig-ensemble"><span class="std std-ref">Ensemble of 4 random walks, each with 200 steps</span></a>). The key quantities
to record are <span class="math">\(\sum_i \bar x_{i,k}\)</span> and <span class="math">\(\sum_i \bar x_{i,k}^2\)</span>.</p>
</div>
<div class="section" id="playing-around-with-some-code">
<span id="diffu-randomwalk-1d-code1"></span><h3>Playing around with some code<a class="headerlink" href="#playing-around-with-some-code" title="Permalink to this headline">¶</a></h3>
<div class="section" id="scalar-code-1">
<h4>Scalar code<a class="headerlink" href="#scalar-code-1" title="Permalink to this headline">¶</a></h4>
<p>Python has a <code class="docutils literal"><span class="pre">random</span></code> module for drawing random numbers, and a function
<code class="docutils literal"><span class="pre">uniform(a,</span> <span class="pre">b)</span></code> for drawing a uniformly distributed
random number in the interval <span class="math">\([a,b)\)</span>.
If an event happens with probability <span class="math">\(p\)</span>, we can simulate this on
the computer by drawing a random number <span class="math">\(r\)</span> in <span class="math">\([0,1)\)</span>, because then <span class="math">\(r\leq p\)</span>
with probability <span class="math">\(p\)</span> and <span class="math">\(r&gt;p\)</span> with probability <span class="math">\(1-p\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
    <span class="c"># Event happens</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># Event does not happen</span>
</pre></div>
</div>
<p>A random walk with <span class="math">\(N\)</span> steps, starting at <span class="math">\(x_0\)</span>, where we move
to the left with probability <span class="math">\(p\)</span> and to the right
with probability <span class="math">\(1-p\)</span> can now be implemented by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">random_walk1D</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;1D random walk with 1 particle.&quot;&quot;&quot;</span>
    <span class="c"># Store position in step k in position[k]</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">position</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span>
    <span class="k">return</span> <span class="n">position</span>
</pre></div>
</div>
</div>
<div class="section" id="vectorized-code-2">
<span id="index-16"></span><h4>Vectorized code<a class="headerlink" href="#vectorized-code-2" title="Permalink to this headline">¶</a></h4>
<p>Since <span class="math">\(N\)</span> is supposed to be large and we want to repeat the process for
many particles, we should speed up the code as much as possible.
Vectorization is the obvious technique here: we draw all the random
numbers at once with aid of <code class="docutils literal"><span class="pre">numpy</span></code>, and then we formulate vector
operations to get rid of the loop over the steps (<code class="docutils literal"><span class="pre">k</span></code>).
The <code class="docutils literal"><span class="pre">numpy.random</span></code> module has vectorized versions of the functions in
Python&#8217;s built-in <code class="docutils literal"><span class="pre">random</span></code> module. For example, <code class="docutils literal"><span class="pre">numpy.random.uniform(a,</span> <span class="pre">b,</span> <span class="pre">N)</span></code>
returns <code class="docutils literal"><span class="pre">N</span></code> random numbers uniformly distributed between <code class="docutils literal"><span class="pre">a</span></code> (included)
and <code class="docutils literal"><span class="pre">b</span></code> (not included).</p>
<p>We can then make an array of all the steps in a random walk: if
the random number is less than or equal to <span class="math">\(p\)</span>, the step is <span class="math">\(-1\)</span>,
otherwise the step is <span class="math">\(1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The value of <code class="docutils literal"><span class="pre">position[k]</span></code> is the sum of all steps up to step <code class="docutils literal"><span class="pre">k</span></code>.
Such sums are often needed in vectorized algorithms and therefore
available by the <code class="docutils literal"><span class="pre">numpy.cumsum</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
<span class="go">array([ 1,  4,  8, 14])</span>
</pre></div>
</div>
<p>The resulting array in this demo has elements <span class="math">\(1\)</span>, <span class="math">\(1+3=4\)</span>, <span class="math">\(1+3+4=8\)</span>,
and <span class="math">\(1+3+4+6=14\)</span>.</p>
<p>We can now vectorize the <code class="docutils literal"><span class="pre">random_walk1D</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walk1D_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walk1D.&quot;&quot;&quot;</span>
    <span class="c"># Store position in step k in position[k]</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">position</span>
</pre></div>
</div>
<p>This code runs about 10 times faster than the scalar version.
With a parallel <code class="docutils literal"><span class="pre">numpy</span></code> library, the code can also automatically take
advantage of hardware for parallel computing because each of the four
array operations can be trivially parallelized.</p>
</div>
<div class="section" id="fixing-the-random-sequence">
<span id="index-17"></span><h4>Fixing the random sequence<a class="headerlink" href="#fixing-the-random-sequence" title="Permalink to this headline">¶</a></h4>
<p>During software development with random numbers it is advantageous to
always generate the same sequence of random numbers as this may help
debugging processes. To fix the sequence, we set a <em>seed</em> of the random
number generator to some chosen integer, e.g.,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Calls to <code class="docutils literal"><span class="pre">random_walk1D_vec</span></code> give positions of the particle as
depicted in Figure <a class="reference internal" href="#diffu-randomwalk-1d-code1-fig1"><span class="std std-ref">1,000 (left) and 50,000 (right) steps of a random walk</span></a>. The particle starts
at the origin and moves with <span class="math">\(p=\frac{1}{2}\)</span>. Since the seed is the same,
the plot to the left is just a magnification of the first 1/50 steps in
the plot to the right.</p>
<div class="figure" id="id24">
<span id="diffu-randomwalk-1d-code1-fig1"></span><a class="reference internal image-reference" href="_images/rw1D_1sample.png"><img alt="_images/rw1D_1sample.png" src="_images/rw1D_1sample.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>1,000 (left) and 50,000 (right) steps of a random walk</em></span></p>
</div>
</div>
<div class="section" id="verification-8">
<span id="index-18"></span><h4>Verification<a class="headerlink" href="#verification-8" title="Permalink to this headline">¶</a></h4>
<p>When we have a scalar and a vectorized code, it is always a good idea to
develop a unit test for checking that they produce the same result.
A problem in the present context is that the two versions apply to different
random number generators. For a test to be meaningful, we need to fix
the seed and use the same generator. This means that the scalar version
must either use <code class="docutils literal"><span class="pre">np.random</span></code> or have this as an option. An option
is the most flexible choice:</p>
<div class="highlight-text"><div class="highlight"><pre>import random

def random_walk1D(x0, N, p, random=random):
    ...
    r = random.uniform(0, 1)
</pre></div>
</div>
<p>Using <code class="docutils literal"><span class="pre">random=np.random</span></code>, the <code class="docutils literal"><span class="pre">r</span></code> variable gets computed
by <code class="docutils literal"><span class="pre">np.random.uniform</span></code>, and the sequence of random numbers will be
the same as in the vectorized version that employs the same generator
(given that the seed is also the same). A proper test function may be
to check that the positions in the walk are the same in the scalar and
vectorized implementations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_random_walk1D</span><span class="p">():</span>
    <span class="c"># For fixed seed, check that scalar and vectorized versions</span>
    <span class="c"># produce the same result</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="mf">0.6</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">scalar_computed</span> <span class="o">=</span> <span class="n">random_walk1D</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">vectorized_computed</span> <span class="o">=</span> <span class="n">random_walk1D_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">scalar_computed</span> <span class="o">==</span> <span class="n">vectorized_computed</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that we employ <code class="docutils literal"><span class="pre">==</span></code> for arrays with real numbers, which is normally
an inadequate test due to rounding errors, but in the present case,
all arithmetics consists of adding or subtracting one, so these operations
are expected to have no rounding errors. Comparing two <code class="docutils literal"><span class="pre">numpy</span></code> arrays
with <code class="docutils literal"><span class="pre">==</span></code> results in a boolean array, so we need to call the <code class="docutils literal"><span class="pre">all()</span></code>
method to ensure that all elements are <code class="docutils literal"><span class="pre">True</span></code>, i.e., that all elements
in the two arrays match each other pairwise.</p>
</div>
</div>
<div class="section" id="equivalence-with-diffusion">
<span id="diffu-randomwalk-1d-pde"></span><h3>Equivalence with diffusion<a class="headerlink" href="#equivalence-with-diffusion" title="Permalink to this headline">¶</a></h3>
<p id="index-19">The original random walk algorithm can be said to work with
dimensionless coordinates <span class="math">\(\bar x_i = -N + i\)</span>, <span class="math">\(i=0,1,\ldots, 2N+1\)</span>
(<span class="math">\(i\in [-N,N]\)</span>), and <span class="math">\(\bar t_n=n\)</span>, <span class="math">\(n=0,1,\ldots,N\)</span>.  A mesh with
spacings <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span> with dimensions can be introduced
by</p>
<div class="math">
\[x_i = X_0 + \bar x_i \Delta x,\quad t_n = \bar t_n\Delta t{\thinspace .}\]</div>
<p>If we implement the algorithm with dimensionless coordinates, we can just
use this rescaling to obtain the movement in a coordinate system
without unit spacings.</p>
<p>Let <span class="math">\(P^{n+1}_i\)</span> be the probability of finding the particle at mesh point
<span class="math">\(\bar x_i\)</span> at time <span class="math">\(\bar t_{n+1}\)</span>. We can reach mesh point <span class="math">\((i,n+1)\)</span> in two
ways: either coming in from the left from <span class="math">\((i-1,n)\)</span> or from the
right (<span class="math">\(i+1,n)\)</span>. Both has probability <span class="math">\(\frac{1}{2}\)</span> (if we assume
<span class="math">\(p=q=\frac{1}{2}\)</span>). The fundamental equation for <span class="math">\(P^{n+1}_i\)</span> is</p>
<div class="math" id="eq-diffu-randomwalk-1d-pde-markov">
\[\tag{418}
P^{n+1}_i = \frac{1}{2} P^{n}_{i-1} + \frac{1}{2} P^{n}_{i+1}{\thinspace .}\]</div>
<p>(This equation is easiest to understand if one looks at the random walk
as a Markov process and applies the transition probabilities, but this is
beyond scope of the present text.)</p>
<p>Subtracting <span class="math">\(P^{n}_i\)</span> from (<a class="reference internal" href="#diffu-randomwalk-1d"><span class="std std-ref">Random walk in 1D</span></a>) results
in</p>
<div class="math">
\[P^{n+1}_i - P^{n}_i = \frac{1}{2} (P^{n}_{i-1} -2P^{n}_i + \frac{1}{2} P^{n}_{i+1}){\thinspace .}\]</div>
<p>Readers who have seen the Forward Euler discretization of a 1D
diffusion equation recognize this scheme as very close to such a
discretization. We have</p>
<div class="math">
\[\frac{\partial}{\partial t}P(x_i,t_{n})
= \frac{P^{n+1}_i - P^{n}_i}{\Delta t} + {\mathcal{O}(\Delta t)},\]</div>
<p>or in dimensionless coordinates</p>
<div class="math">
\[\frac{\partial}{\partial\bar t}P(\bar x_i,\bar t_n)
\approx P^{n+1}_i - P^{n}_i{\thinspace .}\]</div>
<p>Similarly, we have</p>
<div class="math">
\[\begin{split}\frac{\partial^2}{\partial x^2}P(x_i,t_n) &amp;=
\frac{P^{n}_{i-1} -2P^{n}_i + \frac{1}{2} P^{n}_{i+1}}{\Delta x^2}
+ {\mathcal{O}(\Delta x^2)},\\
\frac{\partial^2}{\partial x^2}P(\bar x_i,\bar t_n) &amp;\approx
P^{n}_{i-1} -2P^{n}_i + \frac{1}{2} P^{n}_{i+1}{\thinspace .}\end{split}\]</div>
<p>Equation (<a class="reference internal" href="#diffu-randomwalk-1d"><span class="std std-ref">Random walk in 1D</span></a>) is therefore equivalent with
the dimensionless diffusion equation</p>
<div class="math" id="eq-diffu-randomwalk-1d-pde-dimless">
\[\tag{419}
\frac{\partial P}{\partial\bar t} = \frac{1}{2}
    \frac{\partial^2 P}{\partial \bar x^2},\]</div>
<p>or the diffusion equation</p>
<div class="math" id="eq-diffu-randomwalk-1d-pde-dim">
\[\tag{420}
\frac{\partial P}{\partial t} = D\frac{\partial^2 P}{\partial x^2},\]</div>
<p>with diffusion coefficient</p>
<div class="math">
\[D = \frac{\Delta x^2}{2\Delta t}{\thinspace .}\]</div>
<p>This derivation shows the tight link between random walk and diffusion.
If we keep track of where the particle is, and repeat the process
many times, or run the algorithms for lots of particles, the histogram
of the positions will approximate the solution of the diffusion equation
for the local probability <span class="math">\(P^n_i\)</span>.</p>
<p>Suppose all the random walks start at the origin. Then the initial
condition for the probability distribution is the Dirac delta
function <span class="math">\(\delta(x)\)</span>. The solution of <a class="reference internal" href="#eq-diffu-randomwalk-1d-pde-dimless"><span class="std std-ref">(419)</span></a>
can be shown to be</p>
<div class="math" id="eq-diffu-randomwalk-1d-pde-dimless-sol">
\[\tag{421}
\bar P(\bar x,\bar t) = \frac{1}{\sqrt{4\pi{\alpha} t}}e^{-\frac{x^2}{4{\alpha} t}},\]</div>
<p>where <span class="math">\({\alpha} = \frac{1}{2}\)</span>.</p>
</div>
<div class="section" id="implementation-of-multiple-walks">
<h3>Implementation of multiple walks<a class="headerlink" href="#implementation-of-multiple-walks" title="Permalink to this headline">¶</a></h3>
<p>Our next task is to implement an ensemble of walks (for statistics,
see the section <a class="reference internal" href="#diffu-randomwalk-1d-evar"><span class="std std-ref">Statistical considerations</span></a>) and also provide data from
the walks such that we can compute the probabilities of the positions
as introduced in the previous section. An appropriate representation
of probabilities <span class="math">\(P^n_i\)</span> are histograms (with <span class="math">\(i\)</span> along the <span class="math">\(x\)</span> axis)
for a few selected values of <span class="math">\(n\)</span>.</p>
<p>To estimate the expectation and variance of the random walks,
the section <a class="reference internal" href="#diffu-randomwalk-1d-evar"><span class="std std-ref">Statistical considerations</span></a> points to recording
<span class="math">\(\sum_j x_{j,k}\)</span> and <span class="math">\(\sum_j x_{j,k}^2\)</span>, where <span class="math">\(x_{j,k}\)</span> is the
position at time/step level <span class="math">\(k\)</span> in random walk number <span class="math">\(j\)</span>.
The histogram of positions needs the individual values <span class="math">\(x_{i,k}\)</span>
for all <span class="math">\(i\)</span> values and some selected <span class="math">\(k\)</span> values.</p>
<p>We introduce <code class="docutils literal"><span class="pre">position[k]</span></code> to hold <span class="math">\(\sum_j x_{j,k}\)</span>,
<code class="docutils literal"><span class="pre">position2[k]</span></code> to hold <span class="math">\(\sum_j (x_{j,k})^2\)</span>, and
<code class="docutils literal"><span class="pre">pos_hist[i,k]</span></code> to hold <span class="math">\(x_{i,k}\)</span>. A selection of <span class="math">\(k\)</span> values can be
specified by saying how many, <code class="docutils literal"><span class="pre">num_times</span></code>, and let them be equally
spaced through time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>
</pre></div>
</div>
<p>This is one of the few situations we want integer division (<code class="docutils literal"><span class="pre">//</span></code>) or
real division rounded to an integer.</p>
<div class="section" id="scalar-version">
<h4>Scalar version<a class="headerlink" href="#scalar-version" title="Permalink to this headline">¶</a></h4>
<p>Our scalar implementation of running <code class="docutils literal"><span class="pre">num_walks</span></code> random walks may go
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walks1D</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="o">*</span><span class="n">num_walks</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Accumulated positions**2</span>
    <span class="n">position2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">num_walks</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>
    <span class="c">#print &#39;save hist:&#39;, post_hist_times</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_walks</span><span class="p">):</span>
        <span class="n">num_times_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos_hist_times</span><span class="p">:</span>
                <span class="c">#print &#39;save, k:&#39;, k, num_times_counter, n</span>
                <span class="n">pos_hist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">num_times_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span>
                <span class="n">num_times_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c"># current_pos corresponds to step k+1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">current_pos</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">position</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_pos</span>
            <span class="n">position2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_pos</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="vectorized-version">
<h4>Vectorized version<a class="headerlink" href="#vectorized-version" title="Permalink to this headline">¶</a></h4>
<p>We have already vectorized a single random walk. The additional
challenge here is to vectorize the computation of the data for the
histogram, <code class="docutils literal"><span class="pre">pos_hist</span></code>, but given the selected steps in <code class="docutils literal"><span class="pre">pos_hist_times</span></code>,
we can find the corresponding positions by indexing with the
list <code class="docutils literal"><span class="pre">pos_hist_times</span></code>: <code class="docutils literal"><span class="pre">position[post_hist_times]</span></code>, which are to be
inserted in <code class="docutils literal"><span class="pre">pos_hist[n,:]</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walks1D_vec1</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walks1D.&quot;&quot;&quot;</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions**2</span>
    <span class="n">walk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>         <span class="c"># Positions of current walk</span>
    <span class="n">walk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_walks</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">walk</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>  <span class="c"># Positions of this walk</span>
        <span class="n">position</span>  <span class="o">+=</span> <span class="n">walk</span>
        <span class="n">position2</span> <span class="o">+=</span> <span class="n">walk</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">pos_hist</span><span class="p">[</span><span class="n">n</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">walk</span><span class="p">[</span><span class="n">pos_hist_times</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="improved-vectorized-version">
<h4>Improved vectorized version<a class="headerlink" href="#improved-vectorized-version" title="Permalink to this headline">¶</a></h4>
<p>Looking at the vectorized version above, we still have one potentially
long Python loop over <code class="docutils literal"><span class="pre">n</span></code>. Normally, <code class="docutils literal"><span class="pre">num_walks</span></code> will be much larger than <code class="docutils literal"><span class="pre">N</span></code>.
The vectorization of the loop over <code class="docutils literal"><span class="pre">N</span></code> certainly speeds up the program,
but if we think of vectorization as also a way to parallelize the code,
all the independent walks (the <code class="docutils literal"><span class="pre">n</span></code> loop) can be executed in parallel.
Therefore, we should include this loop as well in the vectorized
expressions, at the expense of using more memory.</p>
<p>We introduce the array <code class="docutils literal"><span class="pre">walks</span></code> to hold the <span class="math">\(N+1\)</span> steps of all the walks:
each row represents the steps in one walk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">walks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>  <span class="c"># Positions of each walk</span>
<span class="n">walks</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
</pre></div>
</div>
<p>Since all the steps are independent, we can just make one long
vector of enough random numbers (<code class="docutils literal"><span class="pre">N*num_walks</span></code>), translate these
numbers to <span class="math">\(\pm 1\)</span>, then we reshape the array such that the steps
of each walk are stored in the rows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">num_walks</span><span class="p">)</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>The next step is to sum up the steps in each walk. We need the
<code class="docutils literal"><span class="pre">np.cumsum</span></code> function for this, with the argument <code class="docutils literal"><span class="pre">axis=1</span></code> for
indicating a sum across the columns:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  3],</span>
<span class="go">       [ 3,  7, 12]])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal"><span class="pre">walks</span></code> can be computed by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">walks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">position</span></code> vector is the sum of all the walks. That is, we want to
sum all the rows, obtained by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">walks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding expression computes the squares of the positions.
Finally, we need to compute <code class="docutils literal"><span class="pre">pos_hist</span></code>, but that is a matter of
grabbing some of the walks (according to <code class="docutils literal"><span class="pre">pos_hist_times</span></code>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pos_hist</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">walks</span><span class="p">[:,</span><span class="n">pos_hist_times</span><span class="p">]</span>
</pre></div>
</div>
<p>The complete vectorized algorithm without any loop can now be
summarized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walks1D_vec2</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions**2</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>  <span class="c"># Positions of each walk</span>
    <span class="n">walks</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">num_walks</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">walks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">walks</span><span class="p">,</span>    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">walks</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pos_hist</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">walks</span><span class="p">[:,</span><span class="n">pos_hist_times</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
<p>What is the gain of the vectorized implementations? One important gain
is that each vectorized operation can be automatically parallelized
if one applies a parallel <code class="docutils literal"><span class="pre">numpy</span></code> library like <a class="reference external" href="http://numba.pydata.org">Numba</a>. One a single CPU, however, the speed up of the vectorized operations
is also significant. With <span class="math">\(N=1,000\)</span> and 50,000 repeated walks,
the two vectorized versions run about 25 and 18 times faster than the scalar
version, with <code class="docutils literal"><span class="pre">random_walks1D_vec1</span></code> being fastest.</p>
</div>
<div class="section" id="remark-on-vectorized-code-and-parallelization">
<h4>Remark on vectorized code and parallelization<a class="headerlink" href="#remark-on-vectorized-code-and-parallelization" title="Permalink to this headline">¶</a></h4>
<p>Our first attempt on vectorization removed the loop over the <span class="math">\(N\)</span> steps in
a single walk. However, the number of walks is usually much larger than
<span class="math">\(N\)</span>, because of the need for accurate statistics. Therefore, we should
rather remove the loop over all walks. It turns out, from our efficiency
experiments, that the function <code class="docutils literal"><span class="pre">random_walks1D_vec2</span></code> (with no loops) is
slower than <code class="docutils literal"><span class="pre">random_walks1D_vec1</span></code>. This is a bit surprising and may be
explained by less efficiency in the statements involving very large
arrays, containing all steps for all walks at once.</p>
<p>From a parallelization and improved vectorization point of view, it
would be more natural to switch the sequence of the loops in the
serial code such that the shortest loop is the outer loop:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walks1D2</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_walks</span><span class="p">)</span>
    <span class="n">num_times_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos_hist_times</span><span class="p">:</span>
            <span class="n">num_times_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">store_hist</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">store_hist</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_walks</span><span class="p">):</span>
            <span class="c"># current_pos corresponds to step k+1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">current_pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">position</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">position2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">store_hist</span><span class="p">:</span>
                <span class="n">pos_hist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">num_times_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
<p>The vectorized version of this code, where we just vectorize the
loop over <code class="docutils literal"><span class="pre">n</span></code>, becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walks1D2_vec1</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walks1D2.&quot;&quot;&quot;</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>    <span class="c"># Accumulated positions**2</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>

    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_walks</span><span class="p">)</span>
    <span class="n">current_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">num_times_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos_hist_times</span><span class="p">:</span>
            <span class="n">num_times_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">store_hist</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># Store histogram data for this k</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">store_hist</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Move all walks one step</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_walks</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">current_pos</span> <span class="o">+=</span> <span class="n">steps</span>
        <span class="n">position</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_pos</span><span class="p">)</span>
        <span class="n">position2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">current_pos</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store_hist</span><span class="p">:</span>
            <span class="n">pos_hist</span><span class="p">[:,</span><span class="n">num_times_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pos</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
<p>This function runs significantly faster than the <code class="docutils literal"><span class="pre">random_walks1D_vec1</span></code>
function above, typically 1.7 times faster. The code is also more appropriate
in a parallel computing context since each vectorized statement
can work with data of size <code class="docutils literal"><span class="pre">num_walks</span></code> over the compute units, repeated <code class="docutils literal"><span class="pre">N</span></code>
times (compared with data of size <code class="docutils literal"><span class="pre">N</span></code>, repeated <code class="docutils literal"><span class="pre">num_walks</span></code> times, in
<code class="docutils literal"><span class="pre">random_walks1D_vec1</span></code>).</p>
<p>The scalar code with switched loops, <code class="docutils literal"><span class="pre">random_walks1D2</span></code> runs a bit slower
than the original code in <code class="docutils literal"><span class="pre">random_walks1D</span></code>, so with the longest loop as
the inner loop, the vectorized function <code class="docutils literal"><span class="pre">random_walks1D2_vec1</span></code>
is almost 60 times faster than the scalar counterpart, while the
code <code class="docutils literal"><span class="pre">random_walks1D_vec2</span></code> without loops is only around 18 times faster.
Taking into account the very large arrays required by the latter function,
we end up with <code class="docutils literal"><span class="pre">random_walks1D2_vec1</span></code> as the preferred implementation.</p>
</div>
<div class="section" id="test-function">
<h4>Test function<a class="headerlink" href="#test-function" title="Permalink to this headline">¶</a></h4>
<p>During program development, it is highly recommended to carry out
computations by hand for, e.g., <code class="docutils literal"><span class="pre">N=4</span></code> and <code class="docutils literal"><span class="pre">num_walks=3</span></code>.  Normally,
this is done by executing the program with these parameters and
checking with pen and paper that the computations make sense.  The
next step is to use this test for correctness in a formal test
function.</p>
<p>First, we need to check that the simulation of multiple random walks
reproduces the results of <code class="docutils literal"><span class="pre">random_walk1D</span></code>, <code class="docutils literal"><span class="pre">random_walk1D_vec1</span></code>, and
<code class="docutils literal"><span class="pre">random_walk1D_vec2</span></code> for the first walk, if the seed is the
same. Second, we run three random walks (<code class="docutils literal"><span class="pre">N=4</span></code>) with the scalar and
the two vectorized versions and check that the returned arrays are
identical.</p>
<p>For this type of test to be successful, we must be sure that exactly
the same set of random numbers are used in the three versions, a fact
that requires the same random number generator and the same seed, of
course, but also the same sequence of computations.  This is not
obviously the case with the three <code class="docutils literal"><span class="pre">random_walk1D*</span></code> functions we
have presented. The critical issue in <code class="docutils literal"><span class="pre">random_walk1D_vec1</span></code> is that the
first random numbers are used for the first walk, the second set of
random numbers is used for the second walk and so, to be compatible
with how the random numbers are used in the function <code class="docutils literal"><span class="pre">random_walk1D</span></code>.
For the function <code class="docutils literal"><span class="pre">random_walk1D_vec2</span></code> the situation is a bit more
complicated since we generate all the random numbers at once.
However, the critical step now is the reshaping of the array returned
from <code class="docutils literal"><span class="pre">np.where</span></code>: we must reshape as <code class="docutils literal"><span class="pre">(num_walks,</span> <span class="pre">N)</span></code> to ensure that
the first <code class="docutils literal"><span class="pre">N</span></code> random numbers are used for the first walk, the next <code class="docutils literal"><span class="pre">N</span></code>
numbers are used for the second walk, and so on.</p>
<p>We arrive at the test function below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_random_walks1D</span><span class="p">():</span>
    <span class="c"># For fixed seed, check that scalar and vectorized versions</span>
    <span class="c"># produce the same result</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="c"># First, check that random_walks1D for 1 walk reproduces</span>
    <span class="c"># the walk in random_walk1D</span>
    <span class="n">num_walks</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">random_walks1D</span><span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">random_walk1D</span><span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">computed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c"># Same for vectorized versions</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">random_walks1D_vec1</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">random_walk1D_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">computed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">computed</span> <span class="o">=</span> <span class="n">random_walks1D_vec2</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">random_walk1D_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">computed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="c"># Second, check multiple walks: scalar == vectorized</span>
    <span class="n">num_walks</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">num_times</span> <span class="o">=</span> <span class="n">N</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">serial_computed</span> <span class="o">=</span> <span class="n">random_walks1D</span><span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">vectorized1_computed</span> <span class="o">=</span> <span class="n">random_walks1D_vec1</span><span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">vectorized2_computed</span> <span class="o">=</span> <span class="n">random_walks1D_vec2</span><span class="p">(</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">)</span>
    <span class="c"># positions: [0`, 1, 0, 1, 2]</span>
    <span class="c"># Can test without tolerance since everything is +/- 1</span>
    <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="s">&#39;pos2&#39;</span><span class="p">,</span> <span class="s">&#39;pos_hist&#39;</span><span class="p">,</span> <span class="s">&#39;pos_hist_times&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">serial_computed</span><span class="p">,</span>
                       <span class="n">vectorized1_computed</span><span class="p">,</span>
                       <span class="n">return_values</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s"> (serial) vs </span><span class="si">%s</span><span class="s"> (vectorized)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">msg</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">serial_computed</span><span class="p">,</span>
                       <span class="n">vectorized2_computed</span><span class="p">,</span>
                       <span class="n">return_values</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s"> (serial) vs </span><span class="si">%s</span><span class="s"> (vectorized)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="n">msg</span>
</pre></div>
</div>
<p>Such test functions are indispensable for further development of the code
as we can at any time test whether the basic computations remain correct or not.
This is particularly important in stochastic simulations since without
test functions and fixed seeds, we always experience variations from run to
run, and it can be very difficult to spot bugs through averaged statistical
quantities.</p>
</div>
</div>
<div class="section" id="demonstration-of-multiple-walks">
<h3>Demonstration of multiple walks<a class="headerlink" href="#demonstration-of-multiple-walks" title="Permalink to this headline">¶</a></h3>
<p>Assuming now that the code works, we can just scale up the number of
steps in each walk and the number of walks. The latter influences the
accuracy of the statistical estimates.  Figure
<a class="reference internal" href="#diffu-randomwalk-1d-fig-demo1-ex"><span class="std std-ref">Estimated expected value for 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</span></a> shows the impact of the number
of walks on the expectation, which should approach zero.  Figure
<a class="reference internal" href="#diffu-randomwalk-1d-fig-demo1-varx"><span class="std std-ref">Estimated variance over 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</span></a> displays the corresponding
estimate of the variance of the position, which should grow linearly
with the number of steps. It does, seemingly very accurately, but
notice that the scale on the <span class="math">\(y\)</span> axis is so much larger than for the
expectation, so irregularities due to the stochastic nature of the
process become so much less visible in the variance plots.  The
probability of finding a particle at a certain position at time (or
step) 800 is shown in Figure
<a class="reference internal" href="#diffu-randomwalk-1d-fig-demo1-histx"><span class="std std-ref">Estimated probability distribution at step 800, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</span></a>. The dashed red line is the
theoretical distribution <a class="reference internal" href="#eq-diffu-randomwalk-1d-pde-dimless-sol"><span class="std std-ref">(421)</span></a>
arising from solving the diffusion equation
<a class="reference internal" href="#eq-diffu-randomwalk-1d-pde-dimless"><span class="std std-ref">(419)</span></a> instead. As always, we realize
that one needs significantly more statistical samples to estimate a
histogram accurately than the expectation or variance.</p>
<div class="figure" id="id25">
<span id="diffu-randomwalk-1d-fig-demo1-ex"></span><a class="reference internal image-reference" href="_images/rw1D_EX_100_10000_100000_1000000.png"><img alt="_images/rw1D_EX_100_10000_100000_1000000.png" src="_images/rw1D_EX_100_10000_100000_1000000.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Estimated expected value for 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</em></span></p>
</div>
<div class="figure" id="id26">
<span id="diffu-randomwalk-1d-fig-demo1-varx"></span><a class="reference internal image-reference" href="_images/rw1D_VarX_100_10000_100000_1000000.png"><img alt="_images/rw1D_VarX_100_10000_100000_1000000.png" src="_images/rw1D_VarX_100_10000_100000_1000000.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Estimated variance over 1000 steps, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</em></span></p>
</div>
<div class="figure" id="id27">
<span id="diffu-randomwalk-1d-fig-demo1-histx"></span><a class="reference internal image-reference" href="_images/rw1D_HistX_100_10000_100000_1000000.png"><img alt="_images/rw1D_HistX_100_10000_100000_1000000.png" src="_images/rw1D_HistX_100_10000_100000_1000000.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Estimated probability distribution at step 800, using 100 walks (upper left), 10,000 (upper right), 100,000 (lower left), and 1,000,000 (lower right)</em></span></p>
</div>
</div>
<div class="section" id="ascii-visualization-of-1d-random-walk">
<span id="diffu-randomwalk-1d-avplotter"></span><h3>Ascii visualization of 1D random walk<a class="headerlink" href="#ascii-visualization-of-1d-random-walk" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-20"></span><span class="target" id="index-21"></span><p id="index-22">If we want to study (very) long time series of random walks, it can be
convenient to plot the position in a terminal window with the time axis
pointing downwards. The module <code class="docutils literal"><span class="pre">avplotter</span></code> in SciTools has a class <code class="docutils literal"><span class="pre">Plotter</span></code>
for plotting functions in the terminal window with the aid of ascii symbols
only. Below is the code required to visualize a simple random walk,
starting at the origin, and considered over
when the point <span class="math">\(x=-1\)</span> is reached. We use a spacing <span class="math">\(\Delta x = 0.05\)</span> (so
<span class="math">\(x=-1\)</span> corresponds to <span class="math">\(i=-20\)</span>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">run_random_walk</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span>   <span class="c"># Horizontal axis: 75 chars wide</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">random_step</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">*</span><span class="n">random_step</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>                  <span class="c"># Destination reached!</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="c"># Allow Ctrl+c to abort the simulation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c"># Wait for interrupt</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Interrupted by Ctrl+c&#39;</span>
            <span class="k">break</span>
</pre></div>
</div>
<p>Observe that we implement an infinite loop, but allow a smooth interrupt
of the program by <code class="docutils literal"><span class="pre">Ctrl+c</span></code> through Python&#8217;s <code class="docutils literal"><span class="pre">KeyboardInterrupt</span></code>
exception. This is a useful recipe that can be used in many occasions!</p>
<p>The output looks typically like</p>
<div class="highlight-text"><div class="highlight"><pre>             *         |
               *       |
             *         |
               *       |
             *         |
               *       |
                 *     |
               *       |
             *         |
           *           |
         *             |
       *               |
         *             |
       *               |
      *                |
    *                  |
  *                    |
*                      |
</pre></div>
</div>
<p>Positions beyond the limits of the <span class="math">\(x\)</span> axis appear with a value.
<a class="reference external" href="https://github.com/hplgit/fdm-book/blob/master/doc/.src/chapters/diffu/fig-diffu/rw_ascii.txt">A file</a> contains the complete ascii plot corresponding to the
function <code class="docutils literal"><span class="pre">run_random_walk</span></code> above.</p>
</div>
<div class="section" id="random-walk-as-a-stochastic-equation">
<span id="diffu-randomwalk-1d-ode"></span><h3>Random walk as a stochastic equation<a class="headerlink" href="#random-walk-as-a-stochastic-equation" title="Permalink to this headline">¶</a></h3>
<p id="index-23">The (dimensionless) position in a random walk, <span class="math">\(\bar X_k\)</span>, can be expressed as
a stochastic difference equation:</p>
<div class="math" id="eq-diffu-randomwalk-1d-ode-x">
\[\tag{422}
\bar X_k = \bar X_{k-1} + s, \quad x_0=0,\]</div>
<p>where <span class="math">\(s\)</span> is a <a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli variable</a>,
taking on the two values <span class="math">\(s=-1\)</span> and <span class="math">\(s=1\)</span>
with equal probability:</p>
<div class="math">
\[\hbox{P}(s=1)=\frac{1}{2},\quad \hbox{P}(s=-1)=\frac{1}{2}{\thinspace .}\]</div>
<p>The <span class="math">\(s\)</span> variable in a step is independent of the <span class="math">\(s\)</span> variable in other steps.</p>
<p>The difference equation expresses essentially the sum of independent
Bernoulli variables.  Because of the central limit theorem, <span class="math">\(X_k\)</span>,
will then be normally distributed with expectation <span class="math">\(k{\hbox{E}\lbrack s \rbrack}\)</span> and
<span class="math">\(k{\hbox{Var}\lbrack s \rbrack}\)</span>.  The expectation and variance of a Bernoulli variable with
values <span class="math">\(r=0\)</span> and <span class="math">\(r=1\)</span> are <span class="math">\(p\)</span> and <span class="math">\(p(1-p)\)</span>, respectively.
The variable <span class="math">\(s=2r-1\)</span> then has expectation
<span class="math">\(2{\hbox{E}\lbrack r \rbrack}-1=2p-1=0\)</span> and variance <span class="math">\(2^2{\hbox{Var}\lbrack r \rbrack}=4p(1-p)=1\)</span>.  The position
<span class="math">\(X_k\)</span> is normally distributed with zero expectation and variance <span class="math">\(k\)</span>,
as we found in the section <a class="reference internal" href="#diffu-randomwalk-1d-evar"><span class="std std-ref">Statistical considerations</span></a>.</p>
<p>The central limit theorem tells that as long as <span class="math">\(k\)</span> is not small,
the distribution of <span class="math">\(X_k\)</span> remains the same if
we replace the Bernoulli variable <span class="math">\(s\)</span> by any other stochastic variable with
the same expectation and variance. In particular, may let <span class="math">\(s\)</span> be a
standardized Gaussian variable (zero mean, unit variance).</p>
<p>Dividing <a class="reference internal" href="#eq-diffu-randomwalk-1d-ode-x"><span class="std std-ref">(422)</span></a> by <span class="math">\(\Delta t\)</span> gives</p>
<div class="math">
\[\frac{\bar X_k - \bar X_{k-1}}{\Delta t} = \frac{1}{\Delta t} s{\thinspace .}\]</div>
<p>In the limit <span class="math">\(\Delta t\rightarrow 0\)</span>, <span class="math">\(s/\Delta t\)</span> approaches a white noise
stochastic process (<span class="math">\(s\)</span> is standardized Gaussian variable).
With <span class="math">\(\bar X(t)\)</span> as the continuous process in the limit
<span class="math">\(\Delta t\rightarrow 0\)</span> (<span class="math">\(X_k\rightarrow X(t_k)\)</span>),
we formally get the stochastic differential equation</p>
<span class="target" id="index-24"></span><span class="target" id="index-25"></span><div class="math" id="eq-auto173">
<span id="index-26"></span>\[\tag{423}
d\bar X = dW,\]</div>
<p>where <span class="math">\(W(t)\)</span> is a <a class="reference external" href="https://en.wikipedia.org/wiki/Wiener_process">Wiener process</a>. Then <span class="math">\(X\)</span> is also a
Wiener process. It follows from the stochastic ODE <span class="math">\(dX=dW\)</span> that the
probability distribution of <span class="math">\(X\)</span> is given by the <a class="reference external" href="https://en.wikipedia.org/wiki/Fokker-Planck_equation">Fokker-Planck
equation</a>
<a class="reference internal" href="#eq-diffu-randomwalk-1d-pde-dimless"><span class="std std-ref">(419)</span></a>.  In other words, the key
results for random walk we found earlier can alternatively be
derived via a stochastic ordinary differential equation and its
related Fokker-Planck equation.</p>
</div>
<div class="section" id="random-walk-in-2d">
<h3>Random walk in 2D<a class="headerlink" href="#random-walk-in-2d" title="Permalink to this headline">¶</a></h3>
<p>The most obvious generalization of 1D random walk to two spatial
dimensions is to allow movements to the north, east, south, and west,
with equal probability <span class="math">\(\frac{1}{4}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walk2D</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;2D random walk with 1 particle and N moves: N, E, W, S.&quot;&quot;&quot;</span>
    <span class="c"># Store position in step k in position[k]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mf">0.25</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c"># Move north</span>
        <span class="k">elif</span> <span class="mf">0.25</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>   <span class="c"># Move east</span>
        <span class="k">elif</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mf">0.75</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c"># Move south</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_pos</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c"># Move west</span>
        <span class="n">position</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">current_pos</span>
    <span class="k">return</span> <span class="n">position</span>
</pre></div>
</div>
<p>The left plot in Figure <a class="reference internal" href="#diffu-randomwalk-2d-fig-rect-vs-diag"><span class="std std-ref">Random walks in 2D with 200 steps: rectangular mesh (left) and diagonal mesh (right)</span></a> provides
an example on 200 steps with this kind of walk. We may refer to this walk
as a walk on a <em>rectangular mesh</em> as we move from any spatial
mesh point <span class="math">\((i,j)\)</span> to one of its four neighbors in the rectangular directions:
<span class="math">\((i+1,j)\)</span>, <span class="math">\((i-1,j)\)</span>, <span class="math">\((i,j+1)\)</span>, or <span class="math">\((i,j-1)\)</span>.</p>
<div class="figure" id="id28">
<span id="diffu-randomwalk-2d-fig-rect-vs-diag"></span><a class="reference internal image-reference" href="_images/rw2D_sample200.png"><img alt="_images/rw2D_sample200.png" src="_images/rw2D_sample200.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Random walks in 2D with 200 steps: rectangular mesh (left) and diagonal mesh (right)</em></span></p>
</div>
</div>
<div class="section" id="random-walk-in-any-number-of-space-dimensions">
<h3>Random walk in any number of space dimensions<a class="headerlink" href="#random-walk-in-any-number-of-space-dimensions" title="Permalink to this headline">¶</a></h3>
<p>From a programming point of view, especially when implementing a random
walk in any number of dimensions, it is more natural to consider a walk
in the diagonal directions NW, NE, SW, and SE. On a two-dimensional spatial mesh
it means that we go from <span class="math">\((i,j)\)</span> to either <span class="math">\((i+1,j+1)\)</span>, <span class="math">\((i-1,j+1)\)</span>,
<span class="math">\((i+1,j-1)\)</span>, or <span class="math">\((i-1,j-1)\)</span>. We can with such a <em>diagonal mesh</em>
(see right plot in Figure <a class="reference internal" href="#diffu-randomwalk-2d-fig-rect-vs-diag"><span class="std std-ref">Random walks in 2D with 200 steps: rectangular mesh (left) and diagonal mesh (right)</span></a>)
draw a Bernoulli variable for the step in each spatial direction and
trivially write code that works in any number of spatial directions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walkdD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Any-D (diagonal) random walk with 1 particle and N moves.&quot;&quot;&quot;</span>
    <span class="c"># Store position in step k in position[k]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">current_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">position</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">current_pos</span>
    <span class="k">return</span> <span class="n">position</span>
</pre></div>
</div>
<p>A vectorized version is desired. We follow the ideas from the section <a class="reference internal" href="#diffu-randomwalk-1d-code1"><span class="std std-ref">Playing around with some code</span></a>, but each step is now a vector in <span class="math">\(d\)</span>
spatial dimensions. We therefore need to draw <span class="math">\(Nd\)</span> random numbers in <code class="docutils literal"><span class="pre">r</span></code>,
compute steps in the various directions through <code class="docutils literal"><span class="pre">np.where(r</span> <span class="pre">&lt;=p,</span> <span class="pre">-1,</span> <span class="pre">1)</span></code>
(each step being <span class="math">\(-1\)</span> or <span class="math">\(1\)</span>),
and then we can reshape this array to an <span class="math">\(N\times d\)</span> array of step
<em>vectors</em>. Doing an <code class="docutils literal"><span class="pre">np.cumsum</span></code> summation along axis 0 will add
the vectors, as this demo shows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 0,  1],</span>
<span class="go">       [ 2,  4],</span>
<span class="go">       [ 6,  9]])</span>
</pre></div>
</div>
<p>With such summation of step vectors, we get all the positions to be
filled in the <code class="docutils literal"><span class="pre">position</span></code> array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walkdD_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walkdD.&quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="c"># Store position in step k in position[k]</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">position</span>
</pre></div>
</div>
<div class="figure" id="id29">
<span id="diffu-randomwalk-2d-fig-samples"></span><a class="reference internal image-reference" href="_images/rw2D_samples_5000.png"><img alt="_images/rw2D_samples_5000.png" src="_images/rw2D_samples_5000.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Four random walks with 5000 steps in 2D</em></span></p>
</div>
</div>
<div class="section" id="multiple-random-walks-in-any-number-of-space-dimensions">
<h3>Multiple random walks in any number of space dimensions<a class="headerlink" href="#multiple-random-walks-in-any-number-of-space-dimensions" title="Permalink to this headline">¶</a></h3>
<p>As we did in 1D, we extend one single walk to a number of walks (<code class="docutils literal"><span class="pre">num_walks</span></code>
in the code).</p>
<div class="section" id="scalar-code-2">
<h4>Scalar code<a class="headerlink" href="#scalar-code-2" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walksdD</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate num_walks random walks from x0 with N steps.&quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>   <span class="c"># Accumulated positions</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>   <span class="c"># Accumulated positions**2</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_walks</span><span class="p">):</span>
        <span class="n">num_times_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pos_hist_times</span><span class="p">:</span>
                <span class="n">pos_hist</span><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">num_times_counter</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">current_pos</span>
                <span class="n">num_times_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c"># current_pos corresponds to step k+1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">current_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">current_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">position</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">current_pos</span>
            <span class="n">position2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">current_pos</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="vectorized-code-3">
<h4>Vectorized code<a class="headerlink" href="#vectorized-code-3" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">random_walksdD_vec</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_walks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vectorized version of random_walks1D; no loops.&quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>  <span class="c"># Accumulated positions</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>  <span class="c"># Accumulated positions**2</span>
    <span class="n">walks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>  <span class="c"># Positions of each walk</span>
    <span class="n">walks</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="c"># Histogram at num_times selected time points</span>
    <span class="n">pos_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">num_times</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">pos_hist_times</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="o">//</span><span class="n">num_times</span><span class="p">)</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">)]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="o">*</span><span class="n">num_walks</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_walks</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">walks</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">position</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">walks</span><span class="p">,</span>    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">position2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">walks</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pos_hist</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">walks</span><span class="p">[:,</span><span class="n">pos_hist_times</span><span class="p">,:]</span>
    <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">position2</span><span class="p">,</span> <span class="n">pos_hist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_hist_times</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="applications">
<span id="diffu-app"></span><h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 20</strong>: Remaining: comment on boundary conditions for diffusion of substance and heat conduction (include Robin/cooling).]</p>
<div class="section" id="diffusion-of-a-substance">
<span id="diffu-app-substance"></span><h3>Diffusion of a substance<a class="headerlink" href="#diffusion-of-a-substance" title="Permalink to this headline">¶</a></h3>
<p>The first process to be considered is a substance that gets transported
through a fluid at rest by pure diffusion. We consider an arbitrary
volume <span class="math">\(V\)</span> of this fluid, containing the substance with concentration
function <span class="math">\(c(\boldsymbol{x},t)\)</span>. Physically, we can think of a
very small volume with centroid <span class="math">\(\boldsymbol{x}\)</span> at time <span class="math">\(t\)</span> and assign the ratio
of the volume of the substance and the total volume to <span class="math">\(c(\boldsymbol{x}, t)\)</span>.
This means that the mass of the substance in a
small volume <span class="math">\(\Delta V\)</span> is approximately
<span class="math">\(\varrho c\Delta V\)</span>, where <span class="math">\(\varrho\)</span> is the density
of the substance. Consequently, the total mass of the substance inside the volume
<span class="math">\(V\)</span> is the sum of all <span class="math">\(\varrho c\Delta V\)</span>, which becomes the
volume integral <span class="math">\(\int_V\varrho cdV\)</span>.</p>
<p>Let us reason how the mass of the substance changes and thereby derive
a PDE governing the concentration <span class="math">\(c\)</span>.
Suppose the substance flows out of <span class="math">\(V\)</span> with a flux <span class="math">\(\boldsymbol{q}\)</span>.
If <span class="math">\(\Delta S\)</span> is a small part of the boundary <span class="math">\(\partial V\)</span> of <span class="math">\(V\)</span>,
the volume of the substance flowing out through <span class="math">\(dS\)</span> in a small
time interval <span class="math">\(\Delta t\)</span> is <span class="math">\(\varrho \boldsymbol{q}\cdot\boldsymbol{n} \Delta t \Delta S\)</span>,
where <span class="math">\(\boldsymbol{n}\)</span> is an outward unit
normal to the boundary <span class="math">\(\partial V\)</span>, see Figure <a class="reference internal" href="#diffu-app-substance-fig1"><span class="std std-ref">An arbitrary volume of a fluid</span></a>.
We realize that only the normal component of <span class="math">\(\boldsymbol{q}\)</span> is able to transport mass
in and out of <span class="math">\(V\)</span>.
The total outflow of the mass of the substance in a small time interval
<span class="math">\(\Delta t\)</span> becomes the surface integral</p>
<div class="math">
\[\int\limits_{\partial V} \varrho\boldsymbol{q}\cdot\boldsymbol{n} \Delta t\,  dS{\thinspace .}\]</div>
<p>Assuming conservation of mass, this outflow of mass must be balanced by
a loss of mass inside the volume. The increase of mass inside the volume,
during a small time interval <span class="math">\(\Delta t\)</span>, is</p>
<div class="math">
\[\int\limits_V \varrho (c(\boldsymbol{x},t+\Delta t) - c(\boldsymbol{x},t)) dV,\]</div>
<p>assuming <span class="math">\(\varrho\)</span> is constant, which is reasonable.</p>
<p>Setting the two contributions equal to each other ensures balance of
mass inside <span class="math">\(V\)</span>. Dividing by <span class="math">\(\Delta t\)</span> gives</p>
<div class="math">
\[\int\limits_V \varrho \frac{c(\boldsymbol{x},t+\Delta t) - c(\boldsymbol{x},t)}{\Delta t} dV =
- \int\limits_{\partial V} \varrho\boldsymbol{q}\cdot\boldsymbol{n}\, dS{\thinspace .}\]</div>
<p>Note the minus sign on the right-hand side: the left-hand side expresses
loss of mass, while the integral on the right-hand side is the gain of
mass.</p>
<p>Now, letting <span class="math">\(\Delta t\rightarrow 0\)</span>, we have</p>
<div class="math">
\[\frac{c(\boldsymbol{x},t+\Delta t) - c(\boldsymbol{x},t)}{\Delta t} \rightarrow
\frac{\partial c}{\partial t},\]</div>
<p>so</p>
<div class="math" id="eq-diffu-app-substance-integral">
\[\tag{424}
\int\limits_V \varrho \frac{\partial c}{\partial t}dV +
    \int\limits_{\partial V} \varrho\boldsymbol{q}\cdot\boldsymbol{n}\, dS = 0{\thinspace .}\]</div>
<p>To arrive at a PDE,
we express the surface integral as a volume integral using Gauss&#8217;
divergence theorem:</p>
<div class="math">
\[\int\limits_V (\varrho \frac{\partial c}{\partial t} +
\nabla\cdot(\varrho \boldsymbol{q}))dV = 0{\thinspace .}\]</div>
<p>Since <span class="math">\(\varrho\)</span> is constant, we can divide by this quantity.
If the integral is to vanish for an arbitrary volume <span class="math">\(V\)</span>,
the integrand must vanish too,
and we get the mass conservation PDE for the substance:</p>
<div class="math" id="eq-diffu-app-substance-massconv">
\[\tag{425}
\frac{\partial c}{\partial t} +
    \nabla\cdot \boldsymbol{q} = 0{\thinspace .}\]</div>
<div class="figure" id="id30">
<span id="diffu-app-substance-fig1"></span><a class="reference internal image-reference" href="_images/continuum.png"><img alt="_images/continuum.png" src="_images/continuum.png" style="width: 200px;" /></a>
<p class="caption"><span class="caption-text"><em>An arbitrary volume of a fluid</em></span></p>
</div>
<p>A fundamental problem is that this is a scalar PDE for four unknowns:
<span class="math">\(c\)</span> and the three components of <span class="math">\(\boldsymbol{q}\)</span>. We therefore need additional
equations. Here, Fick&#8217;s law comes at rescue: it models how the flux <span class="math">\(\boldsymbol{q}\)</span>
of the substance is related to the concentration <span class="math">\(c\)</span>. Diffusion is
recognized by mass flowing from regions with high concentration to regions
of low concentration. This principle suggests that <span class="math">\(\boldsymbol{q}\)</span> is proportional
to the negative gradient of <span class="math">\(c\)</span>:</p>
<div class="math" id="eq-diffu-app-substance-fick">
\[\tag{426}
\boldsymbol{q} = -{\alpha}\nabla c,\]</div>
<p>where <span class="math">\({\alpha}\)</span> is an empirically determined constant.
The relation <a class="reference internal" href="#eq-diffu-app-substance-fick"><span class="std std-ref">(426)</span></a> is known as Fick&#8217;s law.
Inserting <a class="reference internal" href="#eq-diffu-app-substance-fick"><span class="std std-ref">(426)</span></a> in
<a class="reference internal" href="#eq-diffu-app-substance-massconv"><span class="std std-ref">(425)</span></a> gives a scalar PDE for the
concentration <span class="math">\(c\)</span>:</p>
<div class="math" id="eq-diffu-app-substance-pde">
\[\tag{427}
\frac{\partial c}{\partial t} = {\alpha}\nabla^2 c{\thinspace .}\]</div>
</div>
<div class="section" id="heat-conduction">
<span id="diffu-app-heat"></span><h3>Heat conduction<a class="headerlink" href="#heat-conduction" title="Permalink to this headline">¶</a></h3>
<p>Heat conduction is a well-known diffusion process. The governing PDE
is in this case based on the first law of thermodynamics: the increase
in energy of a system is equal to the work done on the system, plus the
supplied heat. Here, we shall media at rest and neglect the work done
on the system. The principle then reduces to a balance between
increase in internal energy and the supplied heat flow by conduction.</p>
<p>Let <span class="math">\(e(x,t)\)</span> be the <em>internal energy</em> per unit mass. The increase of
the internal energy in a small volume <span class="math">\(\Delta V\)</span> in a small time
interval <span class="math">\(\Delta t\)</span> is then</p>
<div class="math">
\[\varrho (e(\boldsymbol{x},t+\Delta t) - e(\boldsymbol{x},t))\Delta V,\]</div>
<p>where <span class="math">\(\varrho\)</span> is the density of the material subject to heat conduction.
In an arbitrary volume <span class="math">\(V\)</span>, as depicted in
Figure <a class="reference internal" href="#diffu-app-substance-fig1"><span class="std std-ref">An arbitrary volume of a fluid</span></a>, the corresponding increase in internal
energy becomes the volume integral</p>
<div class="math">
\[\int\limits_V \varrho (e(\boldsymbol{x},t+\Delta t) - e(\boldsymbol{x},t))dV{\thinspace .}\]</div>
<p>This increase in internal energy is balanced by heat supplied by
conduction. Let <span class="math">\(\boldsymbol{q}\)</span> be the heat flow per time unit. Through the
surface <span class="math">\(\partial V\)</span> of <span class="math">\(V\)</span> the following amount of heat flows out
of <span class="math">\(V\)</span> during a time interval <span class="math">\(\Delta t\)</span>:</p>
<div class="math">
\[\int\limits_{\partial V} \boldsymbol{q}\cdot\boldsymbol{n}\Delta t\, dS{\thinspace .}\]</div>
<p>The simplified version of the first law of thermodynamics then states that</p>
<div class="math">
\[\int\limits_V \varrho (e(\boldsymbol{x},t+\Delta t) - e(\boldsymbol{x},t))dV = -
\int\limits_{\partial V} \boldsymbol{q}\cdot\boldsymbol{n}\Delta t\, dS{\thinspace .}\]</div>
<p>The minus sign on the right-hand side ensures that the integral there
models net <em>inflow</em> of heat (since <span class="math">\(\boldsymbol{n}\)</span> is an outward unit normal,
<span class="math">\(\boldsymbol{q}\cdot\boldsymbol{n}\)</span> models <em>outflow</em>).
Dividing by <span class="math">\(\Delta t\)</span> and notifying that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\frac{e(\boldsymbol{x},t+\Delta t) - e(\boldsymbol{x},t)}{\Delta t} =
\frac{\partial e}{\partial t},\]</div>
<p>we get (in the limit <span class="math">\(\Delta t\rightarrow 0\)</span>)</p>
<div class="math">
\[\int\limits_V \varrho \frac{\partial e}{\partial t} dV +
\int\limits_{\partial V} \boldsymbol{q}\cdot\boldsymbol{n}\Delta t\, dS = 0{\thinspace .}\]</div>
<p>This is the integral equation for heat conduction, but we aim at a PDE.
The next step is therefore to transform the surface integral to a
volume integral via Gauss&#8217; divergence theorem. The result is</p>
<div class="math">
\[\int\limits_V\left( \varrho \frac{\partial e}{\partial t}
+ \nabla\cdot\boldsymbol{q}\right) dV = 0{\thinspace .}\]</div>
<p>If this equality is to hold for all volumes <span class="math">\(V\)</span>, the integrand must vanish,
and we have the PDE</p>
<div class="math" id="eq-diffu-app-heat-pde1">
\[\tag{428}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\boldsymbol{q}{\thinspace .}\]</div>
<p>Sometimes the supplied heat can come from the medium itself. This is
the case, for instance, when radioactive rock generates heat.
Let us add this effect. If <span class="math">\(f(\boldsymbol{x},t)\)</span> is the supplied heat
per unit volume per unit time, the heat supplied in a small volume
is <span class="math">\(f\Delta t\Delta V\)</span>, and inside an arbitrary volume <span class="math">\(V\)</span> the
supplied generated heat becomes</p>
<div class="math">
\[\int\limits_V f\Delta t dV{\thinspace .}\]</div>
<p>Adding this to the integral statement of the (simplified) first law of
thermodynamics, and continuing the derivation, leads to the PDE</p>
<div class="math" id="eq-diffu-app-heat-pde2">
\[\tag{429}
\varrho \frac{\partial e}{\partial t} = -\nabla\cdot\boldsymbol{q} + f{\thinspace .}\]</div>
<p>There are four unknown scalar fields: <span class="math">\(e\)</span> and <span class="math">\(\boldsymbol{q}\)</span>. Moreover, the
temperature <span class="math">\(T\)</span>, which is our primary quantity to compute, does not
enter the model yet. We need an additional equation, called the
<em>equation of state</em>, relating <span class="math">\(e\)</span>, <span class="math">\(V=1/\varrho=\)</span>, and <span class="math">\(T\)</span>:
<span class="math">\(e=e(V,T)\)</span>. By the chain rule we have</p>
<div class="math">
\[\frac{\partial e}{\partial t} =
\left.\frac{\partial e}{\partial T}\right\vert_{V}
\frac{\partial T}{\partial t} +
\left.\frac{\partial e}{\partial V}\right\vert_{T}
\frac{\partial V}{\partial t}{\thinspace .}\]</div>
<p>The first coefficient <span class="math">\(\partial e/\partial T\)</span> is called <em>specific heat
capacity at constant volume</em>, denoted by <span class="math">\(c_v\)</span>:</p>
<div class="math">
\[c_v = \left.\frac{\partial e}{\partial T}\right\vert_{V}{\thinspace .}\]</div>
<p>The specific heat capacity will in general vary with <span class="math">\(T\)</span>, but taking it as a
constant is a good approximation in many applications.</p>
<p>The term <span class="math">\(\partial e/\partial V\)</span> models effects due to compressibility
and volume expansion. These effects are often small and can be neglected.
We shall do so here. Using <span class="math">\(\partial e/\partial t = c_v\partial T/\partial t\)</span>
in the PDE gives</p>
<div class="math">
\[\varrho c_v\frac{\partial T}{\partial t} = -\nabla\cdot\boldsymbol{q} + f{\thinspace .}\]</div>
<p>We still have four unknown scalar fields (<span class="math">\(T\)</span> and <span class="math">\(\boldsymbol{q}\)</span>). To close the
system, we need a relation between the heat flux <span class="math">\(\boldsymbol{q}\)</span> and the temperature <span class="math">\(T\)</span>
called Fourier&#8217;s law:</p>
<div class="math">
\[\boldsymbol{q} = -k\nabla T,\]</div>
<p>which simply states that heat flows from hot to cold areas, along the
path of greatest variation. In a solid medium, <span class="math">\(k\)</span> depends on the
material of the medium, and in multi-material media one must regard
<span class="math">\(k\)</span> as spatially dependent. In a fluid, it is common to assume that
<span class="math">\(k\)</span> is a constant. The value of <span class="math">\(k\)</span> reflects how easy heat is
conducted through the medium, and <span class="math">\(k\)</span> is named the <em>coefficient of
heat conduction</em>.</p>
<p>We have now one scalar PDE for the unknown temperature field <span class="math">\(T(\boldsymbol{x},t)\)</span>:</p>
<div class="math" id="eq-diffu-app-heat-pde">
\[\tag{430}
\varrho  c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T) + f{\thinspace .}\]</div>
</div>
<div class="section" id="development-of-flow-between-two-flat-plates">
<span id="diffu-app-couette"></span><h3>Development of flow between two flat plates<a class="headerlink" href="#development-of-flow-between-two-flat-plates" title="Permalink to this headline">¶</a></h3>
<p>Diffusion equations may also arise as simplified versions of other
mathematical models, especially in fluid flow. Consider a fluid flowing
between two flat, parallel plates. The velocity is uni-directional, say
along the <span class="math">\(z\)</span> axis, and depends
only on the distance <span class="math">\(x\)</span> from the plates; <span class="math">\(\boldsymbol{u} = u(x,t)\boldsymbol{k}\)</span>.
The flow is governed by the Navier-Stokes equations,</p>
<div class="math">
\[\begin{split}\varrho\frac{\partial\boldsymbol{u}}{\partial t} + \varrho\boldsymbol{u}\cdot\nabla\boldsymbol{u} &amp;= -\nabla p
+ \mu\nabla^2\boldsymbol{u} + \varrho\boldsymbol{f},\\
\nabla\cdot\boldsymbol{u} &amp;= 0,\end{split}\]</div>
<p>where <span class="math">\(p\)</span> is the pressure field, unknown along with the velocity <span class="math">\(\boldsymbol{u}\)</span>,
<span class="math">\(\varrho\)</span> is the fluid density, <span class="math">\(\mu\)</span> the dynamic viscosity, and <span class="math">\(\boldsymbol{f}\)</span>
is some external body force. The geometric restrictions of flow between
two flat plates puts restrictions on the velocity, <span class="math">\(\boldsymbol{u} = u(x,t)\boldsymbol{i}\)</span>,
and the <span class="math">\(z\)</span> component of the Navier-Stokes equations collapses to
a diffusion equation:</p>
<div class="math">
\[\varrho\frac{\partial u}{\partial t} = - \frac{\partial p}{\partial z} +
\mu\frac{\partial^2 u}{\partial z^2}
+ \varrho f_z,\]</div>
<p>if <span class="math">\(f_z\)</span> is the component of <span class="math">\(\boldsymbol{f}\)</span> in the <span class="math">\(z\)</span> direction.</p>
<p>The boundary conditions are derived from the fact that the fluid sticks to
the plates, which means <span class="math">\(\boldsymbol{u}=0\)</span> at the plates. Say the location of the
plates are <span class="math">\(z=0\)</span> and <span class="math">\(z=L\)</span>. We then have</p>
<div class="math">
\[u(0,t)=u(L,t)=0{\thinspace .}\]</div>
<p>One can easily show that <span class="math">\(\partial p/\partial z\)</span> must be a constant or
just a function of time <span class="math">\(t\)</span>. We set <span class="math">\(\partial p/\partial z = -\beta(t)\)</span>.
The body force could be a component of gravity, if desired, set as
<span class="math">\(f_z = \gamma g\)</span>. Switching from <span class="math">\(z\)</span> to <span class="math">\(x\)</span> as independent variable gives
a very standard one-dimensional diffusion equation:</p>
<div class="math">
\[\varrho\frac{\partial u}{\partial t} =
\mu\frac{\partial^2 u}{\partial z^2} + \beta(t) + \varrho\gamma g,\quad
x\in [0,L],\ t\in (0,T]{\thinspace .}\]</div>
<p>The boundary conditions are</p>
<div class="math">
\[u(0,t)=u(L,t)=0,\]</div>
<p>while some initial condition</p>
<div class="math">
\[u(x,0) = I(x)\]</div>
<p>must also be prescribed.</p>
<p>The flow is driven by either the pressure gradient <span class="math">\(\beta\)</span> or gravity, or
a combination of both. One may also consider one moving plate that
drives the fluid. If the plate at <span class="math">\(x=L\)</span> moves with velocity <span class="math">\(U_L(t)\)</span>, we have
the adjusted boundary condition</p>
<div class="math">
\[u(L,t) = U_L(t){\thinspace .}\]</div>
<p>[<strong>hpl 21</strong>: Exercises based on this diffusion model.]</p>
</div>
<div class="section" id="flow-in-a-straight-tube">
<span id="diffu-app-pipeflow"></span><h3>Flow in a straight tube<a class="headerlink" href="#flow-in-a-straight-tube" title="Permalink to this headline">¶</a></h3>
<p>Now we consider viscous fluid flow in a straight tube with radius <span class="math">\(R\)</span>
and rigid walls.
The governing equations are the Navier-Stokes equations, but as
in the section <a class="reference internal" href="#diffu-app-couette"><span class="std std-ref">Development of flow between two flat plates</span></a>, it is natural to assume that the
velocity is directed along the tube, and that it is axi-symmetric.
These assumptions reduced the velocity field to <span class="math">\(\boldsymbol{u} = u(r,x,t)\boldsymbol{i}\)</span>, if the
<span class="math">\(x\)</span> axis is directed along the tube. From the equation of continuity,
<span class="math">\(\nabla\cdot\boldsymbol{u} = 0\)</span>, we see that <span class="math">\(u\)</span> must be independent of <span class="math">\(x\)</span>.
Inserting <span class="math">\(\boldsymbol{u} = u(r,t)\boldsymbol{i}\)</span> in the Navier-Stokes equations, expressed
in axi-symmetric cylindrical coordinates, results in</p>
<div class="math" id="eq-diffu-app-pipeflow-pde">
\[\tag{431}
\varrho\frac{\partial u}{\partial t} =
    \mu\frac{1}{r}\frac{\partial}{\partial r}\left(
    r\frac{\partial u}{\partial r}\right) + \beta(t) + \varrho\gamma g,\quad
    r\in [0,R],\ t\in (0,T]{\thinspace .}\]</div>
<p>Here, <span class="math">\(\beta(t) = -\partial p/\partial x\)</span> is the pressure gradient along
the tube. The associated boundary condition is <span class="math">\(u(R,t)=0\)</span>.</p>
</div>
<div class="section" id="tribology-thin-film-fluid-flow">
<h3>Tribology: thin film fluid flow<a class="headerlink" href="#tribology-thin-film-fluid-flow" title="Permalink to this headline">¶</a></h3>
<p>Thin fluid films are extremely important inside machinery to reduce friction
between gliding surfaces. The mathematical model for the fluid motion takes
the form of a diffusion problem and is quickly derived here.
We consider two solid surfaces whose distance is described by a
gap function <span class="math">\(h(x,y)\)</span>. The space between these surfaces is filled with
a fluid with dynamic viscosity <span class="math">\(\mu\)</span>. The fluid may move partially
because of pressure gradients and partially because the surfaces
move. Let <span class="math">\(U\boldsymbol{i} + V\boldsymbol{j}\)</span> be the relative velocity of the two surfaces and
<span class="math">\(p\)</span> the pressure in the fluid. The mathematical model builds on two
principles: 1) conservation of mass, 2) assumption of locally quasi-static
flow between flat plates.</p>
<p>The conservation of mass equation reads <span class="math">\(\nabla\cdot\boldsymbol{u}\)</span>, where <span class="math">\(\boldsymbol{u}\)</span> is
the local fluid velocity. For thin films the detailed variation between
the surfaces is not of interest, so <span class="math">\(\nabla\cdot\boldsymbol{u} = 0\)</span> is integrated
(average) in the direction perpendicular to the surfaces. This gives
rise to the alternative mass conservation equation</p>
<div class="math">
\[\nabla\cdot\boldsymbol{q} = 0,\quad \boldsymbol{q} = \int\limits_0^{h(x,y)}\boldsymbol{u} dz,\]</div>
<p>where <span class="math">\(z\)</span> is the coordinate perpendicular to the surfaces, and <span class="math">\(\boldsymbol{q}\)</span>
is then the volume flux in the fluid gap.</p>
<p>Locally, we may assume that we have steady flow between two flat
surfaces, with a pressure gradient and where the lower surface is at rest
and the upper moves with velocity <span class="math">\(U\boldsymbol{i} + V\boldsymbol{j}\)</span>.
The corresponding mathematical problem is actually the limit problem
in the section <a class="reference internal" href="#diffu-app-couette"><span class="std std-ref">Development of flow between two flat plates</span></a> as <span class="math">\(t\rightarrow\infty\)</span>. The limit
problem can be solved analytically, and the local volume flux becomes</p>
<div class="math">
\[\boldsymbol{q}(x,y,z) = \int\limits_0^{h}\boldsymbol{u}(x,y,z) dz
= -\frac{h^3}{12\mu}\nabla p + \frac{1}{2} Uh\boldsymbol{i} + \frac{1}{2} Vh\boldsymbol{j}{\thinspace .}\]</div>
<p>The idea is to use this expression locally
also when the surfaces are not flat,
but slowly varying, and if <span class="math">\(U\)</span>, <span class="math">\(V\)</span>, or <span class="math">\(p\)</span> varies in time, provided the
time variation is sufficiently slow. This is a common quasi-static
approximation much used in mathematical modeling.</p>
<p>Inserting the expression for <span class="math">\(\boldsymbol{q}\)</span> via <span class="math">\(p\)</span>, <span class="math">\(U\)</span>, and <span class="math">\(V\)</span> in the
equation <span class="math">\(\nabla\boldsymbol{q} = 0\)</span> gives a diffusion PDE for <span class="math">\(p\)</span>:</p>
<div class="math" id="eq-auto174">
\[\tag{432}
\nabla\cdot\left(\frac{h^3}{12\mu}\nabla p\right) =
    \frac{1}{2}\frac{\partial}{\partial x}(hU)
    + \frac{1}{2}\frac{\partial}{\partial x}(hV){\thinspace .}\]</div>
<p>The boundary conditions must involve <span class="math">\(p\)</span> or <span class="math">\(\boldsymbol{q}\)</span> at the boundary.</p>
<p>[<strong>hpl 22</strong>: Exercise!]</p>
</div>
<div class="section" id="propagation-of-electrical-signals-in-the-brain">
<h3>Propagation of electrical signals in the brain<a class="headerlink" href="#propagation-of-electrical-signals-in-the-brain" title="Permalink to this headline">¶</a></h3>
<p>One can make a model of how electrical signals are propagated along the
neuronal fibers that receive synaptic inputs in the brain. The signal
propagation is one-dimensional and can, in the simplest cases, be
governed by the <a class="reference external" href="http://en.wikipedia.org/wiki/Cable_equation">Cable equation</a>:</p>
<div class="math">
\[c_m \frac{\partial V}{\partial t} =
\frac{1}{r_l}\frac{\partial^2 V}{\partial x^2} - \frac{1}{r_m}V
label{}\]</div>
<p>where <span class="math">\(V(x,t)\)</span> is the voltage to be determined,
<span class="math">\(c_m\)</span> is capacitance of the neuronal fiber, while
<span class="math">\(r_l\)</span> and <span class="math">\(r_m\)</span> are measures of the resistance.
The boundary conditions are often taken as <span class="math">\(V=0\)</span> at a short circuit or open end,
<span class="math">\(\partial V/\partial x=0\)</span> at a sealed end, or <span class="math">\(\partial V/\partial x \propto
V\)</span> where there is an injection of current.</p>
</div>
</div>
<div class="section" id="exercises-7">
<h2>Exercises<a class="headerlink" href="#exercises-7" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-3-6-stabilizing-the-crank-nicolson-method-by-rannacher-time-stepping">
<span id="diffu-exer-cn-rannacher"></span><h3>Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping<a class="headerlink" href="#exercise-3-6-stabilizing-the-crank-nicolson-method-by-rannacher-time-stepping" title="Permalink to this headline">¶</a></h3>
<p>It is well known that the Crank-Nicolson method may give rise to
non-physical oscillations in the solution of diffusion equations
if the initial data exhibit jumps (see the section <a class="reference internal" href="#diffu-pde1-analysis-cn"><span class="std std-ref">Analysis of the Crank-Nicolson scheme</span></a>).
Rannacher <a class="reference internal" href="._book027.html#ref8" id="id7">[Ref8]</a> suggested a stabilizing technique
consisting of using the Backward Euler scheme for the first two
time steps with step length <span class="math">\(\frac{1}{2}\Delta t\)</span>. One can generalize
this idea to taking <span class="math">\(2m\)</span> time steps of size <span class="math">\(\frac{1}{2}\Delta t\)</span> with
the Backward Euler method and then continuing with the
Crank-Nicolson method, which is of second-order in time.
The idea is that the high frequencies of the initial solution are
quickly damped out, and the Backward Euler scheme treats these
high frequencies correctly. Thereafter, the high frequency content of
the solution is gone and the Crank-Nicolson method will do well.</p>
<p>Test this idea for <span class="math">\(m=1,2,3\)</span> on a diffusion problem with a
discontinuous initial condition. Measure the convergence rate using
the solution <a class="reference internal" href="#eq-diffu-analysis-pde1-step-erf-sol"><span class="std std-ref">(350)</span></a> with the boundary
conditions
<a class="reference internal" href="#eq-diffu-analysis-pde1-p1-erf-ul"><span class="std std-ref">(351)</span></a>-<a class="reference internal" href="#eq-diffu-analysis-pde1-p1-erf-ur"><span class="std std-ref">(352)</span></a>
for <span class="math">\(t\)</span> values such that the conditions are in the vicinity of <span class="math">\(\pm 1\)</span>.
For example, <span class="math">\(t&lt; 5a 1.6\cdot 10^{-2}\)</span> makes the solution diffusion from
a step to almost a straight line. The
program <code class="docutils literal"><span class="pre">diffu_erf_sol.py</span></code> shows how to compute the analytical
solution.</p>
</div>
<div class="section" id="project-3-7-energy-estimates-for-diffusion-problems">
<span id="diffu-exer-energy-estimates"></span><h3>Project 3.7: Energy estimates for diffusion problems<a class="headerlink" href="#project-3-7-energy-estimates-for-diffusion-problems" title="Permalink to this headline">¶</a></h3>
<p id="index-27">This project concerns so-called <em>energy estimates</em> for diffusion problems
that can be used for qualitative analytical insight and for
verification of implementations.</p>
<p><strong>a)</strong>
We start with a 1D homogeneous diffusion equation with zero Dirichlet
conditions:</p>
<div class="math" id="eq-diffu-exer-estimates-p1-pdf">
\[\tag{433}
u_t = \alpha u_xx,  x\in \Omega =(0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p1-bc">
\[\tag{434}
u(0,t) = u(L,t) = 0,  t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p1-ic">
\[\tag{435}
u(x,0) = I(x),  x\in [0,L]\]\[    {\thinspace .}\]</div>
<p>The energy estimate for this problem reads</p>
<div class="math" id="eq-diffu-exer-estimates-p1-result">
\[\tag{436}
||u||_{L^2} \leq ||I||_{L^2},\]</div>
<p>where the <span class="math">\(||\cdot ||_{L^2}\)</span> norm is defined by</p>
<div class="math" id="eq-diffu-exer-estimates-l2">
\[\tag{437}
||g||_{L^2} = \sqrt{\int_0^L g^2dx}{\thinspace .}\]</div>
<p>The quantify  <span class="math">\(||u||_{L^2}\)</span> or <span class="math">\(\frac{1}{2} ||u||_{L^2}\)</span> is known
as the <em>energy</em> of the solution, although it is not the physical
energy of the system. A mathematical tradition has introduced the
notion <em>energy</em> in this context.</p>
<p>The estimate <a class="reference internal" href="#eq-diffu-exer-estimates-p1-result"><span class="std std-ref">(436)</span></a> says that the
&#8220;size of $u$&#8221; never exceeds that of the initial condition,
or more precisely, it says that the area under the <span class="math">\(u\)</span> curve decreases
with time.</p>
<p>To show <a class="reference internal" href="#eq-diffu-exer-estimates-p1-result"><span class="std std-ref">(436)</span></a>, multiply the PDE
by <span class="math">\(u\)</span> and integrate from <span class="math">\(0\)</span> to <span class="math">\(L\)</span>. Use that <span class="math">\(uu_t\)</span> can be
expressed as the time derivative of <span class="math">\(u^2\)</span> and that <span class="math">\(u_xxu\)</span> can
integrated by parts to form an integrand <span class="math">\(u_x^2\)</span>. Show that
the time derivative of <span class="math">\(||u||_{L^2}^2\)</span> must be less than or equal
to zero. Integrate this expression and derive
<a class="reference internal" href="#eq-diffu-exer-estimates-p1-result"><span class="std std-ref">(436)</span></a>.</p>
<p><strong>b)</strong>
Now we address a slightly different problem,</p>
<div class="math" id="eq-diffu-exer-estimates-p2-pdf">
\[\tag{438}
u_t = \alpha u_xx + f(x,t),  x\in \Omega =(0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p2-bc">
\[\tag{439}
u(0,t) = u(L,t) = 0,  t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p2-ic">
\[\tag{440}
u(x,0) = 0,  x\in [0,L]\]\[    {\thinspace .}\]</div>
<p>The associated energy estimate is</p>
<div class="math" id="eq-diffu-exer-estimates-p2-result">
\[\tag{441}
||u||_{L^2} \leq ||f||_{L^2}{\thinspace .}\]</div>
<p>(This result is more difficult to derive.)</p>
<p>Now consider the compound problem with an initial condition <span class="math">\(I(x)\)</span> and
a right-hand side <span class="math">\(f(x,t)\)</span>:</p>
<div class="math" id="eq-diffu-exer-estimates-p3-pdf">
\[\tag{442}
u_t = \alpha u_xx + f(x,t),  x\in \Omega =(0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p3-bc">
\[\tag{443}
u(0,t) = u(L,t) = 0,  t\in (0,T],\]</div>
<div class="math" id="eq-diffu-exer-estimates-p3-ic">
\[\tag{444}
u(x,0) = I(x),  x\in [0,L]\]\[    {\thinspace .}\]</div>
<p>Show that if <span class="math">\(w_1\)</span> fulfills
<a class="reference internal" href="#eq-diffu-exer-estimates-p1-pdf"><span class="std std-ref">(433)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p1-ic"><span class="std std-ref">(435)</span></a>
and <span class="math">\(w_2\)</span> fulfills
<a class="reference internal" href="#eq-diffu-exer-estimates-p2-pdf"><span class="std std-ref">(438)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p2-ic"><span class="std std-ref">(440)</span></a>,
then <span class="math">\(u=w_1 + w_2\)</span> is the solution of
<a class="reference internal" href="#eq-diffu-exer-estimates-p3-pdf"><span class="std std-ref">(442)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p3-ic"><span class="std std-ref">(444)</span></a>.
Using the triangle inequality for norms,</p>
<div class="math">
\[||a + b|| \leq ||a|| + ||b||,\]</div>
<p>show that the energy estimate for
<a class="reference internal" href="#eq-diffu-exer-estimates-p3-pdf"><span class="std std-ref">(442)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p3-ic"><span class="std std-ref">(444)</span></a>
becomes</p>
<div class="math" id="eq-diffu-exer-estimates-p3-result">
\[\tag{445}
||u||_{L^2} \leq ||I||_{L^2} + ||f||_{L^2}{\thinspace .}\]</div>
<p><strong>c)</strong>
One application of <a class="reference internal" href="#eq-diffu-exer-estimates-p3-result"><span class="std std-ref">(445)</span></a> is to prove uniqueness
of the solution.
Suppose <span class="math">\(u_1\)</span> and <span class="math">\(u_2\)</span> both fulfill
<a class="reference internal" href="#eq-diffu-exer-estimates-p3-pdf"><span class="std std-ref">(442)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p3-ic"><span class="std std-ref">(444)</span></a>.
Show that <span class="math">\(u=u_1 - u_2\)</span> then fulfills
<a class="reference internal" href="#eq-diffu-exer-estimates-p3-pdf"><span class="std std-ref">(442)</span></a>-<a class="reference internal" href="#eq-diffu-exer-estimates-p3-ic"><span class="std std-ref">(444)</span></a>
with <span class="math">\(f=0\)</span> and <span class="math">\(I=0\)</span>. Use <a class="reference internal" href="#eq-diffu-exer-estimates-p3-result"><span class="std std-ref">(445)</span></a>
to deduce that the energy must be zero for all times and therefore
that <span class="math">\(u_1=u_2\)</span>, which proves that the solution is unique.</p>
<p><strong>d)</strong>
Generalize <a class="reference internal" href="#eq-diffu-exer-estimates-p3-result"><span class="std std-ref">(445)</span></a> to a 2D/3D
diffusion equation <span class="math">\(u_t = \nabla\cdot (\alpha \nabla u)\)</span> for <span class="math">\(x\in\Omega\)</span>.</p>
<p><strong>Hint.</strong>
Use integration by parts in multi dimensions:</p>
<div class="math">
\[\int_\Omega u \nabla\cdot (\alpha\nabla u){\, \mathrm{d}x} =
- \int_\Omega \alpha \nabla u\cdot\nabla u{\, \mathrm{d}x}
+ \int_{\partial\Omega} u \alpha\frac{\partial u}{\partial n},\]</div>
<p>where <span class="math">\(\frac{\partial u}{\partial n} = \boldsymbol{n}\cdot\nabla u\)</span>,
<span class="math">\(\boldsymbol{n}\)</span> being the outward unit normal to the boundary <span class="math">\(\partial\Omega\)</span>
of the domain <span class="math">\(\Omega\)</span>.</p>
<p><strong>e)</strong>
Now we also consider the multi-dimensional PDE <span class="math">\(u_t =
\nabla\cdot (\alpha \nabla u)\)</span>. Integrate both sides over <span class="math">\(\Omega\)</span>
and use Gauss&#8217; divergence theorem, <span class="math">\(\int_\Omega \nabla\cdot\boldsymbol{q}{\, \mathrm{d}x}
= \int_{\partial\Omega}\boldsymbol{q}\cdot\boldsymbol{n}{\, \mathrm{d}s}\)</span> for a vector field
<span class="math">\(\boldsymbol{q}\)</span>. Show that if we have homogeneous Neumann conditions
on the boundary, <span class="math">\(\partial u/\partial n=0\)</span>, area under the
<span class="math">\(u\)</span> surface remains constant in time and</p>
<div class="math" id="eq-diffu-exer-estimates-p4-result">
\[\tag{446}
\int_{\Omega} u{\, \mathrm{d}x} = \int_{\Omega} I{\, \mathrm{d}x}
    {\thinspace .}\]</div>
<p><strong>f)</strong>
Establish a code in 1D, 2D, or 3D that can solve a diffusion equation with a
source term <span class="math">\(f\)</span>, initial condition <span class="math">\(I\)</span>, and zero Dirichlet or
Neumann conditions on the whole boundary.</p>
<p>We can use <a class="reference internal" href="#eq-diffu-exer-estimates-p3-result"><span class="std std-ref">(445)</span></a>
and <a class="reference internal" href="#eq-diffu-exer-estimates-p4-result"><span class="std std-ref">(446)</span></a> as a partial verification
of the code. Choose some functions <span class="math">\(f\)</span> and <span class="math">\(I\)</span> and
check that <a class="reference internal" href="#eq-diffu-exer-estimates-p3-result"><span class="std std-ref">(445)</span></a> is obeyed at any
time when zero Dirichlet conditions are used.
Iterate over the same <span class="math">\(I\)</span> functions and check that
<a class="reference internal" href="#eq-diffu-exer-estimates-p4-result"><span class="std std-ref">(446)</span></a> is fulfilled
when using zero Neumann conditions.</p>
<p><strong>g)</strong>
Make a list of some possible bugs in the code, such as indexing errors
in arrays, failure to set the correct boundary conditions,
evaluation of a term at a wrong time level, and similar.
For each of the bugs, see if the verification tests from the previous
subexercise pass or fail. This investigation shows how strong
the energy estimates and the estimate <a class="reference internal" href="#eq-diffu-exer-estimates-p4-result"><span class="std std-ref">(446)</span></a>
are for pointing out errors in the implementation.</p>
<p>Filename: <code class="docutils literal"><span class="pre">diffu_energy</span></code>.</p>
</div>
<div class="section" id="exercise-3-8-splitting-methods-and-preconditioning">
<span id="diffu-exer-splitting-prec"></span><h3>Exercise 3.8: Splitting methods and preconditioning<a class="headerlink" href="#exercise-3-8-splitting-methods-and-preconditioning" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-28"></span><p id="index-29">In the section <a class="reference internal" href="#diffu-2d-direct-vs-iter"><span class="std std-ref">Direct versus iterative methods</span></a>, we outlined a class of
iterative methods for <span class="math">\(Au=b\)</span> based on splitting <span class="math">\(A\)</span> into <span class="math">\(A=M-N\)</span>
and introducing the iteration</p>
<div class="math">
\[Mu^{k} = Nu^k + b{\thinspace .}\]</div>
<p>The very simplest splitting is <span class="math">\(M=I\)</span>, where <span class="math">\(I\)</span> is the identity
matrix. Show that this choice corresponds to the iteration</p>
<div class="math" id="eq-diffu-exer-splitting-prec-simplest">
\[\tag{447}
u^k = u^{k-1} + r^{k-1},\quad r^{k-1} = b - Au^{k-1},\]</div>
<p>where <span class="math">\(r^{k-1}\)</span> is the residual in the linear system in iteration
<span class="math">\(k-1\)</span>. The formula <a class="reference internal" href="#eq-diffu-exer-splitting-prec-simplest"><span class="std std-ref">(447)</span></a> is known
as Richardson&#8217;s iteration.
Show that if we apply the simple iteration method
<a class="reference internal" href="#eq-diffu-exer-splitting-prec-simplest"><span class="std std-ref">(447)</span></a> to the <em>preconditioned</em>
system <span class="math">\(M^{-1}Au=M^{-1}b\)</span>, we arrive at the Jacobi method by choosing
<span class="math">\(M=D\)</span> (the diagonal of <span class="math">\(A\)</span>) as preconditioner and the SOR method by
choosing <span class="math">\(M=\omega^{-1}D + L\)</span> (<span class="math">\(L\)</span> being the lower triangular part of
<span class="math">\(A\)</span>).  This equivalence shows that we can apply one iteration of the
Jacobi or SOR method as preconditioner.</p>
</div>
<div class="section" id="exercise-3-9-oscillating-surface-temperature-of-the-earth">
<span id="diffu-exer-earthosc"></span><h3>Exercise 3.9: Oscillating surface temperature of the earth<a class="headerlink" href="#exercise-3-9-oscillating-surface-temperature-of-the-earth" title="Permalink to this headline">¶</a></h3>
<p>Consider a day-and-night or seasonal variation in temperature at
the surface of the earth. How deep down in the ground will the
surface oscillations reach? For simplicity, we model only the
vertical variation along a coordinate <span class="math">\(x\)</span>, where <span class="math">\(x=0\)</span> at the
surface, and <span class="math">\(x\)</span> increases as we go down in the ground.
The temperature is governed by the heat equation</p>
<div class="math">
\[\varrho c_v\frac{\partial T}{\partial t} = \nabla\cdot(k\nabla T),\]</div>
<p>in some spatial domain <span class="math">\(x\in [0,L]\)</span>, where <span class="math">\(L\)</span> is chosen large enough such
that we can assume that <span class="math">\(T\)</span> is approximately constant, independent of the surface
oscillations, for <span class="math">\(x&gt;L\)</span>. The parameters <span class="math">\(\varrho\)</span>, <span class="math">\(c_v\)</span>, and <span class="math">\(k\)</span> are the
density, the specific heat capacity at constant volume, and the
heat conduction coefficient, respectively.</p>
<p><strong>a)</strong>
Derive the mathematical model for computing <span class="math">\(T(x,t)\)</span>.
Assume the surface oscillations to be sinusoidal around some mean
temperature <span class="math">\(T_m\)</span>. Let <span class="math">\(T=T_m\)</span> initially. At <span class="math">\(x=L\)</span>, assume <span class="math">\(T\approx T_m\)</span>.</p>
<p><strong>b)</strong>
Scale the model in a) assuming <span class="math">\(k\)</span> is constant. Use a time scale
<span class="math">\(t_c = \omega^{-1}\)</span> and a length scale <span class="math">\(x_c = \sqrt{2{\alpha}/omega}\)</span>,
where <span class="math">\({\alpha} = k/(\varrho c_v)\)</span>. The primary unknown can be scaled
as <span class="math">\(\frac{T-T_m}{2A}\)</span>.</p>
<p>Show that the scaled PDE is</p>
<div class="math">
\[\frac{\partial u}{\partial \bar t} =
\frac{1}{2}\frac{\partial^2 u}{\partial x^2},\]</div>
<p>with initial condition <span class="math">\(u(\bar x,0) = 0\)</span>,
left boundary condition
<span class="math">\(u(0,\bar t)  = \sin(\bar t)\)</span>,
and right boundary condition
<span class="math">\(u(\bar L,\bar t)  = 0\)</span>. The bar indicates a dimensionless quantity.</p>
<p>Show that <span class="math">\(u(\bar x, \bar t)=e^{-\bar x}\sin (\bar x - \bar t)\)</span> is a
solution that fulfills the PDE and the boundary condition at <span class="math">\(\bar x
=0\)</span> (this is the solution we will experience as <span class="math">\(\bar
t\rightarrow\infty\)</span> and <span class="math">\(L\rightarrow\infty\)</span>).  Conclude that an
appropriate domain for <span class="math">\(x\)</span> is <span class="math">\([0,4]\)</span> if a damping <span class="math">\(e^{-4}\approx
0.18\)</span> is appropriate for implementing <span class="math">\(\bar u\approx\hbox{const}\)</span>;
increasing to <span class="math">\([0,6]\)</span> damps <span class="math">\(\bar u\)</span> to 0.0025.</p>
<p><strong>c)</strong>
Compute the scaled temperature and make animations comparing two solutions
with <span class="math">\(\bar L=4\)</span> and <span class="math">\(\bar L=8\)</span>, respectively (keep <span class="math">\(\Delta x\)</span> the same).</p>
</div>
<div class="section" id="exercise-3-10-oscillating-and-pulsating-flow-in-tubes">
<span id="diffu-exer-bloodflow"></span><h3>Exercise 3.10: Oscillating and pulsating flow in tubes<a class="headerlink" href="#exercise-3-10-oscillating-and-pulsating-flow-in-tubes" title="Permalink to this headline">¶</a></h3>
<p>We consider flow in a straight tube with radius <span class="math">\(R\)</span> and straight walls.
The flow is driven by a pressure gradient <span class="math">\(\beta(t)\)</span>. The effect of
gravity can be neglected. The mathematical problem reads</p>
<div class="math" id="eq-auto175">
\[\tag{448}
\varrho\frac{\partial u}{\partial t} =
    \mu\frac{1}{r}\frac{\partial}{\partial r}\left(
    r\frac{\partial u}{\partial r}\right) + \beta(t),\quad
     r\in [0,R],\ t\in (0,T],\]</div>
<div class="math" id="eq-auto176">
\[\tag{449}
u(r,0) = 0,\quad  r\in [0,R],\]</div>
<div class="math" id="eq-auto177">
\[\tag{450}
u(R,0) = 0,\quad  t\in (0,T],\]</div>
<div class="math" id="eq-auto178">
\[\tag{451}
\frac{\partial u}{\partial r}(0,t) = 0,\quad  t\in (0,T].\]</div>
<p>We consider two models for <span class="math">\(\beta(t)\)</span>. One plain, sinusoidal oscillation:</p>
<div class="math" id="eq-auto179">
\[\tag{452}
\beta = A\sin(\omega t),\]</div>
<p>and one with periodic pulses,</p>
<div class="math" id="eq-auto180">
\[\tag{453}
\beta = A\sin^{16}(\omega t),\]</div>
<p>Note that both models can be written as <span class="math">\(\beta = A\sin^m(\omega t)\)</span>, with
<span class="math">\(m=1\)</span> and <span class="math">\(m=16\)</span>, respectively.</p>
<p><strong>a)</strong>
Scale the mathematical model, using the viscous time scale <span class="math">\(\varrho R^2/\mu\)</span>.</p>
<p><strong>b)</strong>
Implement the scaled model from a), using the unifying <span class="math">\(\theta\)</span> scheme
in time and centered differences in space.</p>
<p><strong>c)</strong>
Verify the implementation in b) using a manufactured solution that is
quadratic in <span class="math">\(r\)</span> and linear in <span class="math">\(t\)</span>. Make a corresponding test function.</p>
<p><strong>Hint.</strong>
You need to include an extra source term
in the equation to allow for such tests. Let the spatial variation be
<span class="math">\(1-r^2\)</span> such that the boundary condition is fulfilled.</p>
<p><strong>d)</strong>
Make animations for <span class="math">\(m=1,16\)</span> and <span class="math">\(\alpha=1,0.1\)</span>. Choose <span class="math">\(T\)</span> such that
the motion has reached a steady state (non-visible changes from period to
period in <span class="math">\(u\)</span>).</p>
<p><strong>e)</strong>
For <span class="math">\(\alpha\gg 1\)</span>, the scaling in a) is not good, because the
characteristic time for changes (due to the pressure) is much smaller
than the viscous diffusion time scale (<span class="math">\(\alpha\)</span> becomes large).
We should in this case base
the short time scale on <span class="math">\(1/\omega\)</span>. Scale the model again, and
make an animation for <span class="math">\(m=1,16\)</span> and <span class="math">\(\alpha = 10\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">axyiymm_flow</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Diffusion equations</a><ul>
<li><a class="reference internal" href="#an-explicit-method-for-the-1d-diffusion-equation">An explicit method for the 1D diffusion equation</a><ul>
<li><a class="reference internal" href="#the-initial-boundary-value-problem-for-1d-diffusion">The initial-boundary value problem for 1D diffusion</a></li>
<li><a class="reference internal" href="#forward-euler-scheme">Forward Euler scheme</a></li>
<li><a class="reference internal" href="#implementation-7">Implementation</a></li>
<li><a class="reference internal" href="#verification-6">Verification</a></li>
<li><a class="reference internal" href="#numerical-experiments">Numerical experiments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implicit-methods-for-the-1d-diffusion-equation">Implicit methods for the 1D diffusion equation</a><ul>
<li><a class="reference internal" href="#backward-euler-scheme">Backward Euler scheme</a></li>
<li><a class="reference internal" href="#sparse-matrix-implementation">Sparse matrix implementation</a></li>
<li><a class="reference internal" href="#crank-nicolson-scheme">Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#the-unifying-rule">The unifying <span class="math">\(\theta\)</span> rule</a></li>
<li><a class="reference internal" href="#experiments">Experiments</a></li>
<li><a class="reference internal" href="#the-laplace-and-poisson-equation">The Laplace and Poisson equation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-schemes-for-the-diffusion-equation">Analysis of schemes for the diffusion equation</a><ul>
<li><a class="reference internal" href="#properties-of-the-solution">Properties of the solution</a><ul>
<li><a class="reference internal" href="#similarity-solution">Similarity solution</a></li>
<li><a class="reference internal" href="#solution-for-a-gaussian-pulse">Solution for a Gaussian pulse</a></li>
<li><a class="reference internal" href="#solution-for-a-sine-component">Solution for a sine component</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-discrete-equations">Analysis of discrete equations</a></li>
<li><a class="reference internal" href="#analysis-of-the-finite-difference-schemes">Analysis of the finite difference schemes</a><ul>
<li><a class="reference internal" href="#stability-3">Stability</a></li>
<li><a class="reference internal" href="#accuracy-1">Accuracy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme-2">Analysis of the Forward Euler scheme</a><ul>
<li><a class="reference internal" href="#stability-4">Stability</a></li>
<li><a class="reference internal" href="#accuracy-2">Accuracy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-backward-euler-scheme">Analysis of the Backward Euler scheme</a><ul>
<li><a class="reference internal" href="#stability-5">Stability</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-crank-nicolson-scheme">Analysis of the Crank-Nicolson scheme</a><ul>
<li><a class="reference internal" href="#stability-6">Stability</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-of-accuracy-of-amplification-factors">Summary of accuracy of amplification factors</a></li>
<li><a class="reference internal" href="#analysis-of-the-2d-diffusion-equation">Analysis of the 2D diffusion equation</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme-2">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme-2">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme-2">The Crank-Nicolson scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#explanation-of-numerical-artifacts">Explanation of numerical artifacts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-6">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-3-1-explore-symmetry-in-a-1d-problem">Exercise 3.1: Explore symmetry in a 1D problem</a></li>
<li><a class="reference internal" href="#exercise-3-2-investigate-approximation-errors-from-a-boundary-condition">Exercise 3.2: Investigate approximation errors from a <span class="math">\(u_x=0\)</span> boundary condition</a></li>
<li><a class="reference internal" href="#exercise-3-3-experiment-with-open-boundary-conditions-in-1d">Exercise 3.3: Experiment with open boundary conditions in 1D</a></li>
<li><a class="reference internal" href="#exercise-3-4-simulate-a-diffused-gaussian-peak-in-2d-3d">Exercise 3.4: Simulate a diffused Gaussian peak in 2D/3D</a></li>
<li><a class="reference internal" href="#exercise-3-5-examine-stability-of-a-diffusion-model-with-a-source-term">Exercise 3.5: Examine stability of a diffusion model with a source term</a></li>
</ul>
</li>
<li><a class="reference internal" href="#diffusion-in-heterogeneous-media">Diffusion in heterogeneous media</a><ul>
<li><a class="reference internal" href="#discretization-2">Discretization</a></li>
<li><a class="reference internal" href="#implementation-8">Implementation</a></li>
<li><a class="reference internal" href="#stationary-solution">Stationary solution</a></li>
<li><a class="reference internal" href="#piecewise-constant-medium">Piecewise constant medium</a></li>
<li><a class="reference internal" href="#implementation-of-diffusion-in-a-piecewise-constant-medium">Implementation of diffusion in a piecewise constant medium</a></li>
<li><a class="reference internal" href="#diffusion-equation-in-axi-symmetric-geometries">Diffusion equation in axi-symmetric geometries</a></li>
<li><a class="reference internal" href="#diffusion-equation-in-spherically-symmetric-geometries">Diffusion equation in spherically-symmetric geometries</a><ul>
<li><a class="reference internal" href="#discretization-in-spherical-coordinates">Discretization in spherical coordinates</a></li>
<li><a class="reference internal" href="#discretization-in-cartesian-coordinates">Discretization in Cartesian coordinates</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#diffusion-in-2d">Diffusion in 2D</a><ul>
<li><a class="reference internal" href="#discretization-3">Discretization</a></li>
<li><a class="reference internal" href="#numbering-of-mesh-points-versus-equations-and-unknowns">Numbering of mesh points versus equations and unknowns</a></li>
<li><a class="reference internal" href="#algorithm-for-setting-up-the-coefficient-matrix">Algorithm for setting up the coefficient matrix</a></li>
<li><a class="reference internal" href="#implementation-with-a-dense-coefficient-matrix">Implementation with a dense coefficient matrix</a></li>
<li><a class="reference internal" href="#verification-exact-numerical-solution">Verification: exact numerical solution</a></li>
<li><a class="reference internal" href="#verification-convergence-rates">Verification: convergence rates</a></li>
<li><a class="reference internal" href="#implementation-with-a-sparse-coefficient-matrix">Implementation with a sparse coefficient matrix</a><ul>
<li><a class="reference internal" href="#understanding-the-diagonals">Understanding the diagonals</a></li>
<li><a class="reference internal" href="#filling-the-diagonals">Filling the diagonals</a></li>
<li><a class="reference internal" href="#filling-the-right-hand-side-scalar-version">Filling the right-hand side; scalar version</a></li>
<li><a class="reference internal" href="#filling-the-right-hand-side-vectorized-version">Filling the right-hand side; vectorized version</a></li>
<li><a class="reference internal" href="#verification-7">Verification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-jacobi-iterative-method">The Jacobi iterative method</a><ul>
<li><a class="reference internal" href="#numerical-scheme-and-linear-system">Numerical scheme and linear system</a></li>
<li><a class="reference internal" href="#iterations">Iterations</a></li>
<li><a class="reference internal" href="#initial-guess">Initial guess</a></li>
<li><a class="reference internal" href="#relaxation-1">Relaxation</a></li>
<li><a class="reference internal" href="#stopping-criteria-1">Stopping criteria</a></li>
<li><a class="reference internal" href="#code-friendly-notation">Code-friendly notation</a></li>
<li><a class="reference internal" href="#generalization-of-the-scheme">Generalization of the scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-the-jacobi-method">Implementation of the Jacobi method</a></li>
<li><a class="reference internal" href="#test-problem-diffusion-of-a-sine-hill">Test problem: diffusion of a sine hill</a></li>
<li><a class="reference internal" href="#the-relaxed-jacobi-method-and-its-relation-to-the-forward-euler-method">The relaxed Jacobi method and its relation to the Forward Euler method</a></li>
<li><a class="reference internal" href="#the-gauss-seidel-and-sor-methods">The Gauss-Seidel and SOR methods</a></li>
<li><a class="reference internal" href="#scalar-implementation-of-the-sor-method">Scalar implementation of the SOR method</a></li>
<li><a class="reference internal" href="#vectorized-implementation-of-the-sor-method">Vectorized implementation of the SOR method</a></li>
<li><a class="reference internal" href="#direct-versus-iterative-methods">Direct versus iterative methods</a><ul>
<li><a class="reference internal" href="#direct-methods">Direct methods</a></li>
<li><a class="reference internal" href="#iterative-methods">Iterative methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-conjugate-gradient-method">The Conjugate gradient method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-walk">Random walk</a><ul>
<li><a class="reference internal" href="#random-walk-in-1d">Random walk in 1D</a></li>
<li><a class="reference internal" href="#statistical-considerations">Statistical considerations</a></li>
<li><a class="reference internal" href="#playing-around-with-some-code">Playing around with some code</a><ul>
<li><a class="reference internal" href="#scalar-code-1">Scalar code</a></li>
<li><a class="reference internal" href="#vectorized-code-2">Vectorized code</a></li>
<li><a class="reference internal" href="#fixing-the-random-sequence">Fixing the random sequence</a></li>
<li><a class="reference internal" href="#verification-8">Verification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#equivalence-with-diffusion">Equivalence with diffusion</a></li>
<li><a class="reference internal" href="#implementation-of-multiple-walks">Implementation of multiple walks</a><ul>
<li><a class="reference internal" href="#scalar-version">Scalar version</a></li>
<li><a class="reference internal" href="#vectorized-version">Vectorized version</a></li>
<li><a class="reference internal" href="#improved-vectorized-version">Improved vectorized version</a></li>
<li><a class="reference internal" href="#remark-on-vectorized-code-and-parallelization">Remark on vectorized code and parallelization</a></li>
<li><a class="reference internal" href="#test-function">Test function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#demonstration-of-multiple-walks">Demonstration of multiple walks</a></li>
<li><a class="reference internal" href="#ascii-visualization-of-1d-random-walk">Ascii visualization of 1D random walk</a></li>
<li><a class="reference internal" href="#random-walk-as-a-stochastic-equation">Random walk as a stochastic equation</a></li>
<li><a class="reference internal" href="#random-walk-in-2d">Random walk in 2D</a></li>
<li><a class="reference internal" href="#random-walk-in-any-number-of-space-dimensions">Random walk in any number of space dimensions</a></li>
<li><a class="reference internal" href="#multiple-random-walks-in-any-number-of-space-dimensions">Multiple random walks in any number of space dimensions</a><ul>
<li><a class="reference internal" href="#scalar-code-2">Scalar code</a></li>
<li><a class="reference internal" href="#vectorized-code-3">Vectorized code</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#applications">Applications</a><ul>
<li><a class="reference internal" href="#diffusion-of-a-substance">Diffusion of a substance</a></li>
<li><a class="reference internal" href="#heat-conduction">Heat conduction</a></li>
<li><a class="reference internal" href="#development-of-flow-between-two-flat-plates">Development of flow between two flat plates</a></li>
<li><a class="reference internal" href="#flow-in-a-straight-tube">Flow in a straight tube</a></li>
<li><a class="reference internal" href="#tribology-thin-film-fluid-flow">Tribology: thin film fluid flow</a></li>
<li><a class="reference internal" href="#propagation-of-electrical-signals-in-the-brain">Propagation of electrical signals in the brain</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-7">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-3-6-stabilizing-the-crank-nicolson-method-by-rannacher-time-stepping">Exercise 3.6: Stabilizing the Crank-Nicolson method by Rannacher time stepping</a></li>
<li><a class="reference internal" href="#project-3-7-energy-estimates-for-diffusion-problems">Project 3.7: Energy estimates for diffusion problems</a></li>
<li><a class="reference internal" href="#exercise-3-8-splitting-methods-and-preconditioning">Exercise 3.8: Splitting methods and preconditioning</a></li>
<li><a class="reference internal" href="#exercise-3-9-oscillating-surface-temperature-of-the-earth">Exercise 3.9: Oscillating surface temperature of the earth</a></li>
<li><a class="reference internal" href="#exercise-3-10-oscillating-and-pulsating-flow-in-tubes">Exercise 3.10: Oscillating and pulsating flow in tubes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book010.html"
                        title="previous chapter">Exercises</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book012.html"
                        title="next chapter">Advection-dominated equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book011.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book012.html" title="Advection-dominated equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book010.html" title="Exercises"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>