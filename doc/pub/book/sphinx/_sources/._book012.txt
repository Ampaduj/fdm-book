.. !split

.. _ch:convdiff:

Advection-dominated equations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Wave (the chapter :ref:`ch:wave`) and diffusion (the chapter :ref:`ch:diffu`)
equations are solved reliably by finite difference methods. As soon as
we add a first-order derivative in space, representing *advective
transport* (also known as convective transport), the numerics gets
more complicated, and intuitively attractive methods no longer work
well. We shall show how and why such methods fail and provide
remedies. The present chapter builds on basic knowledge about finite
difference methods for diffusion and wave equations, including the
analysis by Fourier components, truncation error analysis ( :ref:`ch:trunc`), and compact difference notation.

.. _advec:1D:

One-dimensional time-dependent advection equations
==================================================

We consider the pure advection model

.. _Eq:advec:1D:pde1:u:

.. math::

    \tag{502}
    \frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} = 0,\quad
         x\in (0,L),\ t\in (0,T],
        
        

.. _Eq:advec:1D:pde1:U0:

.. math::

    \tag{503}
    u(x,0) = I(x), x\in (0,L),
        
        

.. _Eq:advec:1D:pde1:I:

.. math::

    \tag{504}
    u(0,t) = U_0, t\in (0,T].
        
        

In :ref:`(502) <Eq:advec:1D:pde1:u>`, :math:`v` is a given parameter, typically reflecting
the velocity of transport of a quantity :math:`u` with a flow.
There is only one boundary condition :ref:`(503) <Eq:advec:1D:pde1:U0>` since
the spatial derivative is only first order in the PDE :ref:`(502) <Eq:advec:1D:pde1:u>`.
The information at :math:`x=0` and the initial condition get
transported in the positive :math:`x` direction
if :math:`v>0` through the domain.

It is easiest to find the solution of :ref:`(502) <Eq:advec:1D:pde1:u>` if we remove the
boundary condition and consider a process on the
infinite domain :math:`(-\infty, \infty)`. The solution is simply

.. _Eq:advec:1D:pde1:sol:

.. math::

    \tag{505}
    u(x,t) = I(x-vt){\thinspace .}
        
        

This is also the solution we expect locally in a finite domain before boundary
conditions have reflected or modified the wave.

.. _advec:1D:FTCS:

Simplest scheme: forward in time, centered in space
---------------------------------------------------

Method          (1)
~~~~~~~~~~~~~~~~~~~

A first attempt to solve a PDE like :ref:`(502) <Eq:advec:1D:pde1:u>` will normally
be to look for a time-discretization scheme that is explicit so we avoid
solving systems of linear equations. In space, we anticipate that
centered differences are most accurate and therefore best. These
two arguments lead us to a Forward Euler scheme in time and
centered differences in space:

.. _Eq:_auto210:

.. math::

    \tag{506}
    [D_t^+ u + vD_{2x} u = 0]^n_i
        
        

Written out, we see that this expression reads

.. math::
         u^{n+1} = u^n - \frac{1}{2} C (u^n_{i+1}-u_{i-1}),

with :math:`C` as the Courant number

.. math::
         C = \frac{v\Delta t}{\Delta x}{\thinspace .}

Implementation          (9)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

A solver function for our scheme goes as follows.

.. code-block:: python

    import numpy as np
    import matplotlib.pyplot as plt
    
    def solver_FECS(I, U0, v, L, dt, C, T, user_action=None):
        Nt = int(round(T/float(dt)))
        t = np.linspace(0, Nt*dt, Nt+1)   # Mesh points in time
        dx = v*dt/C
        Nx = int(round(L/dx))
        x = np.linspace(0, L, Nx+1)       # Mesh points in space
        # Make sure dx and dt are compatible with x and t
        dx = x[1] - x[0]
        dt = t[1] - t[0]
        C = v*dt/dx
    
        u   = np.zeros(Nx+1)
        u_1 = np.zeros(Nx+1)
    
        # Set initial condition u(x,0) = I(x)
        for i in range(0, Nx+1):
            u_1[i] = I(x[i])
    
        if user_action is not None:
            user_action(u_1, x, t, 0)
    
        for n in range(0, Nt):
            # Compute u at inner mesh points
            for i in range(1, Nx):
                u[i] = u_1[i] - 0.5*C*(u_1[i+1] - u_1[i-1])
    
            # Insert boundary condition
            u[0] = U0
    
            if user_action is not None:
                user_action(u, x, t, n+1)
    
            # Switch variables before next step
            u_1, u = u, u_1

Test cases
~~~~~~~~~~

The typical solution :math:`u` has the shape of :math:`I` and is transported at
velocity :math:`v` to the right (if :math:`v>0`). Let us consider two different
initial conditions, one smooth (Gaussian pulse) and one non-smooth
(half-truncated cosine pulse):

.. _Eq:advec:1D:case_gaussian:

.. math::

    \tag{507}
    u(x,0) = Ae^{-\frac{1}{2}\left(\frac{x-L/10}{\sigma}\right)^2},
        
        

.. _Eq:advec:1D:case_cos:

.. math::

    \tag{508}
    u(x,0) = A\cos\left(\frac{5\pi}{L}\left( x - \frac{L}{10}\right)\right),\quad
        x < \frac{L}{5} \hbox{ else } 0{\thinspace .}
        
        

The parameter :math:`A` is the maximum value of the initial condition.

Before doing numerical simulations, we scale the PDE
problem and introduce :math:`\bar x = x/L` and :math:`\bar t= vt/L`,
which gives

.. math::
         \frac{\partial\bar u}{\partial \bar t} +
        \frac{\partial\bar u}{\partial\bar x} = 0{\thinspace .}

The unknown :math:`u` is scaled by the maximum value of the initial condition:
:math:`\bar u = u/\max |I(x)|` such that :math:`|\bar u(\bar x, 0)|\in [0,1]`.
The scaled problem is solved by setting :math:`v=1`, :math:`L=1`, and :math:`A=1`.
From now on we drop the bars.

To run our test cases and plot the solution, we make the function

.. code-block:: python

    def run_FECS(case):
        if case == 'gaussian':
            def I(x):
                return np.exp(-0.5*((x-L/10)/sigma)**2)
        elif case == 'cosinehat':
            def I(x):
                return np.cos(np.pi*5/L*(x - L/10)) if x < L/5 else 0
    
        L = 1.0
        sigma = 0.02
        legends = []
    
        def plot(u, x, t, n):
            """Animate and plot every m steps in the same figure."""
            plt.figure(1)
            if n == 0:
                lines = plot(x, u)
            else:
                lines[0].set_ydata(u)
                plt.draw()
                #plt.savefig()
            plt.figure(2)
            m = 40
            if n % m != 0:
                return
            print 't=%g, n=%d, u in [%g, %g] w/%d points' % \ 
                  (t[n], n, u.min(), u.max(), x.size)
            if np.abs(u).max() > 3:  # Instability?
                return
            plt.plot(x, u)
            legends.append('t=%g' % t[n])
            if n > 0:
                plt.hold('on')
    
        plt.ion()
        U0 = 0
        dt = 0.001
        C = 1
        T = 1
        solver(I=I, U0=U0, v=1.0, L=L, dt=dt, C=C, T=T,
               user_action=plot)
        plt.legend(legends, loc='lower left')
        plt.savefig('tmp.png'); plt.savefig('tmp.pdf')
        plt.axis([0, L, -0.75, 1.1])
        plt.show()

Bug?
~~~~

Running either of the test cases, the plot becomes a mess, and
the printout of :math:`u` values in the ``plot`` function reveals that
:math:`u` grows very quickly. We may reduce :math:`\Delta t` and make it
very small, yet the solution just grows.
Such behavior points to a bug in the code.
However, choosing a coarse mesh and performing a time step by
hand calculations produce the same numbers as in the code, so
it seems that the implementation is correct.
The hypothesis is therefore that the solution is unstable.

.. _advec:1D:FTCS:anal:

Analysis of the scheme
----------------------

It is easy to show that a typical Fourier component

.. math::
         u(x,t)= B\sin (k(x-ct))

is a solution of our PDE for any spatial wave length :math:`\lambda = 2\pi /k`
and any amplitude :math:`B`.
A general solution can be thought to be build of a collection of long and
short waves such waves with different amplitudes. Algebraically, the work
simplifies if we introduce the complex Fourier component

.. math::
         u(x,t)={A_{\small\mbox{e}}}^n e^{ikx},

with

.. math::
         {A_{\small\mbox{e}}}=Be^{-ikv\Delta t} = Be^{iCkx}{\thinspace .}

Note that :math:`|{A_{\small\mbox{e}}}| \leq 1`.

It turns out that many schemes also allow a Fourier wave component as
solution, and we can use the numerical value of :math:`A` to learn about the
quality of the scheme. Hence, to analyze the difference scheme we just
have implemented, we look at how treats the Fourier component

.. math::
         u_q^n = A^n e^{ikq\Delta x}{\thinspace .}

Inserting the numerical component in the scheme,

.. math::
         [D_t^+ A^n e^{ikq\Delta x} + v D_{2x}A^n e^{ikq\Delta x}]^n_i,

and making use of :ref:`(627) <Eq:form:exp:fd1c:center>`
results in

.. math::
         [e^{ikq\Delta x} (\frac{A-1}{\Delta t} + v\frac{1}{\Delta x}i\sin (k\Delta x))]^n_i,

which implies

.. math::
         A = 1 - iC\sin(k\Delta x){\thinspace .}

The numerical solution features the formula :math:`A^n`. To find out whether
:math:`A^n` means growth in time, we rewrite :math:`A` in polar form: :math:`A=A_re^{i\phi}`,
for real numbers :math:`A_r` and :math:`\phi`,
since we then have :math:`A^n = A_r^ne^{i\phi n}`. The magnitude of :math:`A^n` is
:math:`A_r^n`. In our case, :math:`A_r = (1 + C^2\sin^2(kx))^{1/2} > 1`, so
:math:`A_r^n` will increase in time, whereas the
exact solution will not. Regardless of :math:`\Delta t`, we get unstable
numerical solutions.

.. _advec:1D:leapfrog:

Leapfrog in time, centered differences in space
-----------------------------------------------

Method          (2)
~~~~~~~~~~~~~~~~~~~

Another explicit scheme is to do a "leapfrog" jump over :math:`2\Delta t` in
time and combine it with central differences in space:

.. math::
         [D_{2t} u + vD_{2x} u = 0]_i^n,

which results in the updating formula

.. math::
         u^{n+1} = u^{n-1} - C(u_{i+1}-u_{i-1}){\thinspace .}

A special scheme is needed to compute :math:`u^1`, but we leave that problem for
now.

Implementation          (10)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We now need to work with three time levels and must modify our solver a bit:

.. code-block:: python

    Nt = int(round(T/float(dt)))
    t = np.linspace(0, Nt*dt, Nt+1)   # Mesh points in time
    ...
    u   = np.zeros(Nx+1)
    u_1 = np.zeros(Nx+1)
    u_2 = np.zeros(Nx+1)
    ...
    for n in range(0, Nt):
        if scheme == 'FECS':
            for i in range(1, Nx):
                u[i] = u_1[i] - 0.5*C*(u_1[i+1] - u_1[i-1])
        elif scheme == 'LFCS':
            if n == 0:
                # Use some scheme for the first step
                for i in range(1, Nx):
                    ...
            else:
                for i in range(1, Nx+1):
                    u[i] = u_2[i] - C*(u_1[i] - u_1[i-1])
    
        # Switch variables before next step
        u_2, u_1, u = u_1, u, u_2

Running a test case
~~~~~~~~~~~~~~~~~~~

Let us try a coarse mesh such that the smooth Gaussian initial condition
is represented by 1 at mesh node 1 and 0 at all other nodes. This
triangular initial condition should then be advected to the right.
Choosing scaled variables as :math:`\Delta t=0.1`, :math:`T=1`, and :math:`C=1` gives
the plot in Figure :ref:`advec:1D:case_gaussian:fig:LFCS`, which
is in fact identical to the exact solution (!).

.. _advec:1D:case_gaussian:fig:LFCS:

.. figure:: solver_FE_Upw.png
   :width: 500

   Leapfrog scheme with :math:`\Delta t = 0.1` and :math:`C=1`

Analysis
~~~~~~~~

We can perform a Fourier analysis again. Inserting the numerical
Fourier component in the Leapfrog scheme, we get

.. math::
         A^2 - i2C\sin(k\Delta x) A - 1 = 0,

and

.. math::
         A = -iC\sin(k\Delta x) \pm \sqrt{1-C^2\sin^2(k\Delta x)}{\thinspace .}

Rewriting to polar form, :math:`A=A_re^{i\phi}`, we see that :math:`A_r=1`, so the
numerical component is not increasing or decreasing in time, which is
exactly what we want. However, for :math:`C>1`, the square root can become
complex valued, so stability is obtained only as long as :math:`C\leq 1`.

We introduce :math:`p=k\Delta x`. The amplification factor now reads

.. math::
         A = -iC\sin p \pm \sqrt{1-C^2\sin^2 p},

and is to be compared to the exact amplification factor

.. math::
         {A_{\small\mbox{e}}} = e^{-ikv\Delta t} = e^{-ikC\Delta x} = e^{-iCp}{\thinspace .}

the section :ref:`advec:1D:disprel` compares many numerical amplification factors
with the exact expression.

.. _advec:1D:FTUP:

Upwind differences in space
---------------------------

.. index:: upwind difference

Since the PDE reflects transport of information along with a flow in
positive :math:`x` direction, when :math:`v>0`, it could be natural to go (what is called)
upstream and not
downstream in a spatial derivative to collect information about the
change of the function. That is, we approximate

.. math::
        
        \frac{\partial u}{\partial x}(x_i,t_n)\approx [D^-_x u]^n_i = \frac{u^n_{i} - u^n_{i-1}}{\Delta x}{\thinspace .}

This is called an *upwind difference* (the corresponding difference in the
time direction would be called a backward difference, and we could use that
name in space too, but *upwind* is the common name for a difference against
the flow in advection problems). This spatial approximation does magic
compared to
the scheme we had with Forward Euler in time and centered difference in space.
With an upwind difference,

.. _Eq:advec:1D:upwind:

.. math::

    \tag{509}
    [D^+_t u + vD^-_x u = 0]^n_i,
        
        

written out as

.. math::
         u^{n+1} = u^n_i - C(u^{n}_{i}-u^{n}_{i-1}),

gives a generally popular and robust scheme that is stable if :math:`C\leq 1`.
As with the Leapfrog scheme, it becomes exact if :math:`C=1`, exactly as shown in
Figure :ref:`advec:1D:case_gaussian:fig:LFCS`.
However, any :math:`C<1` gives a significant reduction in the amplitude of the
solution, which is a purely numerical effect, see Figure
:ref:`advec:1D:FTUS:fig:C08`. Experiments show, however, that
reducing :math:`\Delta t` or :math:`\Delta x`, while keeping :math:`C` fixed reduces the
error.

.. _advec:1D:FTUS:fig:C08:

.. figure:: gaussian_FTUS_C08.png
   :width: 800

   *Forward in time, upwind in space, :math:`C=0.8`, :math:`\Delta t = 0.01` (left) and :math:`\Delta t=0.001` (right)*

The amplification factor can be computed using the
formula :ref:`(625) <Eq:form:exp:fd1:bw>`,

.. math::
         \frac{A - 1}{\Delta t} + \frac{v}{\Delta x}(1 - e^{-ik\Delta x}) = 0,

which means

.. math::
         A = 1 - C(1 - \cos(p) - i\sin(p)){\thinspace .}

For :math:`C<1` there is, unfortunately,
non-physical damping of discrete Fourier components. This damping can
be quite severe.


.. admonition:: Interpretation of upwind difference as artificial diffusion

   One can interpret the upwind difference as extra, artificial diffusion
   in the equation. Solving
   
   .. math::
            \frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x}
           = \nu\frac{\partial^2 u}{\partial x^2},
   
   by a forward difference time and centered differences in space,
   
   .. math::
            D^+_t u + vD_{2x} u = \nu D_xD_x u]^n_i,
   
   gives actually the upwind scheme :ref:`(509) <Eq:advec:1D:upwind>` if
   :math:`\nu = v\Delta x/2`. That is, solving the PDE :math:`u_t + vu_x=0`
   by centered differences in space and forward difference in time is
   unsuccessful, but by adding some artificial diffusion :math:`\nu u_{xx}`,
   the method becomes stable.




.. _advec:1D:periodic_BC:

Periodic boundary conditions
----------------------------

So far, we have given then value of on the left boundary, :math:`u_0^n`, and used
the scheme to propagate the solution signal through the domain.
Often, we want to follow such signals for long time series, and periodic
boundary conditions are then relevant since then enable a signal that
leaves the right boundary to immediately enter the left boundary and propagate
through the domain again.

The periodic boundary condition is

.. math::
         u(0,t) = u(L,t),\quad u_0^n = u_{N_x}^n{\thinspace .}

It means that we in the first equation, involving :math:`u_0^n`, insert :math:`u_{N_x}^n`,
and that we in the last equation, involving :math:`u^{n+1}_{N_x}` insert :math:`u^{n+1}_0`.
Normally, we can do this in the simple way that ``u_1[0]`` is updated as
``u_1[Nx]`` at the beginning of a new time level.

In some schemes we may need :math:`u^{n}_{N_x+1}` and :math:`u^{n}_{-1}`. Periodicity
then means that these values are equal to :math:`u^n_1` and :math:`u^n_{N_x-1}`,
respectively. For the upwind scheme it is sufficient to set
``u_1[0]=u_1[Nx]`` at a new time level before computing ``u[1]``, which ensures
that ``u[1]`` becomes right and at the next time level ``u[0]`` at the current
time level is correctly updated.
For the Leapfrog scheme we must update ``u[0]`` and ``u[Nx]`` using the scheme:

.. code-block:: python

    if periodic_bc:
        i = 0
        u[i] = u_2[i] - C*(u_1[i+1] - u_1[Nx-1])
    for i in range(1, Nx):
        u[i] = u_2[i] - C*(u_1[i+1] - u_1[i-1])
    if periodic_bc:
        u[Nx] = u[0]

.. _advec:1D:CN:

A Crank-Nicolson discretization in time and centered differences in space
-------------------------------------------------------------------------

Another obvious candidate for time discretization is the Crank-Nicolson
method combined with centered differences in space:

.. math::
         [D_t u]^n_i + v\frac{1}{2}([D_{2x} u]^{n+1}_i + [D_{2x} u]^{n}_i) = 0{\thinspace .}

It can be nice to include the Backward Euler scheme too, via the
:math:`\theta`-rule,

.. math::
         [D_t u]^n_i + v\theta [D_{2x} u]^{n+1}_i + v(1-\theta)[D_{2x} u]^{n}_i = 0{\thinspace .}

This gives rise to an *implicit* scheme,

.. math::
         u^{n+1}_i + \frac{\theta}{2} C (u^{n+1}_{i+1} - u^{n+1}_{i-1})
        = u^n_i - \frac{1-\theta}{2} C (u^{n}_{i+1} - u^{n}_{i-1})

for :math:`i=1,\ldots,N_x-1`. At the boundaries we use periodic conditions:

.. math::
         u^{n+1}_0 = u^{n+1}_{N_x},

however, this destroys the tridiagonal structure of the coefficient matrix.
We therefore try the rough approximation

.. math::
         u^{n+1}_0 = u^{n}_{N_x},\quad u^{n+1}_{N_x}=u^n_0{\thinspace .}

Otherwise, we need to prescribe :math:`u_0^{n+1}` and :math:`u_{N_x}^{n+1}`.

The elements on the diagonal in the matrix become:

.. math::
         A_{i,i} = 1,\quad i=0,\ldots,N_x{\thinspace .}

On the subdiagonal and superdiagonal we have

.. math::
         A_{i-1,i} = -\frac{\theta}{2} C,\quad A_{i+1,i} = \frac{\theta}{2} C,\quad i=1,\ldots,N_x-1,

with :math:`A_{0,1}=0` and :math:`A_{N_x-1,N_x}=0` due to the known boundary conditions.
And finally, the right-hand side becomes

.. math::
        \begin{align*}
        b_0 &= u^n_{N_x}\\ 
        b_i &= u^n_i - \frac{1-\theta}{2} C (u^{n}_{i+1} - u^{n}_{i-1}),\quad i=1,\ldots,N_x-1\\ 
        b_{N_x} &= u^n_0
        \end{align*}

The dispersion relation follows from inserting :math:`u^n_i = A^ne^{ikx}`
and using the formula :ref:`(627) <Eq:form:exp:fd1c:center>` for the spatial
differences:

.. math::
         A = \frac{1 - (1-\theta) i C\sin p}{1 + \theta i C\sin p}{\thinspace .}

.. _advec:1D:LaxW:

The Lax-Wendroff method
-----------------------

The Lax-Wendroff method is based on three ideas:

1. Express :math:`u^{n+1}_i` in terms of quantities at :math:`t=t_n` by
   means of a Taylor polynomial of second degree.

2. Replace time-derivatives at :math:`t=t_n` by spatial derivatives,
   using the PDE.

3. Discretize the spatial derivatives by second-order differences.

Let us do this:

.. math::
         u^{n+1}_i = u^n_i + \Delta t\left(\frac{\partial u}{\partial t}\right)^n_i
        + \frac{1}{2}\Delta t^2\left(\frac{\partial^2 u}{\partial t^2}\right)^n_i{\thinspace .}

From the PDE we have that

.. math::
         \frac{\partial u}{\partial t} = -v\frac{\partial u}{\partial x},

which we may use to replace the time-derivatives by spatial derivatives
(:math:`\frac{\partial ^2}{\partial t^2} = v^2\frac{partial^2 u}{\partial x^2}`):

.. math::
         u^{n+1}_i = u^n_i -v \Delta t\left(\frac{\partial u}{\partial x}\right)^n_i
        + \frac{1}{2}\Delta t^2 v^2
        \left(\frac{\partial^2 u}{\partial x^2}\right)^n_i{\thinspace .}

A natural spatial discretization is, for instance, central differences:

.. math::
         u^{n+1}_i = u^n_i -v \Delta t [D_{2x} u]^n_i
        + \frac{1}{2}\Delta t^2 v^2 [D_xD_x u]^n_i,

or

.. math::
         u^{n+1}_i = u^n_i - C (u^{n}_{i+1} - u^{n}_{i-1})
        + \frac{1}{2} C^2 (u^{n}_{i+1}-2u^n_i+u^n_{i-1}){\thinspace .}

This is the explicit Lax-Wendroff scheme.

From an analysis similar to the ones carried out above, we get an
amplification factor

.. math::
         A = 1 - iC\sin p - 2C^2\sin^2 (p/2){\thinspace .}

This means that :math:`|A|=1` and also that we have an exact solution of :math:`C=1`!

.. _advec:1D:disprel:

Analysis of dispersion relations
--------------------------------

We have developed expressions for :math:`A(C,p)` in the exact solution
:math:`u_q^n=A^ne^{ikq\Delta x}` of the discrete equations. These
expressions are valuable for investigating the quality of the numerical
solutions. Note that the Fourier component that solves the original
PDE problem has no damping and moves with constant velocity :math:`v`. There
are two basic errors in the numerical Fourier component: there may be
damping and the wave velocity may depend on :math:`C` and :math:`p=k\Delta x`.

The shortest wavelength that can be represented is :math:`\lambda = 2\Delta x`.
The corresponding :math:`k` is :math:`k=2\pi/\lambda = \pi/\Delta x`, so :math:`p=k\Delta x\in
(0,\pi]`.

Given a complex :math:`A` as a function of :math:`C` and :math:`p`, how can we visualize
it? The two key ingredients in :math:`A` is the magnitude, reflecting damping or
growth of the wave, and the angle, closely related to the
velocity of the wave. The Fourier component

.. math::
         D^n e^{ik(x-ct)}

has damping :math:`D` and wave velocity :math:`c`. Let us express our :math:`A` in
polar form, :math:`A = A_re^{i\phi}`, and insert this expression in
our discrete component :math:`u_q^n = A^ne^{ikq\Delta x} = A^ne^{ikx}`:

.. math::
        
        u^n_q = A_r^n e^{i\phi n} e^{ikx} = A_r^n e^{i(kx - n\phi)} =
        A_r^ne^{i(k(x - ct))},

for

.. math::
        
        c = \frac{\phi}{k\Delta t}{\thinspace .}
        

Now,

.. math::
         k\Delta t = \frac{Ck\Delta x}{v}=\frac{Cp}{v},

so

.. math::
         c = \frac{\phi v}{Cp}{\thinspace .}

An appropriate dimensionless quantity to plot is :math:`c/v`:

.. math::
         \frac{c}{v} = \frac{\phi}{Cp}{\thinspace .}

.. _advec:1D:disprel:C099:

.. figure:: disprel_C0_99.png
   :width: 800

   Dispersion relations for :math:`C=0.99`

.. _advec:1D:disprel:C09:

.. figure:: disprel_C0_9.png
   :width: 800

   Dispersion relations for :math:`C=0.9`

.. _advec:1D:disprel:C08:

.. figure:: disprel_C0_8.png
   :width: 800

   Dispersion relations for :math:`C=0.8`

.. _advec:1D:disprel:C05:

.. figure:: disprel_C0_5.png
   :width: 800

   Dispersion relations for :math:`C=0.5`

.. _advec:1D:disprel:C99:

.. figure:: disprel_C0_99.png
   :width: 800

   Dispersion relations for :math:`C=0.99`

The total damping after some time :math:`T=n\Delta t` is reflected by
:math:`A_r(C,p)^n`. Since normally :math:`A_r<1`, the damping goes like
:math:`A_r^{1/\Delta t}` and approaches zero as :math:`\Delta t\rightarrow 0`.

.. _advec:1D:stationary:

One-dimensional stationary advection-diffusion equation
=======================================================

Now we pay attention to a physical process where advection (or convection)
is in balance with diffusion:

.. _Eq:advec:1D:stat:pde1:

.. math::

    \tag{510}
    v\frac{du}{dx} = {\alpha}\frac{d^2 u}{dx^2}{\thinspace .}
        
        

For simplicity, we assume :math:`v` and :math:`{\alpha}` to be constant, but the extension to
the variable-coefficient case is trivial.
This is equation can be viewed as the stationary limit of the corresponding
time-dependent problem

.. _Eq:advec:1D:stat:pde2:

.. math::

    \tag{511}
    \frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} =
        {\alpha}\frac{\partial^2 u}{\partial x^2}{\thinspace .}
        
        

Equations of the form :ref:`(510) <Eq:advec:1D:stat:pde1>` or
:ref:`(511) <Eq:advec:1D:stat:pde2>` arise from transport phenomena, either mass
or heat transport. One can also view the equations as simple model
problems for the Navier-Stokes equations. A fundamental difficulty
with solving these equations is numerical instability if the
first-derivative spatial term dominates over the second-derivative
term.

.. _advec:1D:stationary:model:

A simple model problem          (1)
-----------------------------------

We consider :ref:`(510) <Eq:advec:1D:stat:pde1>` on :math:`[0,L]` equipped with the
boundary conditions :math:`u(0)=U_0`, :math:`u(L)=U_L`.  By scaling we can get rid
of lots of physical parameter and instead reduce the discussion to
combinations of physical parameters. We scale :math:`x` by :math:`\bar x = x/L`,
and :math:`u` by

.. math::
         \bar u = \frac{u - u_0}{u_L-u_0}{\thinspace .}

Inserted in the governing equation we get

.. math::
         \frac{v(u_L-u_0)}{L}\frac{d\bar u}{d\bar x} =
        \frac{{\alpha}(u_L-u_0)}{L^2}\frac{d^2\bar u}{d\bar x^2},\quad
        \bar u(0)=0,\ \bar u(1)=1{\thinspace .}

Dropping the bars is common. We can then simplify to

.. _Eq:advec:1D:stat:pde1s:

.. math::

    \tag{512}
    \frac{du}{dx} = \epsilon\frac{d^2 u}{d x^2},\quad u(0)=0,\ u(1)=1{\thinspace .}
        
        

There are two competing effects in this equation: the advection term
transports signals to the right (with velocity :math:`v`, later with unit
velocity), while the diffusion term transports signals to the left and
right )with strength :math:`{\alpha}`, later with strength :math:`\epsilon`). The
value :math:`u(0)=0` is transported through the domain if :math:`\epsilon` is
small, and :math:`u\approx 0` except in the vicinity of :math:`x=0`, where
:math:`u(1)=1` and the diffusion transports some information about :math:`u(1)=1`
to the left. For large :math:`\epsilon`, diffusion dominates and the :math:`u`
takes on the "average" value, i.e., :math:`u` gets a linear variation from
0 to 1 throughout the domain.

It turns out that we can find an exact solution to the differential
equation problem and also to many of its discretization. This is one
reason why this model problem has been so successful in designing and
investigating numerical methods for mixed convection/advection and
diffusion.  The exact solution reads

.. math::
         {u_{\small\mbox{e}}} (x) = \frac{e^{x/\epsilon} - 1}{e^{1/\epsilon} - 1}{\thinspace .}

.. _advec:1D:stationary:fdm:

A centered finite difference scheme          (2)
------------------------------------------------

The most obvious idea to solve :ref:`(512) <Eq:advec:1D:stat:pde1s>` is to apply
centered differences:

.. math::
         [D_{2x} u = \epsilon D_xD_x u]_i 

for :math:`i=1,\ldots,N_x-1`, with :math:`u_0=0` and :math:`u_{N_x}=1`.
Note that this is a coupled system of algebraic equations
involving :math:`u_0,\ldots,u_{N_x}`.

Written out, the scheme becomes a tridiagonal system

.. math::
         A_{i-1,i}u_{i-1} + A_{i,i}u_i + A_{i+1.i}u_{i+1} = 0,

for :math:`i=1,\ldots,N_x-1`

.. math::
        \begin{align*}
        A_{0,0} &= 1,\\ 
        A_{i-1,i} &= -\frac{1}{\Delta x} -\epsilon\frac{1}{\Delta x^2},\\ 
        A_{i,i} &= 2\epsilon\frac{1}{\Delta x^2},\\ 
        A_{i,i+1} &=  \frac{1}{\Delta x} -\epsilon\frac{1}{\Delta x^2},\\ 
        A_{N_x,N_x} &= 1{\thinspace .}
        \end{align*}

The right-hand side of the linear system is zero except :math:`b_{N_x}=1`.

Figure :ref:`advec:1D:stationary:fdm:fig1` shows reasonably accurate
results with :math:`N_x=20` and :math:`N_x=40` cells in :math:`x` direction and a value of
:math:`\epsilon = 0.1`. Decreasing :math:`\epsilon` to :math:`0.01` leads to oscillatory
solutions as depicted in Figure :ref:`advec:1D:stationary:fdm:fig2`.
This is, unfortunately, a typical phenomenon in this type of problem:
non-physical oscillations arise for small :math:`\epsilon` unless the resolution
:math:`N_x` is not big enough. :ref:`advec:1D:stationary:exer:analysis1`
develops a precise criterion: :math:`u` is oscillation-free if

.. math::
         \Delta x \leq \frac{2}{\epsilon}{\thinspace .}

If we take the present model as a simplified model for a *viscous
boundary layer* in real, industrial fluid flow applications,
:math:`\epsilon\sim 10^{-6}`
and million of cells are required to resolve the boundary layer.
Fortunately, this is not strictly necessary as we have methods in
the next section to overcome the problem!

.. _advec:1D:stationary:fdm:fig1:

.. figure:: twopt_BVP_cen_01.png
   :width: 800

   Comparison of exact and numerical solution for :math:`\epsilon =0.1` and :math:`N_x=20,40` with centered differences

.. _advec:1D:stationary:fdm:fig2:

.. figure:: twopt_BVP_cen_001.png
   :width: 800

   Comparison of exact and numerical solution for :math:`\epsilon =0.01` and :math:`N_x=20,40` with centered differences


.. admonition:: Solver

   A suitable solver for doing the experiments is presented below.
   
   .. @@@CODE src-advec/twopt_BVP.py fromto: import numpy@def u_exact




.. _advec:1D:stationary:upwind:

Remedy: upwind finite difference scheme
---------------------------------------

The scheme can be stabilized by letting the advective transport term, which
is the dominating term, collect its information in the flow direction, i.e.,
upstream or upwind of the point in question. So, instead of using a
center difference

.. math::
         \frac{du}{dx}_i\approx \frac{u_{i+1}-u_{i-1}}{2\Delta x},

we use the one-sided *upwind* difference

.. math::
         \frac{du}{dx}_i\approx \frac{u_{i}-u_{i-1}}{2\Delta x},

in case :math:`v>0`. For :math:`v<0` we set

.. math::
         \frac{du}{dx}_i\approx \frac{u_{i+1}-u_{i}}{2\Delta x},

On compact operator notation form, our upwind scheme can be expressed
as

.. math::
         [D^-_x u = \epsilon D_xD_x u]_i 

provided :math:`v>0` (and :math:`\epsilon > 0`).

We write out the equations and implement them as shown in the program
in the section :ref:`advec:1D:stationary:fdm`. The results appear in Figures
:ref:`advec:1D:stationary:upwind:fig1` and
:ref:`advec:1D:stationary:upwind:fig2`: no more oscillations!

.. _advec:1D:stationary:upwind:fig1:

.. figure:: twopt_BVP_upw_01.png
   :width: 800

   Comparison of exact and numerical solution for :math:`\epsilon =0.1` and :math:`N_x=20,40` with upwind difference

.. _advec:1D:stationary:upwind:fig2:

.. figure:: twopt_BVP_upw_001.png
   :width: 800

   Comparison of exact and numerical solution for :math:`\epsilon =0.01` and :math:`N_x=20,40` with upwind difference

We see that the upwind scheme is always stable, but it gives a thicker
boundary layer when the centered scheme is also stable.
Why the upwind scheme is always stable is easy to understand as
soon as we undertake the mathematical analysis in
:ref:`advec:1D:stationary:exer:analysis1`.
Moreover, the thicker layer (seemingly larger diffusion) can be
understood by doing
:ref:`advec:1D:stationary:exer:analysis2`.


.. admonition:: Exact solution for this model problem

   It turns out that one can introduce a linear combination of the centered
   and upwind differences for the first-derivative term in this model
   problem. One can then adjust the weight in the linear combination so that
   the numerical solution becomes identical to the analytical solution of
   the differential equation problem at any mesh point.
   
   .. This approach cannot be generalized to more complicated problems.




Time-dependent convection-diffusion equations
=============================================

Now it is time to combine time-dependency, convection (advection) and
diffusion into one equation:

.. _Eq:advec:1D:stat:pde3:

.. math::

    \tag{513}
    \frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} =
        {\alpha}\frac{\partial^2 u}{\partial x^2}{\thinspace .}
        
        
        seen that upwind has been critical, so that will work, but will centered
        also work in this case?

.. _advec:2D:

Two-dimensional advection-diffusion equations
=============================================

.. _advec:app:

Applications of advection equations
===================================

Exercises          (8)
======================

.. --- begin exercise ---

.. _advec:1D:stationary:exer:analysis1:

Exercise 4.1: Analyze 1D stationary convection-diffusion problem
----------------------------------------------------------------

Explain the observations in the numerical experiments from the sections :ref:`advec:1D:stationary:fdm` and :ref:`advec:1D:stationary:upwind` by
finding exact numerical solutions.

.. --- begin hint in exercise ---

**Hint.**
The difference equations allow solutions on the form :math:`A^i`, where
:math:`A` is an unknown constant and :math:`i` is a mesh point counter.
There are two solutions for :math:`A`, so the general solution is a linear
combination of the two, where the constants in the linear combination
are determined from the boundary conditions.

.. --- end hint in exercise ---

Filename: ``twopt_BVP_analysis1``.

.. --- end exercise ---

.. --- begin exercise ---

.. _advec:1D:stationary:exer:analysis2:

Exercise 4.2: Interpret upwind difference as artificial diffusion
-----------------------------------------------------------------

Consider an upwind, one-sided difference approximation to
a term :math:`du/dx` in a differential equation. Show that this this
formula can be expressed as a centered difference plus an artificial
diffusion term of strength proportional to :math:`\Delta x`.
This means that introducing an upwind difference also means introducing
extra diffusion of order :math:`{\mathcal{O}(\Delta x)}`.
Filename: ``twopt_BVP_analysis2``.

.. --- end exercise ---

