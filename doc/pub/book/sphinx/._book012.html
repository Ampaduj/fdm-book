
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advection-dominated equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Staggered mesh discretization" href="._book013.html" />
    <link rel="prev" title="Diffusion equations" href="._book011.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Staggered mesh discretization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Diffusion equations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="advection-dominated-equations">
<span id="ch-convdiff"></span><h1>Advection-dominated equations<a class="headerlink" href="#advection-dominated-equations" title="Permalink to this headline">¶</a></h1>
<p>Wave (the chapter <a class="reference internal" href="._book005.html#ch-wave"><span class="std std-ref">Wave equations</span></a>) and diffusion (the chapter <a class="reference internal" href="._book011.html#ch-diffu"><span class="std std-ref">Diffusion equations</span></a>) equations
are solve reliably by finite difference methods. As soon as we add a
first-order derivative in space, representing <em>advective transport</em> (also
known as convective transport), the numerics gets more complicated, and
intuitively attractive methods no longer work well. We shall show
how and why methods fail and provide remedies. The present chapter
builds on basic knowledge about finite difference methods for
the diffusion equations, including the analysis by Fourier components,
truncation error analysis ( <a class="reference internal" href="._book021.html#ch-trunc"><span class="std std-ref">Appendix: Truncation error analysis</span></a>), and
compact difference notation.</p>
<div class="section" id="one-dimensional-time-dependent-advection-equations">
<span id="advec-1d"></span><h2>One-dimensional time-dependent advection equations<a class="headerlink" href="#one-dimensional-time-dependent-advection-equations" title="Permalink to this headline">¶</a></h2>
<p>We consider the pure advection model</p>
<div class="math" id="eq-advec-1d-pde1-u">
\[\tag{454}
\frac{\partial u}{\partial t} + v\frac{partial u}{\partial x} = 0,\quad
     x\in (0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-advec-1d-pde1-u0">
\[\tag{455}
u(x,0) = I(x), x\in (0,L),\]</div>
<div class="math" id="eq-advec-1d-pde1-i">
\[\tag{456}
u(0,t) = U_0, t\in (0,T].\]</div>
<p>In <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(454)</span></a>, <span class="math">\(v\)</span> is a given parameter, typically reflecting
the velocity of transport of a quantity <span class="math">\(u\)</span> with a flow.
There is only one boundary condition <a class="reference internal" href="#eq-advec-1d-pde1-u0"><span class="std std-ref">(455)</span></a> since
there is only a first-derivative term in the PDE <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(454)</span></a>.
The information at <span class="math">\(x=0\)</span> and the initial condition get
transported in positive <span class="math">\(x\)</span> direction
if <span class="math">\(v&gt;0\)</span> through the domain.</p>
<p>The solution of <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(454)</span></a> in an infinite domain (no condition
<a class="reference internal" href="#eq-advec-1d-pde1-u0"><span class="std std-ref">(455)</span></a> at <span class="math">\(x=0\)</span>) is</p>
<div class="math" id="eq-advec-1d-pde1-sol">
\[\tag{457}
u(x,t) = I(x-vt){\thinspace .}\]</div>
<p>This is also the solution we expect if we let <span class="math">\(I(x)\)</span> be located in
the interior of the domain such that <span class="math">\(\lim_{x\rightarrow 0,L}I(x)=0\)</span>
and <span class="math">\(U_0=0\)</span>.</p>
<div class="section" id="simplest-scheme-forward-in-time-centered-in-space">
<h3>Simplest scheme: forward in time, centered in space<a class="headerlink" href="#simplest-scheme-forward-in-time-centered-in-space" title="Permalink to this headline">¶</a></h3>
<div class="section" id="method-1">
<h4>Method<a class="headerlink" href="#method-1" title="Permalink to this headline">¶</a></h4>
<p>A first attempt to solve a PDE like <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(454)</span></a> will normally
look for a time-discretization scheme that is explicit so we avoid
solving systems of linear equations. In space, we anticipate that
centered differences are most accurate and therefore best. These
two arguments lead us to a Forward Euler scheme in time and
centered differences in space:</p>
<div class="math" id="eq-auto181">
\[\tag{458}
[D_t^+ u + vD_{2x} u = 0]^n_i\]</div>
<p>Written out,</p>
<div class="math">
\[u^{n+1} = u^n - \frac{1}{2} C (u^n_{i+1}-u_{i-1}),\]</div>
<p>with <span class="math">\(C\)</span> as the Courant number</p>
<div class="math">
\[C = \frac{v\Delta t}{\Delta x}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-9">
<h4>Implementation<a class="headerlink" href="#implementation-9" title="Permalink to this headline">¶</a></h4>
<p>A solver function for our scheme goes as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver_FECS</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">U0</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">C</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c"># Mesh points in space</span>
    <span class="c"># Make sure dx and dt are compatible with x and t</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Set initial condition u(x,0) = I(x)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c"># Compute u at inner mesh points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c"># Insert boundary condition</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">U0</span>

        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Switch variables before next step</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
</div>
<div class="section" id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this headline">¶</a></h4>
<p>The typical solution is <span class="math">\(u\)</span> has the shape of <span class="math">\(I\)</span> and is transported at
velocity <span class="math">\(v\)</span> to the right (if <span class="math">\(v&gt;0\)</span>). Let us choose a smooth and non-smooth
initial condition:</p>
<div class="math" id="eq-advec-1d-case-gaussian">
\[\tag{459}
u(x,0) = Ae^{-\frac{1}{2}\left(\frac{x-L/10}{\sigma}\right)^2},\]</div>
<div class="math" id="eq-advec-1d-case-cos">
\[\begin{split}\tag{460}
u(x,0) = A\cos\left(\frac{5\pi}{L}\left( x - \frac{L}{10}\right)\right),\quad
    x &lt; \frac{L}{5} \hbox{ else } 0{\thinspace .}\end{split}\]</div>
<p>The parameter <span class="math">\(A\)</span> is the maximum value of the initial condition.</p>
<p>We scale the problem and introduce <span class="math">\(\bar x = x/L\)</span> and <span class="math">\(\bar t= vt/L\)</span>,
which gives</p>
<div class="math">
\[\frac{\partial\bar u}{\partial \bar t} +
\frac{\partial\bar u}{\partial\bar x} = 0{\thinspace .}\]</div>
<p>The unknown <span class="math">\(u\)</span> is scaled by the maximum value of the initial condition:
<span class="math">\(\bar u = u/\max |I(x)|\)</span> such that <span class="math">\(|\bar u(\bar x, 0)|\in [0,1]\)</span>.
The scaled problem is solved by setting <span class="math">\(v=1\)</span>, <span class="math">\(L=1\)</span>, and <span class="math">\(A=1\)</span>.
From now on we drop the bars.</p>
<p>To run a case and plot the solution, we make the function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">run_FECS</span><span class="p">(</span><span class="n">case</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="s">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">case</span> <span class="o">==</span> <span class="s">&#39;cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">/</span><span class="mi">5</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.02</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot every m steps in the same figure.&quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">print</span> <span class="s">&#39;t=</span><span class="si">%g</span><span class="s">, n=</span><span class="si">%d</span><span class="s">, u in [</span><span class="si">%g</span><span class="s">, </span><span class="si">%g</span><span class="s">] w/</span><span class="si">%d</span><span class="s"> points&#39;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">u</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c"># Instability?</span>
            <span class="k">return</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>

    <span class="n">U0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.001</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">U0</span><span class="o">=</span><span class="n">U0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="bug">
<h4>Bug?<a class="headerlink" href="#bug" title="Permalink to this headline">¶</a></h4>
<p>Running either of the test cases, the plot becomes a mess, and
the printout of <span class="math">\(u\)</span> values in the <code class="docutils literal"><span class="pre">plot</span></code> function reveals that
<span class="math">\(u\)</span> grows very quickly. We may reduce <span class="math">\(\Delta t\)</span> and make it
very small, yet the solution just grows.
Such behavior points to a bug in the code.
However, choosing a coarse mesh and performing a time step by
hand calculations produce the same numbers as in the code, so
it seems that the implementation is correct.
The hypothesis is therefore that the solution is unstable.</p>
</div>
</div>
<div class="section" id="analysis-of-the-scheme">
<h3>Analysis of the scheme<a class="headerlink" href="#analysis-of-the-scheme" title="Permalink to this headline">¶</a></h3>
<p>We can analyze the finite difference scheme by look at how it treats
a Fourier component</p>
<div class="math">
\[u_q^n = A^n e^{ikq\Delta x}{\thinspace .}\]</div>
<p>The corresponding analytical Fourier component is</p>
<div class="math">
\[u = {A_{\small\mbox{e}}}^n e^{ikx},\quad {A_{\small\mbox{e}}} = e^{-ivk\Delta t}=e^{-iCkx}{\thinspace .}\]</div>
<p>In particular, <span class="math">\(|{A_{\small\mbox{e}}}| \leq 1\)</span>.</p>
<p>Inserting the numerical component in the scheme,</p>
<div class="math">
\[[D_t^+ A^n e^{ikq\Delta x} + v D_{2x}A^n e^{ikq\Delta x}]^n_i,\]</div>
<p>and making use of <a class="reference internal" href="._book020.html#eq-form-exp-fd1c-center"><span class="std std-ref">(595)</span></a>
results in</p>
<div class="math">
\[[e^{ikq\Delta x} (\frac{A-1}{\Delta t} + v\frac{1}{\Delta x}i\sin (k\Delta x))]^n_i,\]</div>
<p>which implies</p>
<div class="math">
\[A = 1 - iC\sin(k\Delta x){\thinspace .}\]</div>
<p>The numerical solution features the formula <span class="math">\(A^n\)</span>. To find out whether
<span class="math">\(A^n\)</span> means growth in time, we rewrite <span class="math">\(A\)</span> in polar form: <span class="math">\(A=A_re^{i\phi}\)</span>,
for real numbers <span class="math">\(A_r\)</span> and <span class="math">\(\phi\)</span>,
since we then have <span class="math">\(A^n = A_r^ne^{i\phi n}\)</span>. The magnitude of <span class="math">\(A^n\)</span> is
<span class="math">\(A_r^n\)</span>. In our case, <span class="math">\(A_r = (1 + C^2\sin^2(kx))^{1/2} &gt; 1\)</span>, so
<span class="math">\(A_r^n\)</span> will increase in time, whereas the
exact solution will not. Regardless of <span class="math">\(\Delta t\)</span>, we get unstable
numerical solutions.</p>
</div>
<div class="section" id="leapfrog-in-time-centered-differences-in-space">
<h3>Leapfrog in time, centered differences in space<a class="headerlink" href="#leapfrog-in-time-centered-differences-in-space" title="Permalink to this headline">¶</a></h3>
<div class="section" id="method-2">
<h4>Method<a class="headerlink" href="#method-2" title="Permalink to this headline">¶</a></h4>
<p>Another explicit scheme is to do a &#8220;leapfrog&#8221; jump over <span class="math">\(2\Delta t\)</span> in
time and combine it with central differences in space:</p>
<div class="math">
\[[D_{2t} u + vD_{2x} u = 0,\]</div>
<p>which results in the updating formula</p>
<div class="math">
\[u^{n+1} = u^{n-1} - C(u_{i+1}-u_{i-1}){\thinspace .}\]</div>
<p>A special scheme is needed to compute <span class="math">\(u^1\)</span>, but we leave that problem or
now.</p>
</div>
<div class="section" id="implementation-10">
<h4>Implementation<a class="headerlink" href="#implementation-10" title="Permalink to this headline">¶</a></h4>
<p>We now need to have three time levels and must modify our solver a bit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Mesh points in time</span>
<span class="o">...</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s">&#39;FECS&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s">&#39;LFCS&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Use some scheme for the first step</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
                <span class="o">...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_2</span>
</pre></div>
</div>
</div>
<div class="section" id="running-the-test-case">
<h4>Running the test case<a class="headerlink" href="#running-the-test-case" title="Permalink to this headline">¶</a></h4>
<p>Let us try a coarse mesh such that the smooth Gaussian initial condition
is represented by 1 at mesh node 1 and 0 at all other nodes. This
triangular initial condition should then be advected to the right.
Choosing scaled variables as <span class="math">\(\Delta t=0.1\)</span>, <span class="math">\(T=1\)</span>, and <span class="math">\(C=1\)</span> gives
the plot in Figure <a class="reference internal" href="#advec-1d-case-gaussian-fig-lfcs"><span class="std std-ref">Leapfrog scheme with  and </span></a>, which
is in fact identical to the exact solution (!).</p>
<div class="figure" id="id1">
<span id="advec-1d-case-gaussian-fig-lfcs"></span><a class="reference internal image-reference" href="_images/solver_FE_Upw.png"><img alt="_images/solver_FE_Upw.png" src="_images/solver_FE_Upw.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Leapfrog scheme with <span class="math">\(\Delta t = 0.1\)</span> and <span class="math">\(C=1\)</span></span></p>
</div>
</div>
<div class="section" id="analysis">
<h4>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h4>
<p>We can perform a Fourier analysis again. Inserting the numerical
Fourier component in the Leapfrog scheme, we get</p>
<div class="math">
\[A^2 - i2C\sin(k\Delta x) A - 1 = 0,\]</div>
<p>and</p>
<div class="math">
\[A = -iC\sin(k\Delta x) \pm \sqrt{1-C^2\sin^2(k\Delta x)}{\thinspace .}\]</div>
<p>Rewriting to polar form, <span class="math">\(A=A_re^{i\phi}\)</span>, we see that <span class="math">\(A_r=1\)</span>, so the
numerical component is not increasing or decreasing in time, which is
exactly what we want. However, for <span class="math">\(C&gt;1\)</span>, the square root can become
complex valued, so stability is obtained only as long as <span class="math">\(C\leq 1\)</span>.</p>
<p>[<strong>hpl 24</strong>: The complete numerical solution? How are the two roots combined?]</p>
<p>We introduce <span class="math">\(p=k\Delta x\)</span>. The amplification factor now reads</p>
<div class="math">
\[A = -iC\sin p \pm \sqrt{1-C^2\sin^2 p},\]</div>
<p>and is to be compared to the exact amplification factor</p>
<div class="math">
\[{A_{\small\mbox{e}}} = e^{-ikv\Delta t} = e^{-ikC\Delta x} = e^{-iCp}{\thinspace .}\]</div>
<p>the section <a class="reference internal" href="#advec-1d-disprel"><span class="std std-ref">Analysis of dispersion relations</span></a> compares many numerical amplification factors
with the exact expression.</p>
</div>
</div>
<div class="section" id="upwind-differences-in-space">
<h3>Upwind differences in space<a class="headerlink" href="#upwind-differences-in-space" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Since the PDE reflects transport of information along with a flow in
positive <span class="math">\(x\)</span> direction <span class="math">\(v&gt;0\)</span>, it could be natural to go upstream and not
downstream in a spatial derivative. That is, we approximate</p>
<div class="math">
\[\frac{\partial u}{\partial x}(x_i,t_n)\approx [D^-_x u]^n_i = \frac{u^n_{i} - u^n_{i-1}}{\Delta x}{\thinspace .}\]</div>
<p>This is called an <em>upwind difference</em>. This spatial approximation does magic to
the scheme we had with Forward Euler in time and centered difference in space.
With an upwind difference,</p>
<div class="math" id="eq-advec-1d-upwind">
\[\tag{461}
[D^+_t u + vD^-_x u = 0]^n_i,\]</div>
<p>written out as</p>
<div class="math">
\[u^{n+1} = u^n_i - C(u^{n}_{i}-u^{n}_{i-1}),\]</div>
<p>gives a robust scheme that is stable if <span class="math">\(C\leq 1\)</span>.
As with the Leapfrog scheme, it becomes exact if <span class="math">\(C=1\)</span>.
A plot of the solution in case <span class="math">\(C=1\)</span> is therefore given in
Figure <a class="reference internal" href="#advec-1d-case-gaussian-fig-lfcs"><span class="std std-ref">Leapfrog scheme with  and </span></a>.</p>
<p>The amplification factor can be computed using the
formula <a class="reference internal" href="._book020.html#eq-form-exp-fd1-bw"><span class="std std-ref">(593)</span></a>,</p>
<div class="math">
\[\frac{A - 1}{\Delta t} + \frac{v}{\Delta x}(1 - e^{-ik\Delta x}) = 0,\]</div>
<p>which means</p>
<div class="math">
\[A = 1 - C(1 - \cos(p) - i\sin(p)){\thinspace .}\]</div>
<p>For <span class="math">\(C&lt;1\)</span> there is, unfortunately,
non-physical damping of discrete Fourier components. This damping can
be quite severe.</p>
<p>One can interpret the upwind difference as extra, artificial diffusion
in the equation. Solving</p>
<div class="math">
\[\frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x}
= \nu\frac{\partial^2 u}{\partial x^2},\]</div>
<p>by a forward difference time and centered differences in space,</p>
<div class="math">
\[D^+_t u + vD_{2x} u = \nu D_xD_x u]^n_i,\]</div>
<p>gives actually the upwind scheme <a class="reference internal" href="#eq-advec-1d-upwind"><span class="std std-ref">(461)</span></a> if
<span class="math">\(\nu = v\Delta x/2\)</span>. That is, solving the PDE <span class="math">\(u_t + vu_x=0\)</span>
by centered differences in space and forward difference in time is
unsuccessful, but by adding some artificial diffusion <span class="math">\(\nu u_{xx}\)</span>,
the method becomes stable.</p>
</div>
<div class="section" id="a-crank-nicolson-discretization-in-time-and-centered-differences-in-space">
<h3>A Crank-Nicolson discretization in time and centered differences in space<a class="headerlink" href="#a-crank-nicolson-discretization-in-time-and-centered-differences-in-space" title="Permalink to this headline">¶</a></h3>
<div class="math">
\[A = \frac{1 - \frac{1}{2} i C\sin p}{1 + \frac{1}{2} i C\sin p}{\thinspace .}\]</div>
</div>
<div class="section" id="the-lax-wendroff-method">
<h3>The Lax-Wendroff method<a class="headerlink" href="#the-lax-wendroff-method" title="Permalink to this headline">¶</a></h3>
<div class="math">
\[A = 1 - iC\sin p - 2C^2\sin^2 (p/2){\thinspace .}\]</div>
</div>
<div class="section" id="analysis-of-dispersion-relations">
<span id="advec-1d-disprel"></span><h3>Analysis of dispersion relations<a class="headerlink" href="#analysis-of-dispersion-relations" title="Permalink to this headline">¶</a></h3>
<p>We have developed expressions for <span class="math">\(A(C,p)\)</span> in the exact solution
<span class="math">\(u_q^n=A^ne^{ikq\Delta x}\)</span> of the discrete equations. These
expressions are valuable for investigating the quality of the numerical
solutions. Note that the Fourier component that solves the original
PDE problem has no damping and moves with constant velocity <span class="math">\(v\)</span>. There
are two basic errors in the numerical Fourier component: there may be
damping and the wave velocity may depend on <span class="math">\(C\)</span> and <span class="math">\(p=k\Delta x\)</span>.</p>
<p>The shortest wavelength that can be represented is <span class="math">\(\lambda = 2\Delta x\)</span>.
The corresponding <span class="math">\(k\)</span> is <span class="math">\(k=2\pi/\lambda = \pi/Delta x\)</span>, so <span class="math">\(p=k\Delta x\in
(0,\pi]\)</span>.</p>
<p>Given a complex <span class="math">\(A\)</span> as a function of <span class="math">\(C\)</span> and <span class="math">\(p\)</span>, how can we visualize
it? The two key ingredients in <span class="math">\(A\)</span> is the magnitude, reflecting damping or
growth of the wave, and the angle, closely related to the
velocity of the wave. The Fourier component</p>
<div class="math">
\[D^n e^{ik(x-ct)}\]</div>
<p>has damping <span class="math">\(D\)</span> and wave velocity <span class="math">\(c\)</span>. Let us express our <span class="math">\(A\)</span> in
polar form, <span class="math">\(A = A_re^{i\phi}\)</span>, and insert this expression in
our discrete component <span class="math">\(u_q^n = A^ne^{ikq\Delta x} = A^ne^{ikx}\)</span>:</p>
<div class="math">
\[u^n_q = A_r^n e^{i\phi n} e^{ikx} = A_r^n e^{i(kx - n\phi)} =
A_r^ne^{i(k(x - ct))},\]</div>
<p>for</p>
<div class="math">
\[c = \frac{\phi}{k\Delta t}{\thinspace .}\]</div>
<p>Now,</p>
<div class="math">
\[k\Delta t = \frac{Ck\Delta x}{v}=\frac{Cp}{v},\]</div>
<p>so</p>
<div class="math">
\[c = \frac{\phi v}{Cp}{\thinspace .}\]</div>
<p>An appropriate dimensionless quantity to plot is <span class="math">\(c/v\)</span>:</p>
<div class="math">
\[\frac{c}{v} = \frac{\phi}{Cp}{\thinspace .}\]</div>
<div class="figure" id="id2">
<span id="advec-1d-disprel-c099"></span><a class="reference internal image-reference" href="_images/disprel_C0_99.png"><img alt="_images/disprel_C0_99.png" src="_images/disprel_C0_99.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.99\)</span></span></p>
</div>
<div class="figure" id="id3">
<span id="advec-1d-disprel-c09"></span><a class="reference internal image-reference" href="_images/disprel_C0_9.png"><img alt="_images/disprel_C0_9.png" src="_images/disprel_C0_9.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.9\)</span></span></p>
</div>
<div class="figure" id="id4">
<span id="advec-1d-disprel-c08"></span><a class="reference internal image-reference" href="_images/disprel_C0_8.png"><img alt="_images/disprel_C0_8.png" src="_images/disprel_C0_8.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.8\)</span></span></p>
</div>
<div class="figure" id="id5">
<span id="advec-1d-disprel-c05"></span><a class="reference internal image-reference" href="_images/disprel_C0_5.png"><img alt="_images/disprel_C0_5.png" src="_images/disprel_C0_5.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.5\)</span></span></p>
</div>
<div class="figure" id="id6">
<span id="advec-1d-disprel-c99"></span><a class="reference internal image-reference" href="_images/disprel_C0_99.png"><img alt="_images/disprel_C0_99.png" src="_images/disprel_C0_99.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.99\)</span></span></p>
</div>
<p>The total damping after some time <span class="math">\(T=n\Delta t\)</span> is reflected by
<span class="math">\(A_r(C,p)^n\)</span>. Since normally <span class="math">\(A_r&lt;1\)</span>, the damping goes like
<span class="math">\(A_r^{1/\Delta t}\)</span> and approaches zero as <span class="math">\(\Delta t\rightarrow 0\)</span>.
[<strong>hpl 25</strong>: No, how do we explain that reducing <span class="math">\(\Delta t\)</span> reduces the damping, while keeping <span class="math">\(C\)</span> fixed?]</p>
</div>
</div>
<div class="section" id="one-dimensional-stationary-advection-diffusion-equation">
<h2>One-dimensional stationary advection-diffusion equation<a class="headerlink" href="#one-dimensional-stationary-advection-diffusion-equation" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="two-dimensional-advection-diffusion-equations">
<h2>Two-dimensional advection-diffusion equations<a class="headerlink" href="#two-dimensional-advection-diffusion-equations" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="applications-of-advection-equations">
<h2>Applications of advection equations<a class="headerlink" href="#applications-of-advection-equations" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advection-dominated equations</a><ul>
<li><a class="reference internal" href="#one-dimensional-time-dependent-advection-equations">One-dimensional time-dependent advection equations</a><ul>
<li><a class="reference internal" href="#simplest-scheme-forward-in-time-centered-in-space">Simplest scheme: forward in time, centered in space</a><ul>
<li><a class="reference internal" href="#method-1">Method</a></li>
<li><a class="reference internal" href="#implementation-9">Implementation</a></li>
<li><a class="reference internal" href="#test-cases">Test cases</a></li>
<li><a class="reference internal" href="#bug">Bug?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-scheme">Analysis of the scheme</a></li>
<li><a class="reference internal" href="#leapfrog-in-time-centered-differences-in-space">Leapfrog in time, centered differences in space</a><ul>
<li><a class="reference internal" href="#method-2">Method</a></li>
<li><a class="reference internal" href="#implementation-10">Implementation</a></li>
<li><a class="reference internal" href="#running-the-test-case">Running the test case</a></li>
<li><a class="reference internal" href="#analysis">Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#upwind-differences-in-space">Upwind differences in space</a></li>
<li><a class="reference internal" href="#a-crank-nicolson-discretization-in-time-and-centered-differences-in-space">A Crank-Nicolson discretization in time and centered differences in space</a></li>
<li><a class="reference internal" href="#the-lax-wendroff-method">The Lax-Wendroff method</a></li>
<li><a class="reference internal" href="#analysis-of-dispersion-relations">Analysis of dispersion relations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#one-dimensional-stationary-advection-diffusion-equation">One-dimensional stationary advection-diffusion equation</a></li>
<li><a class="reference internal" href="#two-dimensional-advection-diffusion-equations">Two-dimensional advection-diffusion equations</a></li>
<li><a class="reference internal" href="#applications-of-advection-equations">Applications of advection equations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book011.html"
                        title="previous chapter">Diffusion equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book013.html"
                        title="next chapter">Staggered mesh discretization</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book012.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Staggered mesh discretization"
             >next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Diffusion equations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>