
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advection-dominated equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Nonlinear problems" href="._book013.html" />
    <link rel="prev" title="Diffusion equations" href="._book011.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Nonlinear problems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Diffusion equations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="advection-dominated-equations">
<span id="ch-convdiff"></span><h1>Advection-dominated equations<a class="headerlink" href="#advection-dominated-equations" title="Permalink to this headline">¶</a></h1>
<p>Wave (the chapter <a class="reference internal" href="._book005.html#ch-wave"><span class="std std-ref">Wave equations</span></a>) and diffusion (the chapter <a class="reference internal" href="._book011.html#ch-diffu"><span class="std std-ref">Diffusion equations</span></a>)
equations are solved reliably by finite difference methods. As soon as
we add a first-order derivative in space, representing <em>advective
transport</em> (also known as convective transport), the numerics gets
more complicated, and intuitively attractive methods no longer work
well. We shall show how and why such methods fail and provide
remedies. The present chapter builds on basic knowledge about finite
difference methods for diffusion and wave equations, including the
analysis by Fourier components, truncation error analysis ( <a class="reference internal" href="._book021.html#ch-trunc"><span class="std std-ref">Appendix: Truncation error analysis</span></a>), and compact difference notation.</p>
<div class="section" id="one-dimensional-time-dependent-advection-equations">
<span id="advec-1d"></span><h2>One-dimensional time-dependent advection equations<a class="headerlink" href="#one-dimensional-time-dependent-advection-equations" title="Permalink to this headline">¶</a></h2>
<p>We consider the pure advection model</p>
<div class="math" id="eq-advec-1d-pde1-u">
\[\tag{502}
\frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} = 0,\quad
     x\in (0,L),\ t\in (0,T],\]</div>
<div class="math" id="eq-advec-1d-pde1-u0">
\[\tag{503}
u(x,0) = I(x), x\in (0,L),\]</div>
<div class="math" id="eq-advec-1d-pde1-i">
\[\tag{504}
u(0,t) = U_0, t\in (0,T].\]</div>
<p>In <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(502)</span></a>, <span class="math">\(v\)</span> is a given parameter, typically reflecting
the velocity of transport of a quantity <span class="math">\(u\)</span> with a flow.
There is only one boundary condition <a class="reference internal" href="#eq-advec-1d-pde1-u0"><span class="std std-ref">(503)</span></a> since
the spatial derivative is only first order in the PDE <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(502)</span></a>.
The information at <span class="math">\(x=0\)</span> and the initial condition get
transported in the positive <span class="math">\(x\)</span> direction
if <span class="math">\(v&gt;0\)</span> through the domain.</p>
<p>It is easiest to find the solution of <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(502)</span></a> if we remove the
boundary condition and consider a process on the
infinite domain <span class="math">\((-\infty, \infty)\)</span>. The solution is simply</p>
<div class="math" id="eq-advec-1d-pde1-sol">
\[\tag{505}
u(x,t) = I(x-vt){\thinspace .}\]</div>
<p>This is also the solution we expect locally in a finite domain before boundary
conditions have reflected or modified the wave.</p>
<div class="section" id="simplest-scheme-forward-in-time-centered-in-space">
<span id="advec-1d-ftcs"></span><h3>Simplest scheme: forward in time, centered in space<a class="headerlink" href="#simplest-scheme-forward-in-time-centered-in-space" title="Permalink to this headline">¶</a></h3>
<div class="section" id="method-1">
<h4>Method<a class="headerlink" href="#method-1" title="Permalink to this headline">¶</a></h4>
<p>A first attempt to solve a PDE like <a class="reference internal" href="#eq-advec-1d-pde1-u"><span class="std std-ref">(502)</span></a> will normally
be to look for a time-discretization scheme that is explicit so we avoid
solving systems of linear equations. In space, we anticipate that
centered differences are most accurate and therefore best. These
two arguments lead us to a Forward Euler scheme in time and
centered differences in space:</p>
<div class="math" id="eq-auto210">
\[\tag{506}
[D_t^+ u + vD_{2x} u = 0]^n_i\]</div>
<p>Written out, we see that this expression reads</p>
<div class="math">
\[u^{n+1} = u^n - \frac{1}{2} C (u^n_{i+1}-u_{i-1}),\]</div>
<p>with <span class="math">\(C\)</span> as the Courant number</p>
<div class="math">
\[C = \frac{v\Delta t}{\Delta x}{\thinspace .}\]</div>
</div>
<div class="section" id="implementation-9">
<h4>Implementation<a class="headerlink" href="#implementation-9" title="Permalink to this headline">¶</a></h4>
<p>A solver function for our scheme goes as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">solver_FECS</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">U0</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Mesh points in time</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">C</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># Mesh points in space</span>
    <span class="c1"># Make sure dx and dt are compatible with x and t</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>

    <span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Set initial condition u(x,0) = I(x)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_action</span><span class="p">(</span><span class="n">u_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="c1"># Compute u at inner mesh points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Insert boundary condition</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">U0</span>

        <span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">user_action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Switch variables before next step</span>
        <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_1</span>
</pre></div>
</div>
</div>
<div class="section" id="test-cases">
<h4>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this headline">¶</a></h4>
<p>The typical solution <span class="math">\(u\)</span> has the shape of <span class="math">\(I\)</span> and is transported at
velocity <span class="math">\(v\)</span> to the right (if <span class="math">\(v&gt;0\)</span>). Let us consider two different
initial conditions, one smooth (Gaussian pulse) and one non-smooth
(half-truncated cosine pulse):</p>
<div class="math" id="eq-advec-1d-case-gaussian">
\[\tag{507}
u(x,0) = Ae^{-\frac{1}{2}\left(\frac{x-L/10}{\sigma}\right)^2},\]</div>
<div class="math" id="eq-advec-1d-case-cos">
\[\tag{508}
u(x,0) = A\cos\left(\frac{5\pi}{L}\left( x - \frac{L}{10}\right)\right),\quad
    x &lt; \frac{L}{5} \hbox{ else } 0{\thinspace .}\]</div>
<p>The parameter <span class="math">\(A\)</span> is the maximum value of the initial condition.</p>
<p>Before doing numerical simulations, we scale the PDE
problem and introduce <span class="math">\(\bar x = x/L\)</span> and <span class="math">\(\bar t= vt/L\)</span>,
which gives</p>
<div class="math">
\[\frac{\partial\bar u}{\partial \bar t} +
\frac{\partial\bar u}{\partial\bar x} = 0{\thinspace .}\]</div>
<p>The unknown <span class="math">\(u\)</span> is scaled by the maximum value of the initial condition:
<span class="math">\(\bar u = u/\max |I(x)|\)</span> such that <span class="math">\(|\bar u(\bar x, 0)|\in [0,1]\)</span>.
The scaled problem is solved by setting <span class="math">\(v=1\)</span>, <span class="math">\(L=1\)</span>, and <span class="math">\(A=1\)</span>.
From now on we drop the bars.</p>
<p>To run our test cases and plot the solution, we make the function</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_FECS</span><span class="p">(</span><span class="n">case</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">case</span> <span class="o">==</span> <span class="s1">&#39;cosinehat&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">5</span><span class="o">/</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">L</span><span class="o">/</span><span class="mi">10</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">L</span><span class="o">/</span><span class="mi">5</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.02</span>
    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Animate and plot every m steps in the same figure.&quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ydata</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="c1">#plt.savefig()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">print</span> <span class="s1">&#39;t=</span><span class="si">%g</span><span class="s1">, n=</span><span class="si">%d</span><span class="s1">, u in [</span><span class="si">%g</span><span class="s1">, </span><span class="si">%g</span><span class="s1">] w/</span><span class="si">%d</span><span class="s1"> points&#39;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">u</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Instability?</span>
            <span class="k">return</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="s1">&#39;on&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
    <span class="n">U0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.001</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">U0</span><span class="o">=</span><span class="n">U0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp.png&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tmp.pdf&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="bug">
<h4>Bug?<a class="headerlink" href="#bug" title="Permalink to this headline">¶</a></h4>
<p>Running either of the test cases, the plot becomes a mess, and
the printout of <span class="math">\(u\)</span> values in the <code class="docutils literal"><span class="pre">plot</span></code> function reveals that
<span class="math">\(u\)</span> grows very quickly. We may reduce <span class="math">\(\Delta t\)</span> and make it
very small, yet the solution just grows.
Such behavior points to a bug in the code.
However, choosing a coarse mesh and performing a time step by
hand calculations produce the same numbers as in the code, so
it seems that the implementation is correct.
The hypothesis is therefore that the solution is unstable.</p>
</div>
</div>
<div class="section" id="analysis-of-the-scheme">
<span id="advec-1d-ftcs-anal"></span><h3>Analysis of the scheme<a class="headerlink" href="#analysis-of-the-scheme" title="Permalink to this headline">¶</a></h3>
<p>It is easy to show that a typical Fourier component</p>
<div class="math">
\[u(x,t)= B\sin (k(x-ct))\]</div>
<p>is a solution of our PDE for any spatial wave length <span class="math">\(\lambda = 2\pi /k\)</span>
and any amplitude <span class="math">\(B\)</span>.
A general solution can be thought to be build of a collection of long and
short waves such waves with different amplitudes. Algebraically, the work
simplifies if we introduce the complex Fourier component</p>
<div class="math">
\[u(x,t)={A_{\small\mbox{e}}}^n e^{ikx},\]</div>
<p>with</p>
<div class="math">
\[{A_{\small\mbox{e}}}=Be^{-ikv\Delta t} = Be^{iCkx}{\thinspace .}\]</div>
<p>Note that <span class="math">\(|{A_{\small\mbox{e}}}| \leq 1\)</span>.</p>
<p>It turns out that many schemes also allow a Fourier wave component as
solution, and we can use the numerical value of <span class="math">\(A\)</span> to learn about the
quality of the scheme. Hence, to analyze the difference scheme we just
have implemented, we look at how treats the Fourier component</p>
<div class="math">
\[u_q^n = A^n e^{ikq\Delta x}{\thinspace .}\]</div>
<p>Inserting the numerical component in the scheme,</p>
<div class="math">
\[[D_t^+ A^n e^{ikq\Delta x} + v D_{2x}A^n e^{ikq\Delta x}]^n_i,\]</div>
<p>and making use of <a class="reference internal" href="._book020.html#eq-form-exp-fd1c-center"><span class="std std-ref">(627)</span></a>
results in</p>
<div class="math">
\[[e^{ikq\Delta x} (\frac{A-1}{\Delta t} + v\frac{1}{\Delta x}i\sin (k\Delta x))]^n_i,\]</div>
<p>which implies</p>
<div class="math">
\[A = 1 - iC\sin(k\Delta x){\thinspace .}\]</div>
<p>The numerical solution features the formula <span class="math">\(A^n\)</span>. To find out whether
<span class="math">\(A^n\)</span> means growth in time, we rewrite <span class="math">\(A\)</span> in polar form: <span class="math">\(A=A_re^{i\phi}\)</span>,
for real numbers <span class="math">\(A_r\)</span> and <span class="math">\(\phi\)</span>,
since we then have <span class="math">\(A^n = A_r^ne^{i\phi n}\)</span>. The magnitude of <span class="math">\(A^n\)</span> is
<span class="math">\(A_r^n\)</span>. In our case, <span class="math">\(A_r = (1 + C^2\sin^2(kx))^{1/2} &gt; 1\)</span>, so
<span class="math">\(A_r^n\)</span> will increase in time, whereas the
exact solution will not. Regardless of <span class="math">\(\Delta t\)</span>, we get unstable
numerical solutions.</p>
</div>
<div class="section" id="leapfrog-in-time-centered-differences-in-space">
<span id="advec-1d-leapfrog"></span><h3>Leapfrog in time, centered differences in space<a class="headerlink" href="#leapfrog-in-time-centered-differences-in-space" title="Permalink to this headline">¶</a></h3>
<div class="section" id="method-2">
<h4>Method<a class="headerlink" href="#method-2" title="Permalink to this headline">¶</a></h4>
<p>Another explicit scheme is to do a &#8220;leapfrog&#8221; jump over <span class="math">\(2\Delta t\)</span> in
time and combine it with central differences in space:</p>
<div class="math">
\[[D_{2t} u + vD_{2x} u = 0]_i^n,\]</div>
<p>which results in the updating formula</p>
<div class="math">
\[u^{n+1} = u^{n-1} - C(u_{i+1}-u_{i-1}){\thinspace .}\]</div>
<p>A special scheme is needed to compute <span class="math">\(u^1\)</span>, but we leave that problem for
now.</p>
</div>
<div class="section" id="implementation-10">
<h4>Implementation<a class="headerlink" href="#implementation-10" title="Permalink to this headline">¶</a></h4>
<p>We now need to work with three time levels and must modify our solver a bit:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Mesh points in time</span>
<span class="o">...</span>
<span class="n">u</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;FECS&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s1">&#39;LFCS&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Use some scheme for the first step</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
                <span class="o">...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_2</span>
</pre></div>
</div>
</div>
<div class="section" id="running-a-test-case">
<h4>Running a test case<a class="headerlink" href="#running-a-test-case" title="Permalink to this headline">¶</a></h4>
<p>Let us try a coarse mesh such that the smooth Gaussian initial condition
is represented by 1 at mesh node 1 and 0 at all other nodes. This
triangular initial condition should then be advected to the right.
Choosing scaled variables as <span class="math">\(\Delta t=0.1\)</span>, <span class="math">\(T=1\)</span>, and <span class="math">\(C=1\)</span> gives
the plot in Figure <a class="reference internal" href="#advec-1d-case-gaussian-fig-lfcs"><span class="std std-ref">Leapfrog scheme with  and </span></a>, which
is in fact identical to the exact solution (!).</p>
<div class="figure" id="id1">
<span id="advec-1d-case-gaussian-fig-lfcs"></span><a class="reference internal image-reference" href="_images/solver_FE_Upw.png"><img alt="_images/solver_FE_Upw.png" src="_images/solver_FE_Upw.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text">Leapfrog scheme with <span class="math">\(\Delta t = 0.1\)</span> and <span class="math">\(C=1\)</span></span></p>
</div>
</div>
<div class="section" id="analysis">
<h4>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h4>
<p>We can perform a Fourier analysis again. Inserting the numerical
Fourier component in the Leapfrog scheme, we get</p>
<div class="math">
\[A^2 - i2C\sin(k\Delta x) A - 1 = 0,\]</div>
<p>and</p>
<div class="math">
\[A = -iC\sin(k\Delta x) \pm \sqrt{1-C^2\sin^2(k\Delta x)}{\thinspace .}\]</div>
<p>Rewriting to polar form, <span class="math">\(A=A_re^{i\phi}\)</span>, we see that <span class="math">\(A_r=1\)</span>, so the
numerical component is not increasing or decreasing in time, which is
exactly what we want. However, for <span class="math">\(C&gt;1\)</span>, the square root can become
complex valued, so stability is obtained only as long as <span class="math">\(C\leq 1\)</span>.</p>
<p>We introduce <span class="math">\(p=k\Delta x\)</span>. The amplification factor now reads</p>
<div class="math">
\[A = -iC\sin p \pm \sqrt{1-C^2\sin^2 p},\]</div>
<p>and is to be compared to the exact amplification factor</p>
<div class="math">
\[{A_{\small\mbox{e}}} = e^{-ikv\Delta t} = e^{-ikC\Delta x} = e^{-iCp}{\thinspace .}\]</div>
<p>the section <a class="reference internal" href="#advec-1d-disprel"><span class="std std-ref">Analysis of dispersion relations</span></a> compares many numerical amplification factors
with the exact expression.</p>
</div>
</div>
<div class="section" id="upwind-differences-in-space">
<span id="advec-1d-ftup"></span><h3>Upwind differences in space<a class="headerlink" href="#upwind-differences-in-space" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Since the PDE reflects transport of information along with a flow in
positive <span class="math">\(x\)</span> direction, when <span class="math">\(v&gt;0\)</span>, it could be natural to go (what is called)
upstream and not
downstream in a spatial derivative to collect information about the
change of the function. That is, we approximate</p>
<div class="math">
\[\frac{\partial u}{\partial x}(x_i,t_n)\approx [D^-_x u]^n_i = \frac{u^n_{i} - u^n_{i-1}}{\Delta x}{\thinspace .}\]</div>
<p>This is called an <em>upwind difference</em> (the corresponding difference in the
time direction would be called a backward difference, and we could use that
name in space too, but <em>upwind</em> is the common name for a difference against
the flow in advection problems). This spatial approximation does magic
compared to
the scheme we had with Forward Euler in time and centered difference in space.
With an upwind difference,</p>
<div class="math" id="eq-advec-1d-upwind">
\[\tag{509}
[D^+_t u + vD^-_x u = 0]^n_i,\]</div>
<p>written out as</p>
<div class="math">
\[u^{n+1} = u^n_i - C(u^{n}_{i}-u^{n}_{i-1}),\]</div>
<p>gives a generally popular and robust scheme that is stable if <span class="math">\(C\leq 1\)</span>.
As with the Leapfrog scheme, it becomes exact if <span class="math">\(C=1\)</span>, exactly as shown in
Figure <a class="reference internal" href="#advec-1d-case-gaussian-fig-lfcs"><span class="std std-ref">Leapfrog scheme with  and </span></a>.
However, any <span class="math">\(C&lt;1\)</span> gives a significant reduction in the amplitude of the
solution, which is a purely numerical effect, see Figure
<a class="reference internal" href="#advec-1d-ftus-fig-c08"><span class="std std-ref">Forward in time, upwind in space,  \( C=0.8 \) ,  \( Delta t = 0.01 \)  (left) and  \( Delta t=0.001 \)  (right)</span></a>. Experiments show, however, that
reducing <span class="math">\(\Delta t\)</span> or <span class="math">\(\Delta x\)</span>, while keeping <span class="math">\(C\)</span> fixed reduces the
error.</p>
<div class="figure" id="id2">
<span id="advec-1d-ftus-fig-c08"></span><a class="reference internal image-reference" href="_images/gaussian_FTUS_C08.png"><img alt="_images/gaussian_FTUS_C08.png" src="_images/gaussian_FTUS_C08.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Forward in time, upwind in space,  \( C=0.8 \) ,  \( Delta t = 0.01 \)  (left) and  \( Delta t=0.001 \)  (right)</em></span></p>
</div>
<p>The amplification factor can be computed using the
formula <a class="reference internal" href="._book020.html#eq-form-exp-fd1-bw"><span class="std std-ref">(625)</span></a>,</p>
<div class="math">
\[\frac{A - 1}{\Delta t} + \frac{v}{\Delta x}(1 - e^{-ik\Delta x}) = 0,\]</div>
<p>which means</p>
<div class="math">
\[A = 1 - C(1 - \cos(p) - i\sin(p)){\thinspace .}\]</div>
<p>For <span class="math">\(C&lt;1\)</span> there is, unfortunately,
non-physical damping of discrete Fourier components. This damping can
be quite severe.</p>
<div class="admonition-interpretation-of-upwind-difference-as-artificial-diffusion admonition">
<p class="first admonition-title">Interpretation of upwind difference as artificial diffusion</p>
<p>One can interpret the upwind difference as extra, artificial diffusion
in the equation. Solving</p>
<div class="math">
\[\frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x}
= \nu\frac{\partial^2 u}{\partial x^2},\]</div>
<p>by a forward difference time and centered differences in space,</p>
<div class="math">
\[D^+_t u + vD_{2x} u = \nu D_xD_x u]^n_i,\]</div>
<p class="last">gives actually the upwind scheme <a class="reference internal" href="#eq-advec-1d-upwind"><span class="std std-ref">(509)</span></a> if
<span class="math">\(\nu = v\Delta x/2\)</span>. That is, solving the PDE <span class="math">\(u_t + vu_x=0\)</span>
by centered differences in space and forward difference in time is
unsuccessful, but by adding some artificial diffusion <span class="math">\(\nu u_{xx}\)</span>,
the method becomes stable.</p>
</div>
</div>
<div class="section" id="periodic-boundary-conditions">
<span id="advec-1d-periodic-bc"></span><h3>Periodic boundary conditions<a class="headerlink" href="#periodic-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>So far, we have given then value of on the left boundary, <span class="math">\(u_0^n\)</span>, and used
the scheme to propagate the solution signal through the domain.
Often, we want to follow such signals for long time series, and periodic
boundary conditions are then relevant since then enable a signal that
leaves the right boundary to immediately enter the left boundary and propagate
through the domain again.</p>
<p>The periodic boundary condition is</p>
<div class="math">
\[u(0,t) = u(L,t),\quad u_0^n = u_{N_x}^n{\thinspace .}\]</div>
<p>It means that we in the first equation, involving <span class="math">\(u_0^n\)</span>, insert <span class="math">\(u_{N_x}^n\)</span>,
and that we in the last equation, involving <span class="math">\(u^{n+1}_{N_x}\)</span> insert <span class="math">\(u^{n+1}_0\)</span>.
Normally, we can do this in the simple way that <code class="docutils literal"><span class="pre">u_1[0]</span></code> is updated as
<code class="docutils literal"><span class="pre">u_1[Nx]</span></code> at the beginning of a new time level.</p>
<p>In some schemes we may need <span class="math">\(u^{n}_{N_x+1}\)</span> and <span class="math">\(u^{n}_{-1}\)</span>. Periodicity
then means that these values are equal to <span class="math">\(u^n_1\)</span> and <span class="math">\(u^n_{N_x-1}\)</span>,
respectively. For the upwind scheme it is sufficient to set
<code class="docutils literal"><span class="pre">u_1[0]=u_1[Nx]</span></code> at a new time level before computing <code class="docutils literal"><span class="pre">u[1]</span></code>, which ensures
that <code class="docutils literal"><span class="pre">u[1]</span></code> becomes right and at the next time level <code class="docutils literal"><span class="pre">u[0]</span></code> at the current
time level is correctly updated.
For the Leapfrog scheme we must update <code class="docutils literal"><span class="pre">u[0]</span></code> and <code class="docutils literal"><span class="pre">u[Nx]</span></code> using the scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">periodic_bc</span><span class="p">:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="o">*</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="k">if</span> <span class="n">periodic_bc</span><span class="p">:</span>
    <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="a-crank-nicolson-discretization-in-time-and-centered-differences-in-space">
<span id="advec-1d-cn"></span><h3>A Crank-Nicolson discretization in time and centered differences in space<a class="headerlink" href="#a-crank-nicolson-discretization-in-time-and-centered-differences-in-space" title="Permalink to this headline">¶</a></h3>
<p>Another obvious candidate for time discretization is the Crank-Nicolson
method combined with centered differences in space:</p>
<div class="math">
\[[D_t u]^n_i + v\frac{1}{2}([D_{2x} u]^{n+1}_i + [D_{2x} u]^{n}_i) = 0{\thinspace .}\]</div>
<p>It can be nice to include the Backward Euler scheme too, via the
<span class="math">\(\theta\)</span>-rule,</p>
<div class="math">
\[[D_t u]^n_i + v\theta [D_{2x} u]^{n+1}_i + v(1-\theta)[D_{2x} u]^{n}_i = 0{\thinspace .}\]</div>
<p>This gives rise to an <em>implicit</em> scheme,</p>
<div class="math">
\[u^{n+1}_i + \frac{\theta}{2} C (u^{n+1}_{i+1} - u^{n+1}_{i-1})
= u^n_i - \frac{1-\theta}{2} C (u^{n}_{i+1} - u^{n}_{i-1})\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span>. At the boundaries we use periodic conditions:</p>
<div class="math">
\[u^{n+1}_0 = u^{n+1}_{N_x},\]</div>
<p>however, this destroys the tridiagonal structure of the coefficient matrix.
We therefore try the rough approximation</p>
<div class="math">
\[u^{n+1}_0 = u^{n}_{N_x},\quad u^{n+1}_{N_x}=u^n_0{\thinspace .}\]</div>
<p>Otherwise, we need to prescribe <span class="math">\(u_0^{n+1}\)</span> and <span class="math">\(u_{N_x}^{n+1}\)</span>.</p>
<p>The elements on the diagonal in the matrix become:</p>
<div class="math">
\[A_{i,i} = 1,\quad i=0,\ldots,N_x{\thinspace .}\]</div>
<p>On the subdiagonal and superdiagonal we have</p>
<div class="math">
\[A_{i-1,i} = -\frac{\theta}{2} C,\quad A_{i+1,i} = \frac{\theta}{2} C,\quad i=1,\ldots,N_x-1,\]</div>
<p>with <span class="math">\(A_{0,1}=0\)</span> and <span class="math">\(A_{N_x-1,N_x}=0\)</span> due to the known boundary conditions.
And finally, the right-hand side becomes</p>
<div class="math">
\[\begin{split}\begin{align*}
b_0 &amp;= u^n_{N_x}\\
b_i &amp;= u^n_i - \frac{1-\theta}{2} C (u^{n}_{i+1} - u^{n}_{i-1}),\quad i=1,\ldots,N_x-1\\
b_{N_x} &amp;= u^n_0
\end{align*}\end{split}\]</div>
<p>The dispersion relation follows from inserting <span class="math">\(u^n_i = A^ne^{ikx}\)</span>
and using the formula <a class="reference internal" href="._book020.html#eq-form-exp-fd1c-center"><span class="std std-ref">(627)</span></a> for the spatial
differences:</p>
<div class="math">
\[A = \frac{1 - (1-\theta) i C\sin p}{1 + \theta i C\sin p}{\thinspace .}\]</div>
</div>
<div class="section" id="the-lax-wendroff-method">
<span id="advec-1d-laxw"></span><h3>The Lax-Wendroff method<a class="headerlink" href="#the-lax-wendroff-method" title="Permalink to this headline">¶</a></h3>
<p>The Lax-Wendroff method is based on three ideas:</p>
<ol class="arabic simple">
<li>Express <span class="math">\(u^{n+1}_i\)</span> in terms of quantities at <span class="math">\(t=t_n\)</span> by
means of a Taylor polynomial of second degree.</li>
<li>Replace time-derivatives at <span class="math">\(t=t_n\)</span> by spatial derivatives,
using the PDE.</li>
<li>Discretize the spatial derivatives by second-order differences.</li>
</ol>
<p>Let us do this:</p>
<div class="math">
\[u^{n+1}_i = u^n_i + \Delta t\left(\frac{\partial u}{\partial t}\right)^n_i
+ \frac{1}{2}\Delta t^2\left(\frac{\partial^2 u}{\partial t^2}\right)^n_i{\thinspace .}\]</div>
<p>From the PDE we have that</p>
<div class="math">
\[\frac{\partial u}{\partial t} = -v\frac{\partial u}{\partial x},\]</div>
<p>which we may use to replace the time-derivatives by spatial derivatives
(<span class="math">\(\frac{\partial ^2}{\partial t^2} = v^2\frac{partial^2 u}{\partial x^2}\)</span>):</p>
<div class="math">
\[u^{n+1}_i = u^n_i -v \Delta t\left(\frac{\partial u}{\partial x}\right)^n_i
+ \frac{1}{2}\Delta t^2 v^2
\left(\frac{\partial^2 u}{\partial x^2}\right)^n_i{\thinspace .}\]</div>
<p>A natural spatial discretization is, for instance, central differences:</p>
<div class="math">
\[u^{n+1}_i = u^n_i -v \Delta t [D_{2x} u]^n_i
+ \frac{1}{2}\Delta t^2 v^2 [D_xD_x u]^n_i,\]</div>
<p>or</p>
<div class="math">
\[u^{n+1}_i = u^n_i - C (u^{n}_{i+1} - u^{n}_{i-1})
+ \frac{1}{2} C^2 (u^{n}_{i+1}-2u^n_i+u^n_{i-1}){\thinspace .}\]</div>
<p>This is the explicit Lax-Wendroff scheme.</p>
<p>From an analysis similar to the ones carried out above, we get an
amplification factor</p>
<div class="math">
\[A = 1 - iC\sin p - 2C^2\sin^2 (p/2){\thinspace .}\]</div>
<p>This means that <span class="math">\(|A|=1\)</span> and also that we have an exact solution of <span class="math">\(C=1\)</span>!</p>
</div>
<div class="section" id="analysis-of-dispersion-relations">
<span id="advec-1d-disprel"></span><h3>Analysis of dispersion relations<a class="headerlink" href="#analysis-of-dispersion-relations" title="Permalink to this headline">¶</a></h3>
<p>We have developed expressions for <span class="math">\(A(C,p)\)</span> in the exact solution
<span class="math">\(u_q^n=A^ne^{ikq\Delta x}\)</span> of the discrete equations. These
expressions are valuable for investigating the quality of the numerical
solutions. Note that the Fourier component that solves the original
PDE problem has no damping and moves with constant velocity <span class="math">\(v\)</span>. There
are two basic errors in the numerical Fourier component: there may be
damping and the wave velocity may depend on <span class="math">\(C\)</span> and <span class="math">\(p=k\Delta x\)</span>.</p>
<p>The shortest wavelength that can be represented is <span class="math">\(\lambda = 2\Delta x\)</span>.
The corresponding <span class="math">\(k\)</span> is <span class="math">\(k=2\pi/\lambda = \pi/\Delta x\)</span>, so <span class="math">\(p=k\Delta x\in
(0,\pi]\)</span>.</p>
<p>Given a complex <span class="math">\(A\)</span> as a function of <span class="math">\(C\)</span> and <span class="math">\(p\)</span>, how can we visualize
it? The two key ingredients in <span class="math">\(A\)</span> is the magnitude, reflecting damping or
growth of the wave, and the angle, closely related to the
velocity of the wave. The Fourier component</p>
<div class="math">
\[D^n e^{ik(x-ct)}\]</div>
<p>has damping <span class="math">\(D\)</span> and wave velocity <span class="math">\(c\)</span>. Let us express our <span class="math">\(A\)</span> in
polar form, <span class="math">\(A = A_re^{i\phi}\)</span>, and insert this expression in
our discrete component <span class="math">\(u_q^n = A^ne^{ikq\Delta x} = A^ne^{ikx}\)</span>:</p>
<div class="math">
\[u^n_q = A_r^n e^{i\phi n} e^{ikx} = A_r^n e^{i(kx - n\phi)} =
A_r^ne^{i(k(x - ct))},\]</div>
<p>for</p>
<div class="math">
\[c = \frac{\phi}{k\Delta t}{\thinspace .}\]</div>
<p>Now,</p>
<div class="math">
\[k\Delta t = \frac{Ck\Delta x}{v}=\frac{Cp}{v},\]</div>
<p>so</p>
<div class="math">
\[c = \frac{\phi v}{Cp}{\thinspace .}\]</div>
<p>An appropriate dimensionless quantity to plot is <span class="math">\(c/v\)</span>:</p>
<div class="math">
\[\frac{c}{v} = \frac{\phi}{Cp}{\thinspace .}\]</div>
<div class="figure" id="id3">
<span id="advec-1d-disprel-c099"></span><a class="reference internal image-reference" href="_images/disprel_C0_99.png"><img alt="_images/disprel_C0_99.png" src="_images/disprel_C0_99.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.99\)</span></span></p>
</div>
<div class="figure" id="id4">
<span id="advec-1d-disprel-c09"></span><a class="reference internal image-reference" href="_images/disprel_C0_9.png"><img alt="_images/disprel_C0_9.png" src="_images/disprel_C0_9.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.9\)</span></span></p>
</div>
<div class="figure" id="id5">
<span id="advec-1d-disprel-c08"></span><a class="reference internal image-reference" href="_images/disprel_C0_8.png"><img alt="_images/disprel_C0_8.png" src="_images/disprel_C0_8.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.8\)</span></span></p>
</div>
<div class="figure" id="id6">
<span id="advec-1d-disprel-c05"></span><a class="reference internal image-reference" href="_images/disprel_C0_5.png"><img alt="_images/disprel_C0_5.png" src="_images/disprel_C0_5.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.5\)</span></span></p>
</div>
<div class="figure" id="id7">
<span id="advec-1d-disprel-c99"></span><a class="reference internal image-reference" href="_images/disprel_C0_99.png"><img alt="_images/disprel_C0_99.png" src="_images/disprel_C0_99.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Dispersion relations for <span class="math">\(C=0.99\)</span></span></p>
</div>
<p>The total damping after some time <span class="math">\(T=n\Delta t\)</span> is reflected by
<span class="math">\(A_r(C,p)^n\)</span>. Since normally <span class="math">\(A_r&lt;1\)</span>, the damping goes like
<span class="math">\(A_r^{1/\Delta t}\)</span> and approaches zero as <span class="math">\(\Delta t\rightarrow 0\)</span>.</p>
</div>
</div>
<div class="section" id="one-dimensional-stationary-advection-diffusion-equation">
<span id="advec-1d-stationary"></span><h2>One-dimensional stationary advection-diffusion equation<a class="headerlink" href="#one-dimensional-stationary-advection-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>Now we pay attention to a physical process where advection (or convection)
is in balance with diffusion:</p>
<div class="math" id="eq-advec-1d-stat-pde1">
\[\tag{510}
v\frac{du}{dx} = {\alpha}\frac{d^2 u}{dx^2}{\thinspace .}\]</div>
<p>For simplicity, we assume <span class="math">\(v\)</span> and <span class="math">\({\alpha}\)</span> to be constant, but the extension to
the variable-coefficient case is trivial.
This is equation can be viewed as the stationary limit of the corresponding
time-dependent problem</p>
<div class="math" id="eq-advec-1d-stat-pde2">
\[\tag{511}
\frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} =
    {\alpha}\frac{\partial^2 u}{\partial x^2}{\thinspace .}\]</div>
<p>Equations of the form <a class="reference internal" href="#eq-advec-1d-stat-pde1"><span class="std std-ref">(510)</span></a> or
<a class="reference internal" href="#eq-advec-1d-stat-pde2"><span class="std std-ref">(511)</span></a> arise from transport phenomena, either mass
or heat transport. One can also view the equations as simple model
problems for the Navier-Stokes equations. A fundamental difficulty
with solving these equations is numerical instability if the
first-derivative spatial term dominates over the second-derivative
term.</p>
<div class="section" id="a-simple-model-problem-1">
<span id="advec-1d-stationary-model"></span><h3>A simple model problem<a class="headerlink" href="#a-simple-model-problem-1" title="Permalink to this headline">¶</a></h3>
<p>We consider <a class="reference internal" href="#eq-advec-1d-stat-pde1"><span class="std std-ref">(510)</span></a> on <span class="math">\([0,L]\)</span> equipped with the
boundary conditions <span class="math">\(u(0)=U_0\)</span>, <span class="math">\(u(L)=U_L\)</span>.  By scaling we can get rid
of lots of physical parameter and instead reduce the discussion to
combinations of physical parameters. We scale <span class="math">\(x\)</span> by <span class="math">\(\bar x = x/L\)</span>,
and <span class="math">\(u\)</span> by</p>
<div class="math">
\[\bar u = \frac{u - u_0}{u_L-u_0}{\thinspace .}\]</div>
<p>Inserted in the governing equation we get</p>
<div class="math">
\[\frac{v(u_L-u_0)}{L}\frac{d\bar u}{d\bar x} =
\frac{{\alpha}(u_L-u_0)}{L^2}\frac{d^2\bar u}{d\bar x^2},\quad
\bar u(0)=0,\ \bar u(1)=1{\thinspace .}\]</div>
<p>Dropping the bars is common. We can then simplify to</p>
<div class="math" id="eq-advec-1d-stat-pde1s">
\[\tag{512}
\frac{du}{dx} = \epsilon\frac{d^2 u}{d x^2},\quad u(0)=0,\ u(1)=1{\thinspace .}\]</div>
<p>There are two competing effects in this equation: the advection term
transports signals to the right (with velocity <span class="math">\(v\)</span>, later with unit
velocity), while the diffusion term transports signals to the left and
right )with strength <span class="math">\({\alpha}\)</span>, later with strength <span class="math">\(\epsilon\)</span>). The
value <span class="math">\(u(0)=0\)</span> is transported through the domain if <span class="math">\(\epsilon\)</span> is
small, and <span class="math">\(u\approx 0\)</span> except in the vicinity of <span class="math">\(x=0\)</span>, where
<span class="math">\(u(1)=1\)</span> and the diffusion transports some information about <span class="math">\(u(1)=1\)</span>
to the left. For large <span class="math">\(\epsilon\)</span>, diffusion dominates and the <span class="math">\(u\)</span>
takes on the &#8220;average&#8221; value, i.e., <span class="math">\(u\)</span> gets a linear variation from
0 to 1 throughout the domain.</p>
<p>It turns out that we can find an exact solution to the differential
equation problem and also to many of its discretization. This is one
reason why this model problem has been so successful in designing and
investigating numerical methods for mixed convection/advection and
diffusion.  The exact solution reads</p>
<div class="math">
\[{u_{\small\mbox{e}}} (x) = \frac{e^{x/\epsilon} - 1}{e^{1/\epsilon} - 1}{\thinspace .}\]</div>
</div>
<div class="section" id="a-centered-finite-difference-scheme-2">
<span id="advec-1d-stationary-fdm"></span><h3>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme-2" title="Permalink to this headline">¶</a></h3>
<p>The most obvious idea to solve <a class="reference internal" href="#eq-advec-1d-stat-pde1s"><span class="std std-ref">(512)</span></a> is to apply
centered differences:</p>
<div class="math">
\[[D_{2x} u = \epsilon D_xD_x u]_i\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span>, with <span class="math">\(u_0=0\)</span> and <span class="math">\(u_{N_x}=1\)</span>.
Note that this is a coupled system of algebraic equations
involving <span class="math">\(u_0,\ldots,u_{N_x}\)</span>.</p>
<p>Written out, the scheme becomes a tridiagonal system</p>
<div class="math">
\[A_{i-1,i}u_{i-1} + A_{i,i}u_i + A_{i+1.i}u_{i+1} = 0,\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span></p>
<div class="math">
\[\begin{split}\begin{align*}
A_{0,0} &amp;= 1,\\
A_{i-1,i} &amp;= -\frac{1}{\Delta x} -\epsilon\frac{1}{\Delta x^2},\\
A_{i,i} &amp;= 2\epsilon\frac{1}{\Delta x^2},\\
A_{i,i+1} &amp;=  \frac{1}{\Delta x} -\epsilon\frac{1}{\Delta x^2},\\
A_{N_x,N_x} &amp;= 1{\thinspace .}
\end{align*}\end{split}\]</div>
<p>The right-hand side of the linear system is zero except <span class="math">\(b_{N_x}=1\)</span>.</p>
<p>Figure <a class="reference internal" href="#advec-1d-stationary-fdm-fig1"><span class="std std-ref">Comparison of exact and numerical solution for  and  with centered differences</span></a> shows reasonably accurate
results with <span class="math">\(N_x=20\)</span> and <span class="math">\(N_x=40\)</span> cells in <span class="math">\(x\)</span> direction and a value of
<span class="math">\(\epsilon = 0.1\)</span>. Decreasing <span class="math">\(\epsilon\)</span> to <span class="math">\(0.01\)</span> leads to oscillatory
solutions as depicted in Figure <a class="reference internal" href="#advec-1d-stationary-fdm-fig2"><span class="std std-ref">Comparison of exact and numerical solution for  and  with centered differences</span></a>.
This is, unfortunately, a typical phenomenon in this type of problem:
non-physical oscillations arise for small <span class="math">\(\epsilon\)</span> unless the resolution
<span class="math">\(N_x\)</span> is not big enough. <a class="reference internal" href="#advec-1d-stationary-exer-analysis1"><span class="std std-ref">Exercise 4.1: Analyze 1D stationary convection-diffusion problem</span></a>
develops a precise criterion: <span class="math">\(u\)</span> is oscillation-free if</p>
<div class="math">
\[\Delta x \leq \frac{2}{\epsilon}{\thinspace .}\]</div>
<p>If we take the present model as a simplified model for a <em>viscous
boundary layer</em> in real, industrial fluid flow applications,
<span class="math">\(\epsilon\sim 10^{-6}\)</span>
and million of cells are required to resolve the boundary layer.
Fortunately, this is not strictly necessary as we have methods in
the next section to overcome the problem!</p>
<div class="figure" id="id8">
<span id="advec-1d-stationary-fdm-fig1"></span><a class="reference internal image-reference" href="_images/twopt_BVP_cen_01.png"><img alt="_images/twopt_BVP_cen_01.png" src="_images/twopt_BVP_cen_01.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Comparison of exact and numerical solution for <span class="math">\(\epsilon =0.1\)</span> and <span class="math">\(N_x=20,40\)</span> with centered differences</span></p>
</div>
<div class="figure" id="id9">
<span id="advec-1d-stationary-fdm-fig2"></span><a class="reference internal image-reference" href="_images/twopt_BVP_cen_001.png"><img alt="_images/twopt_BVP_cen_001.png" src="_images/twopt_BVP_cen_001.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Comparison of exact and numerical solution for <span class="math">\(\epsilon =0.01\)</span> and <span class="math">\(N_x=20,40\)</span> with centered differences</span></p>
</div>
<div class="admonition-solver admonition">
<p class="first admonition-title">Solver</p>
<p class="last">A suitable solver for doing the experiments is presented below.</p>
</div>
</div>
<div class="section" id="remedy-upwind-finite-difference-scheme">
<span id="advec-1d-stationary-upwind"></span><h3>Remedy: upwind finite difference scheme<a class="headerlink" href="#remedy-upwind-finite-difference-scheme" title="Permalink to this headline">¶</a></h3>
<p>The scheme can be stabilized by letting the advective transport term, which
is the dominating term, collect its information in the flow direction, i.e.,
upstream or upwind of the point in question. So, instead of using a
center difference</p>
<div class="math">
\[\frac{du}{dx}_i\approx \frac{u_{i+1}-u_{i-1}}{2\Delta x},\]</div>
<p>we use the one-sided <em>upwind</em> difference</p>
<div class="math">
\[\frac{du}{dx}_i\approx \frac{u_{i}-u_{i-1}}{2\Delta x},\]</div>
<p>in case <span class="math">\(v&gt;0\)</span>. For <span class="math">\(v&lt;0\)</span> we set</p>
<div class="math">
\[\frac{du}{dx}_i\approx \frac{u_{i+1}-u_{i}}{2\Delta x},\]</div>
<p>On compact operator notation form, our upwind scheme can be expressed
as</p>
<div class="math">
\[[D^-_x u = \epsilon D_xD_x u]_i\]</div>
<p>provided <span class="math">\(v&gt;0\)</span> (and <span class="math">\(\epsilon &gt; 0\)</span>).</p>
<p>We write out the equations and implement them as shown in the program
in the section <a class="reference internal" href="#advec-1d-stationary-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>. The results appear in Figures
<a class="reference internal" href="#advec-1d-stationary-upwind-fig1"><span class="std std-ref">Comparison of exact and numerical solution for  and  with upwind difference</span></a> and
<a class="reference internal" href="#advec-1d-stationary-upwind-fig2"><span class="std std-ref">Comparison of exact and numerical solution for  and  with upwind difference</span></a>: no more oscillations!</p>
<div class="figure" id="id10">
<span id="advec-1d-stationary-upwind-fig1"></span><a class="reference internal image-reference" href="_images/twopt_BVP_upw_01.png"><img alt="_images/twopt_BVP_upw_01.png" src="_images/twopt_BVP_upw_01.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Comparison of exact and numerical solution for <span class="math">\(\epsilon =0.1\)</span> and <span class="math">\(N_x=20,40\)</span> with upwind difference</span></p>
</div>
<div class="figure" id="id11">
<span id="advec-1d-stationary-upwind-fig2"></span><a class="reference internal image-reference" href="_images/twopt_BVP_upw_001.png"><img alt="_images/twopt_BVP_upw_001.png" src="_images/twopt_BVP_upw_001.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Comparison of exact and numerical solution for <span class="math">\(\epsilon =0.01\)</span> and <span class="math">\(N_x=20,40\)</span> with upwind difference</span></p>
</div>
<p>We see that the upwind scheme is always stable, but it gives a thicker
boundary layer when the centered scheme is also stable.
Why the upwind scheme is always stable is easy to understand as
soon as we undertake the mathematical analysis in
<a class="reference internal" href="#advec-1d-stationary-exer-analysis1"><span class="std std-ref">Exercise 4.1: Analyze 1D stationary convection-diffusion problem</span></a>.
Moreover, the thicker layer (seemingly larger diffusion) can be
understood by doing
<a class="reference internal" href="#advec-1d-stationary-exer-analysis2"><span class="std std-ref">Exercise 4.2: Interpret upwind difference as artificial diffusion</span></a>.</p>
<div class="admonition-exact-solution-for-this-model-problem admonition">
<p class="first admonition-title">Exact solution for this model problem</p>
<p class="last">It turns out that one can introduce a linear combination of the centered
and upwind differences for the first-derivative term in this model
problem. One can then adjust the weight in the linear combination so that
the numerical solution becomes identical to the analytical solution of
the differential equation problem at any mesh point.</p>
</div>
</div>
</div>
<div class="section" id="time-dependent-convection-diffusion-equations">
<h2>Time-dependent convection-diffusion equations<a class="headerlink" href="#time-dependent-convection-diffusion-equations" title="Permalink to this headline">¶</a></h2>
<p>Now it is time to combine time-dependency, convection (advection) and
diffusion into one equation:</p>
<div class="math" id="eq-advec-1d-stat-pde3">
\[ \begin{align}\begin{aligned}\tag{513}
\frac{\partial u}{\partial t} + v\frac{\partial u}{\partial x} =
    {\alpha}\frac{\partial^2 u}{\partial x^2}{\thinspace .}\\
    seen that upwind has been critical, so that will work, but will centered
    also work in this case?\end{aligned}\end{align} \]</div>
</div>
<div class="section" id="two-dimensional-advection-diffusion-equations">
<span id="advec-2d"></span><h2>Two-dimensional advection-diffusion equations<a class="headerlink" href="#two-dimensional-advection-diffusion-equations" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="applications-of-advection-equations">
<span id="advec-app"></span><h2>Applications of advection equations<a class="headerlink" href="#applications-of-advection-equations" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="exercises-8">
<h2>Exercises<a class="headerlink" href="#exercises-8" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-4-1-analyze-1d-stationary-convection-diffusion-problem">
<span id="advec-1d-stationary-exer-analysis1"></span><h3>Exercise 4.1: Analyze 1D stationary convection-diffusion problem<a class="headerlink" href="#exercise-4-1-analyze-1d-stationary-convection-diffusion-problem" title="Permalink to this headline">¶</a></h3>
<p>Explain the observations in the numerical experiments from the sections <a class="reference internal" href="#advec-1d-stationary-fdm"><span class="std std-ref">A centered finite difference scheme</span></a> and <a class="reference internal" href="#advec-1d-stationary-upwind"><span class="std std-ref">Remedy: upwind finite difference scheme</span></a> by
finding exact numerical solutions.</p>
<p><strong>Hint.</strong>
The difference equations allow solutions on the form <span class="math">\(A^i\)</span>, where
<span class="math">\(A\)</span> is an unknown constant and <span class="math">\(i\)</span> is a mesh point counter.
There are two solutions for <span class="math">\(A\)</span>, so the general solution is a linear
combination of the two, where the constants in the linear combination
are determined from the boundary conditions.</p>
<p>Filename: <code class="docutils literal"><span class="pre">twopt_BVP_analysis1</span></code>.</p>
</div>
<div class="section" id="exercise-4-2-interpret-upwind-difference-as-artificial-diffusion">
<span id="advec-1d-stationary-exer-analysis2"></span><h3>Exercise 4.2: Interpret upwind difference as artificial diffusion<a class="headerlink" href="#exercise-4-2-interpret-upwind-difference-as-artificial-diffusion" title="Permalink to this headline">¶</a></h3>
<p>Consider an upwind, one-sided difference approximation to
a term <span class="math">\(du/dx\)</span> in a differential equation. Show that this this
formula can be expressed as a centered difference plus an artificial
diffusion term of strength proportional to <span class="math">\(\Delta x\)</span>.
This means that introducing an upwind difference also means introducing
extra diffusion of order <span class="math">\({\mathcal{O}(\Delta x)}\)</span>.
Filename: <code class="docutils literal"><span class="pre">twopt_BVP_analysis2</span></code>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advection-dominated equations</a><ul>
<li><a class="reference internal" href="#one-dimensional-time-dependent-advection-equations">One-dimensional time-dependent advection equations</a><ul>
<li><a class="reference internal" href="#simplest-scheme-forward-in-time-centered-in-space">Simplest scheme: forward in time, centered in space</a><ul>
<li><a class="reference internal" href="#method-1">Method</a></li>
<li><a class="reference internal" href="#implementation-9">Implementation</a></li>
<li><a class="reference internal" href="#test-cases">Test cases</a></li>
<li><a class="reference internal" href="#bug">Bug?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-scheme">Analysis of the scheme</a></li>
<li><a class="reference internal" href="#leapfrog-in-time-centered-differences-in-space">Leapfrog in time, centered differences in space</a><ul>
<li><a class="reference internal" href="#method-2">Method</a></li>
<li><a class="reference internal" href="#implementation-10">Implementation</a></li>
<li><a class="reference internal" href="#running-a-test-case">Running a test case</a></li>
<li><a class="reference internal" href="#analysis">Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#upwind-differences-in-space">Upwind differences in space</a></li>
<li><a class="reference internal" href="#periodic-boundary-conditions">Periodic boundary conditions</a></li>
<li><a class="reference internal" href="#a-crank-nicolson-discretization-in-time-and-centered-differences-in-space">A Crank-Nicolson discretization in time and centered differences in space</a></li>
<li><a class="reference internal" href="#the-lax-wendroff-method">The Lax-Wendroff method</a></li>
<li><a class="reference internal" href="#analysis-of-dispersion-relations">Analysis of dispersion relations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#one-dimensional-stationary-advection-diffusion-equation">One-dimensional stationary advection-diffusion equation</a><ul>
<li><a class="reference internal" href="#a-simple-model-problem-1">A simple model problem</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme-2">A centered finite difference scheme</a></li>
<li><a class="reference internal" href="#remedy-upwind-finite-difference-scheme">Remedy: upwind finite difference scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#time-dependent-convection-diffusion-equations">Time-dependent convection-diffusion equations</a></li>
<li><a class="reference internal" href="#two-dimensional-advection-diffusion-equations">Two-dimensional advection-diffusion equations</a></li>
<li><a class="reference internal" href="#applications-of-advection-equations">Applications of advection equations</a></li>
<li><a class="reference internal" href="#exercises-8">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-4-1-analyze-1d-stationary-convection-diffusion-problem">Exercise 4.1: Analyze 1D stationary convection-diffusion problem</a></li>
<li><a class="reference internal" href="#exercise-4-2-interpret-upwind-difference-as-artificial-diffusion">Exercise 4.2: Interpret upwind difference as artificial diffusion</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book011.html"
                        title="previous chapter">Diffusion equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book013.html"
                        title="next chapter">Nonlinear problems</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book012.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book013.html" title="Nonlinear problems"
             >next</a> |</li>
        <li class="right" >
          <a href="._book011.html" title="Diffusion equations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>