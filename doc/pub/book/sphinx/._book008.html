
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference methods for 2D and 3D wave equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with PDEs" href="index.html" />
    <link rel="next" title="Applications of wave equations" href="._book009.html" />
    <link rel="prev" title="Analysis of the difference equations" href="._book007.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book009.html" title="Applications of wave equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book007.html" title="Analysis of the difference equations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-difference-methods-for-2d-and-3d-wave-equations">
<span id="wave-2d3d"></span><h1>Finite difference methods for 2D and 3D wave equations<a class="headerlink" href="#finite-difference-methods-for-2d-and-3d-wave-equations" title="Permalink to this headline">¶</a></h1>
<p>A natural next step is to consider extensions of the methods for
various
variants of the one-dimensional wave equation to two-dimensional (2D) and
three-dimensional (3D) versions of the wave equation.</p>
<div class="section" id="multi-dimensional-wave-equations">
<span id="wave-2d3d-models"></span><h2>Multi-dimensional wave equations<a class="headerlink" href="#multi-dimensional-wave-equations" title="Permalink to this headline">¶</a></h2>
<p>The general wave equation in <span class="math">\(d\)</span> space dimensions, with constant
wave velocity <span class="math">\(c\)</span>,
can be written in the compact form</p>
<div class="math" id="eq-wave-2d3d-model1">
\[\tag{263}
\frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T] ,\]</div>
<p>where</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} ,\]</div>
<p>in a 2D problem (<span class="math">\(d=2\)</span>) and</p>
<div class="math">
\[\nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2},\]</div>
<p>in three space dimensions (<span class="math">\(d=3\)</span>).</p>
<p>Many applications involve variable coefficients, and the general
wave equation in <span class="math">\(d\)</span> dimensions is in this case written as</p>
<div class="math" id="eq-wave-2d3d-model2">
\[\tag{264}
\varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\boldsymbol{x}\in\Omega\subset\mathbb{R}^d,\ t\in (0,T],\]</div>
<p>which in, e.g.,  2D becomes</p>
<div class="math" id="eq-auto114">
\[\tag{265}
\varrho(x,y)
    \frac{\partial^2 u}{\partial t^2} =
    \frac{\partial}{\partial x}\left( q(x,y)
    \frac{\partial u}{\partial x}\right)
    +
    \frac{\partial}{\partial y}\left( q(x,y)
    \frac{\partial u}{\partial y}\right)
    + f(x,y,t)
    {\thinspace .}\]</div>
<p>To save some writing and space we may use the index notation, where
subscript <span class="math">\(t\)</span>, <span class="math">\(x\)</span>, or <span class="math">\(y\)</span> means differentiation with respect
to that coordinate. For example,</p>
<div class="math">
\[\begin{split}\begin{align*}
\frac{\partial^2 u}{\partial t^2} &amp;= u_{tt},\\
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right) &amp;= (q u_y)_y
{\thinspace .}
\end{align*}\end{split}\]</div>
<p>These comments extend straightforwardly to 3D, which means that
the 3D versions of the
two wave PDEs, with and without variable coefficients,
can be stated as</p>
<div class="math" id="eq-wave-2d3d-model1-v2">
\[\tag{266}
u_{tt} = c^2(u_{xx} + u_{yy} + u_{zz}) + f,\]</div>
<div class="math" id="eq-wave-2d3d-model2-v2">
\[\tag{267}
\varrho u_{tt} = (q u_x)_x + (q u_z)_z + (q u_z)_z + f{\thinspace .}\]</div>
<p>At <em>each point</em> of the boundary <span class="math">\(\partial\Omega\)</span> (of <span class="math">\(\Omega\)</span>) we need
<em>one</em> boundary condition involving the unknown <span class="math">\(u\)</span>.
The boundary conditions are of three principal types:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u\)</span> is prescribed (<span class="math">\(u=0\)</span> or a known time variation of <span class="math">\(u\)</span> at
the boundary points, e.g.,
modeling an incoming wave),</li>
<li><span class="math">\(\partial u/\partial n = \boldsymbol{n}\cdot\nabla u\)</span> is prescribed
(zero for reflecting boundaries),</li>
<li>an open boundary condition (also called radiation condition)
is specified to let waves travel undisturbed out of the domain,
see <a class="reference internal" href="._book006.html#wave-app-exer-radiationbc"><span class="std std-ref">Problem 2.12: Implement open boundary conditions</span></a> for details.</li>
</ol>
</div></blockquote>
<p>All the listed wave equations with <em>second-order</em> derivatives in
time need <em>two</em> initial conditions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u=I\)</span>,</li>
<li><span class="math">\(u_t = V\)</span>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="mesh">
<span id="wave-2d3d-mesh"></span><h2>Mesh<a class="headerlink" href="#mesh" title="Permalink to this headline">¶</a></h2>
<p>We introduce a mesh in time and in space. The mesh in time consists
of time points</p>
<div class="math">
\[t_0=0 &lt; t_1 &lt; \cdots &lt; t_{N_t},\]</div>
<p>normally, for wave equation problems, with a constant spacing <span class="math">\(\Delta
t= t_{n+1}-t_{n}\)</span>, <span class="math">\(n\in{{\mathcal{I^-}_t}}\)</span>.</p>
<p>Finite difference methods are easy to implement on simple rectangle-
or box-shaped <em>spatial domains</em>. More complicated shapes of the
spatial domain require substantially more advanced techniques and
implementational efforts (and a finite element method is usually a more
convenient approach). On a rectangle- or box-shaped domain, mesh
points are introduced separately in the various space directions:</p>
<div class="math">
\[\begin{split}\begin{align*}
&amp;x_0 &lt; x_1 &lt; \cdots &lt; x_{N_x}  \hbox{ in the }x \hbox{ direction},\\
&amp;y_0 &lt; y_1 &lt; \cdots &lt; y_{N_y}  \hbox{ in the }y \hbox{ direction},\\
&amp;z_0 &lt; z_1 &lt; \cdots &lt; z_{N_z}  \hbox{ in the }z \hbox{ direction}{\thinspace .}
\end{align*}\end{split}\]</div>
<p>We can write a general mesh point as <span class="math">\((x_i,y_j,z_k,t_n)\)</span>, with
<span class="math">\(i\in{\mathcal{I}_x}\)</span>, <span class="math">\(j\in{\mathcal{I}_y}\)</span>, <span class="math">\(k\in{\mathcal{I}_z}\)</span>, and <span class="math">\(n\in{\mathcal{I}_t}\)</span>.</p>
<p>It is a very common choice to use constant mesh spacings:
<span class="math">\(\Delta x = x_{i+1}-x_{i}\)</span>, <span class="math">\(i\in{{\mathcal{I^-}_x}}\)</span>,
<span class="math">\(\Delta y = y_{j+1}-y_{j}\)</span>, <span class="math">\(j\in{{\mathcal{I^-}_y}}\)</span>, and
<span class="math">\(\Delta z = z_{k+1}-z_{k}\)</span>, <span class="math">\(k\in{{\mathcal{I^-}_z}}\)</span>.
With equal mesh spacings one often introduces
<span class="math">\(h = \Delta x = \Delta y =\Delta z\)</span>.</p>
<p>The unknown <span class="math">\(u\)</span> at mesh point <span class="math">\((x_i,y_j,z_k,t_n)\)</span> is denoted by
<span class="math">\(u^{n}_{i,j,k}\)</span>. In 2D problems we just skip the <span class="math">\(z\)</span> coordinate
(by assuming no variation in that direction: <span class="math">\(\partial/\partial z=0\)</span>)
and write <span class="math">\(u^n_{i,j}\)</span>.</p>
</div>
<div class="section" id="discretization-1">
<span id="wave-2d3d-discretization"></span><h2>Discretization<a class="headerlink" href="#discretization-1" title="Permalink to this headline">¶</a></h2>
<p>Two- and three-dimensional wave equations are easily discretized by
assembling building blocks for discretization of
1D wave equations, because the multi-dimensional versions just contain
terms of the same type as those in 1D.</p>
<div class="section" id="discretizing-the-pdes">
<h3>Discretizing the PDEs<a class="headerlink" href="#discretizing-the-pdes" title="Permalink to this headline">¶</a></h3>
<p>Equation <a class="reference internal" href="#eq-wave-2d3d-model1-v2"><span class="std std-ref">(266)</span></a> can be discretized as</p>
<div class="math" id="eq-auto115">
\[\tag{268}
[D_tD_t u = c^2(D_xD_x u + D_yD_yu + D_zD_z u) + f]^n_{i,j,k}
    {\thinspace .}\]</div>
<p>A 2D version might be instructive to write out in detail:</p>
<div class="math">
\[[D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},\]</div>
<p>which becomes</p>
<div class="math">
\[\frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>Assuming, as usual, that all values at time levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span>
are known, we can solve for the only unknown <span class="math">\(u^{n+1}_{i,j}\)</span>. The
result can be compactly written as</p>
<div class="math" id="eq-wave-2d3d-models-unp1">
\[\tag{269}
u^{n+1}_{i,j} = 2u^n_{i,j} + u^{n-1}_{i,j} + c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}{\thinspace .}\]</div>
<p>As in the 1D case, we need to develop a special formula for <span class="math">\(u^1_{i,j}\)</span>
where we combine the general scheme for <span class="math">\(u^{n+1}_{i,j}\)</span>, when <span class="math">\(n=0\)</span>,
with the discretization of the initial condition:</p>
<div class="math">
\[[D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
{\thinspace .}\]</div>
<p>The result becomes, in compact form,</p>
<div class="math" id="eq-wave-2d3d-models-u1">
\[\tag{270}
u^{1}_{i,j} = u^0_{i,j} -2\Delta V_{i,j} + {\frac{1}{2}}
    c^2\Delta t^2[D_xD_x u + D_yD_y u]^0_{i,j}{\thinspace .}\]</div>
<p>The PDE <a class="reference internal" href="#eq-wave-2d3d-model2-v2"><span class="std std-ref">(267)</span></a>
with variable coefficients is discretized term by term using
the corresponding elements from the 1D case:</p>
<div class="math" id="eq-auto116">
\[\tag{271}
[\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
    D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
    {\thinspace .}\]</div>
<p>When written out and solved for the unknown <span class="math">\(u^{n+1}_{i,j,k}\)</span>, one gets the
scheme</p>
<div class="math">
\[\begin{split}\begin{align*}
u^{n+1}_{i,j,k} &amp;= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\qquad \frac{1}{2}(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\
&amp;\qquad\qquad\frac{1}{2}(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\
&amp;\quad \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \frac{1}{2}(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\
&amp;\qquad\qquad \frac{1}{2}(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\
&amp;\quad \Delta t^2 f^n_{i,j,k}
{\thinspace .}
\end{align*}\end{split}\]</div>
<p>Also here we need to develop a special formula for <span class="math">\(u^1_{i,j,k}\)</span>
by combining the scheme for <span class="math">\(n=0\)</span> with the discrete initial condition,
which is just a matter of inserting
<span class="math">\(u^{-1}_{i,j,k}=u^1_{i,j,k} - 2\Delta tV_{i,j,k}\)</span> in the scheme
and solving for <span class="math">\(u^1_{i,j,k}\)</span>.</p>
</div>
<div class="section" id="handling-boundary-conditions-where-is-known">
<h3>Handling boundary conditions where <span class="math">\(u\)</span> is known<a class="headerlink" href="#handling-boundary-conditions-where-is-known" title="Permalink to this headline">¶</a></h3>
<p>The schemes listed above are valid for the internal points in the mesh.
After updating these, we need to visit all the mesh points at the
boundaries and set the prescribed <span class="math">\(u\)</span> value.</p>
</div>
<div class="section" id="discretizing-the-neumann-condition">
<h3>Discretizing the Neumann condition<a class="headerlink" href="#discretizing-the-neumann-condition" title="Permalink to this headline">¶</a></h3>
<p>The condition <span class="math">\(\partial u/\partial n = 0\)</span> was implemented in 1D by
discretizing it with a <span class="math">\(D_{2x}u\)</span> centered difference, followed by
eliminating the fictitious <span class="math">\(u\)</span> point outside the mesh by using the
general scheme at the boundary point. Alternatively, one can introduce
ghost cells and update a ghost value for use in the Neumann
condition. Exactly the same ideas are reused in multiple dimensions.</p>
<p>Consider the condition  <span class="math">\(\partial u/\partial n = 0\)</span>
at a boundary <span class="math">\(y=0\)</span> of a rectangular domain <span class="math">\([0, L_x]\times [0,L_y]\)</span> in 2D.
The normal direction is then in <span class="math">\(-y\)</span> direction,
so</p>
<div class="math">
\[\frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y},\]</div>
<p>and we set</p>
<div class="math">
\[[-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0
{\thinspace .}\]</div>
<p>From this it follows that <span class="math">\(u^n_{i,-1}=u^n_{i,1}\)</span>.
The discretized PDE at the boundary point <span class="math">\((i,0)\)</span> reads</p>
<div class="math">
\[\frac{u^{n+1}_{i,0} - 2u^{n}_{i,0} + u^{n-1}_{i,0}}{\Delta t^2}
= c^2
\frac{u^{n}_{i+1,0} - 2u^{n}_{i,0} + u^{n}_{i-1,0}}{\Delta x^2}
+ c^2
\frac{u^{n}_{i,1} - 2u^{n}_{i,0} + u^{n}_{i,-1}}{\Delta y^2}
+ f^n_{i,j},\]</div>
<p>We can then just insert <span class="math">\(u^n_{i,1}\)</span> for <span class="math">\(u^n_{i,-1}\)</span> in this equation
and solve for the boundary value <span class="math">\(u^{n+1}_{i,0}\)</span>, just as was done in 1D.</p>
<p>From these calculations, we see a pattern:
the general scheme applies at the boundary <span class="math">\(j=0\)</span> too if we just
replace <span class="math">\(j-1\)</span> by <span class="math">\(j+1\)</span>. Such a pattern is particularly useful for
implementations. The details follow from the explained 1D case
in the section <a class="reference internal" href="._book006.html#wave-pde2-neumann-impl"><span class="std std-ref">Implementation of Neumann conditions</span></a>.</p>
<p>The alternative approach to eliminating fictitious values outside the
mesh is to have <span class="math">\(u^n_{i,-1}\)</span> available as a ghost value.  The mesh is
extended with one extra line (2D) or plane (3D) of ghost cells at a
Neumann boundary. In the present example it means that we need a line
with ghost cells below the <span class="math">\(y\)</span> axis.  The ghost values must be updated
according to <span class="math">\(u^{n+1}_{i,-1}=u^{n+1}_{i,1}\)</span>.</p>
</div>
</div>
</div>
<div class="section" id="implementation-6">
<span id="wave-2d3d-impl"></span><h1>Implementation<a class="headerlink" href="#implementation-6" title="Permalink to this headline">¶</a></h1>
<p id="index-0">We shall now describe in detail various Python implementations
for solving a standard 2D, linear wave equation with constant
wave velocity and <span class="math">\(u=0\)</span> on the
boundary. The wave equation is to be solved
in the space-time domain <span class="math">\(\Omega\times (0,T]\)</span>,
where <span class="math">\(\Omega = (0,L_x)\times (0,L_y)\)</span> is a rectangular spatial
domain. More precisely,
the complete initial-boundary value problem is defined by</p>
<div class="math" id="eq-auto117">
\[\tag{272}
u_{tt} = c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad (x,y)\in \Omega,\ t\in (0,T],\]</div>
<div class="math" id="eq-auto118">
\[\tag{273}
u(x,y,0) = I(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto119">
\[\tag{274}
u_t(x,y,0) = V(x,y),\quad (x,y)\in\Omega,\]</div>
<div class="math" id="eq-auto120">
\[\tag{275}
u = 0,\quad (x,y)\in\partial\Omega,\ t\in (0,T],\]</div>
<p>where <span class="math">\(\partial\Omega\)</span> is the boundary of <span class="math">\(\Omega\)</span>, in this case
the four sides of the rectangle <span class="math">\(\Omega = [0,L_x]\times [0,L_y]\)</span>:
<span class="math">\(x=0\)</span>, <span class="math">\(x=L_x\)</span>, <span class="math">\(y=0\)</span>, and <span class="math">\(y=L_y\)</span>.</p>
<p>The PDE is discretized as</p>
<div class="math">
\[[D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},\]</div>
<p>which leads to an explicit updating formula to be implemented in a
program:</p>
<div class="math">
\[u^{n+1}_{i,j} = -u^{n-1}_{i,j} + 2u^n_{i,j} + \nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-discrete">
\[\tag{276}
\quad C_x^2(
    u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}) + C_y^2
    (u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}) + \Delta t^2 f_{i,j}^n,\]</div>
<p>for all interior mesh points <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span> and
<span class="math">\(j\in{{\mathcal{I^i}_y}}\)</span>, for <span class="math">\(n\in{{\mathcal{I^+}_t}}\)</span>.
The constants <span class="math">\(C_x\)</span> and <span class="math">\(C_y\)</span> are defined as</p>
<div class="math">
\[C_x = c\frac{\Delta t}{\Delta x},\quad C_x = c\frac{\Delta t}{\Delta y}
{\thinspace .}\]</div>
<p>At the boundary, we simply set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for
<span class="math">\(i=0\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>; <span class="math">\(i=N_x\)</span>, <span class="math">\(j=0,\ldots,N_y\)</span>;
<span class="math">\(j=0\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>; and <span class="math">\(j=N_y\)</span>, <span class="math">\(i=0,\ldots,N_x\)</span>.
For the first step, <span class="math">\(n=0\)</span>, <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(276)</span></a>
is combined with the discretization of the initial condition <span class="math">\(u_t=V\)</span>,
<span class="math">\([D_{2t} u = V]^0_{i,j}\)</span> to obtain a special formula for
<span class="math">\(u^1_{i,j}\)</span> at the interior mesh points:</p>
<div class="math">
\[u^{1}_{i,j} = u^0_{i,j} + \Delta t V_{i,j} + \nonumber\]</div>
<div class="math">
\[\quad {\frac{1}{2}}C_x^2(
u^{0}_{i+1,j} - 2u^{0}_{i,j} + u^{0}_{i-1,j}) + {\frac{1}{2}}C_y^2
(u^{0}_{i,j+1} - 2u^{0}_{i,j} + u^{0}_{i,j-1}) +\nonumber\]</div>
<div class="math" id="eq-wave-2d3d-impl1-2du0-ueq-n0-discrete">
\[\tag{277}
\quad \frac{1}{2}\Delta t^2f_{i,j}^n,\]</div>
<p>The algorithm is very similar to the one in 1D:</p>
<ol class="arabic simple">
<li>Set initial condition <span class="math">\(u^0_{i,j}=I(x_i,y_j)\)</span></li>
<li>Compute <span class="math">\(u^1_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(276)</span></a></li>
<li>Set <span class="math">\(u^1_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
<li>For <span class="math">\(n=1,2,\ldots,N_t\)</span>:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Find <span class="math">\(u^{n+1}_{i,j}\)</span> from <a class="reference internal" href="#eq-wave-2d3d-impl1-2du0-ueq-discrete"><span class="std std-ref">(276)</span></a>
for all internal mesh points, <span class="math">\(i\in{{\mathcal{I^i}_x}}\)</span>, <span class="math">\(j\in{{\mathcal{I^i}_y}}\)</span></li>
<li>Set <span class="math">\(u^{n+1}_{i,j}=0\)</span> for the boundaries <span class="math">\(i=0,N_x\)</span>, <span class="math">\(j=0,N_y\)</span></li>
</ol>
</div></blockquote>
<div class="section" id="scalar-computations">
<span id="wave2d3d-impl-scalar"></span><h2>Scalar computations<a class="headerlink" href="#scalar-computations" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">solver</span></code> function for a 2D case with constant wave velocity and
boundary condition <span class="math">\(u=0\)</span> is analogous to the 1D case with similar parameter
values (see <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code>), apart from a few necessary
extensions. The code is found in the program
<a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>.</p>
<div class="section" id="domain-and-mesh">
<h3>Domain and mesh<a class="headerlink" href="#domain-and-mesh" title="Permalink to this headline">¶</a></h3>
<p>The spatial domain is now <span class="math">\([0,L_x]\times [0,L_y]\)</span>, specified
by the arguments <code class="docutils literal"><span class="pre">Lx</span></code> and <code class="docutils literal"><span class="pre">Ly</span></code>. Similarly, the number of mesh
points in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions,
<span class="math">\(N_x\)</span> and <span class="math">\(N_y\)</span>, become the arguments <code class="docutils literal"><span class="pre">Nx</span></code> and <code class="docutils literal"><span class="pre">Ny</span></code>.
In multi-dimensional problems it makes less sense to specify a
Courant number since the wave velocity is a vector and mesh spacings
may differ in the various spatial directions.
We therefore give <span class="math">\(\Delta t\)</span> explicitly. The signature of
the <code class="docutils literal"><span class="pre">solver</span></code> function is then</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
           <span class="n">user_action</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;scalar&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>Key parameters used in the calculations are created as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c1"># mesh points in x dir</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                  <span class="c1"># mesh points in y dir</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>                 <span class="c1"># mesh points in time</span>
<span class="n">Cx2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="c1"># help variables</span>
<span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="solution-arrays">
<h3>Solution arrays<a class="headerlink" href="#solution-arrays" title="Permalink to this headline">¶</a></h3>
<p>We store <span class="math">\(u^{n+1}_{i,j}\)</span>, <span class="math">\(u^{n}_{i,j}\)</span>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> in three two-dimensional arrays,</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span>   <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>   <span class="c1"># solution array</span>
<span class="n">u_n</span> <span class="o">=</span> <span class="p">[</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>  <span class="c1"># t-dt, t-2*dt</span>
</pre></div>
</div>
<p>where <span class="math">\(u^{n+1}_{i,j}\)</span> corresponds to <code class="docutils literal"><span class="pre">u[i,j]</span></code>,
<span class="math">\(u^{n}_{i,j}\)</span> to <code class="docutils literal"><span class="pre">u_n[i,j]</span></code>, and
<span class="math">\(u^{n-1}_{i,j}\)</span> to <code class="docutils literal"><span class="pre">u_nm1[i,j]</span></code>.</p>
</div>
<div class="section" id="index-sets">
<span id="index-1"></span><h3>Index sets<a class="headerlink" href="#index-sets" title="Permalink to this headline">¶</a></h3>
<p>It is also convenient to introduce the index sets (cf. the section <a class="reference internal" href="._book006.html#wave-indexset"><span class="std std-ref">Index set notation</span></a>)</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">It</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-the-solution">
<h3>Computing the solution<a class="headerlink" href="#computing-the-solution" title="Permalink to this headline">¶</a></h3>
<p>Inserting the initial
condition <code class="docutils literal"><span class="pre">I</span></code> in <code class="docutils literal"><span class="pre">u_n</span></code> and making a callback to the user in terms of
the <code class="docutils literal"><span class="pre">user_action</span></code> function is a straightforward generalization of
the 1D code from the section <a class="reference internal" href="._book005.html#wave-string-impl"><span class="std std-ref">Sketch of an implementation</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span>
        <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

<span class="k">if</span> <span class="n">user_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">user_action</span><span class="p">(</span><span class="n">u_n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">user_action</span></code> function has additional arguments compared to the
1D case. The arguments <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> will be commented
upon in the section <a class="reference internal" href="#wave2d3d-impl-vectorized"><span class="std std-ref">Vectorized computations</span></a>.</p>
<p>The key finite difference formula <a class="reference internal" href="#eq-wave-2d3d-models-unp1"><span class="std std-ref">(269)</span></a>
for updating the solution at
a time level is implemented in a separate function as</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u_nm1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                   <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">Ix</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="n">Iy</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c1"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c1"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_nm1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> \
                     <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="c1"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">Iy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Ix</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Iy</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">step1</span></code> variable has been introduced to allow the formula to be
reused for the first step, computing <span class="math">\(u^1_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">advance_scalar</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                   <span class="n">n</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Below, we will make many alternative implementations of the
<code class="docutils literal"><span class="pre">advance_scalar</span></code> function to speed up the code since most of
the CPU time in simulations is spent in this function.</p>
<div class="admonition-remark-how-to-use-the-solution admonition">
<p class="first admonition-title">Remark: How to use the solution</p>
<p class="last">The <code class="docutils literal"><span class="pre">solver</span></code> function in the <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code> code
updates arrays for the next time step by switching references as
described in the section <a class="reference internal" href="._book005.html#wave-pde1-impl-ref-switch"><span class="std std-ref">Remark on the updating of arrays</span></a>. Any use of <code class="docutils literal"><span class="pre">u</span></code> on the
user&#8217;s side is assumed to take place in the user action function. However,
should the code be changed such that <code class="docutils literal"><span class="pre">u</span></code> is returned and used as solution,
have in mind that you must return <code class="docutils literal"><span class="pre">u_n</span></code> after the time lime, otherwise
a <code class="docutils literal"><span class="pre">return</span> <span class="pre">u</span></code> will actually return <code class="docutils literal"><span class="pre">u_nm1</span></code> (due to the switching of array
indices in the loop)!</p>
</div>
</div>
</div>
<div class="section" id="vectorized-computations">
<span id="wave2d3d-impl-vectorized"></span><h2>Vectorized computations<a class="headerlink" href="#vectorized-computations" title="Permalink to this headline">¶</a></h2>
<p>The scalar code above turns out to be extremely slow for large 2D
meshes, and probably useless in 3D beyond debugging of small test cases.
Vectorization is therefore a must for multi-dimensional
finite difference computations in Python. For example,
with a mesh consisting of <span class="math">\(30\times 30\)</span> cells, vectorization
brings down the CPU time by a factor of 70 (!). Equally important,
vectorized code can also easily be parallelized to take (usually)
optimal advantage of parallel computer platforms.</p>
<p>In the vectorized case, we must be able to evaluate user-given
functions like <span class="math">\(I(x,y)\)</span> and <span class="math">\(f(x,y,t)\)</span> for the entire mesh in one
operation (without loops). These user-given functions are provided as
Python functions <code class="docutils literal"><span class="pre">I(x,y)</span></code> and <code class="docutils literal"><span class="pre">f(x,y,t)</span></code>, respectively.  Having the
one-dimensional coordinate arrays <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> is not sufficient when
calling <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">f</span></code> in a vectorized way.  We must extend <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code>
to their vectorized versions <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">newaxis</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="c1"># or</span>
<span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">yv</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</pre></div>
</div>
<p>This is a standard required technique when evaluating functions over
a 2D mesh, say <code class="docutils literal"><span class="pre">sin(xv)*cos(xv)</span></code>, which then gives a result with shape
<code class="docutils literal"><span class="pre">(Nx+1,Ny+1)</span></code>. Calling <code class="docutils literal"><span class="pre">I(xv,</span> <span class="pre">yv)</span></code> and <code class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></code> will now
return <code class="docutils literal"><span class="pre">I</span></code> and <code class="docutils literal"><span class="pre">f</span></code> values for the entire set of mesh points.</p>
<p>With the <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> arrays for vectorized computing,
setting the initial condition is just a matter of</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u_n</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
<p>One could also have written <code class="docutils literal"><span class="pre">u_n</span> <span class="pre">=</span> <span class="pre">I(xv,</span> <span class="pre">yv)</span></code> and let <code class="docutils literal"><span class="pre">u_n</span></code> point to a
new object, but vectorized operations often make use of direct
insertion in the original array through <code class="docutils literal"><span class="pre">u_n[:,:]</span></code>, because sometimes
not all of the array is to be filled by such a function
evaluation. This is the case with the computational scheme for
<span class="math">\(u^{n+1}_{i,j}\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">advance_vectorized</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">u_nm1</span><span class="p">,</span> <span class="n">f_a</span><span class="p">,</span> <span class="n">Cx2</span><span class="p">,</span> <span class="n">Cy2</span><span class="p">,</span> <span class="n">dt2</span><span class="p">,</span>
                       <span class="n">V</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">step1</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt2</span><span class="p">)</span>  <span class="c1"># save</span>
        <span class="n">Cx2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cx2</span><span class="p">;</span>  <span class="n">Cy2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Cy2</span><span class="p">;</span> <span class="n">dt2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt2</span>  <span class="c1"># redefine</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">D1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="n">D2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_xx</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">u_yy</span> <span class="o">=</span> <span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">D1</span><span class="o">*</span><span class="n">u_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">D2</span><span class="o">*</span><span class="n">u_nm1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="n">Cx2</span><span class="o">*</span><span class="n">u_xx</span> <span class="o">+</span> <span class="n">Cy2</span><span class="o">*</span><span class="n">u_yy</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f_a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">step1</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Boundary condition u=0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">u</span>
</pre></div>
</div>
<p>Array slices in 2D are more complicated to understand than those in
1D, but the logic from 1D applies to each dimension separately.
For example, when doing <span class="math">\(u^{n}_{i,j} - u^{n}_{i-1,j}\)</span> for <span class="math">\(i\in{{\mathcal{I^+}_x}}\)</span>,
we just keep <code class="docutils literal"><span class="pre">j</span></code> constant and make a slice in the first index:
<code class="docutils literal"><span class="pre">u_n[1:,j]</span> <span class="pre">-</span> <span class="pre">u_n[:-1,j]</span></code>, exactly as in 1D. The <code class="docutils literal"><span class="pre">1:</span></code> slice
specifies all the indices <span class="math">\(i=1,2,\ldots,N_x\)</span> (up to the last
valid index),
while <code class="docutils literal"><span class="pre">:-1</span></code> specifies the relevant indices for the second term:
<span class="math">\(0,1,\ldots,N_x-1\)</span> (up to, but not including the last index).</p>
<p>In the above code segment, the situation is slightly more complicated,
because each displaced slice in one direction is
accompanied by a <code class="docutils literal"><span class="pre">1:-1</span></code> slice in the other direction. The reason is
that we only work with the internal points for the index that is
kept constant in a difference.</p>
<p>The boundary conditions along the four sides makes use of
a slice consisting of all indices along a boundary:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">u</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[:,</span><span class="n">Ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span> <span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>In the vectorized update of <code class="docutils literal"><span class="pre">u</span></code> (above), the function <code class="docutils literal"><span class="pre">f</span></code> is first computed
as an array over all mesh points:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>f_a = f(xv, yv, t[n])
</pre></div>
</div>
<p>We could, alternatively, have used the call <code class="docutils literal"><span class="pre">f(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])[1:-1,1:-1]</span></code>
in the last term of the update statement, but other implementations
in compiled languages benefit from having <code class="docutils literal"><span class="pre">f</span></code> available in an array
rather than calling our Python function <code class="docutils literal"><span class="pre">f(x,y,t)</span></code> for
every point.</p>
<p>Also in the <code class="docutils literal"><span class="pre">advance_vectorized</span></code> function we have introduced a
boolean <code class="docutils literal"><span class="pre">step1</span></code> to reuse the formula for the first time step
in the same way as we did with <code class="docutils literal"><span class="pre">advance_scalar</span></code>.
We refer to the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code>
for the details on how the overall algorithm is implemented.</p>
<p>The callback function now has the arguments
<code class="docutils literal"><span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">xv,</span> <span class="pre">y,</span> <span class="pre">yv,</span> <span class="pre">t,</span> <span class="pre">n</span></code>. The inclusion of <code class="docutils literal"><span class="pre">xv</span></code> and <code class="docutils literal"><span class="pre">yv</span></code> makes it
easy to, e.g., compute an exact 2D solution in the callback function
and compute errors, through an expression like
<code class="docutils literal"><span class="pre">u</span> <span class="pre">-</span> <span class="pre">u_exact(xv,</span> <span class="pre">yv,</span> <span class="pre">t[n])</span></code>.</p>
</div>
<div class="section" id="verification-6">
<span id="wave2d3d-impl-verify"></span><h2>Verification<a class="headerlink" href="#verification-6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="testing-a-quadratic-solution">
<h3>Testing a quadratic solution<a class="headerlink" href="#testing-a-quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>The 1D solution from the section <a class="reference internal" href="._book005.html#wave-pde2-fd-verify-quadratic"><span class="std std-ref">Constructing an exact solution of the discrete equations</span></a> can be
generalized to multi-dimensions and provides a test case where the
exact solution also fulfills the discrete equations, such that we know
(to machine precision) what numbers the solver function should
produce. In 2D we use the following generalization of
<a class="reference internal" href="._book005.html#eq-wave-pde2-fd-verify-quadratic-uex"><span class="std std-ref">(189)</span></a>:</p>
<div class="math" id="eq-wave2d3d-impl-verify-quadratic">
\[\tag{278}
{u_{\small\mbox{e}}}(x,y,t) = x(L_x-x)y(L_y-y)(1+{\frac{1}{2}}t)
    {\thinspace .}\]</div>
<p>This solution fulfills the PDE problem if <span class="math">\(I(x,y)={u_{\small\mbox{e}}}(x,y,0)\)</span>,
<span class="math">\(V=\frac{1}{2}{u_{\small\mbox{e}}}(x,y,0)\)</span>, and <span class="math">\(f=2c^2(1+{\frac{1}{2}}t)(y(L_y-y) +
x(L_x-x))\)</span>. To show that <span class="math">\({u_{\small\mbox{e}}}\)</span> also solves the discrete equations,
we start with the general results <span class="math">\([D_t D_t 1]^n=0\)</span>, <span class="math">\([D_t D_t t]^n=0\)</span>,
and <span class="math">\([D_t D_t t^2]=2\)</span>, and use these to compute</p>
<div class="math">
\[\begin{split}\begin{align*}
[D_xD_x {u_{\small\mbox{e}}}]^n_{i,j} &amp;= [y(L_y-y)(1+{\frac{1}{2}}t) D_xD_x x(L_x-x)]^n_{i,j}\\
&amp;= y_j(L_y-y_j)(1+{\frac{1}{2}}t_n)(-2){\thinspace .}
\end{align*}\end{split}\]</div>
<p>A similar calculation must be carried out for the <span class="math">\([D_yD_y
{u_{\small\mbox{e}}}]^n_{i,j}\)</span> and <span class="math">\([D_tD_t {u_{\small\mbox{e}}}]^n_{i,j}\)</span> terms.  One must also show
that the quadratic solution fits the special formula for
<span class="math">\(u^1_{i,j}\)</span>. The details are left as <a class="reference internal" href="#wave-exer-quadratic-2d"><span class="std std-ref">Exercise 2.16: Check that a solution fulfills the discrete model</span></a>.
The <code class="docutils literal"><span class="pre">test_quadratic</span></code> function in the
<a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program implements this verification as a proper test function
for the pytest and nose frameworks.</p>
</div>
</div>
<div class="section" id="visualization-2">
<h2>Visualization<a class="headerlink" href="#visualization-2" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><p id="index-3">Eventually, we are ready with a real application with our code!
Look at the <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code> and the <code class="docutils literal"><span class="pre">gaussian</span></code> function. It
starts with a Gaussian function to see how it propagates in a square
with <span class="math">\(u=0\)</span> on the boundaries:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="n">plot_method</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;vectorized&#39;</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initial Gaussian bell in the middle of the domain.</span>
<span class="sd">    plot_method=1 applies mesh function,</span>
<span class="sd">    =2 means surf, =3 means Matplotlib, =4 means mayavi,</span>
<span class="sd">    =0 means no plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Clean up plot files</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s1">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">Lx</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">exp</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gaussian peak at (Lx/2, Ly/2).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">Lx</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">Ly</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User action function for plotting.&quot;&quot;&quot;</span>
    <span class="o">...</span>

    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">dt</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span>
                     <span class="n">user_action</span><span class="o">=</span><span class="n">plot_u</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="matplotlib">
<h3>Matplotlib<a class="headerlink" href="#matplotlib" title="Permalink to this headline">¶</a></h3>
<p>We want to animate a 3D surface in Matplotlib, but this is a really
slow process and not recommended, so we consider Matplotlib not an
option as long as on-screen animation is desired. One can use the
recipes for single shots of <span class="math">\(u\)</span>, where it does produce high-quality
3D plots.</p>
</div>
<div class="section" id="gnuplot">
<span id="index-4"></span><h3>Gnuplot<a class="headerlink" href="#gnuplot" title="Permalink to this headline">¶</a></h3>
<p>Let us look at different ways for visualization. We import SciTools as
<code class="docutils literal"><span class="pre">st</span></code> and can access <code class="docutils literal"><span class="pre">st.mesh</span></code> and <code class="docutils literal"><span class="pre">st.surf</span></code> in Matplotlib or Gnuplot,
but this is not supported except for the Gnuplot package, where it
works really well (Figure <a class="reference internal" href="#wave2d3d-impl-viz-fig-gnuplot1"><span class="std std-ref">Snapshots of the surface plotted by Gnuplot</span></a>).  Then
we choose <code class="docutils literal"><span class="pre">plot_method=2</span></code> (or less relevant <code class="docutils literal"><span class="pre">plot_method=1</span></code>) and force
the backend for SciTools to be Gnuplot (if you have the C package
Gnuplot and the <code class="docutils literal"><span class="pre">Gnuplot.py</span></code> Python interface module installed):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python wave2D_u0.py --SCITOOLS_easyviz_backend gnuplot
</pre></div>
</div>
<p>It gives a nice visualization with lifted surface and contours beneath.
Figure <a class="reference internal" href="#wave2d3d-impl-viz-fig-gnuplot1"><span class="std std-ref">Snapshots of the surface plotted by Gnuplot</span></a> shows four plots of <span class="math">\(u\)</span>.</p>
<div class="figure" id="id2">
<span id="wave2d3d-impl-viz-fig-gnuplot1"></span><a class="reference internal image-reference" href="_images/wave2D_u0_gnuplot_gaussian.png"><img alt="_images/wave2D_u0_gnuplot_gaussian.png" src="_images/wave2D_u0_gnuplot_gaussian.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Snapshots of the surface plotted by Gnuplot</em></span></p>
</div>
<p>Video files can be made of the PNG frames:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; ffmpeg -i tmp_%04d.png -r 25 -vcodec flv movie.flv
Terminal&gt; ffmpeg -i tmp_%04d.png -r 25 -vcodec linx264 movie.mp4
Terminal&gt; ffmpeg -i tmp_%04d.png -r 25 -vcodec libvpx movie.webm
Terminal&gt; ffmpeg -i tmp_%04d.png -r 25 -vcodec libtheora movie.ogg
</pre></div>
</div>
<p>It is wise to use a high frame rate - a low one will just skip many
frames. There may also be considerable quality differences between the
different formats.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/gnuplot/wave2D_u0_gaussian/movie25.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-wave/gnuplot/wave2D_u0_gaussian/movie25.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-wave/gnuplot/wave2D_u0_gaussian/movie25.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script></div>
<div class="section" id="mayavi">
<span id="index-5"></span><h3>Mayavi<a class="headerlink" href="#mayavi" title="Permalink to this headline">¶</a></h3>
<p>The best option for doing visualization of 2D and 3D scalar and vector fields
in Python programs is Mayavi, which is an interface to the high-quality
package VTK in C++. There is good online documentation and also
an introduction in Chapter 5 of <a class="reference internal" href="._book027.html#ref06" id="id1">[Ref06]</a>.</p>
<p>To obtain Mayavi on Ubuntu platforms you can write</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>pip install mayavi --upgrade
</pre></div>
</div>
<p>For Mac OS X and Windows, we recommend using Anaconda.
To obtain Mayavi for Anaconda you can write</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>conda install mayavi
</pre></div>
</div>
<p>Mayavi has a MATLAB-like interface called <code class="docutils literal"><span class="pre">mlab</span></code>. We can do</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mayavi.mlab</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="c1"># or</span>
<span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
</pre></div>
</div>
<p>and have <code class="docutils literal"><span class="pre">plt</span></code> (as usual) or <code class="docutils literal"><span class="pre">mlab</span></code>
as a kind of MATLAB visualization access inside our program (just
more powerful and with higher visual quality).</p>
<p>The official documentation of the <code class="docutils literal"><span class="pre">mlab</span></code> module is provided in two
places, one for the <a class="reference external" href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_helper_functions.html">basic functionality</a>
and one for <a class="reference external" href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_other_functions.html">further functionality</a>.
Basic <a class="reference external" href="http://docs.enthought.com/mayavi/mayavi/auto/mlab_figure.html">figure
handling</a>
is very similar to the one we know from Matplotlib.  Just as for
Matplotlib, all plotting commands you do in <code class="docutils literal"><span class="pre">mlab</span></code> will go into the
same figure, until you manually change to a new figure.</p>
<p>Back to our application, the following code for the user action
function with plotting in Mayavi is relevant to add.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Top of the file</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">mayavi.mlab</span> <span class="kn">as</span> <span class="nn">mlab</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># We don&#39;t have mayavi</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">axes3d</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">u_surf</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User action function for plotting.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Works well with Gnuplot backend, not with Matplotlib</span>
            <span class="n">st</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">caxis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Works well with Gnuplot backend, not with Matplotlib</span>
            <span class="n">st</span><span class="o">.</span><span class="n">surfc</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">zlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="n">colorbar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">colormap</span><span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">hot</span><span class="p">(),</span> <span class="n">caxis</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                  <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">print</span> <span class="s1">&#39;Experimental 3D matplotlib...not recommended&#39;</span>
        <span class="k">elif</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Mayavi visualization</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">extent1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">surf</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span>
                          <span class="n">colormap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">,</span>
                          <span class="n">warp_scale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent1</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">7</span><span class="p">,</span> <span class="o">.</span><span class="mi">7</span><span class="p">,</span> <span class="o">.</span><span class="mi">7</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent1</span><span class="p">,</span>
                      <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">zlabel</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">x_axis_visibility</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                      <span class="n">z_axis_visibility</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">outline</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="o">.</span><span class="mi">7</span><span class="p">,</span> <span class="o">.</span><span class="mi">7</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent1</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">z</span><span class="o">=-</span><span class="mi">4</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.14</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">object</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
                          <span class="n">nb_labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nb_colors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">label_fmt</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gaussian t=</span><span class="si">%g</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">mlab</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">142</span><span class="p">,</span> <span class="o">-</span><span class="mi">72</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">camera</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">camera</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">yaw</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_method</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># pause between frames</span>
            <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;tmp_</span><span class="si">%04d</span><span class="s1">.png&#39;</span> <span class="o">%</span> <span class="n">n</span>
            <span class="k">if</span> <span class="n">plot_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">mlab</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  <span class="c1"># time consuming!</span>
            <span class="k">elif</span> <span class="n">plot_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  <span class="c1"># time consuming!</span>
</pre></div>
</div>
<p>This is a point to get started - visualization is as always a very
time-consuming and experimental discipline. With the PNG files we
can use <code class="docutils literal"><span class="pre">ffmpeg</span></code> to create videos.</p>
<div class="figure" id="id3">
<a class="reference internal image-reference" href="_images/mayavi2D_gaussian1.png"><img alt="_images/mayavi2D_gaussian1.png" src="_images/mayavi2D_gaussian1.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">Plot with Mayavi</span></p>
</div>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/mayavi/wave2D_u0_gaussian/movie.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-wave/mayavi/wave2D_u0_gaussian/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script></div>
</div>
</div>
<div class="section" id="exercises-4">
<h1>Exercises<a class="headerlink" href="#exercises-4" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-2-16-check-that-a-solution-fulfills-the-discrete-model">
<span id="wave-exer-quadratic-2d"></span><h2>Exercise 2.16: Check that a solution fulfills the discrete model<a class="headerlink" href="#exercise-2-16-check-that-a-solution-fulfills-the-discrete-model" title="Permalink to this headline">¶</a></h2>
<p>Carry out all mathematical details to show that
<a class="reference internal" href="#eq-wave2d3d-impl-verify-quadratic"><span class="std std-ref">(278)</span></a> is indeed a solution of the
discrete model for a 2D wave equation with <span class="math">\(u=0\)</span> on the boundary.
One must check the boundary conditions, the initial conditions,
the general discrete equation at a time level and the special
version of this equation for the first time level.
Filename: <code class="docutils literal"><span class="pre">check_quadratic_solution</span></code>.</p>
</div>
<div class="section" id="project-2-17-calculus-with-2d-mesh-functions">
<span id="wave-exer-mesh3d-calculus"></span><h2>Project 2.17: Calculus with 2D mesh functions<a class="headerlink" href="#project-2-17-calculus-with-2d-mesh-functions" title="Permalink to this headline">¶</a></h2>
<p>The goal of this project is to redo
<a class="reference internal" href="._book005.html#wave-exer-mesh1d-calculus"><span class="std std-ref">Project 2.6: Calculus with 1D mesh functions</span></a> with 2D
mesh functions (<span class="math">\(f_{i,j}\)</span>).</p>
<p><strong>Differentiation.</strong>
The differentiation results in a discrete gradient
function, which in the 2D case can be represented by a three-dimensional
array <code class="docutils literal"><span class="pre">df[d,i,j]</span></code> where <code class="docutils literal"><span class="pre">d</span></code> represents the direction of
the derivative, and <code class="docutils literal"><span class="pre">i,j</span></code> is a mesh point in 2D.
Use centered differences for
the derivative at inner points and one-sided forward or backward
differences at the boundary points. Construct unit tests and
write a corresponding test function.</p>
<p><strong>Integration.</strong>
The integral of a 2D mesh function <span class="math">\(f_{i,j}\)</span> is defined as</p>
<div class="math">
\[F_{i,j} = \int_{y_0}^{y_j} \int_{x_0}^{x_i} f(x,y)dxdy,\]</div>
<p>where <span class="math">\(f(x,y)\)</span> is a function that takes on the values of the
discrete mesh function <span class="math">\(f_{i,j}\)</span> at the mesh points, but can also
be evaluated in between the mesh points. The particular variation
between mesh points can be taken as bilinear, but this is not
important as we will use a product Trapezoidal rule to approximate
the integral over a cell in the mesh and then we only need to
evaluate <span class="math">\(f(x,y)\)</span> at the mesh points.</p>
<p>Suppose <span class="math">\(F_{i,j}\)</span> is computed. The calculation of <span class="math">\(F_{i+1,j}\)</span>
is then</p>
<div class="math">
\[\begin{split}\begin{align*}
F_{i+1,j} &amp;= F_{i,j} + \int_{x_i}^{x_{i+1}}\int_{y_0}^{y_j} f(x,y)dydx\\
&amp; \approx \Delta x \frac{1}{2}\left(
\int_{y_0}^{y_j} f(x_{i},y)dy
+ \int_{y_0}^{y_j} f(x_{i+1},y)dy\right)
\end{align*}\end{split}\]</div>
<p>The integrals in the <span class="math">\(y\)</span> direction can be approximated by a Trapezoidal
rule. A similar idea can be used to compute <span class="math">\(F_{i,j+1}\)</span>. Thereafter,
<span class="math">\(F_{i+1,j+1}\)</span> can be computed by adding the integral over the final
corner cell to <span class="math">\(F_{i+1,j} + F_{i,j+1} - F_{i,j}\)</span>. Carry out the
details of these computations and implement a function that can
return <span class="math">\(F_{i,j}\)</span> for all mesh indices <span class="math">\(i\)</span> and <span class="math">\(j\)</span>. Use the
fact that the Trapezoidal rule is exact for linear functions and
write a test function.
Filename: <code class="docutils literal"><span class="pre">mesh_calculus_2D</span></code>.</p>
</div>
<div class="section" id="exercise-2-18-implement-neumann-conditions-in-2d">
<span id="wave-app-exer-wave2d-neumann"></span><h2>Exercise 2.18: Implement Neumann conditions in 2D<a class="headerlink" href="#exercise-2-18-implement-neumann-conditions-in-2d" title="Permalink to this headline">¶</a></h2>
<p>Modify the <a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave2D_u0/wave2D_u0.py">wave2D_u0.py</a>
program, which solves the 2D wave equation <span class="math">\(u_{tt}=c^2(u_{xx}+u_{yy})\)</span>
with constant wave velocity <span class="math">\(c\)</span> and <span class="math">\(u=0\)</span> on the boundary, to have
Neumann boundary conditions: <span class="math">\(\partial u/\partial n=0\)</span>.
Include both scalar code (for debugging and reference) and
vectorized code (for speed).</p>
<p>To test the code, use <span class="math">\(u=1.2\)</span> as solution (<span class="math">\(I(x,y)=1.2\)</span>, <span class="math">\(V=f=0\)</span>, and
<span class="math">\(c\)</span> arbitrary), which should be exactly reproduced with any mesh
as long as the stability criterion is satisfied.
Another test is to use the plug-shaped pulse
in the <code class="docutils literal"><span class="pre">pulse</span></code> function from the section <a class="reference internal" href="._book006.html#wave-pde2-software"><span class="std std-ref">Building a general 1D wave equation solver</span></a>
and the <a class="reference external" href="http://tinyurl.com/nu656p2/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
program. This pulse
is exactly propagated in 1D if <span class="math">\(c\Delta t/\Delta x=1\)</span>. Check
that also the 2D program can propagate this pulse exactly
in <span class="math">\(x\)</span> direction (<span class="math">\(c\Delta t/\Delta x=1\)</span>, <span class="math">\(\Delta y\)</span> arbitrary)
and <span class="math">\(y\)</span> direction (<span class="math">\(c\Delta t/\Delta y=1\)</span>, <span class="math">\(\Delta x\)</span> arbitrary).
Filename: <code class="docutils literal"><span class="pre">wave2D_dn</span></code>.</p>
</div>
<div class="section" id="exercise-2-19-test-the-efficiency-of-compiled-loops-in-3d">
<span id="wave-exer-3d-f77-cy-efficiency"></span><h2>Exercise 2.19: Test the efficiency of compiled loops in 3D<a class="headerlink" href="#exercise-2-19-test-the-efficiency-of-compiled-loops-in-3d" title="Permalink to this headline">¶</a></h2>
<p>Extend the <code class="docutils literal"><span class="pre">wave2D_u0.py</span></code> code and the Cython, Fortran, and C versions to 3D.
Set up an efficiency experiment to determine the relative efficiency of
pure scalar Python code, vectorized code, Cython-compiled loops,
Fortran-compiled loops, and C-compiled loops.
Normalize the CPU time for each mesh by the fastest version.
Filename: <code class="docutils literal"><span class="pre">wave3D_u0</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference methods for 2D and 3D wave equations</a><ul>
<li><a class="reference internal" href="#multi-dimensional-wave-equations">Multi-dimensional wave equations</a></li>
<li><a class="reference internal" href="#mesh">Mesh</a></li>
<li><a class="reference internal" href="#discretization-1">Discretization</a><ul>
<li><a class="reference internal" href="#discretizing-the-pdes">Discretizing the PDEs</a></li>
<li><a class="reference internal" href="#handling-boundary-conditions-where-is-known">Handling boundary conditions where <span class="math">\(u\)</span> is known</a></li>
<li><a class="reference internal" href="#discretizing-the-neumann-condition">Discretizing the Neumann condition</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-6">Implementation</a><ul>
<li><a class="reference internal" href="#scalar-computations">Scalar computations</a><ul>
<li><a class="reference internal" href="#domain-and-mesh">Domain and mesh</a></li>
<li><a class="reference internal" href="#solution-arrays">Solution arrays</a></li>
<li><a class="reference internal" href="#index-sets">Index sets</a></li>
<li><a class="reference internal" href="#computing-the-solution">Computing the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vectorized-computations">Vectorized computations</a></li>
<li><a class="reference internal" href="#verification-6">Verification</a><ul>
<li><a class="reference internal" href="#testing-a-quadratic-solution">Testing a quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization-2">Visualization</a><ul>
<li><a class="reference internal" href="#matplotlib">Matplotlib</a></li>
<li><a class="reference internal" href="#gnuplot">Gnuplot</a></li>
<li><a class="reference internal" href="#mayavi">Mayavi</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-4">Exercises</a><ul>
<li><a class="reference internal" href="#exercise-2-16-check-that-a-solution-fulfills-the-discrete-model">Exercise 2.16: Check that a solution fulfills the discrete model</a></li>
<li><a class="reference internal" href="#project-2-17-calculus-with-2d-mesh-functions">Project 2.17: Calculus with 2D mesh functions</a></li>
<li><a class="reference internal" href="#exercise-2-18-implement-neumann-conditions-in-2d">Exercise 2.18: Implement Neumann conditions in 2D</a></li>
<li><a class="reference internal" href="#exercise-2-19-test-the-efficiency-of-compiled-loops-in-3d">Exercise 2.19: Test the efficiency of compiled loops in 3D</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book007.html"
                        title="previous chapter">Analysis of the difference equations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book009.html"
                        title="next chapter">Applications of wave equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book008.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book009.html" title="Applications of wave equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book007.html" title="Analysis of the difference equations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>