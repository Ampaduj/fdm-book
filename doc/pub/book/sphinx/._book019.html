
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exercises</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with PDEs" href="index.html" />
    <link rel="next" title="Appendix: Useful formulas" href="._book020.html" />
    <link rel="prev" title="Operator splitting methods" href="._book018.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book020.html" title="Appendix: Useful formulas"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book018.html" title="Operator splitting methods"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="exercises-9">
<span id="nonlin-exer"></span><h1>Exercises<a class="headerlink" href="#exercises-9" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-5-1-determine-if-equations-are-nonlinear-or-not">
<span id="nonlin-exer-lin-vs-nonlin"></span><h2>Problem 5.1: Determine if equations are nonlinear or not<a class="headerlink" href="#problem-5-1-determine-if-equations-are-nonlinear-or-not" title="Permalink to this headline">¶</a></h2>
<p>Classify each term in the following equations as linear or nonlinear.
Assume that <span class="math">\(u\)</span>, <span class="math">\(\boldsymbol{u}\)</span>, and <span class="math">\(p\)</span> are unknown functions and that
all other symbols are known quantities.</p>
<ol class="arabic simple">
<li><span class="math">\(mu^{\prime\prime} + \beta |u^{\prime}|u^{\prime} + cu = F(t)\)</span></li>
<li><span class="math">\(u_t = {\alpha} u_{xx}\)</span></li>
<li><span class="math">\(u_{tt} = c^2\nabla^2 u\)</span></li>
<li><span class="math">\(u_t = \nabla\cdot({\alpha}(u)\nabla u) + f(x,y)\)</span></li>
<li><span class="math">\(u_t + f(u)_x = 0\)</span></li>
<li><span class="math">\(\boldsymbol{u}_t + \boldsymbol{u}\cdot\nabla \boldsymbol{u} = -\nabla p + r\nabla^2\boldsymbol{u}\)</span>, <span class="math">\(\nabla\cdot\boldsymbol{u} = 0\)</span>
(<span class="math">\(\boldsymbol{u}\)</span> is a vector field)</li>
<li><span class="math">\(u^{\prime} = f(u,t)\)</span></li>
<li><span class="math">\(\nabla^2 u = \lambda e^u\)</span></li>
</ol>
<p>Filename: <code class="docutils literal"><span class="pre">nonlinear_vs_linear</span></code>.</p>
</div>
<div class="section" id="problem-5-2-derive-and-investigate-a-generalized-logistic-model">
<span id="nonlin-exer-logistic-gen"></span><h2>Problem 5.2: Derive and investigate a generalized logistic model<a class="headerlink" href="#problem-5-2-derive-and-investigate-a-generalized-logistic-model" title="Permalink to this headline">¶</a></h2>
<p>The logistic model for population growth is derived by assuming
a nonlinear growth rate,</p>
<div class="math" id="eq-nonlin-exer-logistic-gen-eq">
\[\tag{601}
u^{\prime} = a(u)u,\quad u(0)=I,\]</div>
<p>and the logistic model arises from the simplest possible choice of
<span class="math">\(a(u)\)</span>: <span class="math">\(r(u)=\varrho(1 - u/M)\)</span>, where <span class="math">\(M\)</span> is the maximum value of <span class="math">\(u\)</span> that
the environment can sustain, and <span class="math">\(\varrho\)</span> is the growth under
unlimited access to resources (as in the beginning when <span class="math">\(u\)</span> is small).
The idea is that <span class="math">\(a(u)\sim\varrho\)</span> when <span class="math">\(u\)</span> is small and that
<span class="math">\(a(t)\rightarrow 0\)</span> as <span class="math">\(u\rightarrow M\)</span>.</p>
<p>An <span class="math">\(a(u)\)</span> that generalizes the linear choice is the polynomial form</p>
<div class="math" id="eq-nonlin-exer-logistic-gen-r1">
\[\tag{602}
a(u) = \varrho(1-u/M)^p,\]</div>
<p>where <span class="math">\(p&gt;0\)</span> is some real number.</p>
<p><strong>a)</strong>
Formulate a Forward Euler, Backward Euler, and a Crank-Nicolson
scheme for <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-eq"><span class="std std-ref">(601)</span></a>.</p>
<p><strong>Hint.</strong>
Use a geometric mean approximation in the Crank-Nicolson scheme:
<span class="math">\([a(u)u]^{n+1/2}\approx a(u^n)u^{n+1}\)</span>.</p>
<p><strong>b)</strong>
Formulate Picard and Newton iteration for the Backward Euler scheme in a).</p>
<p><strong>c)</strong>
Implement the numerical solution methods from a) and b).
Use <a class="reference external" href="http://tinyurl.com/nu656p2/nonlin/logistic.py">logistic.py</a> to compare the case
<span class="math">\(p=1\)</span> and the choice <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-r1"><span class="std std-ref">(602)</span></a>.</p>
<p><strong>d)</strong>
Implement unit tests that check the asymptotic limit of the solutions:
<span class="math">\(u\rightarrow M\)</span> as <span class="math">\(t\rightarrow\infty\)</span>.</p>
<p><strong>Hint.</strong>
You need to experiment to find what &#8220;infinite time&#8221; is
(increases substantially with <span class="math">\(p\)</span>) and what the
appropriate tolerance is for testing the asymptotic limit.</p>
<p><strong>e)</strong>
Perform experiments with Newton and Picard iteration for
the model <a class="reference internal" href="#eq-nonlin-exer-logistic-gen-r1"><span class="std std-ref">(602)</span></a>.
See how sensitive
the number of iterations is to <span class="math">\(\Delta t\)</span> and <span class="math">\(p\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">logistic_p</span></code>.</p>
</div>
<div class="section" id="problem-5-3-experience-the-behavior-of-newton-s-method">
<span id="nonlin-exer-newton-problems1"></span><h2>Problem 5.3: Experience the behavior of Newton&#8217;s method<a class="headerlink" href="#problem-5-3-experience-the-behavior-of-newton-s-method" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/nu656p2/nonlin/Newton_demo.py">Newton_demo.py</a> illustrates
graphically each step in Newton&#8217;s method and is run like</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python Newton_demo.py f dfdx x0 xmin xmax
</pre></div>
</div>
<p>Use this program to investigate potential
problems with Newton&#8217;s method when solving <span class="math">\(e^{-0.5x^2}\cos (\pi x)=0\)</span>.
Try a starting point <span class="math">\(x_0=0.8\)</span> and <span class="math">\(x_0=0.85\)</span> and watch the different
behavior. Just run</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt;  python Newton_demo.py &#39;0.2 + exp(-0.5*x**2)*cos(pi*x)&#39; \
           &#39;-x*exp(-x**2)*cos(pi*x) - pi*exp(-x**2)*sin(pi*x)&#39; \
           0.85 -3 3
</pre></div>
</div>
<p>and repeat with 0.85 replaced by 0.8.</p>
</div>
<div class="section" id="exercise-5-4-compute-the-jacobian-of-a-system">
<span id="nonlin-exer-vib-jacobian"></span><h2>Exercise 5.4: Compute the Jacobian of a <span class="math">\(2\times 2\)</span> system<a class="headerlink" href="#exercise-5-4-compute-the-jacobian-of-a-system" title="Permalink to this headline">¶</a></h2>
<p>Write up the system <a class="reference internal" href="._book013.html#eq-nonlin-ode-generic-sys-pendulum-u0"><span class="std std-ref">(537)</span></a>-<a class="reference internal" href="._book013.html#eq-nonlin-ode-generic-sys-pendulum-u1"><span class="std std-ref">(538)</span></a> in the form <span class="math">\(F(u)=0\)</span>, <span class="math">\(F=(F_0,F_1)\)</span>, <span class="math">\(u=(u_0,u_1)\)</span>,
and compute the Jacobian <span class="math">\(J_{i,j}=\partial F_i/\partial u_j\)</span>.</p>
</div>
<div class="section" id="problem-5-5-solve-nonlinear-equations-arising-from-a-vibration-ode">
<span id="nonlin-exer-vib-geometric-mean"></span><h2>Problem 5.5: Solve nonlinear equations arising from a vibration ODE<a class="headerlink" href="#problem-5-5-solve-nonlinear-equations-arising-from-a-vibration-ode" title="Permalink to this headline">¶</a></h2>
<p>Consider a nonlinear vibration problem</p>
<div class="math" id="eq-auto252">
\[\tag{603}
mu^{\prime\prime} + bu^{\prime}|u^{\prime}| + s(u) = F(t),\]</div>
<p>where <span class="math">\(m&gt;0\)</span> is a constant, <span class="math">\(b\geq 0\)</span> is a constant, <span class="math">\(s(u)\)</span> a possibly
nonlinear function of <span class="math">\(u\)</span>, and <span class="math">\(F(t)\)</span> is a prescribed function. Such
models arise from Newton&#8217;s second law of motion in mechanical
vibration problems where <span class="math">\(s(u)\)</span> is a spring or restoring force,
<span class="math">\(mu^{\prime\prime}\)</span> is mass times acceleration, and
<span class="math">\(bu^{\prime}|u^{\prime}|\)</span> models water or air drag.</p>
<p><strong>a)</strong>
Rewrite the equation for <span class="math">\(u\)</span> as a system of two first-order ODEs, and
discretize this system by a Crank-Nicolson (centered difference)
method. With <span class="math">\(v=u^\prime\)</span>, we get a nonlinear term
<span class="math">\(v^{n+\frac{1}{2}}|v^{n+\frac{1}{2}}|\)</span>. Use a geometric
average for <span class="math">\(v^{n+\frac{1}{2}}\)</span>.</p>
<p><strong>b)</strong>
Formulate a Picard iteration method to solve the system of nonlinear
algebraic equations.</p>
<p><strong>c)</strong>
Explain how to apply Newton&#8217;s method to solve the nonlinear equations
at each time level. Derive expressions for the Jacobian and the
right-hand side in each Newton iteration.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_vib</span></code>.</p>
</div>
<div class="section" id="exercise-5-6-find-the-truncation-error-of-arithmetic-mean-of-products">
<span id="nonlin-exer-products-arith-mean"></span><h2>Exercise 5.6: Find the truncation error of arithmetic mean of products<a class="headerlink" href="#exercise-5-6-find-the-truncation-error-of-arithmetic-mean-of-products" title="Permalink to this headline">¶</a></h2>
<p>In the section <a class="reference internal" href="._book015.html#nonlin-pdelevel-picard-cn"><span class="std std-ref">Crank-Nicolson discretization</span></a> we introduce alternative
arithmetic means of a product. Say the product is <span class="math">\(P(t)Q(t)\)</span> evaluated
at <span class="math">\(t=t_{n+\frac{1}{2}}\)</span>. The exact value is</p>
<div class="math">
\[[PQ]^{n+\frac{1}{2}} = P^{n+\frac{1}{2}}Q^{n+\frac{1}{2}}\]</div>
<p>There are two obvious candidates for evaluating <span class="math">\([PQ]^{n+\frac{1}{2}}\)</span>
as a mean of values of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> at <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>. Either
we can take the arithmetic mean of each factor <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>,</p>
<div class="math" id="eq-nonlin-exer-products-arith-mean-f">
\[\tag{604}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^n + P^{n+1})\frac{1}{2}(Q^n + Q^{n+1}),\]</div>
<p>or we can take the arithmetic mean of the product <span class="math">\(PQ\)</span>:</p>
<div class="math" id="eq-nonlin-exer-products-arith-mean-p">
\[\tag{605}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^nQ^n + P^{n+1}Q^{n+1}){\thinspace .}\]</div>
<p>The arithmetic average
of <span class="math">\(P(t_{n+\frac{1}{2}})\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>:</p>
<div class="math">
\[P(t_{n+\frac{1}{2}}) = \frac{1}{2}(P^n + P^{n+1}) +{\mathcal{O}(\Delta t^2)}{\thinspace .}\]</div>
<p>A fundamental question is whether <a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(604)</span></a>
and <a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(605)</span></a> have different
orders of accuracy in <span class="math">\(\Delta t = t_{n+1}-t_n\)</span>. To investigate
this question, expand quantities at <span class="math">\(t_{n+1}\)</span> and <span class="math">\(t_n\)</span> in
Taylor series around <span class="math">\(t_{n+\frac{1}{2}}\)</span>, and subtract the true
value <span class="math">\([PQ]^{n+\frac{1}{2}}\)</span> from the approximations
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(604)</span></a> and
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(605)</span></a> to see what the
order of the error terms are.</p>
<p><strong>Hint.</strong>
You may explore <code class="docutils literal"><span class="pre">sympy</span></code> for carrying out the tedious calculations.
A general Taylor series expansion of <span class="math">\(P(t+\frac{1}{2}\Delta t)\)</span> around <span class="math">\(t\)</span>
involving just a general function <span class="math">\(P(t)\)</span> can be
created as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t dt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">P(0) + t*Subs(Derivative(P(_x), _x), (_x,), (0,)) +</span>
<span class="go">t**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/2 +</span>
<span class="go">t**3*Subs(Derivative(P(_x), _x, _x, _x), (_x,), (0,))/6 + O(t**4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P_p</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P_p</span>
<span class="go">P(0) + dt*Subs(Derivative(P(_x), _x), (_x,), (0,))/2 +</span>
<span class="go">dt**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/8 +</span>
<span class="go">dt**3*Subs(Derivative(P(_x), _x, _x, _x), (_x,), (0,))/48 + O(dt**4)</span>
</pre></div>
</div>
<p>The error of the arithmetic mean, <span class="math">\(\frac{1}{2}(P(-\frac{1}{2}\Delta t)
+ P(-\frac{1}{2}\Delta t))\)</span> for <span class="math">\(t=0\)</span> is then</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P_m</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">P_m</span> <span class="o">+</span> <span class="n">P_p</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span>
<span class="go">dt**2*Subs(Derivative(P(_x), _x, _x), (_x,), (0,))/8 + O(dt**4)</span>
</pre></div>
</div>
<p>Use these examples to investigate the error of
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-f"><span class="std std-ref">(604)</span></a> and
<a class="reference internal" href="#eq-nonlin-exer-products-arith-mean-p"><span class="std std-ref">(605)</span></a> for <span class="math">\(n=0\)</span>. (Choosing <span class="math">\(n=0\)</span>
is necessary for not making the expressions too complicated for <code class="docutils literal"><span class="pre">sympy</span></code>,
but there is of course no lack of generality by using <span class="math">\(n=0\)</span> rather
than an arbitrary <span class="math">\(n\)</span> - the main point is the product and addition
of Taylor series.)</p>
<p>Filename: <code class="docutils literal"><span class="pre">product_arith_mean</span></code>.</p>
</div>
<div class="section" id="problem-5-7-newton-s-method-for-linear-problems">
<span id="nonlin-exer-newton-linear"></span><h2>Problem 5.7: Newton&#8217;s method for linear problems<a class="headerlink" href="#problem-5-7-newton-s-method-for-linear-problems" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have a linear system <span class="math">\(F(u) = Au- b=0\)</span>. Apply Newton&#8217;s method
to this system, and show that the method converges in one iteration.
Filename: <code class="docutils literal"><span class="pre">Newton_linear</span></code>.</p>
</div>
<div class="section" id="problem-5-8-discretize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-fem"></span><h2>Problem 5.8: Discretize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#problem-5-8-discretize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We consider the problem</p>
<div class="math" id="eq-nonlin-exer-1d-1pu2-fem-pde">
\[\tag{606}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p>Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-fem-pde"><span class="std std-ref">(606)</span></a> by a centered
finite difference method on a uniform mesh.
Filename: <code class="docutils literal"><span class="pre">nonlin_1D_coeff_discretize</span></code>.</p>
</div>
<div class="section" id="problem-5-9-linearize-a-1d-problem-with-a-nonlinear-coefficient">
<span id="nonlin-exer-1d-1pu2-picardnewton"></span><h2>Problem 5.9: Linearize a 1D problem with a nonlinear coefficient<a class="headerlink" href="#problem-5-9-linearize-a-1d-problem-with-a-nonlinear-coefficient" title="Permalink to this headline">¶</a></h2>
<p>We have a two-point boundary value problem</p>
<div class="math" id="eq-nonlin-exer-1d-1pu2-picardnewton-pde">
\[\tag{607}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0{\thinspace .}\]</div>
<p><strong>a)</strong>
Construct a Picard iteration method for <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(607)</span></a>
without discretizing in space.</p>
<p><strong>b)</strong>
Apply Newton&#8217;s method to <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(607)</span></a>
without discretizing in space.</p>
<p><strong>c)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(607)</span></a> by a centered finite
difference scheme. Construct a Picard method for the resulting
system of nonlinear algebraic equations.</p>
<p><strong>d)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-1pu2-picardnewton-pde"><span class="std std-ref">(607)</span></a> by a centered finite
difference scheme. Define the system of nonlinear algebraic equations,
calculate the Jacobian, and set up Newton&#8217;s method for solving the system.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_coeff_linearize</span></code>.</p>
</div>
<div class="section" id="problem-5-10-finite-differences-for-the-1d-bratu-problem">
<span id="nonlin-exer-1d-fu-discretize-fd"></span><h2>Problem 5.10: Finite differences for the 1D Bratu problem<a class="headerlink" href="#problem-5-10-finite-differences-for-the-1d-bratu-problem" title="Permalink to this headline">¶</a></h2>
<p>We address the so-called Bratu problem</p>
<div class="math" id="eq-nonlin-exer-1d-fu-discretize-fd-pde">
\[\tag{608}
u^{\prime\prime} + \lambda e^u=0,\quad x\in (0,1),\quad u(0)=u(1)=0,\]</div>
<p>where <span class="math">\(\lambda\)</span> is a given parameter and <span class="math">\(u\)</span> is a function of <span class="math">\(x\)</span>.
This is a widely used model problem for studying numerical
methods for nonlinear differential equations.
The problem <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(608)</span></a> has an
exact solution</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x) = -2\ln\left(\frac{\cosh((x-\frac{1}{2})\theta/2)}{\cosh(\theta/4)}\right),\]</div>
<p>where <span class="math">\(\theta\)</span> solves</p>
<div class="math">
\[\theta = \sqrt{2\lambda}\cosh(\theta/4){\thinspace .}\]</div>
<p>There are two solutions of <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(608)</span></a> for
<span class="math">\(0&lt;\lambda &lt;\lambda_c\)</span> and no solution for <span class="math">\(\lambda &gt;\lambda_c\)</span>.
For <span class="math">\(\lambda = \lambda_c\)</span> there is one unique solution. The critical
value <span class="math">\(\lambda_c\)</span> solves</p>
<div class="math">
\[1 = \sqrt{2\lambda_c}\frac{1}{4}\sinh(\theta(\lambda_c)/4){\thinspace .}\]</div>
<p>A numerical value is <span class="math">\(\lambda_c = 3.513830719\)</span>.</p>
<p><strong>a)</strong>
Discretize <a class="reference internal" href="#eq-nonlin-exer-1d-fu-discretize-fd-pde"><span class="std std-ref">(608)</span></a> by a
centered finite difference method.</p>
<p><strong>b)</strong>
Set up the nonlinear equations <span class="math">\(F_i(u_0,u_1,\ldots,u_{N_x})=0\)</span>
from a). Calculate the associated Jacobian.</p>
<p><strong>c)</strong>
Implement a solver that can compute <span class="math">\(u(x)\)</span> using Newton&#8217;s method.
Plot the error as a function of <span class="math">\(x\)</span> in each iteration.</p>
<p><strong>d)</strong>
Investigate whether Newton&#8217;s method gives second-order convergence
by computing
<span class="math">\(|| {u_{\small\mbox{e}}} - u||/||{u_{\small\mbox{e}}} - u^{-}||^2\)</span>
in each iteration, where <span class="math">\(u\)</span> is solution in the current iteration and
<span class="math">\(u^{-}\)</span> is the solution in the previous iteration.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_Bratu_fd</span></code>.</p>
</div>
<div class="section" id="problem-5-11-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences">
<span id="nonlin-exer-1d-heat-nonlinear-fdm"></span><h2>Problem 5.11: Discretize a nonlinear 1D heat conduction PDE by finite differences<a class="headerlink" href="#problem-5-11-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>We address the 1D heat conduction PDE</p>
<div class="math">
\[\varrho c(T) T_t = (k(T)T_x)_x,\]</div>
<p>for <span class="math">\(x\in [0,L]\)</span>,
where <span class="math">\(\varrho\)</span> is the density of the solid material, <span class="math">\(c(T)\)</span> is
the heat capacity, <span class="math">\(T\)</span> is the temperature, and <span class="math">\(k(T)\)</span> is the
heat conduction coefficient. <span class="math">\(T(x,0)=I(x)\)</span>, and ends are
subject to a cooling law:</p>
<div class="math">
\[k(T)T_x|_{x=0} = h(T)(T-T_s),\quad -k(T)T_x|_{x=L}=h(T)(T-T_s),\]</div>
<p>where <span class="math">\(h(T)\)</span> is a heat transfer coefficient and <span class="math">\(T_s\)</span> is the
given surrounding temperature.</p>
<p><strong>a)</strong>
Discretize this PDE in time using either a
Backward Euler or Crank-Nicolson scheme.</p>
<p><strong>b)</strong>
Formulate a Picard iteration method for the time-discrete problem
(i.e., an iteration method before discretizing in space).</p>
<p><strong>c)</strong>
Formulate a Newton method for the time-discrete problem in b).</p>
<p><strong>d)</strong>
Discretize the PDE by a finite difference method in space.
Derive the matrix and right-hand side of a Picard iteration method applied
to the space-time discretized PDE.</p>
<p><strong>e)</strong>
Derive the matrix and right-hand side of a Newton method applied
to the discretized PDE in d).</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_1D_heat_FD</span></code>.</p>
</div>
<div class="section" id="problem-5-12-differentiate-a-highly-nonlinear-term">
<span id="nonlin-exer-grad-pow-term"></span><h2>Problem 5.12: Differentiate a highly nonlinear term<a class="headerlink" href="#problem-5-12-differentiate-a-highly-nonlinear-term" title="Permalink to this headline">¶</a></h2>
<p>The operator <span class="math">\(\nabla\cdot({\alpha}(u)\nabla u)\)</span> with
<span class="math">\({\alpha}(u) = |\nabla u|^q\)</span> appears in several physical problems,
especially flow of Non-Newtonian fluids. The expression <span class="math">\(|\nabla u|\)</span>
is defined as the Euclidean norm of a vector:
<span class="math">\(|\nabla u|^2 = \nabla u \cdot \nabla u\)</span>.
In a Newton method one
has to carry out the differentiation <span class="math">\(\partial{\alpha}(u)/\partial c_j\)</span>,
for <span class="math">\(u=\sum_kc_k{\psi}_k\)</span>. Show that</p>
<div class="math">
\[{\partial\over\partial u_j} |\nabla u|^q =
q|\nabla  u|^{q-2}\nabla u\cdot
\nabla{\psi}_j{\thinspace .}\]</div>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_differentiate</span></code>.</p>
</div>
<div class="section" id="exercise-5-13-crank-nicolson-for-a-nonlinear-3d-diffusion-equation">
<span id="nonlin-exer-2d-heat-nonlinear-fd"></span><h2>Exercise 5.13: Crank-Nicolson for a nonlinear 3D diffusion equation<a class="headerlink" href="#exercise-5-13-crank-nicolson-for-a-nonlinear-3d-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>Redo the section <a class="reference internal" href="._book017.html#nonlin-alglevel-dd-fd"><span class="std std-ref">Finite difference discretization</span></a> when a Crank-Nicolson scheme
is used to discretize the equations in time and the problem is
formulated for three spatial dimensions.</p>
<p><strong>Hint.</strong>
Express the Jacobian as <span class="math">\(J_{i,j,k,r,s,t} = \partial F_{i,j,k}/\partial u_{r,s,t}\)</span> and observe, as in the 2D case, that <span class="math">\(J_{i,j,k,r,s,t}\)</span> is very sparse:
<span class="math">\(J_{i,j,k,r,s,t}\neq 0\)</span> only for <span class="math">\(r=i\pm i\)</span>, <span class="math">\(s=j\pm 1\)</span>, and <span class="math">\(t=k\pm 1\)</span>
as well as <span class="math">\(r=i\)</span>, <span class="math">\(s=j\)</span>, and <span class="math">\(t=k\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_heat_FD_CN_2D</span></code>.</p>
</div>
<div class="section" id="problem-5-14-find-the-sparsity-of-the-jacobian">
<span id="nonlin-exer-sparsity-jacobian"></span><h2>Problem 5.14: Find the sparsity of the Jacobian<a class="headerlink" href="#problem-5-14-find-the-sparsity-of-the-jacobian" title="Permalink to this headline">¶</a></h2>
<p>Consider a typical nonlinear Laplace term like
<span class="math">\(\nabla\cdot{\alpha}(u)\nabla u\)</span> discretized by centered finite differences.
Explain why the Jacobian corresponding to this term has the same
sparsity pattern as the matrix associated with the corresponding linear
term <span class="math">\({\alpha}\nabla^2 u\)</span>.</p>
<p><strong>Hint.</strong>
Set up the unknowns that enter the difference equation at a
point <span class="math">\((i,j)\)</span> in 2D or <span class="math">\((i,j,k)\)</span> in 3D, and identify the
nonzero entries of the Jacobian that can arise from such a type
of difference equation.</p>
<p>Filename: <code class="docutils literal"><span class="pre">nonlin_sparsity_Jacobian</span></code>.</p>
</div>
<div class="section" id="problem-5-15-investigate-a-1d-problem-with-a-continuation-method">
<span id="nonlin-exer-continuation-1dnnflow"></span><h2>Problem 5.15: Investigate a 1D problem with a continuation method<a class="headerlink" href="#problem-5-15-investigate-a-1d-problem-with-a-continuation-method" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Flow of a pseudo-plastic power-law fluid between two flat plates can be
modeled by</p>
<div class="math">
\[\frac{d}{dx}\left(\mu_0\left\vert\frac{du}{dx}\right\vert^{n-1}
\frac{du}{dx}\right) = -\beta,\quad u^{\prime}(0)=0,\ u(H) = 0,\]</div>
<p>where <span class="math">\(\beta&gt;0\)</span> and <span class="math">\(\mu_0&gt;0\)</span> are constants.
A target value of <span class="math">\(n\)</span> may be <span class="math">\(n=0.2\)</span>.</p>
<p><strong>a)</strong>
Formulate a Picard iteration method directly for the differential
equation problem.</p>
<p><strong>b)</strong>
Perform a finite difference discretization of the problem in
each Picard iteration. Implement a solver that can compute <span class="math">\(u\)</span>
on a mesh. Verify that the solver gives an exact solution for <span class="math">\(n=1\)</span>
on a uniform mesh regardless of the cell size.</p>
<p><strong>c)</strong>
Given a sequence of decreasing <span class="math">\(n\)</span> values, solve the problem for each
<span class="math">\(n\)</span> using the solution for the previous <span class="math">\(n\)</span> as initial guess for
the Picard iteration. This is called a continuation method.
Experiment with <span class="math">\(n=(1,0.6,0.2)\)</span> and <span class="math">\(n=(1,0.9,0.8,\ldots,0.2)\)</span>
and make a table of the number of Picard iterations versus <span class="math">\(n\)</span>.</p>
<p><strong>d)</strong>
Derive a Newton method at the differential equation level and
discretize the resulting linear equations in each Newton iteration
with the finite difference method.</p>
<p><strong>e)</strong>
Investigate if Newton&#8217;s method has better convergence properties than
Picard iteration, both in combination with a continuation method.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Exercises</a><ul>
<li><a class="reference internal" href="#problem-5-1-determine-if-equations-are-nonlinear-or-not">Problem 5.1: Determine if equations are nonlinear or not</a></li>
<li><a class="reference internal" href="#problem-5-2-derive-and-investigate-a-generalized-logistic-model">Problem 5.2: Derive and investigate a generalized logistic model</a></li>
<li><a class="reference internal" href="#problem-5-3-experience-the-behavior-of-newton-s-method">Problem 5.3: Experience the behavior of Newton&#8217;s method</a></li>
<li><a class="reference internal" href="#exercise-5-4-compute-the-jacobian-of-a-system">Exercise 5.4: Compute the Jacobian of a <span class="math">\(2\times 2\)</span> system</a></li>
<li><a class="reference internal" href="#problem-5-5-solve-nonlinear-equations-arising-from-a-vibration-ode">Problem 5.5: Solve nonlinear equations arising from a vibration ODE</a></li>
<li><a class="reference internal" href="#exercise-5-6-find-the-truncation-error-of-arithmetic-mean-of-products">Exercise 5.6: Find the truncation error of arithmetic mean of products</a></li>
<li><a class="reference internal" href="#problem-5-7-newton-s-method-for-linear-problems">Problem 5.7: Newton&#8217;s method for linear problems</a></li>
<li><a class="reference internal" href="#problem-5-8-discretize-a-1d-problem-with-a-nonlinear-coefficient">Problem 5.8: Discretize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#problem-5-9-linearize-a-1d-problem-with-a-nonlinear-coefficient">Problem 5.9: Linearize a 1D problem with a nonlinear coefficient</a></li>
<li><a class="reference internal" href="#problem-5-10-finite-differences-for-the-1d-bratu-problem">Problem 5.10: Finite differences for the 1D Bratu problem</a></li>
<li><a class="reference internal" href="#problem-5-11-discretize-a-nonlinear-1d-heat-conduction-pde-by-finite-differences">Problem 5.11: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
<li><a class="reference internal" href="#problem-5-12-differentiate-a-highly-nonlinear-term">Problem 5.12: Differentiate a highly nonlinear term</a></li>
<li><a class="reference internal" href="#exercise-5-13-crank-nicolson-for-a-nonlinear-3d-diffusion-equation">Exercise 5.13: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
<li><a class="reference internal" href="#problem-5-14-find-the-sparsity-of-the-jacobian">Problem 5.14: Find the sparsity of the Jacobian</a></li>
<li><a class="reference internal" href="#problem-5-15-investigate-a-1d-problem-with-a-continuation-method">Problem 5.15: Investigate a 1D problem with a continuation method</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book018.html"
                        title="previous chapter">Operator splitting methods</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book020.html"
                        title="next chapter">Appendix: Useful formulas</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book019.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book020.html" title="Appendix: Useful formulas"
             >next</a> |</li>
        <li class="right" >
          <a href="._book018.html" title="Operator splitting methods"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>