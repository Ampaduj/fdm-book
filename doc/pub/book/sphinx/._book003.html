
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generalization: damping, nonlinear spring, and external excitation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with Partial Differential Equations" href="index.html" />
    <link rel="next" title="Wave equations" href="._book004.html" />
    <link rel="prev" title="Vibration ODEs" href="._book002.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Wave equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="generalization-damping-nonlinear-spring-and-external-excitation">
<span id="vib-model2"></span><h1>Generalization: damping, nonlinear spring, and external excitation<a class="headerlink" href="#generalization-damping-nonlinear-spring-and-external-excitation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">We shall now generalize the simple model problem from
the section <a class="reference internal" href="._book002.html#vib-model1"><span class="std std-ref">Finite difference discretization</span></a> to include a possibly nonlinear damping term <span class="math">\(f(u^{\prime})\)</span>,
a possibly nonlinear spring (or restoring) force <span class="math">\(s(u)\)</span>, and
some external excitation <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="eq-vib-ode2">
\[\tag{58}
mu^{\prime\prime} + f(u^{\prime}) + s(u) = F(t),\quad u(0)=I,\ u^{\prime}(0)=V,\ t\in (0,T]
    {\thinspace .}\]</div>
<p>We have also included a possibly nonzero initial value of <span class="math">\(u^{\prime}(0)\)</span>.
The parameters <span class="math">\(m\)</span>, <span class="math">\(f(u^{\prime})\)</span>, <span class="math">\(s(u)\)</span>, <span class="math">\(F(t)\)</span>, <span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(T\)</span> are
input data.</p>
<p>There are two main types of damping (friction) forces: linear <span class="math">\(f(u^{\prime})=bu\)</span>, or
quadratic <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>. Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: <span class="math">\(s(u)=cu\)</span>, but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with <span class="math">\(s(u)\sim \sin(u)\)</span>.</p>
<div class="section" id="a-centered-scheme-for-linear-damping">
<span id="vib-ode2-fdm-flin"></span><h2>A centered scheme for linear damping<a class="headerlink" href="#a-centered-scheme-for-linear-damping" title="Permalink to this headline">¶</a></h2>
<p>Sampling <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> at a mesh point <span class="math">\(t_n\)</span>, replacing
<span class="math">\(u^{\prime\prime}(t_n)\)</span> by <span class="math">\([D_tD_tu]^n\)</span>, and <span class="math">\(u^{\prime}(t_n)\)</span> by <span class="math">\([D_{2t}u]^n\)</span> results
in the discretization</p>
<div class="math" id="eq-auto22">
\[\tag{59}
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,\]</div>
<p>which written out means</p>
<div class="math" id="eq-vib-ode2-step3b">
\[\tag{60}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> as usual means <span class="math">\(F(t)\)</span> evaluated at <span class="math">\(t=t_n\)</span>.
Solving <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a> with respect to the unknown
<span class="math">\(u^{n+1}\)</span> gives a problem: the <span class="math">\(u^{n+1}\)</span> inside the <span class="math">\(f\)</span> function
makes the equation <em>nonlinear</em> unless <span class="math">\(f(u^{\prime})\)</span> is a linear function,
<span class="math">\(f(u^{\prime})=bu^{\prime}\)</span>. For now we shall assume that <span class="math">\(f\)</span> is linear in <span class="math">\(u^{\prime}\)</span>.
Then</p>
<div class="math" id="eq-vib-ode2-step3b2">
\[\tag{61}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>which gives an explicit formula for <span class="math">\(u\)</span> at each
new time level:</p>
<div class="math" id="eq-vib-ode2-step4">
\[\tag{62}
u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
    \Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}\]\[    {\thinspace .}\]</div>
<p>For the first time step we need to discretize <span class="math">\(u^{\prime}(0)=V\)</span>
as <span class="math">\([D_{2t}u = V]^0\)</span> and combine
with <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> for <span class="math">\(n=0\)</span>. The discretized initial condition
leads to</p>
<div class="math" id="eq-vib-ode2-ic-du">
\[\tag{63}
u^{-1} = u^{1} - 2\Delta t V,\]</div>
<p>which inserted in <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> for <span class="math">\(n=0\)</span> gives an equation
that can be solved for
<span class="math">\(u^1\)</span>:</p>
<div class="math" id="eq-vib-ode2-step4b">
\[\tag{64}
u^1 = u^0 + \Delta t\, V
    + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
    {\thinspace .}\]</div>
</div>
<div class="section" id="a-centered-scheme-for-quadratic-damping">
<span id="vib-ode2-fdm-fquad"></span><h2>A centered scheme for quadratic damping<a class="headerlink" href="#a-centered-scheme-for-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>When <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>, we get a quadratic equation for <span class="math">\(u^{n+1}\)</span>
in <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a>. This equation can be straightforwardly
solved by the well-known formula for the roots of a quadratic equation.
However, we can also avoid the nonlinearity by introducing
an approximation with an error of order no higher than what we
already have from replacing derivatives with finite differences.</p>
<span class="target" id="index-3"></span><p id="index-4">We start with <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> and only replace
<span class="math">\(u^{\prime\prime}\)</span> by <span class="math">\(D_tD_tu\)</span>, resulting in</p>
<div class="math" id="eq-vib-ode2-quad-idea1">
\[\tag{65}
[mD_tD_t u + bu^{\prime}|u^{\prime}| + s(u) = F]^n{\thinspace .}\]</div>
<p>Here, <span class="math">\(u^{\prime}|u^{\prime}|\)</span> is to be computed at time <span class="math">\(t_n\)</span>. The idea
is now to introduce
a <em>geometric mean</em>, defined by</p>
<div class="math">
\[(w^2)^n \approx w^{n-\frac{1}{2}}w^{n+\frac{1}{2}},\]</div>
<p>for some quantity <span class="math">\(w\)</span> depending on time. The error in the geometric mean
approximation is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, the same as in the
approximation <span class="math">\(u^{\prime\prime}\approx D_tD_tu\)</span>. With <span class="math">\(w=u^{\prime}\)</span> it follows
that</p>
<div class="math">
\[[u^{\prime}|u^{\prime}|]^n \approx u^{\prime}(t_{n+\frac{1}{2}})|u^{\prime}(t_{n-\frac{1}{2}})|{\thinspace .}\]</div>
<p>The next step is to approximate
<span class="math">\(u^{\prime}\)</span> at <span class="math">\(t_{n\pm 1/2}\)</span>, and fortunately a centered difference
fits perfectly into the formulas since it involves <span class="math">\(u\)</span> values at
the mesh points only. With the approximations</p>
<div class="math" id="eq-vib-ode2-quad-idea2">
\[\tag{66}
u^{\prime}(t_{n+1/2})\approx [D_t u]^{n+\frac{1}{2}},\quad u^{\prime}(t_{n-1/2})\approx [D_t u]^{n-\frac{1}{2}},\]</div>
<p>we get</p>
<div class="math" id="eq-auto23">
\[\tag{67}
[u^{\prime}|u^{\prime}|]^n
    \approx [D_tu]^{n+\frac{1}{2}}|[D_tu]^{n-\frac{1}{2}}| = \frac{u^{n+1}-u^n}{\Delta t}
    \frac{|u^n-u^{n-1}|}{\Delta t}
    {\thinspace .}\]</div>
<p>The counterpart to <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(60)</span></a> is then</p>
<div class="math" id="eq-vib-ode2-step3b-quad">
\[\tag{68}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
    + s(u^n) = F^n,\]</div>
<p>which is linear in the unknown <span class="math">\(u^{n+1}\)</span>. Therefore, we can easily solve
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(68)</span></a>
with respect to <span class="math">\(u^{n+1}\)</span> and achieve the explicit updating formula</p>
<div class="math">
\[u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\]</div>
<div class="math" id="eq-vib-ode2-step4-quad">
\[\tag{69}
\qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
    \right)
    {\thinspace .}\]</div>
<p>In the derivation of a special equation for the first
time step we run into some trouble: inserting <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(63)</span></a>
in <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(69)</span></a> for <span class="math">\(n=0\)</span> results in a complicated nonlinear
equation for <span class="math">\(u^1\)</span>. By thinking differently about the problem we can
easily get away with the nonlinearity again. We have for <span class="math">\(n=0\)</span> that
<span class="math">\(b[u^{\prime}|u^{\prime}|]^0 = bV|V|\)</span>. Using this value in <a class="reference internal" href="#eq-vib-ode2-quad-idea1"><span class="std std-ref">(65)</span></a>
gives</p>
<div class="math" id="eq-auto24">
\[\tag{70}
[mD_tD_t u + bV|V| + s(u) = F]^0
    {\thinspace .}\]</div>
<p>Writing this equation out and using <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(63)</span></a> results in the
special equation for the first time step:</p>
<div class="math" id="eq-vib-ode2-step4b-quad">
\[\tag{71}
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
    {\thinspace .}\]</div>
</div>
<div class="section" id="a-forward-backward-discretization-of-the-quadratic-damping-term">
<h2>A forward-backward discretization of the quadratic damping term<a class="headerlink" href="#a-forward-backward-discretization-of-the-quadratic-damping-term" title="Permalink to this headline">¶</a></h2>
<p>The previous section first proposed to discretize the quadratic
damping term <span class="math">\(|u^{\prime}|u^{\prime}\)</span> using centered differences:
<span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>. As this gives rise to a nonlinearity in
<span class="math">\(u^{n+1}\)</span>, it was instead proposed to use a geometric mean combined
with centered differences.  But there are other alternatives. To get
rid of the nonlinearity in <span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>, one can think
differently: apply a backward difference to <span class="math">\(|u^{\prime}|\)</span>, such that
the term involves known values, and apply a forward difference to
<span class="math">\(u^{\prime}\)</span> to make the term linear in the unknown <span class="math">\(u^{n+1}\)</span>. With
mathematics,</p>
<div class="math" id="eq-vib-ode2-nonlin-fbdiff">
\[\tag{72}
[\beta |u^{\prime}|u^{\prime}]^n \approx \beta |[D_t^-u]^n|[D_t^+ u]^n =
    \beta\left\vert\frac{u^n-u^{n-1}}{\Delta t}\right\vert
    \frac{u^{n+1}-u^n}{\Delta t}{\thinspace .}\]</div>
<p>The forward and backward differences have both an error proportional
to <span class="math">\(\Delta t\)</span> so one may think the discretization above leads to
a first-order scheme.
However, by looking at the formulas, we realize that the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(72)</span></a>
result in exactly the same scheme as in
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(68)</span></a> where we
used a geometric mean and centered differences and committed errors
of size <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. Therefore, the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(72)</span></a>
act in a symmetric way and actually produce a second-order
accurate discretization of the quadratic damping term.</p>
</div>
<div class="section" id="implementation-3">
<span id="vib-ode2-solver"></span><h2>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h2>
<p>The algorithm arising from the methods in the sections <a class="reference internal" href="#vib-ode2-fdm-flin"><span class="std std-ref">A centered scheme for linear damping</span></a>
and <a class="reference internal" href="#vib-ode2-fdm-fquad"><span class="std std-ref">A centered scheme for quadratic damping</span></a> is very similar to the undamped case in
the section <a class="reference internal" href="._book002.html#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>. The difference is
basically a question of different formulas for <span class="math">\(u^1\)</span> and
<span class="math">\(u^{n+1}\)</span>. This is actually quite remarkable. The equation
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> is normally impossible to solve by pen and paper, but
possible for some special choices of <span class="math">\(F\)</span>, <span class="math">\(s\)</span>, and <span class="math">\(f\)</span>. On the
contrary, the complexity of the
nonlinear generalized model <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> versus the
simple undamped model is not a big deal when we solve the
problem numerically!</p>
<p>The computational algorithm takes the form</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4b"><span class="std std-ref">(64)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4b-quad"><span class="std std-ref">(71)</span></a> if quadratic damping</li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(62)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(69)</span></a> if quadratic damping</li>
</ol>
</div></blockquote>
</div></blockquote>
<p>Modifying the <code class="docutils literal"><span class="pre">solver</span></code> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span class="sd">    u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span class="sd">    F(t) and s(u) are Python functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                      <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                      <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The complete code resides in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>.</p>
</div>
<div class="section" id="verification-2">
<span id="vib-ode2-verify"></span><h2>Verification<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constant-solution">
<h3>Constant solution<a class="headerlink" href="#constant-solution" title="Permalink to this headline">¶</a></h3>
<p>For debugging and initial verification, a constant solution is often
very useful. We choose <span class="math">\({u_{\small\mbox{e}}}(t)=I\)</span>, which implies <span class="math">\(V=0\)</span>.
Inserted in the ODE, we get
<span class="math">\(F(t)=s(I)\)</span> for any choice of <span class="math">\(f\)</span>. Since the discrete derivative
of a constant vanishes (in particular, <span class="math">\([D_{2t}I]^n=0\)</span>,
<span class="math">\([D_tI]^n=0\)</span>, and <span class="math">\([D_tD_t I]^n=0\)</span>), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision. The function <code class="docutils literal"><span class="pre">test_constant</span></code> in <code class="docutils literal"><span class="pre">vib.py</span></code>
implements this test.</p>
<p>[<strong>hpl 8</strong>: Add verification tests for constant, linear, quadratic. Check how many bugs that are caught by these tests.]</p>
</div>
<div class="section" id="linear-solution">
<h3>Linear solution<a class="headerlink" href="#linear-solution" title="Permalink to this headline">¶</a></h3>
<p>Now we choose a linear solution: <span class="math">\({u_{\small\mbox{e}}} = ct + d\)</span>. The initial condition
<span class="math">\(u(0)=I\)</span> implies <span class="math">\(d=I\)</span>, and <span class="math">\(u^{\prime}(0)=V\)</span> forces <span class="math">\(c\)</span> to be <span class="math">\(V\)</span>.
Inserting <span class="math">\({u_{\small\mbox{e}}}=Vt+I\)</span> in the ODE with linear damping results in</p>
<div class="math">
\[0 + bV + s(Vt+I) = F(t),\]</div>
<p>while quadratic damping requires the source term</p>
<div class="math">
\[0 + b|V|V + s(Vt+I) = F(t){\thinspace .}\]</div>
<p>Since the finite difference approximations used to compute <span class="math">\(u^{\prime}\)</span> all
are exact for a linear function, it turns out that the linear <span class="math">\({u_{\small\mbox{e}}}\)</span>
is also a solution of the discrete equations.
<a class="reference internal" href="#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 9: Use linear/quadratic functions for verification</span></a> asks you to carry out
all the details.</p>
</div>
<div class="section" id="quadratic-solution">
<h3>Quadratic solution<a class="headerlink" href="#quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>Choosing <span class="math">\({u_{\small\mbox{e}}} = bt^2 + Vt + I\)</span>, with <span class="math">\(b\)</span> arbitrary,
fulfills the initial conditions and
fits the ODE if <span class="math">\(F\)</span> is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in <span class="math">\(t\)</span> does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a class="reference internal" href="#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 9: Use linear/quadratic functions for verification</span></a> will reveal
the details. One can fit <span class="math">\(F^n\)</span> in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).</p>
</div>
</div>
<div class="section" id="visualization">
<span id="vib-ode2-viz"></span><h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>The functions for visualizations differ significantly from
those in the undamped case in the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> program because,
in the present general case, we do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency <span class="math">\(\sqrt{s'(0)/m}\)</span> for linear <span class="math">\(s\)</span> and small damping,
and one period dictated by <span class="math">\(F(t)\)</span> in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify <span class="math">\(T\)</span> and the window width
to get a plot that moves with the graph and shows
the most recent parts of it in long time simulations.</p>
<p>The <code class="docutils literal"><span class="pre">vib.py</span></code> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.</p>
</div>
<div class="section" id="user-interface">
<span id="vib-ode2-ui"></span><h2>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p id="index-6">The <code class="docutils literal"><span class="pre">main</span></code> function is changed substantially from
the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> code, since we need to
specify the new data <span class="math">\(c\)</span>, <span class="math">\(s(u)\)</span>, and <span class="math">\(F(t)\)</span>.  In addition, we must
set <span class="math">\(T\)</span> and the plot window width (instead of the number of periods we
want to simulate as in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of <span class="math">\(u\)</span>, we can use the <code class="docutils literal"><span class="pre">plot_empricial_freq_and_amplitude</span></code>
function&#8217;s estimate of the number of local maxima. This number is now
returned from the function and used in <code class="docutils literal"><span class="pre">main</span></code> to decide on the
visualization technique.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="n">empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_periods</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <code class="docutils literal"><span class="pre">vib.py</span></code> contains
the above code snippets and can solve the model problem
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>. As a demo of <code class="docutils literal"><span class="pre">vib.py</span></code>, we consider the case
<span class="math">\(I=1\)</span>, <span class="math">\(V=0\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(c=0.03\)</span>, <span class="math">\(s(u)=\sin(u)\)</span>, <span class="math">\(F(t)=3\cos(4t)\)</span>,
<span class="math">\(\Delta t = 0.05\)</span>, and <span class="math">\(T=140\)</span>. The relevant command to run is</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03
</pre></div>
</div>
<p>This results in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a class="reference internal" href="#vib-ode2-fig-demo"><span class="std std-ref">Damped oscillator excited by a sinusoidal function</span></a> shows a part of the time series.</p>
<div class="figure" id="id3">
<span id="vib-ode2-fig-demo"></span><a class="reference internal image-reference" href="_images/vib_gen_demo.png"><img alt="_images/vib_gen_demo.png" src="_images/vib_gen_demo.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Damped oscillator excited by a sinusoidal function</em></span></p>
</div>
</div>
<div class="section" id="the-euler-cromer-scheme-for-the-generalized-model">
<h2>The Euler-Cromer scheme for the generalized model<a class="headerlink" href="#the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>The ideas of the Euler-Cromer method from the section <a class="reference internal" href="._book002.html#vib-model2x2-eulercromer"><span class="std std-ref">The Euler-Cromer method</span></a>
carry over to the generalized model. We write <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>
as two equations for <span class="math">\(u\)</span> and <span class="math">\(v=u^{\prime}\)</span>. The first equation is taken as the
one with <span class="math">\(v'\)</span> on the left-hand side:</p>
<div class="math" id="eq-vib-ode2-eulercromer-veq">
\[\tag{73}
v' = \frac{1}{m}(F(t)-s(u)-f(v)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-ueq">
\[\tag{74}
u^{\prime} = v{\thinspace .}\]</div>
<p>The idea is to step <a class="reference internal" href="#eq-vib-ode2-eulercromer-veq"><span class="std std-ref">(73)</span></a> forward using
a standard Forward Euler method, while we update <span class="math">\(u\)</span> from
<a class="reference internal" href="#eq-vib-ode2-eulercromer-ueq"><span class="std std-ref">(74)</span></a> with a Backward Euler method,
utilizing the recent, computed <span class="math">\(v^{n+1}\)</span> value. In detail,</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq0a">
\[\tag{75}
\frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0a">
\[\tag{76}
\frac{u^{n+1}-u^n}{\Delta t} = v^{n+1},\]</div>
<p>resulting in the explicit scheme</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq">
\[\tag{77}
v^{n+1} = v^n + \Delta t\frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0">
\[\tag{78}
u^{n+1} = u^n + \Delta t\,v^{n+1}{\thinspace .}\]</div>
<p>We immediately note one very favorable feature of this scheme: all the
nonlinearities in <span class="math">\(s(u)\)</span> and <span class="math">\(f(v)\)</span> are evaluated at a previous time
level. This makes the Euler-Cromer method easier to apply and
hence much more convenient than the centered scheme for the second-order
ODE <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a>.</p>
<p>The initial conditions are trivially set as</p>
<div class="math" id="eq-auto25">
\[\tag{79}
v^0 = V,\]</div>
<div class="math" id="eq-auto26">
\[\tag{80}
u^0 = I{\thinspace .}\]</div>
<p>[<strong>hpl 9</strong>: odespy for the generalized problem]</p>
</div>
</div>
<div class="section" id="exercises-and-problems">
<h1>Exercises and Problems<a class="headerlink" href="#exercises-and-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-1-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-undamped-verify-linquad"></span><h2>Problem 1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Consider the ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2u=f(t), \quad u(0)=I,\ u^{\prime}(0)=V,\ t\in(0,T]{\thinspace .}\]</div>
<p>Discretize this equation according to
<span class="math">\([D_tD_t u + \omega^2 u = f]^n\)</span>.</p>
<p><strong>a)</strong>
Derive the equation for the
first time step (<span class="math">\(u^1\)</span>).</p>
<p><strong>b)</strong>
For verification purposes,
we use the method of manufactured solutions (MMS) with the
choice of <span class="math">\({u_{\small\mbox{e}}}(x,t)= ct+d\)</span>.
Find restrictions on <span class="math">\(c\)</span> and <span class="math">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math">\(f\)</span> by term.
Show that <span class="math">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math">\(D_tD_t\)</span> operator is linear,
<span class="math">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math">\({u_{\small\mbox{e}}}\)</span> is also a perfect solution of the discrete equations.</p>
<p><strong>c)</strong>
Use <code class="docutils literal"><span class="pre">sympy</span></code> to do the symbolic calculations above. Here is a
sketch of the program <code class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span>
    <span class="k">print</span> <span class="s">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s">, u&#39;(0)=</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sym</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c"># Residual in discrete equations (should be 0)</span>
    <span class="k">print</span> <span class="s">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <code class="docutils literal"><span class="pre">main</span></code>
function works.</p>
<p><strong>d)</strong>
The purpose now is to choose a quadratic function
<span class="math">\({u_{\small\mbox{e}}} = bt^2 + ct + d\)</span> as exact solution. Extend the <code class="docutils literal"><span class="pre">sympy</span></code>
code above with a function <code class="docutils literal"><span class="pre">quadratic</span></code> for fitting <code class="docutils literal"><span class="pre">f</span></code> and checking
if the discrete equations are fulfilled. (The function is very similar
to <code class="docutils literal"><span class="pre">linear</span></code>.)</p>
<p><strong>e)</strong>
Will a polynomial of degree three fulfill the discrete equations?</p>
<p><strong>f)</strong>
Implement a <code class="docutils literal"><span class="pre">solver</span></code> function for computing the numerical
solution of this problem.</p>
<p><strong>g)</strong>
Write a nose test for checking that the quadratic solution
is computed to correctly (too machine precision, but the
round-off errors accumulate and increase with <span class="math">\(T\)</span>) by the <code class="docutils literal"><span class="pre">solver</span></code>
function.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_undamped_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-2-show-linear-growth-of-the-phase-with-time">
<span id="vib-exer-phase-err-growth"></span><h2>Exercise 2: Show linear growth of the phase with time<a class="headerlink" href="#exercise-2-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h2>
<p>Consider an exact solution <span class="math">\(I\cos (\omega t)\)</span> and an
approximation <span class="math">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as time lag between the peak <span class="math">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math">\(m\)</span>.
Filename: <code class="docutils literal"><span class="pre">vib_phase_error_growth</span></code>.</p>
</div>
<div class="section" id="exercise-3-improve-the-accuracy-by-adjusting-the-frequency">
<span id="vib-exer-w-adjust"></span><h2>Exercise 3: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h2>
<p>According to <a class="reference internal" href="._book002.html#eq-vib-ode1-tildeomega-series"><span class="std std-ref">(19)</span></a>, the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <code class="docutils literal"><span class="pre">w</span></code> parameter in the algorithm
in the <code class="docutils literal"><span class="pre">solver</span></code> function in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> by <code class="docutils literal"><span class="pre">w*(1</span> <span class="pre">-</span>
<span class="pre">(1./24)*w**2*dt**2</span></code> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math">\(\omega\)</span>).
Filename: <code class="docutils literal"><span class="pre">vib_adjust_w</span></code>.</p>
</div>
<div class="section" id="exercise-4-see-if-adaptive-methods-improve-the-phase-error">
<span id="vib-exer-undamped-adaptive"></span><h2>Exercise 4: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h2>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math">\(u^{\prime\prime}+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a class="reference internal" href="._book020.html#ref2" id="id1">[Ref2]</a>.  Run the scheme with a very low
tolerance (say <span class="math">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver&#8217;s mesh (<code class="docutils literal"><span class="pre">len(solver.t_all)</span></code>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference internal" href="._book002.html#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.
Filename: <code class="docutils literal"><span class="pre">vib_undamped_adaptive</span></code>.</p>
</div>
<div class="section" id="exercise-5-use-a-taylor-polynomial-to-compute">
<span id="vib-exer-step4b-alt"></span><h2>Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span><a class="headerlink" href="#exercise-5-use-a-taylor-polynomial-to-compute" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the derivation of <a class="reference internal" href="._book002.html#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a> for
computing <span class="math">\(u^1\)</span>, one can use a Taylor polynomial with three terms
for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u(t_1) \approx u(0) + u^{\prime}(0)\Delta t + {\frac{1}{2}}u^{\prime\prime}(0)\Delta t^2\]</div>
<p>With <span class="math">\(u^{\prime\prime}=-\omega^2 u\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>, show that this method also leads to
<a class="reference internal" href="._book002.html#eq-vib-ode1-step4b"><span class="std std-ref">(8)</span></a>. Generalize the condition on <span class="math">\(u^{\prime}(0)\)</span> to
be <span class="math">\(u^{\prime}(0)=V\)</span> and compute <span class="math">\(u^1\)</span> in this case with both methods.
Filename: <code class="docutils literal"><span class="pre">vib_first_step</span></code>.</p>
</div>
<div class="section" id="exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">
<span id="vib-exer-wdt-limit"></span><h2>Exercise 6: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h2>
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory &#8220;cos-like&#8221; function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math">\(\omega\Delta t\)</span> when <span class="math">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math">\(\Delta t\)</span> is the mesh spacing.
Filename: <code class="docutils literal"><span class="pre">vib_largest_wdt</span></code>.</p>
</div>
<div class="section" id="exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<span id="vib-exer-fd-exp-plot"></span><h2>Exercise 7: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h2>
<p>We introduce the error fraction</p>
<div class="math">
\[E = \frac{[D_tD_t u]^n}{u^{\prime\prime}(t_n)}\]</div>
<p>to measure the error in the finite difference approximation <span class="math">\(D_tD_tu\)</span> to
<span class="math">\(u^{\prime\prime}\)</span>.
Compute <span class="math">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math">
\[E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\omega\Delta t}{2})
{\thinspace .}\]</div>
<p>Plot <span class="math">\(E\)</span> as a function of <span class="math">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math">\(p\)</span> are <span class="math">\([0,\pi]\)</span> (see <a class="reference internal" href="#vib-exer-wdt-limit"><span class="std std-ref">Exercise 6: Find the minimal resolution of an oscillatory function</span></a>
for why <span class="math">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math">\(E\)</span> as a Taylor polynomial in <span class="math">\(p\)</span> up to
fourth degree (use, e.g., <code class="docutils literal"><span class="pre">sympy</span></code>).
Filename: <code class="docutils literal"><span class="pre">vib_plot_fd_exp_error</span></code>.</p>
</div>
<div class="section" id="exercise-8-verify-convergence-rates-of-the-error-in-energy">
<span id="vib-exer-energy-convrate"></span><h2>Exercise 8: Verify convergence rates of the error in energy<a class="headerlink" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h2>
<p>We consider the ODE problem <span class="math">\(u^{\prime\prime} + \omega^2u=0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=V\)</span>,
for <span class="math">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math">\(E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference internal" href="._book002.html#vib-model1-energy"><span class="std std-ref">Energy considerations</span></a>.</p>
<p>Make a nose test in a file <code class="docutils literal"><span class="pre">test_error_conv.py</span></code>, where code from
<code class="docutils literal"><span class="pre">vib_undamped.py</span></code> is imported, but the <code class="docutils literal"><span class="pre">convergence_rates</span></code> and
<code class="docutils literal"><span class="pre">test_convergence_rates</span></code> functions are copied and modified to also
incorporate computations of the error in energy and the convergence
rate of this error. The expected rate is 2.
Filename: <code class="docutils literal"><span class="pre">test_error_conv</span></code>.</p>
</div>
<div class="section" id="exercise-9-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-verify-gen-linear"></span><h2>Exercise 9: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-9-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>This exercise is a generalization of <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a> to the extended model problem
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a>, <code class="docutils literal"><span class="pre">sympy</span></code> will do most
of the work required to analyze the generalized problem.
Filename: <code class="docutils literal"><span class="pre">vib_verify_mms</span></code>.</p>
</div>
<div class="section" id="exercise-10-use-an-exact-discrete-solution-for-verification">
<span id="vib-exer-discrete-omega"></span><h2>Exercise 10: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-10-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Write a nose test function in a separate file
that employs the exact discrete solution
<a class="reference internal" href="._book002.html#eq-vib-ode1-un-exact"><span class="std std-ref">(20)</span></a> to verify the implementation of the
<code class="docutils literal"><span class="pre">solver</span></code> function in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.
Filename: <code class="docutils literal"><span class="pre">test_vib_undamped_exact_discrete_sol</span></code>.</p>
</div>
<div class="section" id="exercise-11-use-analytical-solution-for-convergence-rate-tests">
<span id="vib-exer-conv-rate"></span><h2>Exercise 11: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to perform convergence tests of the
problem <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(58)</span></a> when <span class="math">\(s(u)=\omega^2u\)</span> and <span class="math">\(F(t)=A\sin\phi t\)</span>.
Find the complete analytical solution to the problem in this case
(most textbooks on mechanics or ordinary differential equations list
the various elements you need to write down the exact solution).
Modify the <code class="docutils literal"><span class="pre">convergence_rate</span></code> function from the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>
program to perform experiments with the extended model.  Verify that
the error is of order <span class="math">\(\Delta t^2\)</span>.
Filename: <code class="docutils literal"><span class="pre">vib_conv_rate</span></code>.</p>
</div>
<div class="section" id="exercise-12-investigate-the-amplitude-errors-of-many-solvers">
<span id="vib-exer-undamped-odespy"></span><h2>Exercise 12: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h2>
<p>Use the program <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code> from the section <a class="reference internal" href="._book002.html#vib-model2x2-compare"><span class="std std-ref">Comparison of schemes</span></a> and the amplitude estimation from the
<code class="docutils literal"><span class="pre">amplitudes</span></code> function in the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> file (see the section <a class="reference internal" href="._book002.html#vib-ode1-empirical"><span class="std std-ref">Empirical analysis of the solution</span></a>) to investigate how well famous methods for
1st-order ODEs can preserve the amplitude of <span class="math">\(u\)</span> in undamped
oscillations.  Test, for example, the 3rd- and 4th-order Runge-Kutta
methods (<code class="docutils literal"><span class="pre">RK3</span></code>, <code class="docutils literal"><span class="pre">RK4</span></code>), the Crank-Nicolson method (<code class="docutils literal"><span class="pre">CrankNicolson</span></code>),
the 2nd- and 3rd-order Adams-Bashforth methods (<code class="docutils literal"><span class="pre">AdamsBashforth2</span></code>,
<code class="docutils literal"><span class="pre">AdamsBashforth3</span></code>), and a 2nd-order Backwards scheme
(<code class="docutils literal"><span class="pre">Backward2Step</span></code>).  The relevant governing equations are listed in
the beginning of the section <a class="reference internal" href="._book002.html#vib-model2x2"><span class="std std-ref">Alternative schemes based on 1st-order equations</span></a>.
Filename: <code class="docutils literal"><span class="pre">vib_amplitude_errors</span></code>.</p>
</div>
<div class="section" id="exercise-13-minimize-memory-usage-of-a-vibration-solver">
<span id="vib-exer-memsave"></span><h2>Exercise 13: Minimize memory usage of a vibration solver<a class="headerlink" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>
store the complete solution <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is
convenient for later plotting.
Make a memory minimizing version of this program where only the last three
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> values are stored in memory.
Write each computed <span class="math">\((t_{n+1}, u^{n+1})\)</span> pair to file.
Visualize the data in the file (a cool solution is to
read one line at a time and
plot the <span class="math">\(u\)</span> value using the line-by-line plotter in the
<code class="docutils literal"><span class="pre">visualize_front_ascii</span></code> function - this technique makes it trivial
to visualize very long time simulations).
Filename: <code class="docutils literal"><span class="pre">vib_memsave</span></code>.</p>
</div>
<div class="section" id="exercise-14-implement-the-solver-via-classes">
<span id="vib-exer-gen-class"></span><h2>Exercise 14: Implement the solver via classes<a class="headerlink" href="#exercise-14-implement-the-solver-via-classes" title="Permalink to this headline">¶</a></h2>
<p>Reimplement the <code class="docutils literal"><span class="pre">vib.py</span></code>
program
using a class <code class="docutils literal"><span class="pre">Problem</span></code> to hold all the physical parameters of the problem,
a class <code class="docutils literal"><span class="pre">Solver</span></code> to hold the numerical parameters and compute the
solution, and a class <code class="docutils literal"><span class="pre">Visualizer</span></code> to display the solution.</p>
<p><strong>Hint.</strong>
Use the ideas and examples
for an <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book009.html#classes-for-problem-and-solution-method">ODE model</a> in <a class="reference internal" href="._book020.html#ref2" id="id2">[Ref2]</a>.
More specifically, make a superclass <code class="docutils literal"><span class="pre">Problem</span></code> for holding the scalar
physical parameters of a problem and let subclasses implement the
<span class="math">\(s(u)\)</span> and <span class="math">\(F(t)\)</span> functions as methods.
Try to call up as much existing functionality in <code class="docutils literal"><span class="pre">vib.py</span></code> as possible.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_class</span></code>.</p>
</div>
<div class="section" id="exercise-15-interpret-as-a-forward-backward-difference">
<span id="vib-exer-dtdt-asdtpdtm"></span><h2>Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference<a class="headerlink" href="#exercise-15-interpret-as-a-forward-backward-difference" title="Permalink to this headline">¶</a></h2>
<p>Show that the difference <span class="math">\([D_t D_tu]^n\)</span> is equal to <span class="math">\([D_t^+D_t^-u]^n\)</span>
and <span class="math">\(D_t^-D_t^+u]^n\)</span>. That is, instead of applying a centered difference
twice one can alternatively apply a mixture forward and backward
differences.
Filename: <code class="docutils literal"><span class="pre">vib_DtDt_fw_bw</span></code>.</p>
</div>
<div class="section" id="exercise-16-use-a-backward-difference-for-the-damping-term">
<span id="vib-exer-quad-damping-bw"></span><h2>Exercise 16: Use a backward difference for the damping term<a class="headerlink" href="#exercise-16-use-a-backward-difference-for-the-damping-term" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to discretizing the damping terms <span class="math">\(\beta u^{\prime}\)</span> and
<span class="math">\(\beta |u^{\prime}|u^{\prime}\)</span> by centered differences, we may apply
backward differences:</p>
<div class="math">
\[\begin{split}[u^{\prime}]^n &amp;\approx [D_t^-u]^n,\\
&amp; [|u^{\prime}|u^{\prime}]^n &amp;\approx [|D_t^-u|D_t^-u]^n
= |[D_t^-u]^n|[D_t^-u]^n{\thinspace .}\end{split}\]</div>
<p>The advantage of the backward difference is that the damping term is
evaluated using known values <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span> only.
Extend the <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a> code with a scheme based
on using backward differences in the damping terms. Add statements
to compare the original approach with centered difference and the
new idea launched in this exercise. Perform numerical experiments
to investigate how much accuracy that is lost by using the backward
differences.
Filename: <code class="docutils literal"><span class="pre">vib_gen_bwdamping</span></code>.</p>
</div>
<div class="section" id="exercise-17-analysis-of-the-euler-cromer-scheme">
<span id="vib-exer-eulercromer-analysis"></span><h2>Exercise 17: Analysis of the Euler-Cromer scheme<a class="headerlink" href="#exercise-17-analysis-of-the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Euler-Cromer scheme for the model problem
<span class="math">\(u^{\prime\prime} + \omega^2 u =0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u^{\prime}(0)=0\)</span>, is given in
<a class="reference internal" href="._book002.html#eq-vib-model2x2-eulercromer-ueq1b"><span class="std std-ref">(53)</span></a>-<a class="reference internal" href="._book002.html#eq-vib-model2x2-eulercromer-veq1b"><span class="std std-ref">(52)</span></a>.
Find the exact discrete solutions of this scheme and show that the solution
for <span class="math">\(u^n\)</span> coincides with that found in the section <a class="reference internal" href="._book002.html#vib-ode1-analysis"><span class="std std-ref">Analysis of the numerical scheme</span></a>.</p>
<p><strong>Hint.</strong>
Use an &#8220;ansatz&#8221; <span class="math">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math">\(v^n=qu^n\)</span>, where <span class="math">\(\tilde\omega\)</span> and <span class="math">\(q\)</span> are unknown parameters. The
following formula is handy:</p>
<div class="math">
\[\boldsymbol{e}^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2
= 2\left(\cosh(i\tilde\omega\Delta t) -1 \right)
=-4\sin^2(\frac{\tilde\omega\Delta t}{2}){\thinspace .}\]</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generalization: damping, nonlinear spring, and external excitation</a><ul>
<li><a class="reference internal" href="#a-centered-scheme-for-linear-damping">A centered scheme for linear damping</a></li>
<li><a class="reference internal" href="#a-centered-scheme-for-quadratic-damping">A centered scheme for quadratic damping</a></li>
<li><a class="reference internal" href="#a-forward-backward-discretization-of-the-quadratic-damping-term">A forward-backward discretization of the quadratic damping term</a></li>
<li><a class="reference internal" href="#implementation-3">Implementation</a></li>
<li><a class="reference internal" href="#verification-2">Verification</a><ul>
<li><a class="reference internal" href="#constant-solution">Constant solution</a></li>
<li><a class="reference internal" href="#linear-solution">Linear solution</a></li>
<li><a class="reference internal" href="#quadratic-solution">Quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#the-euler-cromer-scheme-for-the-generalized-model">The Euler-Cromer scheme for the generalized model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#problem-1-use-linear-quadratic-functions-for-verification">Problem 1: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-2-show-linear-growth-of-the-phase-with-time">Exercise 2: Show linear growth of the phase with time</a></li>
<li><a class="reference internal" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency">Exercise 3: Improve the accuracy by adjusting the frequency</a></li>
<li><a class="reference internal" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error">Exercise 4: See if adaptive methods improve the phase error</a></li>
<li><a class="reference internal" href="#exercise-5-use-a-taylor-polynomial-to-compute">Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span></a></li>
<li><a class="reference internal" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">Exercise 6: Find the minimal resolution of an oscillatory function</a></li>
<li><a class="reference internal" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">Exercise 7: Visualize the accuracy of finite differences for a cosine function</a></li>
<li><a class="reference internal" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy">Exercise 8: Verify convergence rates of the error in energy</a></li>
<li><a class="reference internal" href="#exercise-9-use-linear-quadratic-functions-for-verification">Exercise 9: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-10-use-an-exact-discrete-solution-for-verification">Exercise 10: Use an exact discrete solution for verification</a></li>
<li><a class="reference internal" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests">Exercise 11: Use analytical solution for convergence rate tests</a></li>
<li><a class="reference internal" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers">Exercise 12: Investigate the amplitude errors of many solvers</a></li>
<li><a class="reference internal" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver">Exercise 13: Minimize memory usage of a vibration solver</a></li>
<li><a class="reference internal" href="#exercise-14-implement-the-solver-via-classes">Exercise 14: Implement the solver via classes</a></li>
<li><a class="reference internal" href="#exercise-15-interpret-as-a-forward-backward-difference">Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference</a></li>
<li><a class="reference internal" href="#exercise-16-use-a-backward-difference-for-the-damping-term">Exercise 16: Use a backward difference for the damping term</a></li>
<li><a class="reference internal" href="#exercise-17-analysis-of-the-euler-cromer-scheme">Exercise 17: Analysis of the Euler-Cromer scheme</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book002.html"
                        title="previous chapter">Vibration ODEs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book004.html"
                        title="next chapter">Wave equations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book003.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Wave equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with Partial Differential Equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Svein Linge, Hans Petter Langtangen. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>