
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generalization: damping, nonlinearities, and excitation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite Difference Computing with PDEs" href="index.html" />
    <link rel="next" title="Applications of vibration models" href="._book004.html" />
    <link rel="prev" title="Vibration ODEs" href="._book002.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Applications of vibration models"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="generalization-damping-nonlinearities-and-excitation">
<span id="vib-model2"></span><h1>Generalization: damping, nonlinearities, and excitation<a class="headerlink" href="#generalization-damping-nonlinearities-and-excitation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">We shall now generalize the simple model problem from
the section <a class="reference internal" href="._book002.html#vib-model1"><span class="std std-ref">Finite difference discretization</span></a> to include a possibly nonlinear damping term <span class="math">\(f(u^{\prime})\)</span>,
a possibly nonlinear spring (or restoring) force <span class="math">\(s(u)\)</span>, and
some external excitation <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="eq-vib-ode2">
\[\tag{71}
mu^{\prime\prime} + f(u^{\prime}) + s(u) = F(t),\quad u(0)=I,\ u^{\prime}(0)=V,\ t\in (0,T]
    {\thinspace .}\]</div>
<p>We have also included a possibly nonzero initial value of <span class="math">\(u^{\prime}(0)\)</span>.
The parameters <span class="math">\(m\)</span>, <span class="math">\(f(u^{\prime})\)</span>, <span class="math">\(s(u)\)</span>, <span class="math">\(F(t)\)</span>, <span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(T\)</span> are
input data.</p>
<p>There are two main types of damping (friction) forces: linear <span class="math">\(f(u^{\prime})=bu\)</span>, or
quadratic <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>. Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: <span class="math">\(s(u)=cu\)</span>, but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with <span class="math">\(s(u)\sim \sin(u)\)</span>.</p>
<div class="section" id="a-centered-scheme-for-linear-damping">
<span id="vib-ode2-fdm-flin"></span><h2>A centered scheme for linear damping<a class="headerlink" href="#a-centered-scheme-for-linear-damping" title="Permalink to this headline">¶</a></h2>
<p>Sampling <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a> at a mesh point <span class="math">\(t_n\)</span>, replacing
<span class="math">\(u^{\prime\prime}(t_n)\)</span> by <span class="math">\([D_tD_tu]^n\)</span>, and <span class="math">\(u^{\prime}(t_n)\)</span> by <span class="math">\([D_{2t}u]^n\)</span> results
in the discretization</p>
<div class="math" id="eq-auto32">
\[\tag{72}
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,\]</div>
<p>which written out means</p>
<div class="math" id="eq-vib-ode2-step3b">
\[\tag{73}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> as usual means <span class="math">\(F(t)\)</span> evaluated at <span class="math">\(t=t_n\)</span>.
Solving <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(73)</span></a> with respect to the unknown
<span class="math">\(u^{n+1}\)</span> gives a problem: the <span class="math">\(u^{n+1}\)</span> inside the <span class="math">\(f\)</span> function
makes the equation <em>nonlinear</em> unless <span class="math">\(f(u^{\prime})\)</span> is a linear function,
<span class="math">\(f(u^{\prime})=bu^{\prime}\)</span>. For now we shall assume that <span class="math">\(f\)</span> is linear in <span class="math">\(u^{\prime}\)</span>.
Then</p>
<div class="math" id="eq-vib-ode2-step3b2">
\[\tag{74}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>which gives an explicit formula for <span class="math">\(u\)</span> at each
new time level:</p>
<div class="math" id="eq-vib-ode2-step4">
\[ \begin{align}\begin{aligned}\tag{75}
u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
    \Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}\\    {\thinspace .}\end{aligned}\end{align} \]</div>
<p>For the first time step we need to discretize <span class="math">\(u^{\prime}(0)=V\)</span>
as <span class="math">\([D_{2t}u = V]^0\)</span> and combine
with <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(75)</span></a> for <span class="math">\(n=0\)</span>. The discretized initial condition
leads to</p>
<div class="math" id="eq-vib-ode2-ic-du">
\[\tag{76}
u^{-1} = u^{1} - 2\Delta t V,\]</div>
<p>which inserted in <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(75)</span></a> for <span class="math">\(n=0\)</span> gives an equation
that can be solved for
<span class="math">\(u^1\)</span>:</p>
<div class="math" id="eq-vib-ode2-step4b">
\[\tag{77}
u^1 = u^0 + \Delta t\, V
    + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
    {\thinspace .}\]</div>
</div>
<div class="section" id="a-centered-scheme-for-quadratic-damping">
<span id="vib-ode2-fdm-fquad"></span><h2>A centered scheme for quadratic damping<a class="headerlink" href="#a-centered-scheme-for-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>When <span class="math">\(f(u^{\prime})=bu^{\prime}|u^{\prime}|\)</span>, we get a quadratic equation for <span class="math">\(u^{n+1}\)</span>
in <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(73)</span></a>. This equation can be straightforwardly
solved by the well-known formula for the roots of a quadratic equation.
However, we can also avoid the nonlinearity by introducing
an approximation with an error of order no higher than what we
already have from replacing derivatives with finite differences.</p>
<span class="target" id="index-3"></span><p id="index-4">We start with <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a> and only replace
<span class="math">\(u^{\prime\prime}\)</span> by <span class="math">\(D_tD_tu\)</span>, resulting in</p>
<div class="math" id="eq-vib-ode2-quad-idea1">
\[\tag{78}
[mD_tD_t u + bu^{\prime}|u^{\prime}| + s(u) = F]^n{\thinspace .}\]</div>
<p>Here, <span class="math">\(u^{\prime}|u^{\prime}|\)</span> is to be computed at time <span class="math">\(t_n\)</span>. The idea
is now to introduce
a <em>geometric mean</em>, defined by</p>
<div class="math">
\[(w^2)^n \approx w^{n-\frac{1}{2}}w^{n+\frac{1}{2}},\]</div>
<p>for some quantity <span class="math">\(w\)</span> depending on time. The error in the geometric mean
approximation is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, the same as in the
approximation <span class="math">\(u^{\prime\prime}\approx D_tD_tu\)</span>. With <span class="math">\(w=u^{\prime}\)</span> it follows
that</p>
<div class="math">
\[[u^{\prime}|u^{\prime}|]^n \approx u^{\prime}(t_{n+\frac{1}{2}})|u^{\prime}(t_{n-\frac{1}{2}})|{\thinspace .}\]</div>
<p>The next step is to approximate
<span class="math">\(u^{\prime}\)</span> at <span class="math">\(t_{n\pm 1/2}\)</span>, and fortunately a centered difference
fits perfectly into the formulas since it involves <span class="math">\(u\)</span> values at
the mesh points only. With the approximations</p>
<div class="math" id="eq-vib-ode2-quad-idea2">
\[\tag{79}
u^{\prime}(t_{n+1/2})\approx [D_t u]^{n+\frac{1}{2}},\quad u^{\prime}(t_{n-1/2})\approx [D_t u]^{n-\frac{1}{2}},\]</div>
<p>we get</p>
<div class="math" id="eq-auto33">
\[\tag{80}
[u^{\prime}|u^{\prime}|]^n
    \approx [D_tu]^{n+\frac{1}{2}}|[D_tu]^{n-\frac{1}{2}}| = \frac{u^{n+1}-u^n}{\Delta t}
    \frac{|u^n-u^{n-1}|}{\Delta t}
    {\thinspace .}\]</div>
<p>The counterpart to <a class="reference internal" href="#eq-vib-ode2-step3b"><span class="std std-ref">(73)</span></a> is then</p>
<div class="math" id="eq-vib-ode2-step3b-quad">
\[\tag{81}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
    + b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
    + s(u^n) = F^n,\]</div>
<p>which is linear in the unknown <span class="math">\(u^{n+1}\)</span>. Therefore, we can easily solve
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(81)</span></a>
with respect to <span class="math">\(u^{n+1}\)</span> and achieve the explicit updating formula</p>
<div class="math">
\[u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\]</div>
<div class="math" id="eq-vib-ode2-step4-quad">
\[\tag{82}
\qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
    \right)
    {\thinspace .}\]</div>
<p>In the derivation of a special equation for the first
time step we run into some trouble: inserting <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(76)</span></a>
in <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(82)</span></a> for <span class="math">\(n=0\)</span> results in a complicated nonlinear
equation for <span class="math">\(u^1\)</span>. By thinking differently about the problem we can
easily get away with the nonlinearity again. We have for <span class="math">\(n=0\)</span> that
<span class="math">\(b[u^{\prime}|u^{\prime}|]^0 = bV|V|\)</span>. Using this value in <a class="reference internal" href="#eq-vib-ode2-quad-idea1"><span class="std std-ref">(78)</span></a>
gives</p>
<div class="math" id="eq-auto34">
\[\tag{83}
[mD_tD_t u + bV|V| + s(u) = F]^0
    {\thinspace .}\]</div>
<p>Writing this equation out and using <a class="reference internal" href="#eq-vib-ode2-ic-du"><span class="std std-ref">(76)</span></a> results in the
special equation for the first time step:</p>
<div class="math" id="eq-vib-ode2-step4b-quad">
\[\tag{84}
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
    {\thinspace .}\]</div>
</div>
<div class="section" id="a-forward-backward-discretization-of-the-quadratic-damping-term">
<h2>A forward-backward discretization of the quadratic damping term<a class="headerlink" href="#a-forward-backward-discretization-of-the-quadratic-damping-term" title="Permalink to this headline">¶</a></h2>
<p>The previous section first proposed to discretize the quadratic
damping term <span class="math">\(|u^{\prime}|u^{\prime}\)</span> using centered differences:
<span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>. As this gives rise to a nonlinearity in
<span class="math">\(u^{n+1}\)</span>, it was instead proposed to use a geometric mean combined
with centered differences.  But there are other alternatives. To get
rid of the nonlinearity in <span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>, one can think
differently: apply a backward difference to <span class="math">\(|u^{\prime}|\)</span>, such that
the term involves known values, and apply a forward difference to
<span class="math">\(u^{\prime}\)</span> to make the term linear in the unknown <span class="math">\(u^{n+1}\)</span>. With
mathematics,</p>
<div class="math" id="eq-vib-ode2-nonlin-fbdiff">
\[\tag{85}
[\beta |u^{\prime}|u^{\prime}]^n \approx \beta |[D_t^-u]^n|[D_t^+ u]^n =
    \beta\left\vert\frac{u^n-u^{n-1}}{\Delta t}\right\vert
    \frac{u^{n+1}-u^n}{\Delta t}{\thinspace .}\]</div>
<p>The forward and backward differences have both an error proportional
to <span class="math">\(\Delta t\)</span> so one may think the discretization above leads to
a first-order scheme.
However, by looking at the formulas, we realize that the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(85)</span></a>
result in exactly the same scheme as in
<a class="reference internal" href="#eq-vib-ode2-step3b-quad"><span class="std std-ref">(81)</span></a> where we
used a geometric mean and centered differences and committed errors
of size <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. Therefore, the forward-backward
differences in <a class="reference internal" href="#eq-vib-ode2-nonlin-fbdiff"><span class="std std-ref">(85)</span></a>
act in a symmetric way and actually produce a second-order
accurate discretization of the quadratic damping term.</p>
</div>
<div class="section" id="implementation-3">
<span id="vib-ode2-solver"></span><h2>Implementation<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h2>
<p>The algorithm arising from the methods in the sections <a class="reference internal" href="#vib-ode2-fdm-flin"><span class="std std-ref">A centered scheme for linear damping</span></a>
and <a class="reference internal" href="#vib-ode2-fdm-fquad"><span class="std std-ref">A centered scheme for quadratic damping</span></a> is very similar to the undamped case in
the section <a class="reference internal" href="._book002.html#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>. The difference is
basically a question of different formulas for <span class="math">\(u^1\)</span> and
<span class="math">\(u^{n+1}\)</span>. This is actually quite remarkable. The equation
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a> is normally impossible to solve by pen and paper, but
possible for some special choices of <span class="math">\(F\)</span>, <span class="math">\(s\)</span>, and <span class="math">\(f\)</span>. On the
contrary, the complexity of the
nonlinear generalized model <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a> versus the
simple undamped model is not a big deal when we solve the
problem numerically!</p>
<p>The computational algorithm takes the form</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4b"><span class="std std-ref">(77)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4b-quad"><span class="std std-ref">(84)</span></a> if quadratic damping</li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a class="reference internal" href="#eq-vib-ode2-step4"><span class="std std-ref">(75)</span></a> if linear
damping or <a class="reference internal" href="#eq-vib-ode2-step4-quad"><span class="std std-ref">(82)</span></a> if quadratic damping</li>
</ol>
</div></blockquote>
</div></blockquote>
<p>Modifying the <code class="docutils literal"><span class="pre">solver</span></code> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span class="sd">    u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span class="sd">    F(t) and s(u) are Python functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                      <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                      <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The complete code resides in the file <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib.py">vib.py</a>.</p>
</div>
<div class="section" id="verification-3">
<span id="vib-ode2-verify"></span><h2>Verification<a class="headerlink" href="#verification-3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constant-solution">
<h3>Constant solution<a class="headerlink" href="#constant-solution" title="Permalink to this headline">¶</a></h3>
<p>For debugging and initial verification, a constant solution is often
very useful. We choose <span class="math">\({u_{\small\mbox{e}}}(t)=I\)</span>, which implies <span class="math">\(V=0\)</span>.
Inserted in the ODE, we get
<span class="math">\(F(t)=s(I)\)</span> for any choice of <span class="math">\(f\)</span>. Since the discrete derivative
of a constant vanishes (in particular, <span class="math">\([D_{2t}I]^n=0\)</span>,
<span class="math">\([D_tI]^n=0\)</span>, and <span class="math">\([D_tD_t I]^n=0\)</span>), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision. The function <code class="docutils literal"><span class="pre">test_constant</span></code> in <code class="docutils literal"><span class="pre">vib.py</span></code>
implements this test.</p>
</div>
<div class="section" id="linear-solution">
<h3>Linear solution<a class="headerlink" href="#linear-solution" title="Permalink to this headline">¶</a></h3>
<p>Now we choose a linear solution: <span class="math">\({u_{\small\mbox{e}}} = ct + d\)</span>. The initial condition
<span class="math">\(u(0)=I\)</span> implies <span class="math">\(d=I\)</span>, and <span class="math">\(u^{\prime}(0)=V\)</span> forces <span class="math">\(c\)</span> to be <span class="math">\(V\)</span>.
Inserting <span class="math">\({u_{\small\mbox{e}}}=Vt+I\)</span> in the ODE with linear damping results in</p>
<div class="math">
\[0 + bV + s(Vt+I) = F(t),\]</div>
<p>while quadratic damping requires the source term</p>
<div class="math">
\[0 + b|V|V + s(Vt+I) = F(t){\thinspace .}\]</div>
<p>Since the finite difference approximations used to compute <span class="math">\(u^{\prime}\)</span> all
are exact for a linear function, it turns out that the linear <span class="math">\({u_{\small\mbox{e}}}\)</span>
is also a solution of the discrete equations.
<a class="reference internal" href="._book002.html#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 1.10: Use linear/quadratic functions for verification</span></a> asks you to carry out
all the details.</p>
</div>
<div class="section" id="quadratic-solution">
<h3>Quadratic solution<a class="headerlink" href="#quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>Choosing <span class="math">\({u_{\small\mbox{e}}} = bt^2 + Vt + I\)</span>, with <span class="math">\(b\)</span> arbitrary,
fulfills the initial conditions and
fits the ODE if <span class="math">\(F\)</span> is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in <span class="math">\(t\)</span> does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a class="reference internal" href="._book002.html#vib-exer-verify-gen-linear"><span class="std std-ref">Exercise 1.10: Use linear/quadratic functions for verification</span></a> will reveal
the details. One can fit <span class="math">\(F^n\)</span> in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).</p>
</div>
<div class="section" id="catching-bugs">
<h3>Catching bugs<a class="headerlink" href="#catching-bugs" title="Permalink to this headline">¶</a></h3>
<p>How good are the constant and quadratic solutions at catching
bugs in the implementation?</p>
<blockquote>
<div><ul class="simple">
<li>Use <code class="docutils literal"><span class="pre">m</span></code> instead of <code class="docutils literal"><span class="pre">2*m</span></code> in the denominator of <code class="docutils literal"><span class="pre">u[1]</span></code>: constant
works, while quadratic fails.</li>
<li>Use <code class="docutils literal"><span class="pre">b*dt</span></code> instead of <code class="docutils literal"><span class="pre">b*dt/2</span></code> in the updating formula for <code class="docutils literal"><span class="pre">u[n+1]</span></code>
in case of linear damping: constant and quadratic fail.</li>
<li>Use <code class="docutils literal"><span class="pre">F[n+1]</span></code> instead of <code class="docutils literal"><span class="pre">F[n]</span></code> in case of linear or quadratic damping:
constant solution works, quadratic fails.</li>
</ul>
</div></blockquote>
<p>We realize that the constant solution is very useful to catch bugs because
of its simplicity (easy to predict what the different terms in the
formula should evaluate to), while it seems the quadratic solution is
capable of detecting all other types of typos in the scheme (?).
This results demonstrates why we focus so much on exact, simple polynomial
solutions of the numerical schemes in these writings.</p>
</div>
</div>
<div class="section" id="visualization">
<span id="vib-ode2-viz"></span><h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>The functions for visualizations differ significantly from
those in the undamped case in the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> program because,
in the present general case, we do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency <span class="math">\(\sqrt{s'(0)/m}\)</span> for linear <span class="math">\(s\)</span> and small damping,
and one period dictated by <span class="math">\(F(t)\)</span> in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify <span class="math">\(T\)</span> and the window width
to get a plot that moves with the graph and shows
the most recent parts of it in long time simulations.</p>
<p>The <code class="docutils literal"><span class="pre">vib.py</span></code> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.</p>
</div>
<div class="section" id="user-interface">
<span id="vib-ode2-ui"></span><h2>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p id="index-6">The <code class="docutils literal"><span class="pre">main</span></code> function is changed substantially from
the <code class="docutils literal"><span class="pre">vib_undamped.py</span></code> code, since we need to
specify the new data <span class="math">\(c\)</span>, <span class="math">\(s(u)\)</span>, and <span class="math">\(F(t)\)</span>.  In addition, we must
set <span class="math">\(T\)</span> and the plot window width (instead of the number of periods we
want to simulate as in <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of <span class="math">\(u\)</span>, we can use the <code class="docutils literal"><span class="pre">plot_empricial_freq_and_amplitude</span></code>
function&#8217;s estimate of the number of local maxima. This number is now
returned from the function and used in <code class="docutils literal"><span class="pre">main</span></code> to decide on the
visualization technique.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="n">empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_periods</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <code class="docutils literal"><span class="pre">vib.py</span></code> contains
the above code snippets and can solve the model problem
<a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a>. As a demo of <code class="docutils literal"><span class="pre">vib.py</span></code>, we consider the case
<span class="math">\(I=1\)</span>, <span class="math">\(V=0\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(c=0.03\)</span>, <span class="math">\(s(u)=\sin(u)\)</span>, <span class="math">\(F(t)=3\cos(4t)\)</span>,
<span class="math">\(\Delta t = 0.05\)</span>, and <span class="math">\(T=140\)</span>. The relevant command to run is</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03
</pre></div>
</div>
<p>This results in a <a class="reference external" href="http://tinyurl.com/pu5uyfn/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a class="reference internal" href="#vib-ode2-fig-demo"><span class="std std-ref">Damped oscillator excited by a sinusoidal function</span></a> shows a part of the time series.</p>
<div class="figure" id="id3">
<span id="vib-ode2-fig-demo"></span><a class="reference internal image-reference" href="_images/vib_gen_demo.png"><img alt="_images/vib_gen_demo.png" src="_images/vib_gen_demo.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Damped oscillator excited by a sinusoidal function</em></span></p>
</div>
</div>
<div class="section" id="the-euler-cromer-scheme-for-the-generalized-model">
<span id="vib-ode2-eulercromer"></span><h2>The Euler-Cromer scheme for the generalized model<a class="headerlink" href="#the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>The ideas of the Euler-Cromer method from the section <a class="reference internal" href="._book002.html#vib-model2x2-eulercromer"><span class="std std-ref">The Euler-Cromer method</span></a>
carry over to the generalized model. We write <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a>
as two equations for <span class="math">\(u\)</span> and <span class="math">\(v=u^{\prime}\)</span>. The first equation is taken as the
one with <span class="math">\(v^{\prime}\)</span> on the left-hand side:</p>
<div class="math" id="eq-vib-ode2-eulercromer-veq">
\[\tag{86}
v^{\prime} = \frac{1}{m}(F(t)-s(u)-f(v)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-ueq">
\[\tag{87}
u^{\prime} = v{\thinspace .}\]</div>
<p>The idea is to step <a class="reference internal" href="#eq-vib-ode2-eulercromer-veq"><span class="std std-ref">(86)</span></a> forward using
a standard Forward Euler method, while we update <span class="math">\(u\)</span> from
<a class="reference internal" href="#eq-vib-ode2-eulercromer-ueq"><span class="std std-ref">(87)</span></a> with a Backward Euler method,
utilizing the recent, computed <span class="math">\(v^{n+1}\)</span> value. In detail,</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq0a">
\[\tag{88}
\frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0a">
\[\tag{89}
\frac{u^{n+1}-u^n}{\Delta t} = v^{n+1},\]</div>
<p>resulting in the explicit scheme</p>
<div class="math" id="eq-vib-ode2-eulercromer-dveq">
\[\tag{90}
v^{n+1} = v^n + \Delta t\frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="eq-vib-ode2-eulercromer-dueq0">
\[\tag{91}
u^{n+1} = u^n + \Delta t\,v^{n+1}{\thinspace .}\]</div>
<p>We immediately note one very favorable feature of this scheme: all the
nonlinearities in <span class="math">\(s(u)\)</span> and <span class="math">\(f(v)\)</span> are evaluated at a previous time
level. This makes the Euler-Cromer method easier to apply and
hence much more convenient than the centered scheme for the second-order
ODE <a class="reference internal" href="#eq-vib-ode2"><span class="std std-ref">(71)</span></a>.</p>
<p>The initial conditions are trivially set as</p>
<div class="math" id="eq-auto35">
\[\tag{92}
v^0 = V,\]</div>
<div class="math" id="eq-auto36">
\[\tag{93}
u^0 = I{\thinspace .}\]</div>
</div>
<div class="section" id="the-stoermer-verlet-algorithm-for-the-generalized-model">
<span id="vib-model2x2-gen-stormerverlet"></span><h2>The Stoermer-Verlet algorithm for the generalized model<a class="headerlink" href="#the-stoermer-verlet-algorithm-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>We can easily apply the ideas from the section <a class="reference internal" href="._book002.html#vib-model2x2-stormerverlet"><span class="std std-ref">The Stoermer-Verlet algorithm</span></a> to
extend that method to the generalized model</p>
<div class="math">
\[\begin{split}\begin{align*}
v^{\prime} &amp;= \frac{1}{m}(F(t)-s(u)-f(v)),\\
u^{\prime} &amp;= v{\thinspace .}
\end{align*}\end{split}\]</div>
<p>However, since the scheme is essentially centered differences for
the ODE system on a staggered mesh, we do not go into detail here,
but refer to the section <a class="reference internal" href="#vib-ode2-staggered"><span class="std std-ref">A staggered Euler-Cromer scheme for a generalized model</span></a>.</p>
</div>
<div class="section" id="a-staggered-euler-cromer-scheme-for-a-generalized-model">
<span id="vib-ode2-staggered"></span><h2>A staggered Euler-Cromer scheme for a generalized model<a class="headerlink" href="#a-staggered-euler-cromer-scheme-for-a-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>The more general model for vibration problems,</p>
<div class="math" id="eq-auto37">
\[\tag{94}
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T],\]</div>
<p>can be rewritten as a first-order ODE system</p>
<div class="math" id="eq-vib-ode2-staggered-veq">
\[\tag{95}
v' = m^{-1}\left(F(t) - f(v) - s(u)\right),\]</div>
<div class="math" id="eq-vib-ode2-staggered-ueq">
\[\tag{96}
u' = v{\thinspace .}\]</div>
<p>It is natural to introduce a staggered mesh (see the section <a class="reference internal" href="._book002.html#vib-model2x2-staggered"><span class="std std-ref">The Euler-Cromer scheme on a staggered mesh</span></a>) and seek <span class="math">\(u\)</span> at mesh points <span class="math">\(t_n\)</span> (the numerical value is
denoted by <span class="math">\(u^n\)</span>) and <span class="math">\(v\)</span> between mesh points at <span class="math">\(t_{n+1/2}\)</span> (the numerical
value is denoted by <span class="math">\(v^{n+\frac{1}{2}}\)</span>).
A centered difference approximation to <a class="reference internal" href="#eq-vib-ode2-staggered-ueq"><span class="std std-ref">(96)</span></a>-<a class="reference internal" href="#eq-vib-ode2-staggered-veq"><span class="std std-ref">(95)</span></a> can then be written in operator notation as</p>
<div class="math" id="eq-vib-ode2-staggered-dveq">
\[\tag{97}
\lbrack D_tv = m^{-1}\left(F(t) - f(v) - s(u)\right)\rbrack^n,\]</div>
<div class="math" id="eq-vib-ode2-staggered-dueq">
\[\tag{98}
\lbrack D_t u = v\rbrack^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>Written out,</p>
<div class="math" id="eq-vib-ode2-staggered-dveq2">
\[\tag{99}
\frac{v^{n+\frac{1}{2}} - v^{n-\frac{1}{2}}}{\Delta t}
    = m^{-1}\left(F^n - f(v^n) - s(u^n)\right),\]</div>
<div class="math" id="eq-vib-ode2-staggered-dueq2">
\[\tag{100}
\frac{u^n - u^{n-1}}{\Delta t} = v^{n+\frac{1}{2}}{\thinspace .}\]</div>
<p>With linear damping, <span class="math">\(f(v)=bv\)</span>, we can use an arithmetic mean
for <span class="math">\(f(v^n)\)</span>: <span class="math">\(f(v^n)\approx = \frac{1}{2}(f(v^{n-\frac{1}{2}}) +
f(v^{n+\frac{1}{2}}))\)</span>. The system
<a class="reference internal" href="#eq-vib-ode2-staggered-dveq2"><span class="std std-ref">(99)</span></a>-<a class="reference internal" href="#eq-vib-ode2-staggered-dueq2"><span class="std std-ref">(100)</span></a>
can then be solved with respect to the unknowns <span class="math">\(u^n\)</span> and <span class="math">\(v^{n+\frac{1}{2}}\)</span>:</p>
<div class="math" id="eq-vib-ode2-staggered-v-scheme-lin">
\[\tag{101}
v^{n+\frac{1}{2}} = \left(1 + \frac{b}{2m}\Delta t\right)^{-1}\left(
    v^{n-\frac{1}{2}} + {\Delta t}
    m^{-1}\left(F^n - {\frac{1}{2}}f(v^{n-\frac{1}{2}}) - s(u^n)\right)\right),\]</div>
<div class="math" id="eq-vib-ode2-staggered-u-scheme-lin">
\[\tag{102}
u^n  = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}}{\thinspace .}\]</div>
<p>In case of quadratic damping, <span class="math">\(f(v)=b|v|v\)</span>, we can use a geometric mean:
<span class="math">\(f(v^n)\approx b|v^{n-\frac{1}{2}}|v^{n+\frac{1}{2}}\)</span>. Inserting this approximation
in <a class="reference internal" href="#eq-vib-ode2-staggered-dveq2"><span class="std std-ref">(99)</span></a>-<a class="reference internal" href="#eq-vib-ode2-staggered-dueq2"><span class="std std-ref">(100)</span></a> and
solving for the unknowns <span class="math">\(u^n\)</span> and <span class="math">\(v^{n+\frac{1}{2}}\)</span> results in</p>
<div class="math" id="eq-vib-ode2-staggered-v-scheme-quad">
\[\tag{103}
v^{n+\frac{1}{2}} = (1 + \frac{b}{m}|v^{n-\frac{1}{2}}|\Delta t)^{-1}\left(
    v^{n-\frac{1}{2}} + {\Delta t}
    m^{-1}\left(F^n - s(u^n)\right)\right),\]</div>
<div class="math" id="eq-vib-ode2-staggered-u-scheme-quad">
\[\tag{104}
u^n  = u^{n-1} + {\Delta t}v^{n-\frac{1}{2}}{\thinspace .}\]</div>
<p>The initial conditions are derived at the end of
the section <a class="reference internal" href="._book002.html#vib-model2x2-staggered"><span class="std std-ref">The Euler-Cromer scheme on a staggered mesh</span></a>:</p>
<div class="math" id="eq-vib-ode2-staggered-u02">
\[\tag{105}
u^0 = I,\]</div>
<div class="math" id="eq-vib-ode2-staggered-v02">
\[\tag{106}
v^\frac{1}{2} = V - \frac{1}{2}\Delta t\omega^2I
    {\thinspace .}\]</div>
</div>
<div class="section" id="the-pefrl-4th-order-accurate-algorithm">
<span id="vib-ode2-pefrl"></span><h2>The PEFRL 4th-order accurate algorithm<a class="headerlink" href="#the-pefrl-4th-order-accurate-algorithm" title="Permalink to this headline">¶</a></h2>
<p>A variant of the Euler-Cromer type of algorithm, which provides an
error <span class="math">\({\mathcal{O}(\Delta t^4)}\)</span> if <span class="math">\(f(v)=0\)</span>, is called PEFRL
<a class="reference internal" href="._book027.html#ref05" id="id1">[Ref05]</a>. This algorithm is very well suited for integrating
dynamic systems (especially those without damping) over very long time
periods. Define</p>
<div class="math">
\[g(u,v) = \frac{1}{m}(F(t)-s(u)-f(v)){\thinspace .}\]</div>
<p>The algorithm is explicit and features these simple steps:</p>
<div class="math" id="eq-auto38">
\[\tag{107}
u^{n+1,1} = u^n       + \xi\Delta t v^n,\]</div>
<div class="math" id="eq-auto39">
\[\tag{108}
v^{n+1,1} = v^n       + \frac{1}{2}(1-2\lambda)\Delta t g(u^{n+1,1},v^n),\]</div>
<div class="math" id="eq-auto40">
\[\tag{109}
u^{n+1,2} = u^{n+1,1} + \chi\Delta t v^{n+1,1},\]</div>
<div class="math" id="eq-auto41">
\[\tag{110}
v^{n+1,2} = v^{n+1,1} + \lambda\Delta t g(u^{n+1,2}, v^{n+1,1}),\]</div>
<div class="math" id="eq-auto42">
\[\tag{111}
u^{n+1,3} = u^{n+1,2} + (1-2(\chi + \xi))\Delta t v^{n+1,2},\]</div>
<div class="math" id="eq-auto43">
\[\tag{112}
v^{n+1,3} = v^{n+1,2} + \lambda\Delta t g(u^{n+1,3}, v^{n+1,2}),\]</div>
<div class="math" id="eq-auto44">
\[\tag{113}
u^{n+1,4} = u^{n+1,3} + \chi\Delta t v^{n+1,3},\]</div>
<div class="math" id="eq-auto45">
\[\tag{114}
v^{n+1}   = v^{n+1,3} + \frac{1}{2}(1-2\lambda)\Delta t g(u^{n+1,4},v^{n+1,3}),\]</div>
<div class="math" id="eq-auto46">
\[\tag{115}
u^{n+1}   = u^{n+1,4} + \xi\Delta t v^{n+1}\]</div>
<p>The parameters <span class="math">\(\xi\)</span>, <span class="math">\(\lambda\)</span>, and <span class="math">\(\xi\)</span> have the values</p>
<div class="math" id="eq-auto47">
\[\tag{116}
\xi = 0.1786178958448091,\]</div>
<div class="math" id="eq-auto48">
\[\tag{117}
\lambda = -0.2123418310626054,\]</div>
<div class="math" id="eq-auto49">
\[\tag{118}
\chi = -0.06626458266981849\]</div>
</div>
</div>
<div class="section" id="exercises-and-problems-2">
<h1>Exercises and Problems<a class="headerlink" href="#exercises-and-problems-2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-19-implement-the-solver-via-classes">
<span id="vib-exer-gen-class"></span><h2>Exercise 1.19: Implement the solver via classes<a class="headerlink" href="#exercise-1-19-implement-the-solver-via-classes" title="Permalink to this headline">¶</a></h2>
<p>Reimplement the <code class="docutils literal"><span class="pre">vib.py</span></code> program using a class <code class="docutils literal"><span class="pre">Problem</span></code> to hold all
the physical parameters of the problem, a class <code class="docutils literal"><span class="pre">Solver</span></code> to hold the
numerical parameters and compute the solution, and a class
<code class="docutils literal"><span class="pre">Visualizer</span></code> to display the solution.</p>
<p><strong>Hint.</strong>
Use the ideas and examples for an <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book009.html#classes-for-problem-and-solution-method">ODE
model</a>
in <a class="reference internal" href="._book027.html#ref02" id="id2">[Ref02]</a>.  More specifically, make a superclass
<code class="docutils literal"><span class="pre">Problem</span></code> for holding the scalar physical parameters of a problem and
let subclasses implement the <span class="math">\(s(u)\)</span> and <span class="math">\(F(t)\)</span> functions as methods.
Try to call up as much existing functionality in <code class="docutils literal"><span class="pre">vib.py</span></code> as possible.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_class</span></code>.</p>
</div>
<div class="section" id="problem-1-20-use-a-backward-difference-for-the-damping-term">
<span id="vib-exer-quad-damping-bw"></span><h2>Problem 1.20: Use a backward difference for the damping term<a class="headerlink" href="#problem-1-20-use-a-backward-difference-for-the-damping-term" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to discretizing the damping terms <span class="math">\(\beta u^{\prime}\)</span> and
<span class="math">\(\beta |u^{\prime}|u^{\prime}\)</span> by centered differences, we may apply
backward differences:</p>
<div class="math">
\[\begin{split}\begin{align*}
[u^{\prime}]^n &amp;\approx [D_t^-u]^n,\\
&amp; [|u^{\prime}|u^{\prime}]^n\\
&amp;\approx [|D_t^-u|D_t^-u]^n\\
&amp;= |[D_t^-u]^n|[D_t^-u]^n{\thinspace .}
\end{align*}\end{split}\]</div>
<p>The advantage of the backward difference is that the damping term is
evaluated using known values <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span> only.
Extend the <a class="reference external" href="http://tinyurl.com/nu656p2/vib/vib.py">vib.py</a> code with a scheme based
on using backward differences in the damping terms. Add statements
to compare the original approach with centered difference and the
new idea launched in this exercise. Perform numerical experiments
to investigate how much accuracy that is lost by using the backward
differences.</p>
<p>Filename: <code class="docutils literal"><span class="pre">vib_gen_bwdamping</span></code>.</p>
</div>
<div class="section" id="exercise-1-21-use-the-forward-backward-scheme-with-quadratic-damping">
<span id="vib-exer-quad-damping-fwbw"></span><h2>Exercise 1.21: Use the forward-backward scheme with quadratic damping<a class="headerlink" href="#exercise-1-21-use-the-forward-backward-scheme-with-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>We consider the generalized model with quadratic damping, expressed
as a system of two first-order equations as in the section <a class="reference internal" href="#vib-ode2-staggered"><span class="std std-ref">A staggered Euler-Cromer scheme for a generalized model</span></a>:</p>
<div class="math">
\[\begin{split}\begin{align*}
u^{\prime} &amp;= v,\\
v' &amp;= \frac{1}{m}\left( F(t) - \beta |v|v - s(u)\right){\thinspace .}
\end{align*}\end{split}\]</div>
<p>However, contrary to what is done in the section <a class="reference internal" href="#vib-ode2-staggered"><span class="std std-ref">A staggered Euler-Cromer scheme for a generalized model</span></a>,
we want to apply the idea of a forward-backward discretization:
<span class="math">\(u\)</span> is marched forward by a one-sided Forward Euler scheme applied
to the first equation, and
thereafter <span class="math">\(v\)</span> can be marched forward by a Backward Euler scheme in the
second
equation, see in the section <a class="reference internal" href="._book002.html#vib-model2x2-eulercromer"><span class="std std-ref">The Euler-Cromer method</span></a>.
Express the idea in operator notation and write out the
scheme. Unfortunately, the backward difference for the <span class="math">\(v\)</span> equation
creates a nonlinearity <span class="math">\(|v^{n+1}|v^{n+1}\)</span>.  To linearize this
nonlinearity, use the known value <span class="math">\(v^n\)</span> inside the absolute value
factor, i.e., <span class="math">\(|v^{n+1}|v^{n+1}\approx |v^n|v^{n+1}\)</span>.  Show that the
resulting scheme is equivalent to the one in the section <a class="reference internal" href="#vib-ode2-staggered"><span class="std std-ref">A staggered Euler-Cromer scheme for a generalized model</span></a> for some time level <span class="math">\(n\geq 1\)</span>.</p>
<p>What we learn from this exercise is that the first-order differences
and the linearization trick play together in &#8220;the right way&#8221; such that
the scheme is as good as when we (in the section <a class="reference internal" href="#vib-ode2-staggered"><span class="std std-ref">A staggered Euler-Cromer scheme for a generalized model</span></a>)
carefully apply centered differences and a geometric mean on a
staggered mesh to achieve second-order accuracy.
There is a
difference in the handling of the initial conditions, though, as
explained at the end of the section <a class="reference internal" href="._book002.html#vib-model2x2-eulercromer"><span class="std std-ref">The Euler-Cromer method</span></a>.
Filename: <code class="docutils literal"><span class="pre">vib_gen_bwdamping</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generalization: damping, nonlinearities, and excitation</a><ul>
<li><a class="reference internal" href="#a-centered-scheme-for-linear-damping">A centered scheme for linear damping</a></li>
<li><a class="reference internal" href="#a-centered-scheme-for-quadratic-damping">A centered scheme for quadratic damping</a></li>
<li><a class="reference internal" href="#a-forward-backward-discretization-of-the-quadratic-damping-term">A forward-backward discretization of the quadratic damping term</a></li>
<li><a class="reference internal" href="#implementation-3">Implementation</a></li>
<li><a class="reference internal" href="#verification-3">Verification</a><ul>
<li><a class="reference internal" href="#constant-solution">Constant solution</a></li>
<li><a class="reference internal" href="#linear-solution">Linear solution</a></li>
<li><a class="reference internal" href="#quadratic-solution">Quadratic solution</a></li>
<li><a class="reference internal" href="#catching-bugs">Catching bugs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#the-euler-cromer-scheme-for-the-generalized-model">The Euler-Cromer scheme for the generalized model</a></li>
<li><a class="reference internal" href="#the-stoermer-verlet-algorithm-for-the-generalized-model">The Stoermer-Verlet algorithm for the generalized model</a></li>
<li><a class="reference internal" href="#a-staggered-euler-cromer-scheme-for-a-generalized-model">A staggered Euler-Cromer scheme for a generalized model</a></li>
<li><a class="reference internal" href="#the-pefrl-4th-order-accurate-algorithm">The PEFRL 4th-order accurate algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems-2">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#exercise-1-19-implement-the-solver-via-classes">Exercise 1.19: Implement the solver via classes</a></li>
<li><a class="reference internal" href="#problem-1-20-use-a-backward-difference-for-the-damping-term">Problem 1.20: Use a backward difference for the damping term</a></li>
<li><a class="reference internal" href="#exercise-1-21-use-the-forward-backward-scheme-with-quadratic-damping">Exercise 1.21: Use the forward-backward scheme with quadratic damping</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._book002.html"
                        title="previous chapter">Vibration ODEs</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._book004.html"
                        title="next chapter">Applications of vibration models</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._book003.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._book004.html" title="Applications of vibration models"
             >next</a> |</li>
        <li class="right" >
          <a href="._book002.html" title="Vibration ODEs"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite Difference Computing with PDEs</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2016, Hans Petter Langtangen, Svein Linge. Released under CC Attribution 4.0 license.
  </div>
</div>

  </body>
</html>